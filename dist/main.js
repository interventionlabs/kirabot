/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./config.js":
/*!*******************!*\
  !*** ./config.js ***!
  \*******************/
/*! exports provided: keybase, jira */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keybase", function() { return keybase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jira", function() { return jira; });
var keybase = {
  username: 'blahbot',
  paperkey: 'blah blah blu blu',
  channels: [{
    name: 'blah.bots',
    topicName: 'test',
    membersType: 'team',
    topic_type: 'chat'
  }]
};
var jira = {
  host: 'blah.atlassian.net',
  username: 'blah@example.com',
  password: 'password',
  usernameMapper: {
    "blah": "[~blahblah]"
  }
};

/***/ }),

/***/ "./node_modules/ajv/lib/ajv.js":
/*!*************************************!*\
  !*** ./node_modules/ajv/lib/ajv.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compileSchema = __webpack_require__(/*! ./compile */ "./node_modules/ajv/lib/compile/index.js")
  , resolve = __webpack_require__(/*! ./compile/resolve */ "./node_modules/ajv/lib/compile/resolve.js")
  , Cache = __webpack_require__(/*! ./cache */ "./node_modules/ajv/lib/cache.js")
  , SchemaObject = __webpack_require__(/*! ./compile/schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js")
  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js")
  , formats = __webpack_require__(/*! ./compile/formats */ "./node_modules/ajv/lib/compile/formats.js")
  , rules = __webpack_require__(/*! ./compile/rules */ "./node_modules/ajv/lib/compile/rules.js")
  , $dataMetaSchema = __webpack_require__(/*! ./data */ "./node_modules/ajv/lib/data.js")
  , util = __webpack_require__(/*! ./compile/util */ "./node_modules/ajv/lib/compile/util.js");

module.exports = Ajv;

Ajv.prototype.validate = validate;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = __webpack_require__(/*! ./compile/async */ "./node_modules/ajv/lib/compile/async.js");
var customKeyword = __webpack_require__(/*! ./keyword */ "./node_modules/ajv/lib/keyword.js");
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;

var errorClasses = __webpack_require__(/*! ./compile/error_classes */ "./node_modules/ajv/lib/compile/error_classes.js");
Ajv.ValidationError = errorClasses.Validation;
Ajv.MissingRefError = errorClasses.MissingRef;
Ajv.$dataMetaSchema = $dataMetaSchema;

var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);

  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = stableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {const: true}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compileSchema.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new SchemaObject({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve.ids.call(this, schema);

  var schemaObj = new SchemaObject({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto': return _get$IdOrId;
    case 'id': return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = __webpack_require__(/*! ./refs/data.json */ "./node_modules/ajv/lib/refs/data.json");
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ "./node_modules/ajv/lib/refs/json-schema-draft-07.json");
  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}


function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}


function noop() {}


/***/ }),

/***/ "./node_modules/ajv/lib/cache.js":
/*!***************************************!*\
  !*** ./node_modules/ajv/lib/cache.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};


/***/ }),

/***/ "./node_modules/ajv/lib/compile/async.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/async.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MissingRefError = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js").MissingRef;

module.exports = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/error_classes.js":
/*!*******************************************************!*\
  !*** ./node_modules/ajv/lib/compile/error_classes.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js");

module.exports = {
  Validation: errorSubclass(ValidationError),
  MissingRef: errorSubclass(MissingRefError)
};


function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError.message = function (baseId, ref) {
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
};


function MissingRefError(baseId, ref, message) {
  this.message = message || MissingRefError.message(baseId, ref);
  this.missingRef = resolve.url(baseId, ref);
  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/formats.js":
/*!*************************************************!*\
  !*** ./node_modules/ajv/lib/compile/formats.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");

var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\/?\/)?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: hostname,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month >= 1 && month <= 12 && day >= 1 &&
          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour == 23 && minute == 59 && second == 60)) &&
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


function hostname(str) {
  // https://tools.ietf.org/html/rfc1034#section-3.5
  // https://tools.ietf.org/html/rfc1123#section-2
  return str.length <= 255 && HOSTNAME.test(str);
}


var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/index.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var resolve = __webpack_require__(/*! ./resolve */ "./node_modules/ajv/lib/compile/resolve.js")
  , util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js")
  , errorClasses = __webpack_require__(/*! ./error_classes */ "./node_modules/ajv/lib/compile/error_classes.js")
  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ "./node_modules/fast-json-stable-stringify/index.js");

var validateGenerator = __webpack_require__(/*! ../dotjs/validate */ "./node_modules/ajv/lib/dotjs/validate.js");

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util.ucs2length;
var equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js");

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = errorClasses.Validation;

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: errorClasses.MissingRef,
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    var validateSchema = rule.definition.validateSchema;
    if (validateSchema && self._opts.validateSchema !== false) {
      var valid = validateSchema(schema);
      if (!valid) {
        var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
        if (self._opts.validateSchema == 'log') self.logger.error(message);
        else throw new Error(message);
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/resolve.js":
/*!*************************************************!*\
  !*** ./node_modules/ajv/lib/compile/resolve.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var URI = __webpack_require__(/*! uri-js */ "./node_modules/uri-js/dist/es5/uri.all.js")
  , equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js")
  , util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js")
  , SchemaObject = __webpack_require__(/*! ./schema_obj */ "./node_modules/ajv/lib/compile/schema_obj.js")
  , traverse = __webpack_require__(/*! json-schema-traverse */ "./node_modules/json-schema-traverse/index.js");

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = URI.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0,1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = URI.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return URI.serialize(p).split('#')[0] + '#';
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return URI.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {'': schemaId};
  var fullPaths = {'': getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!equal(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !equal(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/rules.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/compile/rules.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ruleModules = __webpack_require__(/*! ../dotjs */ "./node_modules/ajv/lib/dotjs/index.js")
  , toHash = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js").toHash;

module.exports = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ { 'maximum': ['exclusiveMaximum'] },
               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
  ];

  var ALL = [ 'type', '$comment' ];
  var KEYWORDS = [
    '$schema', '$id', 'id', '$data', 'title',
    'description', 'default', 'definitions',
    'examples', 'readOnly', 'writeOnly',
    'contentMediaType', 'contentEncoding',
    'additionalItems', 'then', 'else'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: '$comment',
      code: ruleModules.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};


/***/ }),

/***/ "./node_modules/ajv/lib/compile/schema_obj.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/compile/schema_obj.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! ./util */ "./node_modules/ajv/lib/compile/util.js");

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}


/***/ }),

/***/ "./node_modules/ajv/lib/compile/ucs2length.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/compile/ucs2length.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};


/***/ }),

/***/ "./node_modules/ajv/lib/compile/util.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/compile/util.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js"),
  ucs2length: __webpack_require__(/*! ./ucs2length */ "./node_modules/ajv/lib/compile/ucs2length.js"),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  finalCleanUpCode: finalCleanUpCode,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


var EMPTY_ELSE = /else\s*{\s*}/g
  , EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, '')
            .replace(EMPTY_IF_NO_ELSE, '')
            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
}


var ERRORS_REGEXP = /[^v.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = 'return errors === 0;'
  , RETURN_TRUE = 'validate.errors = null; return true;'
  , RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/
  , RETURN_DATA_ASYNC = 'return data;'
  , ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g
  , REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;

function finalCleanUpCode(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (matches && matches.length == 2) {
    out = async
          ? out.replace(REMOVE_ERRORS_ASYNC, '')
               .replace(RETURN_ASYNC, RETURN_DATA_ASYNC)
          : out.replace(REMOVE_ERRORS, '')
               .replace(RETURN_VALID, RETURN_TRUE);
  }

  matches = out.match(ROOTDATA_REGEXP);
  if (!matches || matches.length !== 3) return out;
  return out.replace(REMOVE_ROOTDATA, '');
}


function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/' \+ '/g, '');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}


/***/ }),

/***/ "./node_modules/ajv/lib/data.js":
/*!**************************************!*\
  !*** ./node_modules/ajv/lib/data.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

module.exports = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i<keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
    }
  }

  return metaSchema;
};


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limit.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limit.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitItems.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitItems.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitLength.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitLength.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/_limitProperties.js":
/*!********************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/_limitProperties.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/allOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/allOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/anyOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/anyOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return it.util.schemaHasRules($sch, it.RULES.all);
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/comment.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/comment.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + ($comment) + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/const.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/const.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/contains.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/contains.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = it.util.schemaHasRules($schema, it.RULES.all);
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    out += ' if (' + ($nextValid) + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
  } else {
    out += ' if (' + ($data) + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should contain a valid item\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/custom.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/custom.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  out += '' + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/dependencies.js":
/*!****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/dependencies.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should have ';
            if ($deps.length == 1) {
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            } else {
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            }
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if (it.util.schemaHasRules($sch, it.RULES.all)) {
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/enum.js":
/*!********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/enum.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/format.js":
/*!**********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/format.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/if.js":
/*!******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/if.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && it.util.schemaHasRules($thenSch, it.RULES.all),
    $elsePresent = $elseSch !== undefined && it.util.schemaHasRules($elseSch, it.RULES.all),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + (it.validate($it)) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + ($nextValid) + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'then\'; ';
      } else {
        $ifClause = '\'then\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + ($nextValid) + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'else\'; ';
      } else {
        $ifClause = '\'else\'';
      }
      out += ' } ';
    }
    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
  '$ref': __webpack_require__(/*! ./ref */ "./node_modules/ajv/lib/dotjs/ref.js"),
  allOf: __webpack_require__(/*! ./allOf */ "./node_modules/ajv/lib/dotjs/allOf.js"),
  anyOf: __webpack_require__(/*! ./anyOf */ "./node_modules/ajv/lib/dotjs/anyOf.js"),
  '$comment': __webpack_require__(/*! ./comment */ "./node_modules/ajv/lib/dotjs/comment.js"),
  const: __webpack_require__(/*! ./const */ "./node_modules/ajv/lib/dotjs/const.js"),
  contains: __webpack_require__(/*! ./contains */ "./node_modules/ajv/lib/dotjs/contains.js"),
  dependencies: __webpack_require__(/*! ./dependencies */ "./node_modules/ajv/lib/dotjs/dependencies.js"),
  'enum': __webpack_require__(/*! ./enum */ "./node_modules/ajv/lib/dotjs/enum.js"),
  format: __webpack_require__(/*! ./format */ "./node_modules/ajv/lib/dotjs/format.js"),
  'if': __webpack_require__(/*! ./if */ "./node_modules/ajv/lib/dotjs/if.js"),
  items: __webpack_require__(/*! ./items */ "./node_modules/ajv/lib/dotjs/items.js"),
  maximum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
  minimum: __webpack_require__(/*! ./_limit */ "./node_modules/ajv/lib/dotjs/_limit.js"),
  maxItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
  minItems: __webpack_require__(/*! ./_limitItems */ "./node_modules/ajv/lib/dotjs/_limitItems.js"),
  maxLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
  minLength: __webpack_require__(/*! ./_limitLength */ "./node_modules/ajv/lib/dotjs/_limitLength.js"),
  maxProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
  minProperties: __webpack_require__(/*! ./_limitProperties */ "./node_modules/ajv/lib/dotjs/_limitProperties.js"),
  multipleOf: __webpack_require__(/*! ./multipleOf */ "./node_modules/ajv/lib/dotjs/multipleOf.js"),
  not: __webpack_require__(/*! ./not */ "./node_modules/ajv/lib/dotjs/not.js"),
  oneOf: __webpack_require__(/*! ./oneOf */ "./node_modules/ajv/lib/dotjs/oneOf.js"),
  pattern: __webpack_require__(/*! ./pattern */ "./node_modules/ajv/lib/dotjs/pattern.js"),
  properties: __webpack_require__(/*! ./properties */ "./node_modules/ajv/lib/dotjs/properties.js"),
  propertyNames: __webpack_require__(/*! ./propertyNames */ "./node_modules/ajv/lib/dotjs/propertyNames.js"),
  required: __webpack_require__(/*! ./required */ "./node_modules/ajv/lib/dotjs/required.js"),
  uniqueItems: __webpack_require__(/*! ./uniqueItems */ "./node_modules/ajv/lib/dotjs/uniqueItems.js"),
  validate: __webpack_require__(/*! ./validate */ "./node_modules/ajv/lib/dotjs/validate.js")
};


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/items.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/items.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/multipleOf.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/multipleOf.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/not.js":
/*!*******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/not.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/oneOf.js":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/oneOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/pattern.js":
/*!***********************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/pattern.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/properties.js":
/*!**************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/properties.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) {
    out += ' var ' + ($dataProperties) + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
              }
              out += ') { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/propertyNames.js":
/*!*****************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/propertyNames.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;';
  if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\' + ' + $key + ' + \'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/ref.js":
/*!*******************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/ref.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + ($valid) + '; ';
      }
      out += ' try { await ' + (__callValidate) + '; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/required.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/required.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += '; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/uniqueItems.js":
/*!***************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/uniqueItems.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + (it.util[$method]($itemType, 'item', true)) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/dotjs/validate.js":
/*!************************************************!*\
  !*** ./node_modules/ajv/lib/dotjs/validate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + ($valid) + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'boolean schema is false\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + ($valid) + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [undefined];
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \'array\'; ';
        }
        out += ' var ' + ($coerced) + ' = undefined; ';
        var $bracesCoercion = '';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($i) {
              out += ' if (' + ($coerced) + ' === undefined) { ';
              $bracesCoercion += '}';
            }
            if (it.opts.coerceTypes == 'array' && $type != 'array') {
              out += ' if (' + ($dataType) + ' == \'array\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
            }
            if ($type == 'string') {
              out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') {
                out += ' && !(' + ($data) + ' % 1)';
              }
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            } else if ($type == 'boolean') {
              out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            } else if ($type == 'null') {
              out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            }
          }
        }
        out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) {
          out += 'if (' + ($parentData) + ' !== undefined)';
        }
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
          }
          if (it.opts.useDefaults && !it.compositeRule) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    out += '  if (' + ($passData) + ' === undefined ';
                    if (it.opts.useDefaults == 'empty') {
                      out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                    }
                    out += ' ) ' + ($passData) + ' = ';
                    if (it.opts.useDefaults == 'shared') {
                      out += ' ' + (it.useDefault($sch.default)) + ' ';
                    } else {
                      out += ' ' + (JSON.stringify($sch.default)) + ' ';
                    }
                    out += '; ';
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    out += '  if (' + ($passData) + ' === undefined ';
                    if (it.opts.useDefaults == 'empty') {
                      out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                    }
                    out += ' ) ' + ($passData) + ' = ';
                    if (it.opts.useDefaults == 'shared') {
                      out += ' ' + (it.useDefault($sch.default)) + ' ';
                    } else {
                      out += ' ' + (JSON.stringify($sch.default)) + ' ';
                    }
                    out += '; ';
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }
  out = it.util.cleanUpCode(out);
  if ($top) {
    out = it.util.finalCleanUpCode(out, $async);
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
}


/***/ }),

/***/ "./node_modules/ajv/lib/keyword.js":
/*!*****************************************!*\
  !*** ./node_modules/ajv/lib/keyword.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
var customRuleCode = __webpack_require__(/*! ./dotjs/custom */ "./node_modules/ajv/lib/dotjs/custom.js");

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword
};

/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;

  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    if (definition.macro && definition.valid !== undefined)
      throw new Error('"valid" option cannot be used with macro keywords');

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      var i, len = dataType.length;
      for (i=0; i<len; i++) checkDataType(dataType[i]);
      for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);
    } else {
      if (dataType) checkDataType(dataType);
      _addRule(keyword, dataType, definition);
    }

    var $data = definition.$data === true && this._opts.$data;
    if ($data && !definition.validate)
      throw new Error('$data support: "validate" function is not defined');

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if ($data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }


  function checkDataType(dataType) {
    if (!RULES.types[dataType]) throw new Error('Unknown type ' + dataType);
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/ajv/lib/refs/data.json":
/*!*********************************************!*\
  !*** ./node_modules/ajv/lib/refs/data.json ***!
  \*********************************************/
/*! exports provided: $schema, $id, description, type, required, properties, additionalProperties, default */
/***/ (function(module) {

module.exports = {"$schema":"http://json-schema.org/draft-07/schema#","$id":"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON Schema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false};

/***/ }),

/***/ "./node_modules/ajv/lib/refs/json-schema-draft-06.json":
/*!*************************************************************!*\
  !*** ./node_modules/ajv/lib/refs/json-schema-draft-06.json ***!
  \*************************************************************/
/*! exports provided: $schema, $id, title, definitions, type, properties, default */
/***/ (function(module) {

module.exports = {"$schema":"http://json-schema.org/draft-06/schema#","$id":"http://json-schema.org/draft-06/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"title":{"type":"string"},"description":{"type":"string"},"default":{},"examples":{"type":"array","items":{}},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":{}},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":{},"enum":{"type":"array","minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":{}};

/***/ }),

/***/ "./node_modules/ajv/lib/refs/json-schema-draft-07.json":
/*!*************************************************************!*\
  !*** ./node_modules/ajv/lib/refs/json-schema-draft-07.json ***!
  \*************************************************************/
/*! exports provided: $schema, $id, title, definitions, type, properties, default */
/***/ (function(module) {

module.exports = {"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true};

/***/ }),

/***/ "./node_modules/asn1/lib/ber/errors.js":
/*!*********************************************!*\
  !*** ./node_modules/asn1/lib/ber/errors.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {

  newInvalidAsn1Error: function (msg) {
    var e = new Error();
    e.name = 'InvalidAsn1Error';
    e.message = msg || '';
    return e;
  }

};


/***/ }),

/***/ "./node_modules/asn1/lib/ber/index.js":
/*!********************************************!*\
  !*** ./node_modules/asn1/lib/ber/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var errors = __webpack_require__(/*! ./errors */ "./node_modules/asn1/lib/ber/errors.js");
var types = __webpack_require__(/*! ./types */ "./node_modules/asn1/lib/ber/types.js");

var Reader = __webpack_require__(/*! ./reader */ "./node_modules/asn1/lib/ber/reader.js");
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/asn1/lib/ber/writer.js");


// --- Exports

module.exports = {

  Reader: Reader,

  Writer: Writer

};

for (var t in types) {
  if (types.hasOwnProperty(t))
    module.exports[t] = types[t];
}
for (var e in errors) {
  if (errors.hasOwnProperty(e))
    module.exports[e] = errors[e];
}


/***/ }),

/***/ "./node_modules/asn1/lib/ber/reader.js":
/*!*********************************************!*\
  !*** ./node_modules/asn1/lib/ber/reader.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = __webpack_require__(/*! assert */ "assert");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;

var ASN1 = __webpack_require__(/*! ./types */ "./node_modules/asn1/lib/ber/types.js");
var errors = __webpack_require__(/*! ./errors */ "./node_modules/asn1/lib/ber/errors.js");


// --- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;



// --- API

function Reader(data) {
  if (!data || !Buffer.isBuffer(data))
    throw new TypeError('data must be a node Buffer');

  this._buf = data;
  this._size = data.length;

  // These hold the "current" state
  this._len = 0;
  this._offset = 0;
}

Object.defineProperty(Reader.prototype, 'length', {
  enumerable: true,
  get: function () { return (this._len); }
});

Object.defineProperty(Reader.prototype, 'offset', {
  enumerable: true,
  get: function () { return (this._offset); }
});

Object.defineProperty(Reader.prototype, 'remain', {
  get: function () { return (this._size - this._offset); }
});

Object.defineProperty(Reader.prototype, 'buffer', {
  get: function () { return (this._buf.slice(this._offset)); }
});


/**
 * Reads a single byte and advances offset; you can pass in `true` to make this
 * a "peek" operation (i.e., get the byte, but don't advance the offset).
 *
 * @param {Boolean} peek true means don't move offset.
 * @return {Number} the next byte, null if not enough data.
 */
Reader.prototype.readByte = function (peek) {
  if (this._size - this._offset < 1)
    return null;

  var b = this._buf[this._offset] & 0xff;

  if (!peek)
    this._offset += 1;

  return b;
};


Reader.prototype.peek = function () {
  return this.readByte(true);
};


/**
 * Reads a (potentially) variable length off the BER buffer.  This call is
 * not really meant to be called directly, as callers have to manipulate
 * the internal buffer afterwards.
 *
 * As a result of this call, you can call `Reader.length`, until the
 * next thing called that does a readLength.
 *
 * @return {Number} the amount of offset to advance the buffer.
 * @throws {InvalidAsn1Error} on bad ASN.1
 */
Reader.prototype.readLength = function (offset) {
  if (offset === undefined)
    offset = this._offset;

  if (offset >= this._size)
    return null;

  var lenB = this._buf[offset++] & 0xff;
  if (lenB === null)
    return null;

  if ((lenB & 0x80) === 0x80) {
    lenB &= 0x7f;

    if (lenB === 0)
      throw newInvalidAsn1Error('Indefinite length not supported');

    if (lenB > 4)
      throw newInvalidAsn1Error('encoding too long');

    if (this._size - offset < lenB)
      return null;

    this._len = 0;
    for (var i = 0; i < lenB; i++)
      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);

  } else {
    // Wasn't a variable length
    this._len = lenB;
  }

  return offset;
};


/**
 * Parses the next sequence in this BER buffer.
 *
 * To get the length of the sequence, call `Reader.length`.
 *
 * @return {Number} the sequence's tag.
 */
Reader.prototype.readSequence = function (tag) {
  var seq = this.peek();
  if (seq === null)
    return null;
  if (tag !== undefined && tag !== seq)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + seq.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  this._offset = o;
  return seq;
};


Reader.prototype.readInt = function () {
  return this._readTag(ASN1.Integer);
};


Reader.prototype.readBoolean = function () {
  return (this._readTag(ASN1.Boolean) === 0 ? false : true);
};


Reader.prototype.readEnumeration = function () {
  return this._readTag(ASN1.Enumeration);
};


Reader.prototype.readString = function (tag, retbuf) {
  if (!tag)
    tag = ASN1.OctetString;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`

  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  if (this.length === 0)
    return retbuf ? Buffer.alloc(0) : '';

  var str = this._buf.slice(this._offset, this._offset + this.length);
  this._offset += this.length;

  return retbuf ? str : str.toString('utf8');
};

Reader.prototype.readOID = function (tag) {
  if (!tag)
    tag = ASN1.OID;

  var b = this.readString(tag, true);
  if (b === null)
    return null;

  var values = [];
  var value = 0;

  for (var i = 0; i < b.length; i++) {
    var byte = b[i] & 0xff;

    value <<= 7;
    value += byte & 0x7f;
    if ((byte & 0x80) === 0) {
      values.push(value);
      value = 0;
    }
  }

  value = values.shift();
  values.unshift(value % 40);
  values.unshift((value / 40) >> 0);

  return values.join('.');
};


Reader.prototype._readTag = function (tag) {
  assert.ok(tag !== undefined);

  var b = this.peek();

  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > 4)
    throw newInvalidAsn1Error('Integer too long: ' + this.length);

  if (this.length > this._size - o)
    return null;
  this._offset = o;

  var fb = this._buf[this._offset];
  var value = 0;

  for (var i = 0; i < this.length; i++) {
    value <<= 8;
    value |= (this._buf[this._offset++] & 0xff);
  }

  if ((fb & 0x80) === 0x80 && i !== 4)
    value -= (1 << (i * 8));

  return value >> 0;
};



// --- Exported API

module.exports = Reader;


/***/ }),

/***/ "./node_modules/asn1/lib/ber/types.js":
/*!********************************************!*\
  !*** ./node_modules/asn1/lib/ber/types.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9, // float
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
};


/***/ }),

/***/ "./node_modules/asn1/lib/ber/writer.js":
/*!*********************************************!*\
  !*** ./node_modules/asn1/lib/ber/writer.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = __webpack_require__(/*! assert */ "assert");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var ASN1 = __webpack_require__(/*! ./types */ "./node_modules/asn1/lib/ber/types.js");
var errors = __webpack_require__(/*! ./errors */ "./node_modules/asn1/lib/ber/errors.js");


// --- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;

var DEFAULT_OPTS = {
  size: 1024,
  growthFactor: 8
};


// --- Helpers

function merge(from, to) {
  assert.ok(from);
  assert.equal(typeof (from), 'object');
  assert.ok(to);
  assert.equal(typeof (to), 'object');

  var keys = Object.getOwnPropertyNames(from);
  keys.forEach(function (key) {
    if (to[key])
      return;

    var value = Object.getOwnPropertyDescriptor(from, key);
    Object.defineProperty(to, key, value);
  });

  return to;
}



// --- API

function Writer(options) {
  options = merge(DEFAULT_OPTS, options || {});

  this._buf = Buffer.alloc(options.size || 1024);
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;

  // A list of offsets in the buffer where we need to insert
  // sequence tag/len pairs.
  this._seq = [];
}

Object.defineProperty(Writer.prototype, 'buffer', {
  get: function () {
    if (this._seq.length)
      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');

    return (this._buf.slice(0, this._offset));
  }
});

Writer.prototype.writeByte = function (b) {
  if (typeof (b) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(1);
  this._buf[this._offset++] = b;
};


Writer.prototype.writeInt = function (i, tag) {
  if (typeof (i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof (tag) !== 'number')
    tag = ASN1.Integer;

  var sz = 4;

  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&
        (sz > 1)) {
    sz--;
    i <<= 8;
  }

  if (sz > 4)
    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');

  this._ensure(2 + sz);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;

  while (sz-- > 0) {
    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);
    i <<= 8;
  }

};


Writer.prototype.writeNull = function () {
  this.writeByte(ASN1.Null);
  this.writeByte(0x00);
};


Writer.prototype.writeEnumeration = function (i, tag) {
  if (typeof (i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof (tag) !== 'number')
    tag = ASN1.Enumeration;

  return this.writeInt(i, tag);
};


Writer.prototype.writeBoolean = function (b, tag) {
  if (typeof (b) !== 'boolean')
    throw new TypeError('argument must be a Boolean');
  if (typeof (tag) !== 'number')
    tag = ASN1.Boolean;

  this._ensure(3);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 0x01;
  this._buf[this._offset++] = b ? 0xff : 0x00;
};


Writer.prototype.writeString = function (s, tag) {
  if (typeof (s) !== 'string')
    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');
  if (typeof (tag) !== 'number')
    tag = ASN1.OctetString;

  var len = Buffer.byteLength(s);
  this.writeByte(tag);
  this.writeLength(len);
  if (len) {
    this._ensure(len);
    this._buf.write(s, this._offset);
    this._offset += len;
  }
};


Writer.prototype.writeBuffer = function (buf, tag) {
  if (typeof (tag) !== 'number')
    throw new TypeError('tag must be a number');
  if (!Buffer.isBuffer(buf))
    throw new TypeError('argument must be a buffer');

  this.writeByte(tag);
  this.writeLength(buf.length);
  this._ensure(buf.length);
  buf.copy(this._buf, this._offset, 0, buf.length);
  this._offset += buf.length;
};


Writer.prototype.writeStringArray = function (strings) {
  if ((!strings instanceof Array))
    throw new TypeError('argument must be an Array[String]');

  var self = this;
  strings.forEach(function (s) {
    self.writeString(s);
  });
};

// This is really to solve DER cases, but whatever for now
Writer.prototype.writeOID = function (s, tag) {
  if (typeof (s) !== 'string')
    throw new TypeError('argument must be a string');
  if (typeof (tag) !== 'number')
    tag = ASN1.OID;

  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
    throw new Error('argument is not a valid OID string');

  function encodeOctet(bytes, octet) {
    if (octet < 128) {
        bytes.push(octet);
    } else if (octet < 16384) {
        bytes.push((octet >>> 7) | 0x80);
        bytes.push(octet & 0x7F);
    } else if (octet < 2097152) {
      bytes.push((octet >>> 14) | 0x80);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else if (octet < 268435456) {
      bytes.push((octet >>> 21) | 0x80);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else {
      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    }
  }

  var tmp = s.split('.');
  var bytes = [];
  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
  tmp.slice(2).forEach(function (b) {
    encodeOctet(bytes, parseInt(b, 10));
  });

  var self = this;
  this._ensure(2 + bytes.length);
  this.writeByte(tag);
  this.writeLength(bytes.length);
  bytes.forEach(function (b) {
    self.writeByte(b);
  });
};


Writer.prototype.writeLength = function (len) {
  if (typeof (len) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(4);

  if (len <= 0x7f) {
    this._buf[this._offset++] = len;
  } else if (len <= 0xff) {
    this._buf[this._offset++] = 0x81;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffff) {
    this._buf[this._offset++] = 0x82;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffffff) {
    this._buf[this._offset++] = 0x83;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else {
    throw newInvalidAsn1Error('Length too long (> 4 bytes)');
  }
};

Writer.prototype.startSequence = function (tag) {
  if (typeof (tag) !== 'number')
    tag = ASN1.Sequence | ASN1.Constructor;

  this.writeByte(tag);
  this._seq.push(this._offset);
  this._ensure(3);
  this._offset += 3;
};


Writer.prototype.endSequence = function () {
  var seq = this._seq.pop();
  var start = seq + 3;
  var len = this._offset - start;

  if (len <= 0x7f) {
    this._shift(start, len, -2);
    this._buf[seq] = len;
  } else if (len <= 0xff) {
    this._shift(start, len, -1);
    this._buf[seq] = 0x81;
    this._buf[seq + 1] = len;
  } else if (len <= 0xffff) {
    this._buf[seq] = 0x82;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[seq] = 0x83;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
  } else {
    throw newInvalidAsn1Error('Sequence too long');
  }
};


Writer.prototype._shift = function (start, len, shift) {
  assert.ok(start !== undefined);
  assert.ok(len !== undefined);
  assert.ok(shift);

  this._buf.copy(this._buf, start + shift, start, start + len);
  this._offset += shift;
};

Writer.prototype._ensure = function (len) {
  assert.ok(len);

  if (this._size - this._offset < len) {
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len)
      sz += len;

    var buf = Buffer.alloc(sz);

    this._buf.copy(buf, 0, 0, this._offset);
    this._buf = buf;
    this._size = sz;
  }
};



// --- Exported API

module.exports = Writer;


/***/ }),

/***/ "./node_modules/asn1/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/asn1/lib/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

// If you have no idea what ASN.1 or BER is, see this:
// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc

var Ber = __webpack_require__(/*! ./ber/index */ "./node_modules/asn1/lib/ber/index.js");



// --- Exported API

module.exports = {

  Ber: Ber,

  BerReader: Ber.Reader,

  BerWriter: Ber.Writer

};


/***/ }),

/***/ "./node_modules/assert-plus/assert.js":
/*!********************************************!*\
  !*** ./node_modules/assert-plus/assert.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright (c) 2012, Mark Cavage. All rights reserved.
// Copyright 2015 Joyent, Inc.

var assert = __webpack_require__(/*! assert */ "assert");
var Stream = __webpack_require__(/*! stream */ "stream").Stream;
var util = __webpack_require__(/*! util */ "util");


///--- Globals

/* JSSTYLED */
var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;


///--- Internal

function _capitalize(str) {
    return (str.charAt(0).toUpperCase() + str.slice(1));
}

function _toss(name, expected, oper, arg, actual) {
    throw new assert.AssertionError({
        message: util.format('%s (%s) is required', name, expected),
        actual: (actual === undefined) ? typeof (arg) : actual(arg),
        expected: expected,
        operator: oper || '===',
        stackStartFunction: _toss.caller
    });
}

function _getClass(arg) {
    return (Object.prototype.toString.call(arg).slice(8, -1));
}

function noop() {
    // Why even bother with asserts?
}


///--- Exports

var types = {
    bool: {
        check: function (arg) { return typeof (arg) === 'boolean'; }
    },
    func: {
        check: function (arg) { return typeof (arg) === 'function'; }
    },
    string: {
        check: function (arg) { return typeof (arg) === 'string'; }
    },
    object: {
        check: function (arg) {
            return typeof (arg) === 'object' && arg !== null;
        }
    },
    number: {
        check: function (arg) {
            return typeof (arg) === 'number' && !isNaN(arg);
        }
    },
    finite: {
        check: function (arg) {
            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
        }
    },
    buffer: {
        check: function (arg) { return Buffer.isBuffer(arg); },
        operator: 'Buffer.isBuffer'
    },
    array: {
        check: function (arg) { return Array.isArray(arg); },
        operator: 'Array.isArray'
    },
    stream: {
        check: function (arg) { return arg instanceof Stream; },
        operator: 'instanceof',
        actual: _getClass
    },
    date: {
        check: function (arg) { return arg instanceof Date; },
        operator: 'instanceof',
        actual: _getClass
    },
    regexp: {
        check: function (arg) { return arg instanceof RegExp; },
        operator: 'instanceof',
        actual: _getClass
    },
    uuid: {
        check: function (arg) {
            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
        },
        operator: 'isUUID'
    }
};

function _setExports(ndebug) {
    var keys = Object.keys(types);
    var out;

    /* re-export standard assert */
    if (process.env.NODE_NDEBUG) {
        out = noop;
    } else {
        out = function (arg, msg) {
            if (!arg) {
                _toss(msg, 'true', arg);
            }
        };
    }

    /* standard checks */
    keys.forEach(function (k) {
        if (ndebug) {
            out[k] = noop;
            return;
        }
        var type = types[k];
        out[k] = function (arg, msg) {
            if (!type.check(arg)) {
                _toss(msg, k, type.operator, arg, type.actual);
            }
        };
    });

    /* optional checks */
    keys.forEach(function (k) {
        var name = 'optional' + _capitalize(k);
        if (ndebug) {
            out[name] = noop;
            return;
        }
        var type = types[k];
        out[name] = function (arg, msg) {
            if (arg === undefined || arg === null) {
                return;
            }
            if (!type.check(arg)) {
                _toss(msg, k, type.operator, arg, type.actual);
            }
        };
    });

    /* arrayOf checks */
    keys.forEach(function (k) {
        var name = 'arrayOf' + _capitalize(k);
        if (ndebug) {
            out[name] = noop;
            return;
        }
        var type = types[k];
        var expected = '[' + k + ']';
        out[name] = function (arg, msg) {
            if (!Array.isArray(arg)) {
                _toss(msg, expected, type.operator, arg, type.actual);
            }
            var i;
            for (i = 0; i < arg.length; i++) {
                if (!type.check(arg[i])) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
            }
        };
    });

    /* optionalArrayOf checks */
    keys.forEach(function (k) {
        var name = 'optionalArrayOf' + _capitalize(k);
        if (ndebug) {
            out[name] = noop;
            return;
        }
        var type = types[k];
        var expected = '[' + k + ']';
        out[name] = function (arg, msg) {
            if (arg === undefined || arg === null) {
                return;
            }
            if (!Array.isArray(arg)) {
                _toss(msg, expected, type.operator, arg, type.actual);
            }
            var i;
            for (i = 0; i < arg.length; i++) {
                if (!type.check(arg[i])) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
            }
        };
    });

    /* re-export built-in assertions */
    Object.keys(assert).forEach(function (k) {
        if (k === 'AssertionError') {
            out[k] = assert[k];
            return;
        }
        if (ndebug) {
            out[k] = noop;
            return;
        }
        out[k] = assert[k];
    });

    /* export ourselves (for unit tests _only_) */
    out._setExports = _setExports;

    return out;
}

module.exports = _setExports(process.env.NODE_NDEBUG);


/***/ }),

/***/ "./node_modules/asynckit/index.js":
/*!****************************************!*\
  !*** ./node_modules/asynckit/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports =
{
  parallel      : __webpack_require__(/*! ./parallel.js */ "./node_modules/asynckit/parallel.js"),
  serial        : __webpack_require__(/*! ./serial.js */ "./node_modules/asynckit/serial.js"),
  serialOrdered : __webpack_require__(/*! ./serialOrdered.js */ "./node_modules/asynckit/serialOrdered.js")
};


/***/ }),

/***/ "./node_modules/asynckit/lib/abort.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/abort.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),

/***/ "./node_modules/asynckit/lib/async.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/async.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defer = __webpack_require__(/*! ./defer.js */ "./node_modules/asynckit/lib/defer.js");

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),

/***/ "./node_modules/asynckit/lib/defer.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/defer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ "./node_modules/asynckit/lib/iterate.js":
/*!**********************************************!*\
  !*** ./node_modules/asynckit/lib/iterate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var async = __webpack_require__(/*! ./async.js */ "./node_modules/asynckit/lib/async.js")
  , abort = __webpack_require__(/*! ./abort.js */ "./node_modules/asynckit/lib/abort.js")
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),

/***/ "./node_modules/asynckit/lib/state.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/state.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),

/***/ "./node_modules/asynckit/lib/terminator.js":
/*!*************************************************!*\
  !*** ./node_modules/asynckit/lib/terminator.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var abort = __webpack_require__(/*! ./abort.js */ "./node_modules/asynckit/lib/abort.js")
  , async = __webpack_require__(/*! ./async.js */ "./node_modules/asynckit/lib/async.js")
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),

/***/ "./node_modules/asynckit/parallel.js":
/*!*******************************************!*\
  !*** ./node_modules/asynckit/parallel.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var iterate    = __webpack_require__(/*! ./lib/iterate.js */ "./node_modules/asynckit/lib/iterate.js")
  , initState  = __webpack_require__(/*! ./lib/state.js */ "./node_modules/asynckit/lib/state.js")
  , terminator = __webpack_require__(/*! ./lib/terminator.js */ "./node_modules/asynckit/lib/terminator.js")
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),

/***/ "./node_modules/asynckit/serial.js":
/*!*****************************************!*\
  !*** ./node_modules/asynckit/serial.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var serialOrdered = __webpack_require__(/*! ./serialOrdered.js */ "./node_modules/asynckit/serialOrdered.js");

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),

/***/ "./node_modules/asynckit/serialOrdered.js":
/*!************************************************!*\
  !*** ./node_modules/asynckit/serialOrdered.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var iterate    = __webpack_require__(/*! ./lib/iterate.js */ "./node_modules/asynckit/lib/iterate.js")
  , initState  = __webpack_require__(/*! ./lib/state.js */ "./node_modules/asynckit/lib/state.js")
  , terminator = __webpack_require__(/*! ./lib/terminator.js */ "./node_modules/asynckit/lib/terminator.js")
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),

/***/ "./node_modules/aws-sign2/index.js":
/*!*****************************************!*\
  !*** ./node_modules/aws-sign2/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/*!
 *  Copyright 2010 LearnBoost <dev@learnboost.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Module dependencies.
 */

var crypto = __webpack_require__(/*! crypto */ "crypto")
  , parse = __webpack_require__(/*! url */ "url").parse
  ;

/**
 * Valid keys.
 */

var keys = 
  [ 'acl'
  , 'location'
  , 'logging'
  , 'notification'
  , 'partNumber'
  , 'policy'
  , 'requestPayment'
  , 'torrent'
  , 'uploadId'
  , 'uploads'
  , 'versionId'
  , 'versioning'
  , 'versions'
  , 'website'
  ]

/**
 * Return an "Authorization" header value with the given `options`
 * in the form of "AWS <key>:<signature>"
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function authorization (options) {
  return 'AWS ' + options.key + ':' + sign(options)
}

module.exports = authorization
module.exports.authorization = authorization

/**
 * Simple HMAC-SHA1 Wrapper
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */ 

function hmacSha1 (options) {
  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
}

module.exports.hmacSha1 = hmacSha1

/**
 * Create a base64 sha1 HMAC for `options`. 
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function sign (options) {
  options.message = stringToSign(options)
  return hmacSha1(options)
}
module.exports.sign = sign

/**
 * Create a base64 sha1 HMAC for `options`. 
 *
 * Specifically to be used with S3 presigned URLs
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function signQuery (options) {
  options.message = queryStringToSign(options)
  return hmacSha1(options)
}
module.exports.signQuery= signQuery

/**
 * Return a string for sign() with the given `options`.
 *
 * Spec:
 * 
 *    <verb>\n
 *    <md5>\n
 *    <content-type>\n
 *    <date>\n
 *    [headers\n]
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function stringToSign (options) {
  var headers = options.amazonHeaders || ''
  if (headers) headers += '\n'
  var r = 
    [ options.verb
    , options.md5
    , options.contentType
    , options.date ? options.date.toUTCString() : ''
    , headers + options.resource
    ]
  return r.join('\n')
}
module.exports.stringToSign = stringToSign

/**
 * Return a string for sign() with the given `options`, but is meant exclusively
 * for S3 presigned URLs
 *
 * Spec:
 * 
 *    <date>\n
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function queryStringToSign (options){
  return 'GET\n\n\n' + options.date + '\n' + options.resource
}
module.exports.queryStringToSign = queryStringToSign

/**
 * Perform the following:
 *
 *  - ignore non-amazon headers
 *  - lowercase fields
 *  - sort lexicographically
 *  - trim whitespace between ":"
 *  - join with newline
 *
 * @param {Object} headers
 * @return {String}
 * @api private
 */

function canonicalizeHeaders (headers) {
  var buf = []
    , fields = Object.keys(headers)
    ;
  for (var i = 0, len = fields.length; i < len; ++i) {
    var field = fields[i]
      , val = headers[field]
      , field = field.toLowerCase()
      ;
    if (0 !== field.indexOf('x-amz')) continue
    buf.push(field + ':' + val)
  }
  return buf.sort().join('\n')
}
module.exports.canonicalizeHeaders = canonicalizeHeaders

/**
 * Perform the following:
 *
 *  - ignore non sub-resources
 *  - sort lexicographically
 *
 * @param {String} resource
 * @return {String}
 * @api private
 */

function canonicalizeResource (resource) {
  var url = parse(resource, true)
    , path = url.pathname
    , buf = []
    ;

  Object.keys(url.query).forEach(function(key){
    if (!~keys.indexOf(key)) return
    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
    buf.push(key + val)
  })

  return path + (buf.length ? '?' + buf.sort().join('&') : '')
}
module.exports.canonicalizeResource = canonicalizeResource


/***/ }),

/***/ "./node_modules/aws4/aws4.js":
/*!***********************************!*\
  !*** ./node_modules/aws4/aws4.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aws4 = exports,
    url = __webpack_require__(/*! url */ "url"),
    querystring = __webpack_require__(/*! querystring */ "querystring"),
    crypto = __webpack_require__(/*! crypto */ "crypto"),
    lru = __webpack_require__(/*! ./lru */ "./node_modules/aws4/lru.js"),
    credentialsCache = lru(1000)

// http://docs.amazonwebservices.com/general/latest/gr/signature-version-4.html

function hmac(key, string, encoding) {
  return crypto.createHmac('sha256', key).update(string, 'utf8').digest(encoding)
}

function hash(string, encoding) {
  return crypto.createHash('sha256').update(string, 'utf8').digest(encoding)
}

// This function assumes the string has already been percent encoded
function encodeRfc3986(urlEncodedString) {
  return urlEncodedString.replace(/[!'()*]/g, function(c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

// request: { path | body, [host], [method], [headers], [service], [region] }
// credentials: { accessKeyId, secretAccessKey, [sessionToken] }
function RequestSigner(request, credentials) {

  if (typeof request === 'string') request = url.parse(request)

  var headers = request.headers = (request.headers || {}),
      hostParts = this.matchHost(request.hostname || request.host || headers.Host || headers.host)

  this.request = request
  this.credentials = credentials || this.defaultCredentials()

  this.service = request.service || hostParts[0] || ''
  this.region = request.region || hostParts[1] || 'us-east-1'

  // SES uses a different domain from the service name
  if (this.service === 'email') this.service = 'ses'

  if (!request.method && request.body)
    request.method = 'POST'

  if (!headers.Host && !headers.host) {
    headers.Host = request.hostname || request.host || this.createHost()

    // If a port is specified explicitly, use it as is
    if (request.port)
      headers.Host += ':' + request.port
  }
  if (!request.hostname && !request.host)
    request.hostname = headers.Host || headers.host

  this.isCodeCommitGit = this.service === 'codecommit' && request.method === 'GIT'
}

RequestSigner.prototype.matchHost = function(host) {
  var match = (host || '').match(/([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com(\.cn)?$/)
  var hostParts = (match || []).slice(1, 3)

  // ES's hostParts are sometimes the other way round, if the value that is expected
  // to be region equals ‘es’ switch them back
  // e.g. search-cluster-name-aaaa00aaaa0aaa0aaaaaaa0aaa.us-east-1.es.amazonaws.com
  if (hostParts[1] === 'es')
    hostParts = hostParts.reverse()

  return hostParts
}

// http://docs.aws.amazon.com/general/latest/gr/rande.html
RequestSigner.prototype.isSingleRegion = function() {
  // Special case for S3 and SimpleDB in us-east-1
  if (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1') return true

  return ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts']
    .indexOf(this.service) >= 0
}

RequestSigner.prototype.createHost = function() {
  var region = this.isSingleRegion() ? '' :
        (this.service === 's3' && this.region !== 'us-east-1' ? '-' : '.') + this.region,
      service = this.service === 'ses' ? 'email' : this.service
  return service + region + '.amazonaws.com'
}

RequestSigner.prototype.prepareRequest = function() {
  this.parsePath()

  var request = this.request, headers = request.headers, query

  if (request.signQuery) {

    this.parsedPath.query = query = this.parsedPath.query || {}

    if (this.credentials.sessionToken)
      query['X-Amz-Security-Token'] = this.credentials.sessionToken

    if (this.service === 's3' && !query['X-Amz-Expires'])
      query['X-Amz-Expires'] = 86400

    if (query['X-Amz-Date'])
      this.datetime = query['X-Amz-Date']
    else
      query['X-Amz-Date'] = this.getDateTime()

    query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256'
    query['X-Amz-Credential'] = this.credentials.accessKeyId + '/' + this.credentialString()
    query['X-Amz-SignedHeaders'] = this.signedHeaders()

  } else {

    if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
      if (request.body && !headers['Content-Type'] && !headers['content-type'])
        headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8'

      if (request.body && !headers['Content-Length'] && !headers['content-length'])
        headers['Content-Length'] = Buffer.byteLength(request.body)

      if (this.credentials.sessionToken && !headers['X-Amz-Security-Token'] && !headers['x-amz-security-token'])
        headers['X-Amz-Security-Token'] = this.credentials.sessionToken

      if (this.service === 's3' && !headers['X-Amz-Content-Sha256'] && !headers['x-amz-content-sha256'])
        headers['X-Amz-Content-Sha256'] = hash(this.request.body || '', 'hex')

      if (headers['X-Amz-Date'] || headers['x-amz-date'])
        this.datetime = headers['X-Amz-Date'] || headers['x-amz-date']
      else
        headers['X-Amz-Date'] = this.getDateTime()
    }

    delete headers.Authorization
    delete headers.authorization
  }
}

RequestSigner.prototype.sign = function() {
  if (!this.parsedPath) this.prepareRequest()

  if (this.request.signQuery) {
    this.parsedPath.query['X-Amz-Signature'] = this.signature()
  } else {
    this.request.headers.Authorization = this.authHeader()
  }

  this.request.path = this.formatPath()

  return this.request
}

RequestSigner.prototype.getDateTime = function() {
  if (!this.datetime) {
    var headers = this.request.headers,
      date = new Date(headers.Date || headers.date || new Date)

    this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, '')

    // Remove the trailing 'Z' on the timestamp string for CodeCommit git access
    if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1)
  }
  return this.datetime
}

RequestSigner.prototype.getDate = function() {
  return this.getDateTime().substr(0, 8)
}

RequestSigner.prototype.authHeader = function() {
  return [
    'AWS4-HMAC-SHA256 Credential=' + this.credentials.accessKeyId + '/' + this.credentialString(),
    'SignedHeaders=' + this.signedHeaders(),
    'Signature=' + this.signature(),
  ].join(', ')
}

RequestSigner.prototype.signature = function() {
  var date = this.getDate(),
      cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(),
      kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey)
  if (!kCredentials) {
    kDate = hmac('AWS4' + this.credentials.secretAccessKey, date)
    kRegion = hmac(kDate, this.region)
    kService = hmac(kRegion, this.service)
    kCredentials = hmac(kService, 'aws4_request')
    credentialsCache.set(cacheKey, kCredentials)
  }
  return hmac(kCredentials, this.stringToSign(), 'hex')
}

RequestSigner.prototype.stringToSign = function() {
  return [
    'AWS4-HMAC-SHA256',
    this.getDateTime(),
    this.credentialString(),
    hash(this.canonicalString(), 'hex'),
  ].join('\n')
}

RequestSigner.prototype.canonicalString = function() {
  if (!this.parsedPath) this.prepareRequest()

  var pathStr = this.parsedPath.path,
      query = this.parsedPath.query,
      headers = this.request.headers,
      queryStr = '',
      normalizePath = this.service !== 's3',
      decodePath = this.service === 's3' || this.request.doNotEncodePath,
      decodeSlashesInPath = this.service === 's3',
      firstValOnly = this.service === 's3',
      bodyHash

  if (this.service === 's3' && this.request.signQuery) {
    bodyHash = 'UNSIGNED-PAYLOAD'
  } else if (this.isCodeCommitGit) {
    bodyHash = ''
  } else {
    bodyHash = headers['X-Amz-Content-Sha256'] || headers['x-amz-content-sha256'] ||
      hash(this.request.body || '', 'hex')
  }

  if (query) {
    queryStr = encodeRfc3986(querystring.stringify(Object.keys(query).sort().reduce(function(obj, key) {
      if (!key) return obj
      obj[key] = !Array.isArray(query[key]) ? query[key] :
        (firstValOnly ? query[key][0] : query[key].slice().sort())
      return obj
    }, {})))
  }
  if (pathStr !== '/') {
    if (normalizePath) pathStr = pathStr.replace(/\/{2,}/g, '/')
    pathStr = pathStr.split('/').reduce(function(path, piece) {
      if (normalizePath && piece === '..') {
        path.pop()
      } else if (!normalizePath || piece !== '.') {
        if (decodePath) piece = decodeURIComponent(piece)
        path.push(encodeRfc3986(encodeURIComponent(piece)))
      }
      return path
    }, []).join('/')
    if (pathStr[0] !== '/') pathStr = '/' + pathStr
    if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/')
  }

  return [
    this.request.method || 'GET',
    pathStr,
    queryStr,
    this.canonicalHeaders() + '\n',
    this.signedHeaders(),
    bodyHash,
  ].join('\n')
}

RequestSigner.prototype.canonicalHeaders = function() {
  var headers = this.request.headers
  function trimAll(header) {
    return header.toString().trim().replace(/\s+/g, ' ')
  }
  return Object.keys(headers)
    .sort(function(a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1 })
    .map(function(key) { return key.toLowerCase() + ':' + trimAll(headers[key]) })
    .join('\n')
}

RequestSigner.prototype.signedHeaders = function() {
  return Object.keys(this.request.headers)
    .map(function(key) { return key.toLowerCase() })
    .sort()
    .join(';')
}

RequestSigner.prototype.credentialString = function() {
  return [
    this.getDate(),
    this.region,
    this.service,
    'aws4_request',
  ].join('/')
}

RequestSigner.prototype.defaultCredentials = function() {
  var env = process.env
  return {
    accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
    secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
    sessionToken: env.AWS_SESSION_TOKEN,
  }
}

RequestSigner.prototype.parsePath = function() {
  var path = this.request.path || '/',
      queryIx = path.indexOf('?'),
      query = null

  if (queryIx >= 0) {
    query = querystring.parse(path.slice(queryIx + 1))
    path = path.slice(0, queryIx)
  }

  // S3 doesn't always encode characters > 127 correctly and
  // all services don't encode characters > 255 correctly
  // So if there are non-reserved chars (and it's not already all % encoded), just encode them all
  if (/[^0-9A-Za-z!'()*\-._~%/]/.test(path)) {
    path = path.split('/').map(function(piece) {
      return encodeURIComponent(decodeURIComponent(piece))
    }).join('/')
  }

  this.parsedPath = {
    path: path,
    query: query,
  }
}

RequestSigner.prototype.formatPath = function() {
  var path = this.parsedPath.path,
      query = this.parsedPath.query

  if (!query) return path

  // Services don't support empty query string keys
  if (query[''] != null) delete query['']

  return path + '?' + encodeRfc3986(querystring.stringify(query))
}

aws4.RequestSigner = RequestSigner

aws4.sign = function(request, credentials) {
  return new RequestSigner(request, credentials).sign()
}


/***/ }),

/***/ "./node_modules/aws4/lru.js":
/*!**********************************!*\
  !*** ./node_modules/aws4/lru.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(size) {
  return new LruCache(size)
}

function LruCache(size) {
  this.capacity = size | 0
  this.map = Object.create(null)
  this.list = new DoublyLinkedList()
}

LruCache.prototype.get = function(key) {
  var node = this.map[key]
  if (node == null) return undefined
  this.used(node)
  return node.val
}

LruCache.prototype.set = function(key, val) {
  var node = this.map[key]
  if (node != null) {
    node.val = val
  } else {
    if (!this.capacity) this.prune()
    if (!this.capacity) return false
    node = new DoublyLinkedNode(key, val)
    this.map[key] = node
    this.capacity--
  }
  this.used(node)
  return true
}

LruCache.prototype.used = function(node) {
  this.list.moveToFront(node)
}

LruCache.prototype.prune = function() {
  var node = this.list.pop()
  if (node != null) {
    delete this.map[node.key]
    this.capacity++
  }
}


function DoublyLinkedList() {
  this.firstNode = null
  this.lastNode = null
}

DoublyLinkedList.prototype.moveToFront = function(node) {
  if (this.firstNode == node) return

  this.remove(node)

  if (this.firstNode == null) {
    this.firstNode = node
    this.lastNode = node
    node.prev = null
    node.next = null
  } else {
    node.prev = null
    node.next = this.firstNode
    node.next.prev = node
    this.firstNode = node
  }
}

DoublyLinkedList.prototype.pop = function() {
  var lastNode = this.lastNode
  if (lastNode != null) {
    this.remove(lastNode)
  }
  return lastNode
}

DoublyLinkedList.prototype.remove = function(node) {
  if (this.firstNode == node) {
    this.firstNode = node.next
  } else if (node.prev != null) {
    node.prev.next = node.next
  }
  if (this.lastNode == node) {
    this.lastNode = node.prev
  } else if (node.next != null) {
    node.next.prev = node.prev
  }
}


function DoublyLinkedNode(key, val) {
  this.key = key
  this.val = val
  this.prev = null
  this.next = null
}


/***/ }),

/***/ "./node_modules/bcrypt-pbkdf/index.js":
/*!********************************************!*\
  !*** ./node_modules/bcrypt-pbkdf/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var crypto_hash_sha512 = __webpack_require__(/*! tweetnacl */ "./node_modules/tweetnacl/nacl-fast.js").lowlevel.crypto_hash;

/*
 * This file is a 1:1 port from the OpenBSD blowfish.c and bcrypt_pbkdf.c. As a
 * result, it retains the original copyright and license. The two files are
 * under slightly different (but compatible) licenses, and are here combined in
 * one file.
 *
 * Credit for the actual porting work goes to:
 *  Devi Mandiri <me@devi.web.id>
 */

/*
 * The Blowfish portions are under the following license:
 *
 * Blowfish block cipher for OpenBSD
 * Copyright 1997 Niels Provos <provos@physnet.uni-hamburg.de>
 * All rights reserved.
 *
 * Implementation advice by David Mazieres <dm@lcs.mit.edu>.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * The bcrypt_pbkdf portions are under the following license:
 *
 * Copyright (c) 2013 Ted Unangst <tedu@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Performance improvements (Javascript-specific):
 *
 * Copyright 2016, Joyent Inc
 * Author: Alex Wilson <alex.wilson@joyent.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

// Ported from OpenBSD bcrypt_pbkdf.c v1.9

var BLF_J = 0;

var Blowfish = function() {
  this.S = [
    new Uint32Array([
      0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,
      0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
      0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
      0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
      0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
      0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
      0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,
      0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
      0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
      0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
      0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,
      0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
      0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,
      0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
      0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
      0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
      0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,
      0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
      0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,
      0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
      0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
      0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
      0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,
      0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
      0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
      0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
      0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
      0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
      0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,
      0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
      0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,
      0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
      0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
      0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
      0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
      0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
      0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,
      0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
      0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
      0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
      0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,
      0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
      0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,
      0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
      0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
      0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
      0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,
      0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
      0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,
      0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
      0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
      0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
      0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,
      0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
      0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
      0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
      0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
      0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
      0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,
      0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
      0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,
      0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
      0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
      0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a]),
    new Uint32Array([
      0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
      0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
      0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
      0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
      0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,
      0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
      0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,
      0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
      0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
      0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
      0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
      0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
      0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,
      0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
      0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
      0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
      0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,
      0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
      0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,
      0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
      0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
      0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
      0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,
      0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
      0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,
      0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
      0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
      0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
      0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,
      0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
      0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
      0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
      0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
      0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
      0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,
      0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
      0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,
      0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
      0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
      0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
      0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
      0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
      0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,
      0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
      0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
      0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
      0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,
      0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
      0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,
      0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
      0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
      0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
      0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,
      0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
      0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,
      0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
      0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
      0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
      0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,
      0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
      0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
      0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
      0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
      0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7]),
    new Uint32Array([
      0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,
      0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
      0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
      0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
      0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,
      0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
      0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
      0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
      0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
      0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
      0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,
      0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
      0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,
      0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
      0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
      0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
      0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
      0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
      0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,
      0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
      0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
      0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
      0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,
      0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
      0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,
      0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
      0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
      0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
      0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,
      0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
      0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,
      0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
      0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
      0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
      0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,
      0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
      0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
      0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
      0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
      0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
      0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,
      0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
      0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,
      0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
      0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
      0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
      0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
      0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
      0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,
      0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
      0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
      0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
      0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,
      0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
      0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,
      0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
      0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
      0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
      0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,
      0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
      0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,
      0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
      0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
      0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0]),
    new Uint32Array([
      0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,
      0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
      0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
      0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
      0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,
      0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
      0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,
      0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
      0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
      0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
      0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,
      0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
      0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
      0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
      0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
      0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
      0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,
      0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
      0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,
      0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
      0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
      0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
      0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
      0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
      0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,
      0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
      0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
      0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
      0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,
      0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
      0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,
      0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
      0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
      0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
      0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,
      0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
      0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,
      0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
      0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
      0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
      0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,
      0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
      0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
      0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
      0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
      0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
      0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,
      0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
      0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,
      0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
      0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
      0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
      0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
      0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
      0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,
      0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
      0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
      0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
      0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,
      0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
      0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,
      0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
      0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
      0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6])
    ];
  this.P = new Uint32Array([
    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,
    0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
    0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
    0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
    0x9216d5d9, 0x8979fb1b]);
};

function F(S, x8, i) {
  return (((S[0][x8[i+3]] +
            S[1][x8[i+2]]) ^
            S[2][x8[i+1]]) +
            S[3][x8[i]]);
};

Blowfish.prototype.encipher = function(x, x8) {
  if (x8 === undefined) {
    x8 = new Uint8Array(x.buffer);
    if (x.byteOffset !== 0)
      x8 = x8.subarray(x.byteOffset);
  }
  x[0] ^= this.P[0];
  for (var i = 1; i < 16; i += 2) {
    x[1] ^= F(this.S, x8, 0) ^ this.P[i];
    x[0] ^= F(this.S, x8, 4) ^ this.P[i+1];
  }
  var t = x[0];
  x[0] = x[1] ^ this.P[17];
  x[1] = t;
};

Blowfish.prototype.decipher = function(x) {
  var x8 = new Uint8Array(x.buffer);
  if (x.byteOffset !== 0)
    x8 = x8.subarray(x.byteOffset);
  x[0] ^= this.P[17];
  for (var i = 16; i > 0; i -= 2) {
    x[1] ^= F(this.S, x8, 0) ^ this.P[i];
    x[0] ^= F(this.S, x8, 4) ^ this.P[i-1];
  }
  var t = x[0];
  x[0] = x[1] ^ this.P[0];
  x[1] = t;
};

function stream2word(data, databytes){
  var i, temp = 0;
  for (i = 0; i < 4; i++, BLF_J++) {
    if (BLF_J >= databytes) BLF_J = 0;
    temp = (temp << 8) | data[BLF_J];
  }
  return temp;
};

Blowfish.prototype.expand0state = function(key, keybytes) {
  var d = new Uint32Array(2), i, k;
  var d8 = new Uint8Array(d.buffer);

  for (i = 0, BLF_J = 0; i < 18; i++) {
    this.P[i] ^= stream2word(key, keybytes);
  }
  BLF_J = 0;

  for (i = 0; i < 18; i += 2) {
    this.encipher(d, d8);
    this.P[i]   = d[0];
    this.P[i+1] = d[1];
  }

  for (i = 0; i < 4; i++) {
    for (k = 0; k < 256; k += 2) {
      this.encipher(d, d8);
      this.S[i][k]   = d[0];
      this.S[i][k+1] = d[1];
    }
  }
};

Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
  var d = new Uint32Array(2), i, k;

  for (i = 0, BLF_J = 0; i < 18; i++) {
    this.P[i] ^= stream2word(key, keybytes);
  }

  for (i = 0, BLF_J = 0; i < 18; i += 2) {
    d[0] ^= stream2word(data, databytes);
    d[1] ^= stream2word(data, databytes);
    this.encipher(d);
    this.P[i]   = d[0];
    this.P[i+1] = d[1];
  }

  for (i = 0; i < 4; i++) {
    for (k = 0; k < 256; k += 2) {
      d[0] ^= stream2word(data, databytes);
      d[1] ^= stream2word(data, databytes);
      this.encipher(d);
      this.S[i][k]   = d[0];
      this.S[i][k+1] = d[1];
    }
  }
  BLF_J = 0;
};

Blowfish.prototype.enc = function(data, blocks) {
  for (var i = 0; i < blocks; i++) {
    this.encipher(data.subarray(i*2));
  }
};

Blowfish.prototype.dec = function(data, blocks) {
  for (var i = 0; i < blocks; i++) {
    this.decipher(data.subarray(i*2));
  }
};

var BCRYPT_BLOCKS = 8,
    BCRYPT_HASHSIZE = 32;

function bcrypt_hash(sha2pass, sha2salt, out) {
  var state = new Blowfish(),
      cdata = new Uint32Array(BCRYPT_BLOCKS), i,
      ciphertext = new Uint8Array([79,120,121,99,104,114,111,109,97,116,105,
            99,66,108,111,119,102,105,115,104,83,119,97,116,68,121,110,97,109,
            105,116,101]); //"OxychromaticBlowfishSwatDynamite"

  state.expandstate(sha2salt, 64, sha2pass, 64);
  for (i = 0; i < 64; i++) {
    state.expand0state(sha2salt, 64);
    state.expand0state(sha2pass, 64);
  }

  for (i = 0; i < BCRYPT_BLOCKS; i++)
    cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
  for (i = 0; i < 64; i++)
    state.enc(cdata, cdata.byteLength / 8);

  for (i = 0; i < BCRYPT_BLOCKS; i++) {
    out[4*i+3] = cdata[i] >>> 24;
    out[4*i+2] = cdata[i] >>> 16;
    out[4*i+1] = cdata[i] >>> 8;
    out[4*i+0] = cdata[i];
  }
};

function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
  var sha2pass = new Uint8Array(64),
      sha2salt = new Uint8Array(64),
      out = new Uint8Array(BCRYPT_HASHSIZE),
      tmpout = new Uint8Array(BCRYPT_HASHSIZE),
      countsalt = new Uint8Array(saltlen+4),
      i, j, amt, stride, dest, count,
      origkeylen = keylen;

  if (rounds < 1)
    return -1;
  if (passlen === 0 || saltlen === 0 || keylen === 0 ||
      keylen > (out.byteLength * out.byteLength) || saltlen > (1<<20))
    return -1;

  stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
  amt = Math.floor((keylen + stride - 1) / stride);

  for (i = 0; i < saltlen; i++)
    countsalt[i] = salt[i];

  crypto_hash_sha512(sha2pass, pass, passlen);

  for (count = 1; keylen > 0; count++) {
    countsalt[saltlen+0] = count >>> 24;
    countsalt[saltlen+1] = count >>> 16;
    countsalt[saltlen+2] = count >>>  8;
    countsalt[saltlen+3] = count;

    crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
    bcrypt_hash(sha2pass, sha2salt, tmpout);
    for (i = out.byteLength; i--;)
      out[i] = tmpout[i];

    for (i = 1; i < rounds; i++) {
      crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
      bcrypt_hash(sha2pass, sha2salt, tmpout);
      for (j = 0; j < out.byteLength; j++)
        out[j] ^= tmpout[j];
    }

    amt = Math.min(amt, keylen);
    for (i = 0; i < amt; i++) {
      dest = i * stride + (count - 1);
      if (dest >= origkeylen)
        break;
      key[dest] = out[i];
    }
    keylen -= i;
  }

  return 0;
};

module.exports = {
      BLOCKS: BCRYPT_BLOCKS,
      HASHSIZE: BCRYPT_HASHSIZE,
      hash: bcrypt_hash,
      pbkdf: bcrypt_pbkdf
};


/***/ }),

/***/ "./node_modules/caseless/index.js":
/*!****************************************!*\
  !*** ./node_modules/caseless/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function Caseless (dict) {
  this.dict = dict || {}
}
Caseless.prototype.set = function (name, value, clobber) {
  if (typeof name === 'object') {
    for (var i in name) {
      this.set(i, name[i], value)
    }
  } else {
    if (typeof clobber === 'undefined') clobber = true
    var has = this.has(name)

    if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value
    else this.dict[has || name] = value
    return has
  }
}
Caseless.prototype.has = function (name) {
  var keys = Object.keys(this.dict)
    , name = name.toLowerCase()
    ;
  for (var i=0;i<keys.length;i++) {
    if (keys[i].toLowerCase() === name) return keys[i]
  }
  return false
}
Caseless.prototype.get = function (name) {
  name = name.toLowerCase()
  var result, _key
  var headers = this.dict
  Object.keys(headers).forEach(function (key) {
    _key = key.toLowerCase()
    if (name === _key) result = headers[key]
  })
  return result
}
Caseless.prototype.swap = function (name) {
  var has = this.has(name)
  if (has === name) return
  if (!has) throw new Error('There is no header than matches "'+name+'"')
  this.dict[name] = this.dict[has]
  delete this.dict[has]
}
Caseless.prototype.del = function (name) {
  var has = this.has(name)
  return delete this.dict[has || name]
}

module.exports = function (dict) {return new Caseless(dict)}
module.exports.httpify = function (resp, headers) {
  var c = new Caseless(headers)
  resp.setHeader = function (key, value, clobber) {
    if (typeof value === 'undefined') return
    return c.set(key, value, clobber)
  }
  resp.hasHeader = function (key) {
    return c.has(key)
  }
  resp.getHeader = function (key) {
    return c.get(key)
  }
  resp.removeHeader = function (key) {
    return c.del(key)
  }
  resp.headers = c.dict
  return c
}


/***/ }),

/***/ "./node_modules/combined-stream/lib/combined_stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/combined-stream/lib/combined_stream.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(/*! util */ "util");
var Stream = __webpack_require__(/*! stream */ "stream").Stream;
var DelayedStream = __webpack_require__(/*! delayed-stream */ "./node_modules/delayed-stream/lib/delayed_stream.js");
var defer = __webpack_require__(/*! ./defer.js */ "./node_modules/combined-stream/lib/defer.js");

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    defer(this._pipeNext.bind(this, stream));
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),

/***/ "./node_modules/combined-stream/lib/defer.js":
/*!***************************************************!*\
  !*** ./node_modules/combined-stream/lib/defer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),

/***/ "./node_modules/delayed-stream/lib/delayed_stream.js":
/*!***********************************************************!*\
  !*** ./node_modules/delayed-stream/lib/delayed_stream.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__(/*! stream */ "stream").Stream;
var util = __webpack_require__(/*! util */ "util");

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),

/***/ "./node_modules/ecc-jsbn/index.js":
/*!****************************************!*\
  !*** ./node_modules/ecc-jsbn/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var crypto = __webpack_require__(/*! crypto */ "crypto");
var BigInteger = __webpack_require__(/*! jsbn */ "./node_modules/jsbn/index.js").BigInteger;
var ECPointFp = __webpack_require__(/*! ./lib/ec.js */ "./node_modules/ecc-jsbn/lib/ec.js").ECPointFp;
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
exports.ECCurves = __webpack_require__(/*! ./lib/sec.js */ "./node_modules/ecc-jsbn/lib/sec.js");

// zero prepad
function unstupid(hex,len)
{
	return (hex.length >= len) ? hex : unstupid("0"+hex,len);
}

exports.ECKey = function(curve, key, isPublic)
{
  var priv;
	var c = curve();
	var n = c.getN();
  var bytes = Math.floor(n.bitLength()/8);

  if(key)
  {
    if(isPublic)
    {
      var curve = c.getCurve();
//      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format
//      var y = key.slice(bytes+1);
//      this.P = new ECPointFp(curve,
//        curve.fromBigInteger(new BigInteger(x.toString("hex"), 16)),
//        curve.fromBigInteger(new BigInteger(y.toString("hex"), 16)));      
      this.P = curve.decodePointHex(key.toString("hex"));
    }else{
      if(key.length != bytes) return false;
      priv = new BigInteger(key.toString("hex"), 16);      
    }
  }else{
    var n1 = n.subtract(BigInteger.ONE);
    var r = new BigInteger(crypto.randomBytes(n.bitLength()));
    priv = r.mod(n1).add(BigInteger.ONE);
    this.P = c.getG().multiply(priv);
  }
  if(this.P)
  {
//  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);
//  this.PublicKey = Buffer.from("04"+pubhex,"hex");
    this.PublicKey = Buffer.from(c.getCurve().encodeCompressedPointHex(this.P),"hex");
  }
  if(priv)
  {
    this.PrivateKey = Buffer.from(unstupid(priv.toString(16),bytes*2),"hex");
    this.deriveSharedSecret = function(key)
    {
      if(!key || !key.P) return false;
      var S = key.P.multiply(priv);
      return Buffer.from(unstupid(S.getX().toBigInteger().toString(16),bytes*2),"hex");
   }     
  }
}



/***/ }),

/***/ "./node_modules/ecc-jsbn/lib/ec.js":
/*!*****************************************!*\
  !*** ./node_modules/ecc-jsbn/lib/ec.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Basic Javascript Elliptic Curve implementation
// Ported loosely from BouncyCastle's Java EC code
// Only Fp curves implemented for now

// Requires jsbn.js and jsbn2.js
var BigInteger = __webpack_require__(/*! jsbn */ "./node_modules/jsbn/index.js").BigInteger
var Barrett = BigInteger.prototype.Barrett

// ----------------
// ECFieldElementFp

// constructor
function ECFieldElementFp(q,x) {
    this.x = x;
    // TODO if(x.compareTo(q) >= 0) error
    this.q = q;
}

function feFpEquals(other) {
    if(other == this) return true;
    return (this.q.equals(other.q) && this.x.equals(other.x));
}

function feFpToBigInteger() {
    return this.x;
}

function feFpNegate() {
    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
}

function feFpAdd(b) {
    return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
}

function feFpSubtract(b) {
    return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
}

function feFpMultiply(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
}

function feFpSquare() {
    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
}

function feFpDivide(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
}

ECFieldElementFp.prototype.equals = feFpEquals;
ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
ECFieldElementFp.prototype.negate = feFpNegate;
ECFieldElementFp.prototype.add = feFpAdd;
ECFieldElementFp.prototype.subtract = feFpSubtract;
ECFieldElementFp.prototype.multiply = feFpMultiply;
ECFieldElementFp.prototype.square = feFpSquare;
ECFieldElementFp.prototype.divide = feFpDivide;

// ----------------
// ECPointFp

// constructor
function ECPointFp(curve,x,y,z) {
    this.curve = curve;
    this.x = x;
    this.y = y;
    // Projective coordinates: either zinv == null or z * zinv == 1
    // z and zinv are just BigIntegers, not fieldElements
    if(z == null) {
      this.z = BigInteger.ONE;
    }
    else {
      this.z = z;
    }
    this.zinv = null;
    //TODO: compression flag
}

function pointFpGetX() {
    if(this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.x.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
}

function pointFpGetY() {
    if(this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.y.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
}

function pointFpEquals(other) {
    if(other == this) return true;
    if(this.isInfinity()) return other.isInfinity();
    if(other.isInfinity()) return this.isInfinity();
    var u, v;
    // u = Y2 * Z1 - Y1 * Z2
    u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
    if(!u.equals(BigInteger.ZERO)) return false;
    // v = X2 * Z1 - X1 * Z2
    v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
    return v.equals(BigInteger.ZERO);
}

function pointFpIsInfinity() {
    if((this.x == null) && (this.y == null)) return true;
    return this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO);
}

function pointFpNegate() {
    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
}

function pointFpAdd(b) {
    if(this.isInfinity()) return b;
    if(b.isInfinity()) return this;

    // u = Y2 * Z1 - Y1 * Z2
    var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
    // v = X2 * Z1 - X1 * Z2
    var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);

    if(BigInteger.ZERO.equals(v)) {
        if(BigInteger.ZERO.equals(u)) {
            return this.twice(); // this == b, so double
        }
	return this.curve.getInfinity(); // this = -b, so infinity
    }

    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var x2 = b.x.toBigInteger();
    var y2 = b.y.toBigInteger();

    var v2 = v.square();
    var v3 = v2.multiply(v);
    var x1v2 = x1.multiply(v2);
    var zu2 = u.square().multiply(this.z);

    // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
    // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
    // z3 = v^3 * z1 * z2
    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);

    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
}

function pointFpTwice() {
    if(this.isInfinity()) return this;
    if(this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();

    // TODO: optimized handling of constants
    var THREE = new BigInteger("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();

    var y1z1 = y1.multiply(this.z);
    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
    var a = this.curve.a.toBigInteger();

    // w = 3 * x1^2 + a * z1^2
    var w = x1.square().multiply(THREE);
    if(!BigInteger.ZERO.equals(a)) {
      w = w.add(this.z.square().multiply(a));
    }
    w = w.mod(this.curve.q);
    //this.curve.reduce(w);
    // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
    // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
    // z3 = 8 * (y1 * z1)^3
    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);

    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
}

// Simple NAF (Non-Adjacent Form) multiplication algorithm
// TODO: modularize the multiplication algorithm
function pointFpMultiply(k) {
    if(this.isInfinity()) return this;
    if(k.signum() == 0) return this.curve.getInfinity();

    var e = k;
    var h = e.multiply(new BigInteger("3"));

    var neg = this.negate();
    var R = this;

    var i;
    for(i = h.bitLength() - 2; i > 0; --i) {
	R = R.twice();

	var hBit = h.testBit(i);
	var eBit = e.testBit(i);

	if (hBit != eBit) {
	    R = R.add(hBit ? this : neg);
	}
    }

    return R;
}

// Compute this*j + x*k (simultaneous multiplication)
function pointFpMultiplyTwo(j,x,k) {
  var i;
  if(j.bitLength() > k.bitLength())
    i = j.bitLength() - 1;
  else
    i = k.bitLength() - 1;

  var R = this.curve.getInfinity();
  var both = this.add(x);
  while(i >= 0) {
    R = R.twice();
    if(j.testBit(i)) {
      if(k.testBit(i)) {
        R = R.add(both);
      }
      else {
        R = R.add(this);
      }
    }
    else {
      if(k.testBit(i)) {
        R = R.add(x);
      }
    }
    --i;
  }

  return R;
}

ECPointFp.prototype.getX = pointFpGetX;
ECPointFp.prototype.getY = pointFpGetY;
ECPointFp.prototype.equals = pointFpEquals;
ECPointFp.prototype.isInfinity = pointFpIsInfinity;
ECPointFp.prototype.negate = pointFpNegate;
ECPointFp.prototype.add = pointFpAdd;
ECPointFp.prototype.twice = pointFpTwice;
ECPointFp.prototype.multiply = pointFpMultiply;
ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;

// ----------------
// ECCurveFp

// constructor
function ECCurveFp(q,a,b) {
    this.q = q;
    this.a = this.fromBigInteger(a);
    this.b = this.fromBigInteger(b);
    this.infinity = new ECPointFp(this, null, null);
    this.reducer = new Barrett(this.q);
}

function curveFpGetQ() {
    return this.q;
}

function curveFpGetA() {
    return this.a;
}

function curveFpGetB() {
    return this.b;
}

function curveFpEquals(other) {
    if(other == this) return true;
    return(this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
}

function curveFpGetInfinity() {
    return this.infinity;
}

function curveFpFromBigInteger(x) {
    return new ECFieldElementFp(this.q, x);
}

function curveReduce(x) {
    this.reducer.reduce(x);
}

// for now, work with hex strings because they're easier in JS
function curveFpDecodePointHex(s) {
    switch(parseInt(s.substr(0,2), 16)) { // first byte
    case 0:
	return this.infinity;
    case 2:
    case 3:
	// point compression not supported yet
	return null;
    case 4:
    case 6:
    case 7:
	var len = (s.length - 2) / 2;
	var xHex = s.substr(2, len);
	var yHex = s.substr(len+2, len);

	return new ECPointFp(this,
			     this.fromBigInteger(new BigInteger(xHex, 16)),
			     this.fromBigInteger(new BigInteger(yHex, 16)));

    default: // unsupported
	return null;
    }
}

function curveFpEncodePointHex(p) {
	if (p.isInfinity()) return "00";
	var xHex = p.getX().toBigInteger().toString(16);
	var yHex = p.getY().toBigInteger().toString(16);
	var oLen = this.getQ().toString(16).length;
	if ((oLen % 2) != 0) oLen++;
	while (xHex.length < oLen) {
		xHex = "0" + xHex;
	}
	while (yHex.length < oLen) {
		yHex = "0" + yHex;
	}
	return "04" + xHex + yHex;
}

ECCurveFp.prototype.getQ = curveFpGetQ;
ECCurveFp.prototype.getA = curveFpGetA;
ECCurveFp.prototype.getB = curveFpGetB;
ECCurveFp.prototype.equals = curveFpEquals;
ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
ECCurveFp.prototype.reduce = curveReduce;
//ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;

// from: https://github.com/kaielvin/jsbn-ec-point-compression
ECCurveFp.prototype.decodePointHex = function(s)
{
	var yIsEven;
    switch(parseInt(s.substr(0,2), 16)) { // first byte
    case 0:
	return this.infinity;
    case 2:
	yIsEven = false;
    case 3:
	if(yIsEven == undefined) yIsEven = true;
	var len = s.length - 2;
	var xHex = s.substr(2, len);
	var x = this.fromBigInteger(new BigInteger(xHex,16));
	var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
	var beta = alpha.sqrt();

    if (beta == null) throw "Invalid point compression";

    var betaValue = beta.toBigInteger();
    if (betaValue.testBit(0) != yIsEven)
    {
        // Use the other root
        beta = this.fromBigInteger(this.getQ().subtract(betaValue));
    }
    return new ECPointFp(this,x,beta);
    case 4:
    case 6:
    case 7:
	var len = (s.length - 2) / 2;
	var xHex = s.substr(2, len);
	var yHex = s.substr(len+2, len);

	return new ECPointFp(this,
			     this.fromBigInteger(new BigInteger(xHex, 16)),
			     this.fromBigInteger(new BigInteger(yHex, 16)));

    default: // unsupported
	return null;
    }
}
ECCurveFp.prototype.encodeCompressedPointHex = function(p)
{
	if (p.isInfinity()) return "00";
	var xHex = p.getX().toBigInteger().toString(16);
	var oLen = this.getQ().toString(16).length;
	if ((oLen % 2) != 0) oLen++;
	while (xHex.length < oLen)
		xHex = "0" + xHex;
	var yPrefix;
	if(p.getY().toBigInteger().isEven()) yPrefix = "02";
	else                                 yPrefix = "03";

	return yPrefix + xHex;
}


ECFieldElementFp.prototype.getR = function()
{
	if(this.r != undefined) return this.r;

    this.r = null;
    var bitLength = this.q.bitLength();
    if (bitLength > 128)
    {
        var firstWord = this.q.shiftRight(bitLength - 64);
        if (firstWord.intValue() == -1)
        {
            this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
        }
    }
    return this.r;
}
ECFieldElementFp.prototype.modMult = function(x1,x2)
{
    return this.modReduce(x1.multiply(x2));
}
ECFieldElementFp.prototype.modReduce = function(x)
{
    if (this.getR() != null)
    {
        var qLen = q.bitLength();
        while (x.bitLength() > (qLen + 1))
        {
            var u = x.shiftRight(qLen);
            var v = x.subtract(u.shiftLeft(qLen));
            if (!this.getR().equals(BigInteger.ONE))
            {
                u = u.multiply(this.getR());
            }
            x = u.add(v); 
        }
        while (x.compareTo(q) >= 0)
        {
            x = x.subtract(q);
        }
    }
    else
    {
        x = x.mod(q);
    }
    return x;
}
ECFieldElementFp.prototype.sqrt = function()
{
    if (!this.q.testBit(0)) throw "unsupported";

    // p mod 4 == 3
    if (this.q.testBit(1))
    {
    	var z = new ECFieldElementFp(this.q,this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE),this.q));
    	return z.square().equals(this) ? z : null;
    }

    // p mod 4 == 1
    var qMinusOne = this.q.subtract(BigInteger.ONE);

    var legendreExponent = qMinusOne.shiftRight(1);
    if (!(this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)))
    {
        return null;
    }

    var u = qMinusOne.shiftRight(2);
    var k = u.shiftLeft(1).add(BigInteger.ONE);

    var Q = this.x;
    var fourQ = modDouble(modDouble(Q));

    var U, V;
    do
    {
        var P;
        do
        {
            P = new BigInteger(this.q.bitLength(), new SecureRandom());
        }
        while (P.compareTo(this.q) >= 0
            || !(P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne)));

        var result = this.lucasSequence(P, Q, k);
        U = result[0];
        V = result[1];

        if (this.modMult(V, V).equals(fourQ))
        {
            // Integer division by 2, mod q
            if (V.testBit(0))
            {
                V = V.add(q);
            }

            V = V.shiftRight(1);

            return new ECFieldElementFp(q,V);
        }
    }
    while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));

    return null;
}
ECFieldElementFp.prototype.lucasSequence = function(P,Q,k)
{
    var n = k.bitLength();
    var s = k.getLowestSetBit();

    var Uh = BigInteger.ONE;
    var Vl = BigInteger.TWO;
    var Vh = P;
    var Ql = BigInteger.ONE;
    var Qh = BigInteger.ONE;

    for (var j = n - 1; j >= s + 1; --j)
    {
        Ql = this.modMult(Ql, Qh);

        if (k.testBit(j))
        {
            Qh = this.modMult(Ql, Q);
            Uh = this.modMult(Uh, Vh);
            Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
            Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
        }
        else
        {
            Qh = Ql;
            Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
            Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
            Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
        }
    }

    Ql = this.modMult(Ql, Qh);
    Qh = this.modMult(Ql, Q);
    Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
    Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
    Ql = this.modMult(Ql, Qh);

    for (var j = 1; j <= s; ++j)
    {
        Uh = this.modMult(Uh, Vl);
        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
        Ql = this.modMult(Ql, Ql);
    }

    return [ Uh, Vl ];
}

var exports = {
  ECCurveFp: ECCurveFp,
  ECPointFp: ECPointFp,
  ECFieldElementFp: ECFieldElementFp
}

module.exports = exports


/***/ }),

/***/ "./node_modules/ecc-jsbn/lib/sec.js":
/*!******************************************!*\
  !*** ./node_modules/ecc-jsbn/lib/sec.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Named EC curves

// Requires ec.js, jsbn.js, and jsbn2.js
var BigInteger = __webpack_require__(/*! jsbn */ "./node_modules/jsbn/index.js").BigInteger
var ECCurveFp = __webpack_require__(/*! ./ec.js */ "./node_modules/ecc-jsbn/lib/ec.js").ECCurveFp


// ----------------
// X9ECParameters

// constructor
function X9ECParameters(curve,g,n,h) {
    this.curve = curve;
    this.g = g;
    this.n = n;
    this.h = h;
}

function x9getCurve() {
    return this.curve;
}

function x9getG() {
    return this.g;
}

function x9getN() {
    return this.n;
}

function x9getH() {
    return this.h;
}

X9ECParameters.prototype.getCurve = x9getCurve;
X9ECParameters.prototype.getG = x9getG;
X9ECParameters.prototype.getN = x9getN;
X9ECParameters.prototype.getH = x9getH;

// ----------------
// SECNamedCurves

function fromHex(s) { return new BigInteger(s, 16); }

function secp128r1() {
    // p = 2^128 - 2^97 - 1
    var p = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("E87579C11079F43DD824993C2CEE5ED3");
    //byte[] S = Hex.decode("000E0D4D696E6768756151750CC03A4473D03679");
    var n = fromHex("FFFFFFFE0000000075A30D1B9038A115");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "161FF7528B899B2D0C28607CA52C5B86"
		+ "CF5AC8395BAFEB13C02DA292DDED7A83");
    return new X9ECParameters(curve, G, n, h);
}

function secp160k1() {
    // p = 2^160 - 2^32 - 2^14 - 2^12 - 2^9 - 2^8 - 2^7 - 2^3 - 2^2 - 1
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73");
    var a = BigInteger.ZERO;
    var b = fromHex("7");
    //byte[] S = null;
    var n = fromHex("0100000000000000000001B8FA16DFAB9ACA16B6B3");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "3B4C382CE37AA192A4019E763036F4F5DD4D7EBB"
                + "938CF935318FDCED6BC28286531733C3F03C4FEE");
    return new X9ECParameters(curve, G, n, h);
}

function secp160r1() {
    // p = 2^160 - 2^31 - 1
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC");
    var b = fromHex("1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45");
    //byte[] S = Hex.decode("1053CDE42C14D696E67687561517533BF3F83345");
    var n = fromHex("0100000000000000000001F4C8F927AED3CA752257");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
		+ "4A96B5688EF573284664698968C38BB913CBFC82"
		+ "23A628553168947D59DCC912042351377AC5FB32");
    return new X9ECParameters(curve, G, n, h);
}

function secp192k1() {
    // p = 2^192 - 2^32 - 2^12 - 2^8 - 2^7 - 2^6 - 2^3 - 1
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37");
    var a = BigInteger.ZERO;
    var b = fromHex("3");
    //byte[] S = null;
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D"
                + "9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D");
    return new X9ECParameters(curve, G, n, h);
}

function secp192r1() {
    // p = 2^192 - 2^64 - 1
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC");
    var b = fromHex("64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1");
    //byte[] S = Hex.decode("3045AE6FC8422F64ED579528D38120EAE12196D5");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012"
                + "07192B95FFC8DA78631011ED6B24CDD573F977A11E794811");
    return new X9ECParameters(curve, G, n, h);
}

function secp224r1() {
    // p = 2^224 - 2^96 + 1
    var p = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001");
    var a = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE");
    var b = fromHex("B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4");
    //byte[] S = Hex.decode("BD71344799D5C7FCDC45B59FA3B9AB8F6A948BC5");
    var n = fromHex("FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21"
                + "BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34");
    return new X9ECParameters(curve, G, n, h);
}

function secp256r1() {
    // p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1
    var p = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF");
    var a = fromHex("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC");
    var b = fromHex("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B");
    //byte[] S = Hex.decode("C49D360886E704936A6678E1139D26B7819F7E90");
    var n = fromHex("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551");
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex("04"
                + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296"
		+ "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5");
    return new X9ECParameters(curve, G, n, h);
}

// TODO: make this into a proper hashtable
function getSECCurveByName(name) {
    if(name == "secp128r1") return secp128r1();
    if(name == "secp160k1") return secp160k1();
    if(name == "secp160r1") return secp160r1();
    if(name == "secp192k1") return secp192k1();
    if(name == "secp192r1") return secp192r1();
    if(name == "secp224r1") return secp224r1();
    if(name == "secp256r1") return secp256r1();
    return null;
}

module.exports = {
  "secp128r1":secp128r1,
  "secp160k1":secp160k1,
  "secp160r1":secp160r1,
  "secp192k1":secp192k1,
  "secp192r1":secp192r1,
  "secp224r1":secp224r1,
  "secp256r1":secp256r1
}


/***/ }),

/***/ "./node_modules/extend/index.js":
/*!**************************************!*\
  !*** ./node_modules/extend/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};


/***/ }),

/***/ "./node_modules/extsprintf/lib/extsprintf.js":
/*!***************************************************!*\
  !*** ./node_modules/extsprintf/lib/extsprintf.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * extsprintf.js: extended POSIX-style sprintf
 */

var mod_assert = __webpack_require__(/*! assert */ "assert");
var mod_util = __webpack_require__(/*! util */ "util");

/*
 * Public interface
 */
exports.sprintf = jsSprintf;
exports.printf = jsPrintf;
exports.fprintf = jsFprintf;

/*
 * Stripped down version of s[n]printf(3c).  We make a best effort to throw an
 * exception when given a format string we don't understand, rather than
 * ignoring it, so that we won't break existing programs if/when we go implement
 * the rest of this.
 *
 * This implementation currently supports specifying
 *	- field alignment ('-' flag),
 * 	- zero-pad ('0' flag)
 *	- always show numeric sign ('+' flag),
 *	- field width
 *	- conversions for strings, decimal integers, and floats (numbers).
 *	- argument size specifiers.  These are all accepted but ignored, since
 *	  Javascript has no notion of the physical size of an argument.
 *
 * Everything else is currently unsupported, most notably precision, unsigned
 * numbers, non-decimal numbers, and characters.
 */
function jsSprintf(fmt)
{
	var regex = [
	    '([^%]*)',				/* normal text */
	    '%',				/* start of format */
	    '([\'\\-+ #0]*?)',			/* flags (optional) */
	    '([1-9]\\d*)?',			/* width (optional) */
	    '(\\.([1-9]\\d*))?',		/* precision (optional) */
	    '[lhjztL]*?',			/* length mods (ignored) */
	    '([diouxXfFeEgGaAcCsSp%jr])'	/* conversion */
	].join('');

	var re = new RegExp(regex);
	var args = Array.prototype.slice.call(arguments, 1);
	var flags, width, precision, conversion;
	var left, pad, sign, arg, match;
	var ret = '';
	var argn = 1;

	mod_assert.equal('string', typeof (fmt));

	while ((match = re.exec(fmt)) !== null) {
		ret += match[1];
		fmt = fmt.substring(match[0].length);

		flags = match[2] || '';
		width = match[3] || 0;
		precision = match[4] || '';
		conversion = match[6];
		left = false;
		sign = false;
		pad = ' ';

		if (conversion == '%') {
			ret += '%';
			continue;
		}

		if (args.length === 0)
			throw (new Error('too few args to sprintf'));

		arg = args.shift();
		argn++;

		if (flags.match(/[\' #]/))
			throw (new Error(
			    'unsupported flags: ' + flags));

		if (precision.length > 0)
			throw (new Error(
			    'non-zero precision not supported'));

		if (flags.match(/-/))
			left = true;

		if (flags.match(/0/))
			pad = '0';

		if (flags.match(/\+/))
			sign = true;

		switch (conversion) {
		case 's':
			if (arg === undefined || arg === null)
				throw (new Error('argument ' + argn +
				    ': attempted to print undefined or null ' +
				    'as a string'));
			ret += doPad(pad, width, left, arg.toString());
			break;

		case 'd':
			arg = Math.floor(arg);
			/*jsl:fallthru*/
		case 'f':
			sign = sign && arg > 0 ? '+' : '';
			ret += sign + doPad(pad, width, left,
			    arg.toString());
			break;

		case 'x':
			ret += doPad(pad, width, left, arg.toString(16));
			break;

		case 'j': /* non-standard */
			if (width === 0)
				width = 10;
			ret += mod_util.inspect(arg, false, width);
			break;

		case 'r': /* non-standard */
			ret += dumpException(arg);
			break;

		default:
			throw (new Error('unsupported conversion: ' +
			    conversion));
		}
	}

	ret += fmt;
	return (ret);
}

function jsPrintf() {
	var args = Array.prototype.slice.call(arguments);
	args.unshift(process.stdout);
	jsFprintf.apply(null, args);
}

function jsFprintf(stream) {
	var args = Array.prototype.slice.call(arguments, 1);
	return (stream.write(jsSprintf.apply(this, args)));
}

function doPad(chr, width, left, str)
{
	var ret = str;

	while (ret.length < width) {
		if (left)
			ret += chr;
		else
			ret = chr + ret;
	}

	return (ret);
}

/*
 * This function dumps long stack traces for exceptions having a cause() method.
 * See node-verror for an example.
 */
function dumpException(ex)
{
	var ret;

	if (!(ex instanceof Error))
		throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));

	/* Note that V8 prepends "ex.stack" with ex.toString(). */
	ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;

	if (ex.cause && typeof (ex.cause) === 'function') {
		var cex = ex.cause();
		if (cex) {
			ret += '\nCaused by: ' + dumpException(cex);
		}
	}

	return (ret);
}


/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArray = Array.isArray;
var keyList = Object.keys;
var hasProp = Object.prototype.hasOwnProperty;

module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    var arrA = isArray(a)
      , arrB = isArray(b)
      , i
      , length
      , key;

    if (arrA && arrB) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    if (arrA != arrB) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA != dateB) return false;
    if (dateA && dateB) return a.getTime() == b.getTime();

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA != regexpB) return false;
    if (regexpA && regexpB) return a.toString() == b.toString();

    var keys = keyList(a);
    length = keys.length;

    if (length !== keyList(b).length)
      return false;

    for (i = length; i-- !== 0;)
      if (!hasProp.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      key = keys[i];
      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  return a!==a && b!==b;
};


/***/ }),

/***/ "./node_modules/fast-json-stable-stringify/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-json-stable-stringify/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};


/***/ }),

/***/ "./node_modules/forever-agent/index.js":
/*!*********************************************!*\
  !*** ./node_modules/forever-agent/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = ForeverAgent
ForeverAgent.SSL = ForeverAgentSSL

var util = __webpack_require__(/*! util */ "util")
  , Agent = __webpack_require__(/*! http */ "http").Agent
  , net = __webpack_require__(/*! net */ "net")
  , tls = __webpack_require__(/*! tls */ "tls")
  , AgentSSL = __webpack_require__(/*! https */ "https").Agent
  
function getConnectionName(host, port) {  
  var name = ''
  if (typeof host === 'string') {
    name = host + ':' + port
  } else {
    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.
    name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':')
  }
  return name
}    

function ForeverAgent(options) {
  var self = this
  self.options = options || {}
  self.requests = {}
  self.sockets = {}
  self.freeSockets = {}
  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
  self.on('free', function(socket, host, port) {
    var name = getConnectionName(host, port)

    if (self.requests[name] && self.requests[name].length) {
      self.requests[name].shift().onSocket(socket)
    } else if (self.sockets[name].length < self.minSockets) {
      if (!self.freeSockets[name]) self.freeSockets[name] = []
      self.freeSockets[name].push(socket)
      
      // if an error happens while we don't use the socket anyway, meh, throw the socket away
      var onIdleError = function() {
        socket.destroy()
      }
      socket._onIdleError = onIdleError
      socket.on('error', onIdleError)
    } else {
      // If there are no pending requests just destroy the
      // socket and it will get removed from the pool. This
      // gets us out of timeout issues and allows us to
      // default to Connection:keep-alive.
      socket.destroy()
    }
  })

}
util.inherits(ForeverAgent, Agent)

ForeverAgent.defaultMinSockets = 5


ForeverAgent.prototype.createConnection = net.createConnection
ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
ForeverAgent.prototype.addRequest = function(req, host, port) {
  var name = getConnectionName(host, port)
  
  if (typeof host !== 'string') {
    var options = host
    port = options.port
    host = options.host
  }

  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
    var idleSocket = this.freeSockets[name].pop()
    idleSocket.removeListener('error', idleSocket._onIdleError)
    delete idleSocket._onIdleError
    req._reusedSocket = true
    req.onSocket(idleSocket)
  } else {
    this.addRequestNoreuse(req, host, port)
  }
}

ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
  if (this.sockets[name]) {
    var index = this.sockets[name].indexOf(s)
    if (index !== -1) {
      this.sockets[name].splice(index, 1)
    }
  } else if (this.sockets[name] && this.sockets[name].length === 0) {
    // don't leak
    delete this.sockets[name]
    delete this.requests[name]
  }
  
  if (this.freeSockets[name]) {
    var index = this.freeSockets[name].indexOf(s)
    if (index !== -1) {
      this.freeSockets[name].splice(index, 1)
      if (this.freeSockets[name].length === 0) {
        delete this.freeSockets[name]
      }
    }
  }

  if (this.requests[name] && this.requests[name].length) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(name, host, port).emit('free')
  }
}

function ForeverAgentSSL (options) {
  ForeverAgent.call(this, options)
}
util.inherits(ForeverAgentSSL, ForeverAgent)

ForeverAgentSSL.prototype.createConnection = createConnectionSSL
ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest

function createConnectionSSL (port, host, options) {
  if (typeof port === 'object') {
    options = port;
  } else if (typeof host === 'object') {
    options = host;
  } else if (typeof options === 'object') {
    options = options;
  } else {
    options = {};
  }

  if (typeof port === 'number') {
    options.port = port;
  }

  if (typeof host === 'string') {
    options.host = host;
  }

  return tls.connect(options);
}


/***/ }),

/***/ "./node_modules/form-data/lib/form_data.js":
/*!*************************************************!*\
  !*** ./node_modules/form-data/lib/form_data.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var CombinedStream = __webpack_require__(/*! combined-stream */ "./node_modules/combined-stream/lib/combined_stream.js");
var util = __webpack_require__(/*! util */ "util");
var path = __webpack_require__(/*! path */ "path");
var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var parseUrl = __webpack_require__(/*! url */ "url").parse;
var fs = __webpack_require__(/*! fs */ "fs");
var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js");
var asynckit = __webpack_require__(/*! asynckit */ "./node_modules/asynckit/index.js");
var populate = __webpack_require__(/*! ./populate.js */ "./node_modules/form-data/lib/populate.js");

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData();
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {

  if (value.hasOwnProperty('fd')) {

    // take read range into a account
    // `end` = Infinity –> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (value.hasOwnProperty('httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (value.hasOwnProperty('httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) {
      continue;
    }

    // convert all headers to arrays.
    if (!Array.isArray(header)) {
      header = [header];
    }

    // add non-empty headers.
    if (header.length) {
      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path);
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err) {
      this._error(err);
      return;
    }

    // add content length
    request.setHeader('Content-Length', length);

    this.pipe(request);
    if (cb) {
      request.on('error', cb);
      request.on('response', cb.bind(this, null));
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};


/***/ }),

/***/ "./node_modules/form-data/lib/populate.js":
/*!************************************************!*\
  !*** ./node_modules/form-data/lib/populate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ "./node_modules/har-schema/lib/afterRequest.json":
/*!*******************************************************!*\
  !*** ./node_modules/har-schema/lib/afterRequest.json ***!
  \*******************************************************/
/*! exports provided: $id, $schema, type, optional, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"afterRequest.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","optional":true,"required":["lastAccess","eTag","hitCount"],"properties":{"expires":{"type":"string","pattern":"^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"},"lastAccess":{"type":"string","pattern":"^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"},"eTag":{"type":"string"},"hitCount":{"type":"integer"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/beforeRequest.json":
/*!********************************************************!*\
  !*** ./node_modules/har-schema/lib/beforeRequest.json ***!
  \********************************************************/
/*! exports provided: $id, $schema, type, optional, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"beforeRequest.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","optional":true,"required":["lastAccess","eTag","hitCount"],"properties":{"expires":{"type":"string","pattern":"^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"},"lastAccess":{"type":"string","pattern":"^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"},"eTag":{"type":"string"},"hitCount":{"type":"integer"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/browser.json":
/*!**************************************************!*\
  !*** ./node_modules/har-schema/lib/browser.json ***!
  \**************************************************/
/*! exports provided: $id, $schema, type, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"browser.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["name","version"],"properties":{"name":{"type":"string"},"version":{"type":"string"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/cache.json":
/*!************************************************!*\
  !*** ./node_modules/har-schema/lib/cache.json ***!
  \************************************************/
/*! exports provided: $id, $schema, properties, default */
/***/ (function(module) {

module.exports = {"$id":"cache.json#","$schema":"http://json-schema.org/draft-06/schema#","properties":{"beforeRequest":{"oneOf":[{"type":"null"},{"$ref":"beforeRequest.json#"}]},"afterRequest":{"oneOf":[{"type":"null"},{"$ref":"afterRequest.json#"}]},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/content.json":
/*!**************************************************!*\
  !*** ./node_modules/har-schema/lib/content.json ***!
  \**************************************************/
/*! exports provided: $id, $schema, type, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"content.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["size","mimeType"],"properties":{"size":{"type":"integer"},"compression":{"type":"integer"},"mimeType":{"type":"string"},"text":{"type":"string"},"encoding":{"type":"string"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/cookie.json":
/*!*************************************************!*\
  !*** ./node_modules/har-schema/lib/cookie.json ***!
  \*************************************************/
/*! exports provided: $id, $schema, type, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"cookie.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["name","value"],"properties":{"name":{"type":"string"},"value":{"type":"string"},"path":{"type":"string"},"domain":{"type":"string"},"expires":{"type":["string","null"],"format":"date-time"},"httpOnly":{"type":"boolean"},"secure":{"type":"boolean"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/creator.json":
/*!**************************************************!*\
  !*** ./node_modules/har-schema/lib/creator.json ***!
  \**************************************************/
/*! exports provided: $id, $schema, type, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"creator.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["name","version"],"properties":{"name":{"type":"string"},"version":{"type":"string"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/entry.json":
/*!************************************************!*\
  !*** ./node_modules/har-schema/lib/entry.json ***!
  \************************************************/
/*! exports provided: $id, $schema, type, optional, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"entry.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","optional":true,"required":["startedDateTime","time","request","response","cache","timings"],"properties":{"pageref":{"type":"string"},"startedDateTime":{"type":"string","format":"date-time","pattern":"^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"},"time":{"type":"number","min":0},"request":{"$ref":"request.json#"},"response":{"$ref":"response.json#"},"cache":{"$ref":"cache.json#"},"timings":{"$ref":"timings.json#"},"serverIPAddress":{"type":"string","oneOf":[{"format":"ipv4"},{"format":"ipv6"}]},"connection":{"type":"string"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/har.json":
/*!**********************************************!*\
  !*** ./node_modules/har-schema/lib/har.json ***!
  \**********************************************/
/*! exports provided: $id, $schema, type, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"har.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["log"],"properties":{"log":{"$ref":"log.json#"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/header.json":
/*!*************************************************!*\
  !*** ./node_modules/har-schema/lib/header.json ***!
  \*************************************************/
/*! exports provided: $id, $schema, type, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"header.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["name","value"],"properties":{"name":{"type":"string"},"value":{"type":"string"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/har-schema/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  afterRequest: __webpack_require__(/*! ./afterRequest.json */ "./node_modules/har-schema/lib/afterRequest.json"),
  beforeRequest: __webpack_require__(/*! ./beforeRequest.json */ "./node_modules/har-schema/lib/beforeRequest.json"),
  browser: __webpack_require__(/*! ./browser.json */ "./node_modules/har-schema/lib/browser.json"),
  cache: __webpack_require__(/*! ./cache.json */ "./node_modules/har-schema/lib/cache.json"),
  content: __webpack_require__(/*! ./content.json */ "./node_modules/har-schema/lib/content.json"),
  cookie: __webpack_require__(/*! ./cookie.json */ "./node_modules/har-schema/lib/cookie.json"),
  creator: __webpack_require__(/*! ./creator.json */ "./node_modules/har-schema/lib/creator.json"),
  entry: __webpack_require__(/*! ./entry.json */ "./node_modules/har-schema/lib/entry.json"),
  har: __webpack_require__(/*! ./har.json */ "./node_modules/har-schema/lib/har.json"),
  header: __webpack_require__(/*! ./header.json */ "./node_modules/har-schema/lib/header.json"),
  log: __webpack_require__(/*! ./log.json */ "./node_modules/har-schema/lib/log.json"),
  page: __webpack_require__(/*! ./page.json */ "./node_modules/har-schema/lib/page.json"),
  pageTimings: __webpack_require__(/*! ./pageTimings.json */ "./node_modules/har-schema/lib/pageTimings.json"),
  postData: __webpack_require__(/*! ./postData.json */ "./node_modules/har-schema/lib/postData.json"),
  query: __webpack_require__(/*! ./query.json */ "./node_modules/har-schema/lib/query.json"),
  request: __webpack_require__(/*! ./request.json */ "./node_modules/har-schema/lib/request.json"),
  response: __webpack_require__(/*! ./response.json */ "./node_modules/har-schema/lib/response.json"),
  timings: __webpack_require__(/*! ./timings.json */ "./node_modules/har-schema/lib/timings.json")
}


/***/ }),

/***/ "./node_modules/har-schema/lib/log.json":
/*!**********************************************!*\
  !*** ./node_modules/har-schema/lib/log.json ***!
  \**********************************************/
/*! exports provided: $id, $schema, type, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"log.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["version","creator","entries"],"properties":{"version":{"type":"string"},"creator":{"$ref":"creator.json#"},"browser":{"$ref":"browser.json#"},"pages":{"type":"array","items":{"$ref":"page.json#"}},"entries":{"type":"array","items":{"$ref":"entry.json#"}},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/page.json":
/*!***********************************************!*\
  !*** ./node_modules/har-schema/lib/page.json ***!
  \***********************************************/
/*! exports provided: $id, $schema, type, optional, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"page.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","optional":true,"required":["startedDateTime","id","title","pageTimings"],"properties":{"startedDateTime":{"type":"string","format":"date-time","pattern":"^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"},"id":{"type":"string","unique":true},"title":{"type":"string"},"pageTimings":{"$ref":"pageTimings.json#"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/pageTimings.json":
/*!******************************************************!*\
  !*** ./node_modules/har-schema/lib/pageTimings.json ***!
  \******************************************************/
/*! exports provided: $id, $schema, type, properties, default */
/***/ (function(module) {

module.exports = {"$id":"pageTimings.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","properties":{"onContentLoad":{"type":"number","min":-1},"onLoad":{"type":"number","min":-1},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/postData.json":
/*!***************************************************!*\
  !*** ./node_modules/har-schema/lib/postData.json ***!
  \***************************************************/
/*! exports provided: $id, $schema, type, optional, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"postData.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","optional":true,"required":["mimeType"],"properties":{"mimeType":{"type":"string"},"text":{"type":"string"},"params":{"type":"array","required":["name"],"properties":{"name":{"type":"string"},"value":{"type":"string"},"fileName":{"type":"string"},"contentType":{"type":"string"},"comment":{"type":"string"}}},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/query.json":
/*!************************************************!*\
  !*** ./node_modules/har-schema/lib/query.json ***!
  \************************************************/
/*! exports provided: $id, $schema, type, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"query.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["name","value"],"properties":{"name":{"type":"string"},"value":{"type":"string"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/request.json":
/*!**************************************************!*\
  !*** ./node_modules/har-schema/lib/request.json ***!
  \**************************************************/
/*! exports provided: $id, $schema, type, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"request.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["method","url","httpVersion","cookies","headers","queryString","headersSize","bodySize"],"properties":{"method":{"type":"string"},"url":{"type":"string","format":"uri"},"httpVersion":{"type":"string"},"cookies":{"type":"array","items":{"$ref":"cookie.json#"}},"headers":{"type":"array","items":{"$ref":"header.json#"}},"queryString":{"type":"array","items":{"$ref":"query.json#"}},"postData":{"$ref":"postData.json#"},"headersSize":{"type":"integer"},"bodySize":{"type":"integer"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/response.json":
/*!***************************************************!*\
  !*** ./node_modules/har-schema/lib/response.json ***!
  \***************************************************/
/*! exports provided: $id, $schema, type, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"response.json#","$schema":"http://json-schema.org/draft-06/schema#","type":"object","required":["status","statusText","httpVersion","cookies","headers","content","redirectURL","headersSize","bodySize"],"properties":{"status":{"type":"integer"},"statusText":{"type":"string"},"httpVersion":{"type":"string"},"cookies":{"type":"array","items":{"$ref":"cookie.json#"}},"headers":{"type":"array","items":{"$ref":"header.json#"}},"content":{"$ref":"content.json#"},"redirectURL":{"type":"string"},"headersSize":{"type":"integer"},"bodySize":{"type":"integer"},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-schema/lib/timings.json":
/*!**************************************************!*\
  !*** ./node_modules/har-schema/lib/timings.json ***!
  \**************************************************/
/*! exports provided: $id, $schema, required, properties, default */
/***/ (function(module) {

module.exports = {"$id":"timings.json#","$schema":"http://json-schema.org/draft-06/schema#","required":["send","wait","receive"],"properties":{"dns":{"type":"number","min":-1},"connect":{"type":"number","min":-1},"blocked":{"type":"number","min":-1},"send":{"type":"number","min":-1},"wait":{"type":"number","min":-1},"receive":{"type":"number","min":-1},"ssl":{"type":"number","min":-1},"comment":{"type":"string"}}};

/***/ }),

/***/ "./node_modules/har-validator/lib/error.js":
/*!*************************************************!*\
  !*** ./node_modules/har-validator/lib/error.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function HARError (errors) {
  var message = 'validation failed'

  this.name = 'HARError'
  this.message = message
  this.errors = errors

  if (typeof Error.captureStackTrace === 'function') {
    Error.captureStackTrace(this, this.constructor)
  } else {
    this.stack = (new Error(message)).stack
  }
}

HARError.prototype = Error.prototype

module.exports = HARError


/***/ }),

/***/ "./node_modules/har-validator/lib/promise.js":
/*!***************************************************!*\
  !*** ./node_modules/har-validator/lib/promise.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Ajv = __webpack_require__(/*! ajv */ "./node_modules/ajv/lib/ajv.js")
var HARError = __webpack_require__(/*! ./error */ "./node_modules/har-validator/lib/error.js")
var schemas = __webpack_require__(/*! har-schema */ "./node_modules/har-schema/lib/index.js")

var ajv

function createAjvInstance () {
  var ajv = new Ajv({
    allErrors: true
  })
  ajv.addMetaSchema(__webpack_require__(/*! ajv/lib/refs/json-schema-draft-06.json */ "./node_modules/ajv/lib/refs/json-schema-draft-06.json"))
  ajv.addSchema(schemas)

  return ajv
}

function validate (name, data) {
  data = data || {}

  // validator config
  ajv = ajv || createAjvInstance()

  var validate = ajv.getSchema(name + '.json')

  return new Promise(function (resolve, reject) {
    var valid = validate(data)

    !valid ? reject(new HARError(validate.errors)) : resolve(data)
  })
}

exports.afterRequest = function (data) {
  return validate('afterRequest', data)
}

exports.beforeRequest = function (data) {
  return validate('beforeRequest', data)
}

exports.browser = function (data) {
  return validate('browser', data)
}

exports.cache = function (data) {
  return validate('cache', data)
}

exports.content = function (data) {
  return validate('content', data)
}

exports.cookie = function (data) {
  return validate('cookie', data)
}

exports.creator = function (data) {
  return validate('creator', data)
}

exports.entry = function (data) {
  return validate('entry', data)
}

exports.har = function (data) {
  return validate('har', data)
}

exports.header = function (data) {
  return validate('header', data)
}

exports.log = function (data) {
  return validate('log', data)
}

exports.page = function (data) {
  return validate('page', data)
}

exports.pageTimings = function (data) {
  return validate('pageTimings', data)
}

exports.postData = function (data) {
  return validate('postData', data)
}

exports.query = function (data) {
  return validate('query', data)
}

exports.request = function (data) {
  return validate('request', data)
}

exports.response = function (data) {
  return validate('response', data)
}

exports.timings = function (data) {
  return validate('timings', data)
}


/***/ }),

/***/ "./node_modules/http-signature/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/http-signature/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

var parser = __webpack_require__(/*! ./parser */ "./node_modules/http-signature/lib/parser.js");
var signer = __webpack_require__(/*! ./signer */ "./node_modules/http-signature/lib/signer.js");
var verify = __webpack_require__(/*! ./verify */ "./node_modules/http-signature/lib/verify.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/http-signature/lib/utils.js");



///--- API

module.exports = {

  parse: parser.parseRequest,
  parseRequest: parser.parseRequest,

  sign: signer.signRequest,
  signRequest: signer.signRequest,
  createSigner: signer.createSigner,
  isSigner: signer.isSigner,

  sshKeyToPEM: utils.sshKeyToPEM,
  sshKeyFingerprint: utils.fingerprint,
  pemToRsaSSHKey: utils.pemToRsaSSHKey,

  verify: verify.verifySignature,
  verifySignature: verify.verifySignature,
  verifyHMAC: verify.verifyHMAC
};


/***/ }),

/***/ "./node_modules/http-signature/lib/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/parser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var util = __webpack_require__(/*! util */ "util");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/http-signature/lib/utils.js");



///--- Globals

var HASH_ALGOS = utils.HASH_ALGOS;
var PK_ALGOS = utils.PK_ALGOS;
var HttpSignatureError = utils.HttpSignatureError;
var InvalidAlgorithmError = utils.InvalidAlgorithmError;
var validateAlgorithm = utils.validateAlgorithm;

var State = {
  New: 0,
  Params: 1
};

var ParamsState = {
  Name: 0,
  Quote: 1,
  Value: 2,
  Comma: 3
};


///--- Specific Errors


function ExpiredRequestError(message) {
  HttpSignatureError.call(this, message, ExpiredRequestError);
}
util.inherits(ExpiredRequestError, HttpSignatureError);


function InvalidHeaderError(message) {
  HttpSignatureError.call(this, message, InvalidHeaderError);
}
util.inherits(InvalidHeaderError, HttpSignatureError);


function InvalidParamsError(message) {
  HttpSignatureError.call(this, message, InvalidParamsError);
}
util.inherits(InvalidParamsError, HttpSignatureError);


function MissingHeaderError(message) {
  HttpSignatureError.call(this, message, MissingHeaderError);
}
util.inherits(MissingHeaderError, HttpSignatureError);

function StrictParsingError(message) {
  HttpSignatureError.call(this, message, StrictParsingError);
}
util.inherits(StrictParsingError, HttpSignatureError);

///--- Exported API

module.exports = {

  /**
   * Parses the 'Authorization' header out of an http.ServerRequest object.
   *
   * Note that this API will fully validate the Authorization header, and throw
   * on any error.  It will not however check the signature, or the keyId format
   * as those are specific to your environment.  You can use the options object
   * to pass in extra constraints.
   *
   * As a response object you can expect this:
   *
   *     {
   *       "scheme": "Signature",
   *       "params": {
   *         "keyId": "foo",
   *         "algorithm": "rsa-sha256",
   *         "headers": [
   *           "date" or "x-date",
   *           "digest"
   *         ],
   *         "signature": "base64"
   *       },
   *       "signingString": "ready to be passed to crypto.verify()"
   *     }
   *
   * @param {Object} request an http.ServerRequest.
   * @param {Object} options an optional options object with:
   *                   - clockSkew: allowed clock skew in seconds (default 300).
   *                   - headers: required header names (def: date or x-date)
   *                   - algorithms: algorithms to support (default: all).
   *                   - strict: should enforce latest spec parsing
   *                             (default: false).
   * @return {Object} parsed out object (see above).
   * @throws {TypeError} on invalid input.
   * @throws {InvalidHeaderError} on an invalid Authorization header error.
   * @throws {InvalidParamsError} if the params in the scheme are invalid.
   * @throws {MissingHeaderError} if the params indicate a header not present,
   *                              either in the request headers from the params,
   *                              or not in the params from a required header
   *                              in options.
   * @throws {StrictParsingError} if old attributes are used in strict parsing
   *                              mode.
   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
   */
  parseRequest: function parseRequest(request, options) {
    assert.object(request, 'request');
    assert.object(request.headers, 'request.headers');
    if (options === undefined) {
      options = {};
    }
    if (options.headers === undefined) {
      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
    }
    assert.object(options, 'options');
    assert.arrayOfString(options.headers, 'options.headers');
    assert.optionalFinite(options.clockSkew, 'options.clockSkew');

    var authzHeaderName = options.authorizationHeaderName || 'authorization';

    if (!request.headers[authzHeaderName]) {
      throw new MissingHeaderError('no ' + authzHeaderName + ' header ' +
                                   'present in the request');
    }

    options.clockSkew = options.clockSkew || 300;


    var i = 0;
    var state = State.New;
    var substate = ParamsState.Name;
    var tmpName = '';
    var tmpValue = '';

    var parsed = {
      scheme: '',
      params: {},
      signingString: ''
    };

    var authz = request.headers[authzHeaderName];
    for (i = 0; i < authz.length; i++) {
      var c = authz.charAt(i);

      switch (Number(state)) {

      case State.New:
        if (c !== ' ') parsed.scheme += c;
        else state = State.Params;
        break;

      case State.Params:
        switch (Number(substate)) {

        case ParamsState.Name:
          var code = c.charCodeAt(0);
          // restricted name of A-Z / a-z
          if ((code >= 0x41 && code <= 0x5a) || // A-Z
              (code >= 0x61 && code <= 0x7a)) { // a-z
            tmpName += c;
          } else if (c === '=') {
            if (tmpName.length === 0)
              throw new InvalidHeaderError('bad param format');
            substate = ParamsState.Quote;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        case ParamsState.Quote:
          if (c === '"') {
            tmpValue = '';
            substate = ParamsState.Value;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        case ParamsState.Value:
          if (c === '"') {
            parsed.params[tmpName] = tmpValue;
            substate = ParamsState.Comma;
          } else {
            tmpValue += c;
          }
          break;

        case ParamsState.Comma:
          if (c === ',') {
            tmpName = '';
            substate = ParamsState.Name;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        default:
          throw new Error('Invalid substate');
        }
        break;

      default:
        throw new Error('Invalid substate');
      }

    }

    if (!parsed.params.headers || parsed.params.headers === '') {
      if (request.headers['x-date']) {
        parsed.params.headers = ['x-date'];
      } else {
        parsed.params.headers = ['date'];
      }
    } else {
      parsed.params.headers = parsed.params.headers.split(' ');
    }

    // Minimally validate the parsed object
    if (!parsed.scheme || parsed.scheme !== 'Signature')
      throw new InvalidHeaderError('scheme was not "Signature"');

    if (!parsed.params.keyId)
      throw new InvalidHeaderError('keyId was not specified');

    if (!parsed.params.algorithm)
      throw new InvalidHeaderError('algorithm was not specified');

    if (!parsed.params.signature)
      throw new InvalidHeaderError('signature was not specified');

    // Check the algorithm against the official list
    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
    try {
      validateAlgorithm(parsed.params.algorithm);
    } catch (e) {
      if (e instanceof InvalidAlgorithmError)
        throw (new InvalidParamsError(parsed.params.algorithm + ' is not ' +
          'supported'));
      else
        throw (e);
    }

    // Build the signingString
    for (i = 0; i < parsed.params.headers.length; i++) {
      var h = parsed.params.headers[i].toLowerCase();
      parsed.params.headers[i] = h;

      if (h === 'request-line') {
        if (!options.strict) {
          /*
           * We allow headers from the older spec drafts if strict parsing isn't
           * specified in options.
           */
          parsed.signingString +=
            request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
        } else {
          /* Strict parsing doesn't allow older draft headers. */
          throw (new StrictParsingError('request-line is not a valid header ' +
            'with strict parsing enabled.'));
        }
      } else if (h === '(request-target)') {
        parsed.signingString +=
          '(request-target): ' + request.method.toLowerCase() + ' ' +
          request.url;
      } else {
        var value = request.headers[h];
        if (value === undefined)
          throw new MissingHeaderError(h + ' was not in the request');
        parsed.signingString += h + ': ' + value;
      }

      if ((i + 1) < parsed.params.headers.length)
        parsed.signingString += '\n';
    }

    // Check against the constraints
    var date;
    if (request.headers.date || request.headers['x-date']) {
        if (request.headers['x-date']) {
          date = new Date(request.headers['x-date']);
        } else {
          date = new Date(request.headers.date);
        }
      var now = new Date();
      var skew = Math.abs(now.getTime() - date.getTime());

      if (skew > options.clockSkew * 1000) {
        throw new ExpiredRequestError('clock skew of ' +
                                      (skew / 1000) +
                                      's was greater than ' +
                                      options.clockSkew + 's');
      }
    }

    options.headers.forEach(function (hdr) {
      // Remember that we already checked any headers in the params
      // were in the request, so if this passes we're good.
      if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
        throw new MissingHeaderError(hdr + ' was not a signed header');
    });

    if (options.algorithms) {
      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
        throw new InvalidParamsError(parsed.params.algorithm +
                                     ' is not a supported algorithm');
    }

    parsed.algorithm = parsed.params.algorithm.toUpperCase();
    parsed.keyId = parsed.params.keyId;
    return parsed;
  }

};


/***/ }),

/***/ "./node_modules/http-signature/lib/signer.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/signer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var http = __webpack_require__(/*! http */ "http");
var util = __webpack_require__(/*! util */ "util");
var sshpk = __webpack_require__(/*! sshpk */ "./node_modules/sshpk/lib/index.js");
var jsprim = __webpack_require__(/*! jsprim */ "./node_modules/jsprim/lib/jsprim.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/http-signature/lib/utils.js");

var sprintf = __webpack_require__(/*! util */ "util").format;

var HASH_ALGOS = utils.HASH_ALGOS;
var PK_ALGOS = utils.PK_ALGOS;
var InvalidAlgorithmError = utils.InvalidAlgorithmError;
var HttpSignatureError = utils.HttpSignatureError;
var validateAlgorithm = utils.validateAlgorithm;

///--- Globals

var AUTHZ_FMT =
  'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';

///--- Specific Errors

function MissingHeaderError(message) {
  HttpSignatureError.call(this, message, MissingHeaderError);
}
util.inherits(MissingHeaderError, HttpSignatureError);

function StrictParsingError(message) {
  HttpSignatureError.call(this, message, StrictParsingError);
}
util.inherits(StrictParsingError, HttpSignatureError);

/* See createSigner() */
function RequestSigner(options) {
  assert.object(options, 'options');

  var alg = [];
  if (options.algorithm !== undefined) {
    assert.string(options.algorithm, 'options.algorithm');
    alg = validateAlgorithm(options.algorithm);
  }
  this.rs_alg = alg;

  /*
   * RequestSigners come in two varieties: ones with an rs_signFunc, and ones
   * with an rs_signer.
   *
   * rs_signFunc-based RequestSigners have to build up their entire signing
   * string within the rs_lines array and give it to rs_signFunc as a single
   * concat'd blob. rs_signer-based RequestSigners can add a line at a time to
   * their signing state by using rs_signer.update(), thus only needing to
   * buffer the hash function state and one line at a time.
   */
  if (options.sign !== undefined) {
    assert.func(options.sign, 'options.sign');
    this.rs_signFunc = options.sign;

  } else if (alg[0] === 'hmac' && options.key !== undefined) {
    assert.string(options.keyId, 'options.keyId');
    this.rs_keyId = options.keyId;

    if (typeof (options.key) !== 'string' && !Buffer.isBuffer(options.key))
      throw (new TypeError('options.key for HMAC must be a string or Buffer'));

    /*
     * Make an rs_signer for HMACs, not a rs_signFunc -- HMACs digest their
     * data in chunks rather than requiring it all to be given in one go
     * at the end, so they are more similar to signers than signFuncs.
     */
    this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
    this.rs_signer.sign = function () {
      var digest = this.digest('base64');
      return ({
        hashAlgorithm: alg[1],
        toString: function () { return (digest); }
      });
    };

  } else if (options.key !== undefined) {
    var key = options.key;
    if (typeof (key) === 'string' || Buffer.isBuffer(key))
      key = sshpk.parsePrivateKey(key);

    assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
      'options.key must be a sshpk.PrivateKey');
    this.rs_key = key;

    assert.string(options.keyId, 'options.keyId');
    this.rs_keyId = options.keyId;

    if (!PK_ALGOS[key.type]) {
      throw (new InvalidAlgorithmError(key.type.toUpperCase() + ' type ' +
        'keys are not supported'));
    }

    if (alg[0] !== undefined && key.type !== alg[0]) {
      throw (new InvalidAlgorithmError('options.key must be a ' +
        alg[0].toUpperCase() + ' key, was given a ' +
        key.type.toUpperCase() + ' key instead'));
    }

    this.rs_signer = key.createSign(alg[1]);

  } else {
    throw (new TypeError('options.sign (func) or options.key is required'));
  }

  this.rs_headers = [];
  this.rs_lines = [];
}

/**
 * Adds a header to be signed, with its value, into this signer.
 *
 * @param {String} header
 * @param {String} value
 * @return {String} value written
 */
RequestSigner.prototype.writeHeader = function (header, value) {
  assert.string(header, 'header');
  header = header.toLowerCase();
  assert.string(value, 'value');

  this.rs_headers.push(header);

  if (this.rs_signFunc) {
    this.rs_lines.push(header + ': ' + value);

  } else {
    var line = header + ': ' + value;
    if (this.rs_headers.length > 0)
      line = '\n' + line;
    this.rs_signer.update(line);
  }

  return (value);
};

/**
 * Adds a default Date header, returning its value.
 *
 * @return {String}
 */
RequestSigner.prototype.writeDateHeader = function () {
  return (this.writeHeader('date', jsprim.rfc1123(new Date())));
};

/**
 * Adds the request target line to be signed.
 *
 * @param {String} method, HTTP method (e.g. 'get', 'post', 'put')
 * @param {String} path
 */
RequestSigner.prototype.writeTarget = function (method, path) {
  assert.string(method, 'method');
  assert.string(path, 'path');
  method = method.toLowerCase();
  this.writeHeader('(request-target)', method + ' ' + path);
};

/**
 * Calculate the value for the Authorization header on this request
 * asynchronously.
 *
 * @param {Func} callback (err, authz)
 */
RequestSigner.prototype.sign = function (cb) {
  assert.func(cb, 'callback');

  if (this.rs_headers.length < 1)
    throw (new Error('At least one header must be signed'));

  var alg, authz;
  if (this.rs_signFunc) {
    var data = this.rs_lines.join('\n');
    var self = this;
    this.rs_signFunc(data, function (err, sig) {
      if (err) {
        cb(err);
        return;
      }
      try {
        assert.object(sig, 'signature');
        assert.string(sig.keyId, 'signature.keyId');
        assert.string(sig.algorithm, 'signature.algorithm');
        assert.string(sig.signature, 'signature.signature');
        alg = validateAlgorithm(sig.algorithm);

        authz = sprintf(AUTHZ_FMT,
          sig.keyId,
          sig.algorithm,
          self.rs_headers.join(' '),
          sig.signature);
      } catch (e) {
        cb(e);
        return;
      }
      cb(null, authz);
    });

  } else {
    try {
      var sigObj = this.rs_signer.sign();
    } catch (e) {
      cb(e);
      return;
    }
    alg = (this.rs_alg[0] || this.rs_key.type) + '-' + sigObj.hashAlgorithm;
    var signature = sigObj.toString();
    authz = sprintf(AUTHZ_FMT,
      this.rs_keyId,
      alg,
      this.rs_headers.join(' '),
      signature);
    cb(null, authz);
  }
};

///--- Exported API

module.exports = {
  /**
   * Identifies whether a given object is a request signer or not.
   *
   * @param {Object} object, the object to identify
   * @returns {Boolean}
   */
  isSigner: function (obj) {
    if (typeof (obj) === 'object' && obj instanceof RequestSigner)
      return (true);
    return (false);
  },

  /**
   * Creates a request signer, used to asynchronously build a signature
   * for a request (does not have to be an http.ClientRequest).
   *
   * @param {Object} options, either:
   *                   - {String} keyId
   *                   - {String|Buffer} key
   *                   - {String} algorithm (optional, required for HMAC)
   *                 or:
   *                   - {Func} sign (data, cb)
   * @return {RequestSigner}
   */
  createSigner: function createSigner(options) {
    return (new RequestSigner(options));
  },

  /**
   * Adds an 'Authorization' header to an http.ClientRequest object.
   *
   * Note that this API will add a Date header if it's not already set. Any
   * other headers in the options.headers array MUST be present, or this
   * will throw.
   *
   * You shouldn't need to check the return type; it's just there if you want
   * to be pedantic.
   *
   * The optional flag indicates whether parsing should use strict enforcement
   * of the version draft-cavage-http-signatures-04 of the spec or beyond.
   * The default is to be loose and support
   * older versions for compatibility.
   *
   * @param {Object} request an instance of http.ClientRequest.
   * @param {Object} options signing parameters object:
   *                   - {String} keyId required.
   *                   - {String} key required (either a PEM or HMAC key).
   *                   - {Array} headers optional; defaults to ['date'].
   *                   - {String} algorithm optional (unless key is HMAC);
   *                              default is the same as the sshpk default
   *                              signing algorithm for the type of key given
   *                   - {String} httpVersion optional; defaults to '1.1'.
   *                   - {Boolean} strict optional; defaults to 'false'.
   * @return {Boolean} true if Authorization (and optionally Date) were added.
   * @throws {TypeError} on bad parameter types (input).
   * @throws {InvalidAlgorithmError} if algorithm was bad or incompatible with
   *                                 the given key.
   * @throws {sshpk.KeyParseError} if key was bad.
   * @throws {MissingHeaderError} if a header to be signed was specified but
   *                              was not present.
   */
  signRequest: function signRequest(request, options) {
    assert.object(request, 'request');
    assert.object(options, 'options');
    assert.optionalString(options.algorithm, 'options.algorithm');
    assert.string(options.keyId, 'options.keyId');
    assert.optionalArrayOfString(options.headers, 'options.headers');
    assert.optionalString(options.httpVersion, 'options.httpVersion');

    if (!request.getHeader('Date'))
      request.setHeader('Date', jsprim.rfc1123(new Date()));
    if (!options.headers)
      options.headers = ['date'];
    if (!options.httpVersion)
      options.httpVersion = '1.1';

    var alg = [];
    if (options.algorithm) {
      options.algorithm = options.algorithm.toLowerCase();
      alg = validateAlgorithm(options.algorithm);
    }

    var i;
    var stringToSign = '';
    for (i = 0; i < options.headers.length; i++) {
      if (typeof (options.headers[i]) !== 'string')
        throw new TypeError('options.headers must be an array of Strings');

      var h = options.headers[i].toLowerCase();

      if (h === 'request-line') {
        if (!options.strict) {
          /**
           * We allow headers from the older spec drafts if strict parsing isn't
           * specified in options.
           */
          stringToSign +=
            request.method + ' ' + request.path + ' HTTP/' +
            options.httpVersion;
        } else {
          /* Strict parsing doesn't allow older draft headers. */
          throw (new StrictParsingError('request-line is not a valid header ' +
            'with strict parsing enabled.'));
        }
      } else if (h === '(request-target)') {
        stringToSign +=
          '(request-target): ' + request.method.toLowerCase() + ' ' +
          request.path;
      } else {
        var value = request.getHeader(h);
        if (value === undefined || value === '') {
          throw new MissingHeaderError(h + ' was not in the request');
        }
        stringToSign += h + ': ' + value;
      }

      if ((i + 1) < options.headers.length)
        stringToSign += '\n';
    }

    /* This is just for unit tests. */
    if (request.hasOwnProperty('_stringToSign')) {
      request._stringToSign = stringToSign;
    }

    var signature;
    if (alg[0] === 'hmac') {
      if (typeof (options.key) !== 'string' && !Buffer.isBuffer(options.key))
        throw (new TypeError('options.key must be a string or Buffer'));

      var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
      hmac.update(stringToSign);
      signature = hmac.digest('base64');

    } else {
      var key = options.key;
      if (typeof (key) === 'string' || Buffer.isBuffer(key))
        key = sshpk.parsePrivateKey(options.key);

      assert.ok(sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
        'options.key must be a sshpk.PrivateKey');

      if (!PK_ALGOS[key.type]) {
        throw (new InvalidAlgorithmError(key.type.toUpperCase() + ' type ' +
          'keys are not supported'));
      }

      if (alg[0] !== undefined && key.type !== alg[0]) {
        throw (new InvalidAlgorithmError('options.key must be a ' +
          alg[0].toUpperCase() + ' key, was given a ' +
          key.type.toUpperCase() + ' key instead'));
      }

      var signer = key.createSign(alg[1]);
      signer.update(stringToSign);
      var sigObj = signer.sign();
      if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
        throw (new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() +
          ' is not a supported hash algorithm'));
      }
      options.algorithm = key.type + '-' + sigObj.hashAlgorithm;
      signature = sigObj.toString();
      assert.notStrictEqual(signature, '', 'empty signature produced');
    }

    var authzHeaderName = options.authorizationHeaderName || 'Authorization';

    request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT,
                                               options.keyId,
                                               options.algorithm,
                                               options.headers.join(' '),
                                               signature));

    return true;
  }

};


/***/ }),

/***/ "./node_modules/http-signature/lib/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/http-signature/lib/utils.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var sshpk = __webpack_require__(/*! sshpk */ "./node_modules/sshpk/lib/index.js");
var util = __webpack_require__(/*! util */ "util");

var HASH_ALGOS = {
  'sha1': true,
  'sha256': true,
  'sha512': true
};

var PK_ALGOS = {
  'rsa': true,
  'dsa': true,
  'ecdsa': true
};

function HttpSignatureError(message, caller) {
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, caller || HttpSignatureError);

  this.message = message;
  this.name = caller.name;
}
util.inherits(HttpSignatureError, Error);

function InvalidAlgorithmError(message) {
  HttpSignatureError.call(this, message, InvalidAlgorithmError);
}
util.inherits(InvalidAlgorithmError, HttpSignatureError);

function validateAlgorithm(algorithm) {
  var alg = algorithm.toLowerCase().split('-');

  if (alg.length !== 2) {
    throw (new InvalidAlgorithmError(alg[0].toUpperCase() + ' is not a ' +
      'valid algorithm'));
  }

  if (alg[0] !== 'hmac' && !PK_ALGOS[alg[0]]) {
    throw (new InvalidAlgorithmError(alg[0].toUpperCase() + ' type keys ' +
      'are not supported'));
  }

  if (!HASH_ALGOS[alg[1]]) {
    throw (new InvalidAlgorithmError(alg[1].toUpperCase() + ' is not a ' +
      'supported hash algorithm'));
  }

  return (alg);
}

///--- API

module.exports = {

  HASH_ALGOS: HASH_ALGOS,
  PK_ALGOS: PK_ALGOS,

  HttpSignatureError: HttpSignatureError,
  InvalidAlgorithmError: InvalidAlgorithmError,

  validateAlgorithm: validateAlgorithm,

  /**
   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
   *
   * The intent of this module is to interoperate with OpenSSL only,
   * specifically the node crypto module's `verify` method.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} PEM encoded form of the RSA public key.
   * @throws {TypeError} on bad input.
   * @throws {Error} on invalid ssh key formatted data.
   */
  sshKeyToPEM: function sshKeyToPEM(key) {
    assert.string(key, 'ssh_key');

    var k = sshpk.parseKey(key, 'ssh');
    return (k.toString('pem'));
  },


  /**
   * Generates an OpenSSH fingerprint from an ssh public key.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} key fingerprint.
   * @throws {TypeError} on bad input.
   * @throws {Error} if what you passed doesn't look like an ssh public key.
   */
  fingerprint: function fingerprint(key) {
    assert.string(key, 'ssh_key');

    var k = sshpk.parseKey(key, 'ssh');
    return (k.fingerprint('md5').toString('hex'));
  },

  /**
   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)
   *
   * The reverse of the above function.
   */
  pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
    assert.equal('string', typeof (pem), 'typeof pem');

    var k = sshpk.parseKey(pem, 'pem');
    k.comment = comment;
    return (k.toString('ssh'));
  }
};


/***/ }),

/***/ "./node_modules/http-signature/lib/verify.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/verify.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var sshpk = __webpack_require__(/*! sshpk */ "./node_modules/sshpk/lib/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/http-signature/lib/utils.js");

var HASH_ALGOS = utils.HASH_ALGOS;
var PK_ALGOS = utils.PK_ALGOS;
var InvalidAlgorithmError = utils.InvalidAlgorithmError;
var HttpSignatureError = utils.HttpSignatureError;
var validateAlgorithm = utils.validateAlgorithm;

///--- Exported API

module.exports = {
  /**
   * Verify RSA/DSA signature against public key.  You are expected to pass in
   * an object that was returned from `parse()`.
   *
   * @param {Object} parsedSignature the object you got from `parse`.
   * @param {String} pubkey RSA/DSA private key PEM.
   * @return {Boolean} true if valid, false otherwise.
   * @throws {TypeError} if you pass in bad arguments.
   * @throws {InvalidAlgorithmError}
   */
  verifySignature: function verifySignature(parsedSignature, pubkey) {
    assert.object(parsedSignature, 'parsedSignature');
    if (typeof (pubkey) === 'string' || Buffer.isBuffer(pubkey))
      pubkey = sshpk.parseKey(pubkey);
    assert.ok(sshpk.Key.isKey(pubkey, [1, 1]), 'pubkey must be a sshpk.Key');

    var alg = validateAlgorithm(parsedSignature.algorithm);
    if (alg[0] === 'hmac' || alg[0] !== pubkey.type)
      return (false);

    var v = pubkey.createVerify(alg[1]);
    v.update(parsedSignature.signingString);
    return (v.verify(parsedSignature.params.signature, 'base64'));
  },

  /**
   * Verify HMAC against shared secret.  You are expected to pass in an object
   * that was returned from `parse()`.
   *
   * @param {Object} parsedSignature the object you got from `parse`.
   * @param {String} secret HMAC shared secret.
   * @return {Boolean} true if valid, false otherwise.
   * @throws {TypeError} if you pass in bad arguments.
   * @throws {InvalidAlgorithmError}
   */
  verifyHMAC: function verifyHMAC(parsedSignature, secret) {
    assert.object(parsedSignature, 'parsedHMAC');
    assert.string(secret, 'secret');

    var alg = validateAlgorithm(parsedSignature.algorithm);
    if (alg[0] !== 'hmac')
      return (false);

    var hashAlg = alg[1].toUpperCase();

    var hmac = crypto.createHmac(hashAlg, secret);
    hmac.update(parsedSignature.signingString);

    /*
     * Now double-hash to avoid leaking timing information - there's
     * no easy constant-time compare in JS, so we use this approach
     * instead. See for more info:
     * https://www.isecpartners.com/blog/2011/february/double-hmac-
     * verification.aspx
     */
    var h1 = crypto.createHmac(hashAlg, secret);
    h1.update(hmac.digest());
    h1 = h1.digest();
    var h2 = crypto.createHmac(hashAlg, secret);
    h2.update(new Buffer(parsedSignature.params.signature, 'base64'));
    h2 = h2.digest();

    /* Node 0.8 returns strings from .digest(). */
    if (typeof (h1) === 'string')
      return (h1 === h2);
    /* And node 0.10 lacks the .equals() method on Buffers. */
    if (Buffer.isBuffer(h1) && !h1.equals)
      return (h1.toString('binary') === h2.toString('binary'));

    return (h1.equals(h2));
  }
};


/***/ }),

/***/ "./node_modules/is-typedarray/index.js":
/*!*********************************************!*\
  !*** ./node_modules/is-typedarray/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}


/***/ }),

/***/ "./node_modules/isstream/isstream.js":
/*!*******************************************!*\
  !*** ./node_modules/isstream/isstream.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var stream = __webpack_require__(/*! stream */ "stream")


function isStream (obj) {
  return obj instanceof stream.Stream
}


function isReadable (obj) {
  return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
}


function isWritable (obj) {
  return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
}


function isDuplex (obj) {
  return isReadable(obj) && isWritable(obj)
}


module.exports            = isStream
module.exports.isReadable = isReadable
module.exports.isWritable = isWritable
module.exports.isDuplex   = isDuplex


/***/ }),

/***/ "./node_modules/jira-connector/api/application-properties.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jira-connector/api/application-properties.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ApplicationPropertiesClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/application-properties'
 * @constructor ApplicationPropertiesClient
 * @param {JiraClient} jiraClient
 */
function ApplicationPropertiesClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Gets an application property.
     * @method getProperties
     * @memberOf ApplicationPropertiesClient#
     * @param [opts] The options used to make the request.
     * @param [opts.key] A String containing the property key.
     * @param [opts.permissionLevel] When fetching a list specifies the permission level of all items in the list.
     * @param [opts.keyFilter] When fetching a list allows the list to be filtered by the property's start of key e.g.
     *     "jira.lf.*" whould fetch only those permissions that are editable and whose keys start with "jira.lf.". This
     *     is a regex
     * @param [callback] Called when the properties are retrieved.
     * @return {Promise} Resolved when the properties are retrieved.
     */
    this.getProperties = function (opts, callback) {
        var qs = {};
        if (opts) {
            if (opts.key) {
                qs.key = opts.key;
            }
            if (opts.keyFilter) {
                qs.keyFilter = opts.keyFilter;
            }
            if (opts.permissionLevel) {
                qs.keyFilter = opts.permissionLevel;
            }
        }

        var options = {
            uri: this.jiraClient.buildURL('/application-properties'),
            method: 'GET',
            followAllRedirects: true,
            qs: qs
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Modify an application property via PUT. The "value" field present in the PUT will override thee existing value.
     *
     * @method getProperties
     * @memberOf ApplicationPropertiesClient#
     * @param opts The options for modifying the application property.
     * @param opts.id The id of the property to be modified
     * @param opts.property The new data for the property.  See
     *     {@link https://docs.atlassian.com/jira/REST/latest/#d2e4891}
     * @param [callback] Called when the property has been modified
     * @return {Promise} Resolved when the property has been modified
     */
    this.setProperty = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/application-properties'),
            method: 'GET',
            followAllRedirects: true,
            body: opts.property
        };

        return this.jiraClient.makeRequest(options, callback, 'Property Updated');
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/attachment.js":
/*!*******************************************************!*\
  !*** ./node_modules/jira-connector/api/attachment.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var errorStrings = __webpack_require__(/*! ./../lib/error */ "./node_modules/jira-connector/lib/error.js");

module.exports = AttachmentClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/atachment'
 *
 * @constructor AttachmentClient
 * @param {JiraClient} jiraClient
 */
function AttachmentClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns the meta-data for an attachment, including the URI of the actual attached file.
     *
     * @method getAttachment
     * @memberOf AttachmentClient#
     * @param opts The options for the API request.
     * @param opts.attachmentId The id of the attachment to retrieve
     * @param [callback] Called when the attachment metadata is retrieved.
     * @return {Promise} Resolved when the attachment metadata is retrieved.
     */
    this.getAttachment = function (opts, callback) {
        if (!opts.attachmentId) {
            throw new Error(errorStrings.NO_ATTACHMENT_ID_ERROR);
        }

        var options = {
            uri: this.jiraClient.buildURL('/attachment/' + opts.attachmentId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Remove an attachment from an issue.
     *
     * @method deleteAttachment
     * @memberOf AttachmentClient#
     * @param opts The options for the API request.
     * @param opts.attachmentId The id of the attachment to delete
     * @param [callback] Called when the attachment is deleted.
     * @return {Promise} Resolved when the attachment is deleted.
     */
    this.deleteAttachment = function (opts, callback) {
        if (!opts.attachmentId) {
            throw new Error(errorStrings.NO_ATTACHMENT_ID_ERROR);
        }

        var options = {
            uri: this.jiraClient.buildURL('/attachment/' + opts.attachmentId),
            method: 'DELETE',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback, 'Attachment Deleted');
    };


    /**
     * Returns the meta informations for an attachments, specifically if they are enabled and the maximum upload size
     * allowed.
     *
     * @method getGlobalAttachmentMetadata
     * @memberOf AttachmentClient#
     * @param opts This API request actually takes no options; this parameter is ignored.
     * @param [callback] Called when the metadata is retrieved.
     * @return {Promise} Resolved when the metadata is retrieved.
     */
    this.getGlobalAttachmentMetadata = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/attachment/meta'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/auditing.js":
/*!*****************************************************!*\
  !*** ./node_modules/jira-connector/api/auditing.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var errorStrings = __webpack_require__(/*! ./../lib/error */ "./node_modules/jira-connector/lib/error.js");

module.exports = AuditingClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/auditing'
 * @param {JiraClient} jiraClient
 * @constructor AuditingClient
 */
function AuditingClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns auditing records filtered using provided parameters
     *
     * @method getAudits
     * @memberOf AuditingClient#
     * @param opts The filtering options for retrieving audits.
     * @param [opts.offset] The number of record from which search starts
     * @param [opts.limit] Maximum number of returned results (if is limit is <= 0 or > 1000, it will be set do default
     *     value: 1000)
     * @param [opts.filter] Text query; each record that will be returned must contain the provided text in one of its
     *     fields
     * @param [opts.from] Timestamp in past; 'from' must be less or equal 'to', otherwise the result set will be empty
     *     only records that where created in the same moment or after the 'from' timestamp will be provided in
     *     response
     * @param [opts.to] Timestamp in past; 'from' must be less or equal 'to', otherwise the result set will be empty
     *     only records that where created in the same moment or earlier than the 'to' timestamp will be provided in
     *     response
     * @param [callback] Called when the audits are retrieved.
     * @return {Promise} Resolved when the audits are retrieved.
     */
    this.getAudits = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/auditing/record'),
            json: true,
            followAllRedirects: true,
            method: 'GET',
            qs: {
                offset: opts.offset,
                limit: opts.limit,
                filter: opts.filter,
                from: opts.from,
                to: opts.to
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     *
     * @method createAudit
     * @memberOf AuditingClient#
     * @param opts The request options.
     * @param opts.audit See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2557}
     * @param [callback] Called when the audit is created.
     * @return {Promise} Resolved when the audit is created.
     */
    this.createAudit = function (opts, callback) {
        if (!opts.audit) {
            throw new Error(errorStrings.NO_AUDIT_ERROR);
        }

        var options = {
            uri: this.jiraClient.buildURL('/auditing/record'),
            json: true,
            followAllRedirects: true,
            method: 'POST',
            body: opts.audit
        };

        return this.jiraClient.makeRequest(options, callback, 'Audit Record Added');
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/auth.js":
/*!*************************************************!*\
  !*** ./node_modules/jira-connector/api/auth.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");

module.exports = AuthClient;

/**
 * Used to access Jira REST endpoints in '/rest/auth/1/session'
 *
 * @param {JiraClient} jiraClient
 * @constructor UserClient
 */
function AuthClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Logs the current user out of JIRA, destroying the existing session, if any.
     *
     * @method logout
     * @memberOf Auth#
     * @param [callback] Called when the user has been logged out.
     * @return {Promise} Resolved when the user has been logged out.
     */
    this.logout = function (callback) {
        var options = {
            uri: this.jiraClient.buildAuthURL('/session'),
            method: 'DELETE',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback), 'User logged out.';
    };

    /**
     * Creates a new session for a user in JIRA.
     *
     * @method login
     * @memberOf Auth#
     * @param opts The request options sent to the Jira API
     * @param opts.username The name of the user to login.
     * @param opts.password The password of the user.
     * @param [callback] Called when the user has been logged in.
     * @return {Promise} Resolved when the user has been logged in.
     */
    this.login = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildAuthURL('/session'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts
        };

        return this.jiraClient.makeRequest(options, callback, 'User logged in.');
    };

    /**
     * Get current User. Returns information about the currently authenticated user's session.
     *
     * @method currentUser
     * @memberOf Auth#
     * @param [callback] Called when the current user has been retrieved.
     * @return {Promise} Resolved when the user has been retrieved.
     */
    this.currentUser = function (callback) {
        var options = {
            uri: this.jiraClient.buildURL('/session'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}


/***/ }),

/***/ "./node_modules/jira-connector/api/avatar.js":
/*!***************************************************!*\
  !*** ./node_modules/jira-connector/api/avatar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var errorStrings = __webpack_require__(/*! ./../lib/error */ "./node_modules/jira-connector/lib/error.js");

module.exports = AvatarClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/avatar'
 * @param {JiraClient} jiraClient
 * @constructor AvatarClient
 */
function AvatarClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns all system avatars of the given type.
     *
     * @method getAvatars
     * @memberOf AvatarClient#
     * @param opts The options to be used in the API request.
     * @param opts.avatarType The avatar type.  May be 'project' or 'user'.
     * @param [callback] Called when the avatars are retrieved.
     * @return {Promise} Resolved when the avatars are retrieved.
     */
    this.getAvatars = function (opts, callback) {
        if (!opts.avatarType) {
            throw new Error(errorStrings.NO_AVATAR_TYPE_ERROR);
        }
        var options = {
            method: 'GET',
            json: true,
            followAllRedirects: true,
            uri: this.jiraClient.buildURL('/avatar/' + opts.avatarType + '/system')
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Creates a temporary avatar.  This function doesn't seem to work the way the Jira API describes, so for now
     * just don't use it.
     *
     * @method createTemporaryAvatar
     * @memberOf AvatarClient#
     * @param opts The options to be used in the API request.
     * @param opts.avatarType The avatar type.  May be 'project' or 'user'.
     * @param opts.avatarFilename The name of the file being uploaded
     * @param opts.avatarFileSize The size of the file
     * @param opts.avatarFilePath The path to the avatar file.
     * @param [callback] Called when the avatar is created.
     * @return {Promise} Resolved when the avatar is created.
     */
    this.createTemporaryAvatar = function (opts, callback) {
        if (!opts.avatarType) {
            throw new Error(errorStrings.NO_AVATAR_TYPE_ERROR);
        }
        var size = fs.statSync(opts.avatarFilePath).size;
        var name = path.basename(opts.avatarFilePath);
        var options = {
            method: 'POST',
            json: true,
            followAllRedirects: true,
            uri: this.jiraClient.buildURL('/avatar/' + opts.avatarType + '/temporary'),
            headers: {
                "X-Atlassian-Token": "no-check"
            },
            qs: {
                filename: name,
                size: size
            },
            formData: {
                file: fs.createReadStream(opts.avatarFilePath)
            }
        };
        delete options.body;

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Updates the cropping instructions of the temporary avatar.  This function doesn't seem to work the way the Jira
     * API describes, so for now just don't use it.
     *
     * @method cropTemporaryAvatar
     * @memberOf AvatarClient#
     * @param {Object} opts The options to be used in the API request.
     * @param {string} opts.avatarType The avatar type.  May be 'project' or 'user'.
     * @param {Object} opts.crop See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3316}
     * @param [callback] Called when the avatar has been cropped.
     * @return {Promise} Resolved when the avatar has been cropped.
     */
    this.cropTemporaryAvatar = function (opts, callback) {
        if (!opts.avatarType) {
            throw new Error(errorStrings.NO_AVATAR_TYPE_ERROR);
        }

        var options = {
            method: 'POST',
            json: true,
            followAllRedirects: true,
            uri: this.jiraClient.buildURL('/avatar/' + opts.avatarType + '/temporaryCrop'),
            headers: {
                "X-Atlassian-Token": "no-check"
            },
            body: opts.crop
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/board.js":
/*!**************************************************!*\
  !*** ./node_modules/jira-connector/api/board.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = AgileBoardClient;

/**
 * Used to access Jira REST endpoints in '/rest/agile/1.0/dashboard'
 * @param {JiraClient} jiraClient
 * @constructor AgileBoardClient
 */
function AgileBoardClient(jiraClient) {
  this.jiraClient = jiraClient;

  /**
   * Get a list of all dashboards, optionally filtering them.
   *
   * @method getAllBoards
   * @memberOf AgileBoardClient#
   * @param opts The request options to send to the Jira API
   * @param [opts.type] Limits returning boards of a specific type: `scrum` or `kanban`.
   * @param [opts.startAt] The index of the first dashboard to return (0-based). must be 0 or a multiple of
   *     maxResults
   * @param [opts.name] Filters results to boards that match or partially match the specified name.
   * @param [opts.projectKeyOrId] Filters results to boards that are relevant to a project. Relevance meaning that
   *     the jql filter defined in board contains a reference to a project.
   * @param [opts.maxResults] A hint as to the the maximum number of dashboards to return in each call. Note that the
   *     JIRA server reserves the right to impose a maxResults limit that is lower than the value that a client
   *     provides, dues to lack or resources or any other condition. When this happens, your results will be
   *     truncated. Callers should always check the returned maxResults to determine the value that is effectively
   *     being used.
   * @param [callback] Called when the dashboards have been retrieved.
   * @return {Promise} Resolved when the dashboards have been retrieved.
   */
  this.getAllBoards = function(opts, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL("/board"),
      method: "GET",
      json: true,
      followAllRedirects: true,
      qs: {
        type: opts.type,
        startAt: opts.startAt,
        name: opts.name,
        projectKeyOrId: opts.projectKeyOrId,
        maxResults: opts.maxResults
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Get a single agile board.
   *
   * @method getBoard
   * @memberOf AgileBoardClient#
   * @param opts The request options sent to the Jira API.
   * @param opts.boardId The agile board id.
   * @param [callback] Called when the dashboard has been retrieved
   * @return {Promise} Resolved when the dashboard has been retrieved
   */
  this.getBoard = function(opts, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL("/board/" + opts.boardId),
      method: "GET",
      json: true,
      followAllRedirects: true,
      qs: {
        filter: opts.filter,
        startAt: opts.startAt,
        maxResults: opts.maxResults
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Get a list of all issues associated with an agile board
   *
   * @method getIssuesForBoard
   * @memberOf AgileBoardClient#
   * @param opts The request options to send to the Jira API
   * @param opts.boardId The agile board id.
   * @param [opts.startAt] The index of the first issue to return (0-based). must be 0 or a multiple of
   *     maxResults
   * @param [opts.maxResults] A hint as to the the maximum number of issues to return in each call. Note that the
   *     JIRA server reserves the right to impose a maxResults limit that is lower than the value that a client
   *     provides, dues to lack or resources or any other condition. When this happens, your results will be
   *     truncated. Callers should always check the returned maxResults to determine the value that is effectively
   *     being used.
   * @param [opts.jql] Filters results using a JQL query. If you define an order in your JQL query, it will override
   *     the default order of the returned issues. Note that username and userkey have been deprecated as search terms
   *     for this parameter. See the migration guide for details. Use accountId instead.
   * @param [opts.fields] The list of fields to return for each issue. By default, all navigable and Agile fields are
   *     returned.
   * @param [opts.expand] The parameters to expand
   * @param [callback] Called when the issues have been retrieved.
   * @return {Promise} Resolved when the issues have been retrieved.
   */
  this.getIssuesForBoard = function(opts, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL("/board/" + opts.boardId + "/issue"),
      method: "GET",
      json: true,
      followAllRedirects: true,
      qs: {
        startAt: opts.startAt,
        maxResults: opts.maxResults,
        jql: opts.jql,
        fields: opts.fields.join(','),
        expand: opts.expand
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Get a list of sprints associated with an agile board
   *
   * @method getSprintsForBoard
   * @memberOf AgileBoardClient#
   * @param opts The request options to send to the Jira API
   * @param opts.boardId The agile board id.
   * @param [opts.startAt] The index of the first sprint to return (0-based). must be 0 or a multiple of
   *     maxResults
   * @param [opts.maxResults] A hint as to the the maximum number of sprints to return in each call. Note that the
   *     JIRA server reserves the right to impose a maxResults limit that is lower than the value that a client
   *     provides, dues to lack or resources or any other condition. When this happens, your results will be
   *     truncated. Callers should always check the returned maxResults to determine the value that is effectively
   *     being used.
   * @param [opts.state] Optionally filter by state, e.g. 'active'.
   * @param callback Called when the sprints have been retrieved.
   * @return {Promise} Resolved when the sprints have been retrieved.
   */
  this.getSprintsForBoard = function(opts, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL("/board/" + opts.boardId + "/sprint"),
      method: "GET",
      json: true,
      followAllRedirects: true,
      qs: {
        startAt: opts.startAt,
        maxResults: opts.maxResults,
        state: opts.state
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Get a list of all issues from the board's backlog, for the given board Id.
   *
   * @method getIssuesForBacklog
   * @memberOf AgileBoardClient#
   * @param opts The request options to send to the Jira API
   * @param opts.boardId The agile board id.
   * @param {string} jql Filters results using a JQL query.
   * @param {boolean} validateQuery Specifies whether to valide the JQL query.
   * @param {string} fields The list of fields to return for each issue.
   * @param [opts.startAt] The index of the first dashboard to return (0-based). must be 0 or a multiple of
   *     maxResults
   * @param [opts.maxResults] A hint as to the the maximum number of issues to return in each call. Note that the
   *     JIRA server reserves the right to impose a maxResults limit that is lower than the value that a client
   *     provides, dues to lack or resources or any other condition. When this happens, your results will be
   *     truncated. Callers should always check the returned maxResults to determine the value that is effectively
   *     being used.
   * @param [callback] Called when the backlog issues have been retrieved.
   * @return {Promise} Resolved when the backlog issues have been retrieved.
   */
  this.getIssuesForBacklog = function(opts, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL("/board/" + opts.boardId + "/backlog"),
      method: "GET",
      json: true,
      followAllRedirects: true,
      qs: {
        startAt: opts.startAt,
        maxResults: opts.maxResults,
        jql: opts.jql,
        validateQuery: opts.validateQuery,
        fields: opts.fields
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Get configuration for a board
   *
   * @method getBoardConfiguration
   * @memberOf AgileBoardClient#
   * @param opts The request options to send to the Jira API
   * @param opts.boardId The agile board id.
   * @param [callback] Called when the board configuration has been retrieved.
   * @return {Promise} Resolved when the board configuration has been retrieved.
   */
  this.getBoardConfiguration = function(opts, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL(
        "/board/" + opts.boardId + "/configuration"
      ),
      method: "GET",
      json: true,
      followAllRedirects: true
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Creates a board
   *
   * @method createBoard
   * @memberOf AgileSprintClient#
   * @param {string} name Must be less than 255 characters.
   * @param {string} type Valid values: scrum, kanban
   * @param {number} filterId ID of a filter that the user has permissions to view. Note, if the
   *  user does not have the 'Create shared objects' permission and tries to create a shared board,
   *  a private board will be created instead (remember that board sharing depends on the filter sharing).
   * @param {object} location The container that the board will be located in. location must include the
   *  type property (Valid values: project, user). If choosing 'project', then a project must be specified
   *  by a projectKeyOrId property in location. If choosing 'user', the current user is chosen by default.
   *  The projectKeyOrId property should not be provided.
   * @param [callback] Called when the sprint has been created.
   * @return {Promise} Resolved when the sprint has been created.
   */
  this.createBoard = function(name, type, filterId, location, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL("/board"),
      method: "POST",
      followAllRedirects: true,
      json: true,
      body: {
        name,
        type,
        filterId,
        location
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Get a list of projects associated board
   *
   * @method getProjectsForBoard
   * @memberOf AgileBoardClient#
   * @param opts The request options to send to the Jira API
   * @param opts.boardId The agile board id.
   * @param [opts.startAt] The index of the first sprint to return (0-based). must be 0 or a multiple of
   *     maxResults
   * @param [opts.maxResults] A hint as to the the maximum number of sprints to return in each call. Note that the
   *     JIRA server reserves the right to impose a maxResults limit that is lower than the value that a client
   *     provides, dues to lack or resources or any other condition. When this happens, your results will be
   *     truncated. Callers should always check the returned maxResults to determine the value that is effectively
   *     being used.
   * @param callback Called when the sprints have been retrieved.
   * @return {Promise} Resolved when the sprints have been retrieved.
   */
  this.getProjectsForBoard = function(opts, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL("/board/" + opts.boardId + "/project"),
      method: "GET",
      json: true,
      followAllRedirects: true,
      qs: {
        startAt: opts.startAt,
        maxResults: opts.maxResults
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };
}


/***/ }),

/***/ "./node_modules/jira-connector/api/comment.js":
/*!****************************************************!*\
  !*** ./node_modules/jira-connector/api/comment.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var errorStrings = __webpack_require__(/*! ./../lib/error */ "./node_modules/jira-connector/lib/error.js");

module.exports = CommentClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/comment'
 * @constructor CommentClient
 * @param {JiraClient} jiraClient
 */
function CommentClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns the keys of all properties for the comment identified by the key or by the id.
     *
     * @method getCommentPropertyKeys
     * @memberOf CommentClient#
     * @param opts The options passed in the request to the API.
     * @param opts.commentId The id of the comment from which keys will be returned.
     * @param [callback] Called when the keys have been retrieved.
     * @return {Promise} Resolved when the keys have been retrieved.
     */
    this.getCommentPropertyKeys = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Sets the value of the specified comment's property.
     *
     * You can use this resource to store a custom data against the comment identified by the key or by the id. The
     * user who stores the data is required to have permissions to administer the comment.
     *
     * @method setCommentProperty
     * @memberOf CommentClient#
     * @param opts The options passed in the request to the API.
     * @param opts.commentId The id of the comment from which keys will be returned.
     * @param opts.propertyKey The key of the property to be edited.
     * @param opts.propertyValue The new value of the property.
     * @param [callback] Called when the property has been edited.
     * @return {Promise} Resolved when the property has been edited.
     */
    this.setCommentProperty = function (opts, callback) {
        if (!opts.propertyKey) {
            throw new Error(errorStrings.NO_COMMENT_PROPERTY_KEY_ERROR);
        } else if (!opts.propertyValue) {
            throw new Error(errorStrings.NO_COMMENT_PROPERTY_VALUE_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/' + opts.propertyKey, 'PUT', opts.propertyValue);
        return this.jiraClient.makeRequest(options, callback, 'Property Edited');
    };

    /**
     * Returns the value of the property with a given key from the comment identified by the key or by the id. The user
     * who retrieves the property is required to have permissions to read the comment.
     *
     * @method getCommentProperty
     * @memberOf CommentClient#
     * @param opts The options passed in the request to the API.
     * @param opts.commentId The id of the comment from which keys will be returned.
     * @param opts.propertyKey The key of the property to be edited.
     * @param [callback] Called when the property has been retrieved.
     * @return {Promise} Resolved when the property has been retrieved.
     */
    this.getCommentProperty = function (opts, callback) {
        if (!opts.propertyKey) {
            throw new Error(errorStrings.NO_COMMENT_PROPERTY_KEY_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/' + opts.propertyKey, 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Removes the property from the comment identified by the key or by the id. Ths user removing the property is
     * required to have permissions to administer the comment.
     *
     * @method deleteCommentProperty
     * @memberOf CommentClient#
     * @param opts The options passed in the request to the API.
     * @param opts.commentId The id of the comment from which keys will be returned.
     * @param opts.propertyKey The key of the property to be edited.
     * @param [callback] Called when the property has been retrieved.
     * @return {Promise} Resolved when the property has been retrieved.
     */
    this.deleteCommentProperty = function (opts, callback) {
        if (!opts.propertyKey) {
            throw new Error(errorStrings.NO_COMMENT_PROPERTY_KEY_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/' + opts.propertyKey, 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Comment property deleted');
    };

    /**
     * Build out the request options necessary to make a particular API call.
     *
     * @private
     * @method buildRequestOptions
     * @memberOf CommentClient#
     * @param {Object} opts The arguments passed to the method.
     * @param {string} path The path of the endpoint following /issue/{idOrKey}
     * @param {string} method The request method.
     * @param {Object} [body] The request body, if any.
     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.
     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}
     */
    this.buildRequestOptions = function (opts, path, method, body, qs) {
        if (!opts.commentId) {
            throw new Error(errorStrings.NO_COMMENT_ID);
        }
        var basePath = '/comment/' + opts.commentId + "/properties";
        if (!qs) qs = {};
        if (!body) body = {};

        if (opts.fields) {
            qs.fields = '';
            opts.fields.forEach(function (field) {
                qs.fields += field + ','
            });
        }

        if (opts.expand) {
            qs.expand = '';
            opts.expand.forEach(function (ex) {
                qs.expand += ex + ','
            });
        }

        return {
            uri: this.jiraClient.buildURL(basePath + path),
            method: method,
            body: body,
            qs: qs,
            followAllRedirects: true,
            json: true
        };
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/component.js":
/*!******************************************************!*\
  !*** ./node_modules/jira-connector/api/component.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ComponentClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/component'
 *
 * @param {JiraClient} jiraClient
 * @constructor ComponentClient
 */
function ComponentClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Create a component via POST.
     *
     * @method createComponent
     * @memberOf ComponentClient#
     * @param opts The request options sent to the Jira API
     * @param opts.component See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3871}
     * @param [callback] Called when the component has been created.
     * @return {Promise} Resolved when the component has been created.
     */
    this.createComponent = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/component'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts.component
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Modify a component via PUT. Any fields present in the PUT will override existing values. As a convenience, if a
     * field is not present, it is silently ignored. If leadUserName is an empty string ("") the component lead will be
     * removed.
     *
     * @method editComponent
     * @memberOf ComponentClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.id The id of the component to edit.
     * @param opts.component The new data to place in the component.  See
     *      {@link https://docs.atlassian.com/jira/REST/latest/#d2e3939}
     * @param [callback] Called when the component has beed edited.
     * @return {Promise} Resolved when the component has beed edited.
     */
    this.editComponent = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/component/' + opts.id),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: opts.component
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get a project component.
     *
     * @method getComponent
     * @memberOf ComponentClient#
     * @param opts The options sent to the Jira API
     * @param opts.id The id of the component to edit.
     * @param [callback] Called when the component has been retrieved.
     * @return {Promise} Resolved when the component has been retrieved.
     */
    this.getComponent = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/component/' + opts.id),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Delete a project component.
     *
     * @method deleteComponent
     * @memberOf ComponentClient#
     * @param opts The options sent to the Jira API
     * @param opts.id The id of the component to edit.
     * @param [opts.moveIssuesTo] The new component applied to issues whose 'id' component will be deleted. If this
     *     value is null, then the 'id' component is simply removed from the related isues.
     * @param [callback] Called when the component has been deleted.
     * @return {Promise} Resolved when the component has been deleted.
     */
    this.deleteComponent = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/component/' + opts.id),
            method: 'DELETE',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback, 'Project Component Deleted');
    };

    /**
     * Get counts of issues related to this component.
     *
     * @method getRelatedIssueCounts
     * @memberOf ComponentClient#
     * @param opts The options sent to the Jira API
     * @param opts.id The id of the component to edit.
     * @param [callback] Called when the count has been retrieved.
     * @return {Promise} Resolved when the count has been retrieved.
     */
    this.getRelatedIssueCounts = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/component/' + opts.id + '/relatedIssueCounts'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/customFieldOption.js":
/*!**************************************************************!*\
  !*** ./node_modules/jira-connector/api/customFieldOption.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var errorStrings = __webpack_require__(/*! ./../lib/error */ "./node_modules/jira-connector/lib/error.js");

module.exports = CustomFieldOptionClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/customFieldOptions'
 *
 * @param {JiraClient} jiraClient
 * @constructor CustomFieldOptionClient
 */
function CustomFieldOptionClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a full representation of the Custom Field Option that has the given id.
     *
     * @method getCustomFieldOption
     * @memberOf CustomFieldOptionClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.fieldOptionId A String containing an Custom Field Option id
     * @param [callback] Called when data has been retrieved
     * @return {Promise} Resolved when data has been retrieved
     */
    this.getCustomFieldOption = function (opts, callback) {
        if (!opts.fieldOptionId) {
            throw new Error(errorStrings.NO_FIELD_OPTION_ID_ERROR);
        }

        var options = {
            uri: this.jiraClient.buildURL('/customFieldOption/' + opts.fieldOptionId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/dashboard.js":
/*!******************************************************!*\
  !*** ./node_modules/jira-connector/api/dashboard.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = DashboardClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/dashboard'
 * @param {JiraClient} jiraClient
 * @constructor DashboardClient
 */
function DashboardClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Get a list of all dashboards, optionally filtering them.
     *
     * @method getAllDashboards
     * @memberOf DashboardClient#
     * @param opts The request options to send to the Jira API
     * @param [opts.filter] An optional filter that is applied to the list of dashboards. Valid values include
     *     "favourite" for returning only favourite dashboards, and "my" for returning dashboards that are owned by the
     *     calling user.
     * @param [opts.startAt] The index of the first dashboard to return (0-based). must be 0 or a multiple of
     *     maxResults
     * @param [opts.maxResults] A hint as to the the maximum number of dashboards to return in each call. Note that the
     *     JIRA server reserves the right to impose a maxResults limit that is lower than the value that a client
     *     provides, dues to lack or resources or any other condition. When this happens, your results will be
     *     truncated. Callers should always check the returned maxResults to determine the value that is effectively
     *     being used.
     * @param [callback] Called when the dashboards have been retrieved.
     * @return {Promise} Resolved when the dashboards have been retrieved.
     */
    this.getAllDashboards = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/dashboard'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                filter: opts.filter,
                startAt: opts.startAt,
                maxResults: opts.maxResults
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get a single dashboard.
     *
     * @method getDashboard
     * @memberOf DashboardClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.dashboardId The dashboard id.
     * @param [callback] Called when the dashboard has been retrieved
     * @return {Promise} Resolved when the dashboard has been retrieved
     */
    this.getDashboard = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/dashboard/' + opts.dashboardId),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                filter: opts.filter,
                startAt: opts.startAt,
                maxResults: opts.maxResults
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/field.js":
/*!**************************************************!*\
  !*** ./node_modules/jira-connector/api/field.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = FieldClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/field'
 *
 * @param {JiraClient} jiraClient
 * @constructor FieldClient
 */
function FieldClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a list of all fields, both System and Custom
     *
     * @method getAllFields
     * @memberOf FieldClient#
     * @param opts Ignored
     * @param [callback] Called when the fields have been retrieved.
     * @return {Promise} Resolved when the fields have been retrieved.
     */
    this.getAllFields = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/field'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Creates a custom field using a definition (object encapsulating custom field data)
     *
     * @method createCustomField
     * @memberOf FieldClient#
     * @param opts The request options to send to Jira
     * @param opts.field See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3412}
     * @param [callback] Called when the custom field has been created.
     * @return {Promise} Resolved when the custom field has been created.
     */
    this.createCustomField = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/field'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts.field
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/filter.js":
/*!***************************************************!*\
  !*** ./node_modules/jira-connector/api/filter.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = FilterClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/filter'
 *
 * @param {JiraClient} jiraClient
 * @constructor FilterClient
 */
function FilterClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Creates a new filter, and returns newly created filter. Currently sets permissions just using the users default
     * sharing permissions
     *
     * @method createFilter
     * @memberOf FilterClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {Array} [opts.expand] The parameters to expand.
     * @param {Object} opts.filter The filter to create.  See
     *      {@link https://docs.atlassian.com/jira/REST/latest/#d2e3347}
     * @param [callback] Called when the filter has been created.
     * @return {Promise} Resolved when the filter has been created.
     */
    this.createFilter = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/filter'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            qs: {},
            body: opts.filter
        };

        if (opts.expand) {
            options.qs.expand = '';
            opts.expand.forEach(function (ex) {
                options.qs.expand += ex + ','
            });
        }

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns a filter given an id
     *
     * @method getFilter
     * @memberOf FilterClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.filterId The id of the filter to retrieve
     * @param [callback] Called when the filter has been retrieved.
     * @return {Promise} Resolved when the filter has been retrieved.
     */
    this.getFilter = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns all filters for the current user(only for cloud)
     *
     * @method getFilters
     * @memberOf FilterClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param [callback] Called when the filter has been retrieved.
     * @return {Promise} Resolved when the filter has been retrieved.
     */
    this.getFilters = function (opts, callback) {
       var options = {
            uri: this.jiraClient.buildURL('/filter'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Updates an existing filter, and returns its new value.
     *
     * @method updateFilter
     * @memberOf FilterClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.filterId The id of the filter to update
     * @param {Object} opts.filter The new data for the filter.  See
     *      {@link https://docs.atlassian.com/jira/REST/latest/#d2e3401}
     * @param [callback] Called when the filter has been updated.
     * @return {Promise} Resolved when the filter has been updated.
     */
    this.updateFilter = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'PUT', opts.filter);
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Delete a filter.
     *
     * @method deleteFilter
     * @memberOf FilterClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.filterId The id of the filter to delete
     * @param [callback] Called when the filter has been deleted.
     * @return {Promise} Resolved when the filter has been deleted.
     */
    this.deleteFilter = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Filter Deleted');
    };

    /**
     * Returns the default columns for the given filter. Currently logged in user will be used as the user making such
     * request.
     *
     * @method getFilterColumns
     * @memberOf FilterClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.filterId The id of the filter for which to retrieve columns.
     * @param [callback] Called when the columns have been retrieved.
     * @return {Promise} Resolved when the columns have been retrieved.
     */
    this.getFilterColumns = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/columns', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Sets the default columns for the given filter
     *
     * @method setFilterColumns
     * @memberOf FilterClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.filterId The id of the filter for which to update columns.
     * @param {Array} opts.columns The names of the new columns.
     *      See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3460}
     * @param [callback] Called when the columns have been set
     * @return {Promise} Resolved when the columns have been set
     */
    this.setFilterColumns = function (opts, callback) {
        var body = {columns: opts.columns};
        var options = this.buildRequestOptions(opts, '/columns', 'PUT', body);
        return this.jiraClient.makeRequest(options, callback, 'Columns Updated');
    };

    /**
     * Resets the columns for the given filter such that the filter no longer has its own column config.
     *
     * @method resetFilterColumns
     * @memberOf FilterClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.filterId The id of the filter for which to reset columns.
     * @param [callback] Called when the columns have been reset.
     * @return {Promise} Resolved when the columns have been reset.
     */
    this.resetFilterColumns = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/columns', 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Columns Reset');
    };

     /**
     * Adds a share permission for the given filter
     *
     * @method addSharePermission
     * @memberOf FilterClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.filterId The id of the filter for which to reset columns.
     * @param {Object} opts.permission The share permission to apply
     * @param [callback] Called when the columns have been reset.
     * @return {Promise} Resolved when the columns have been reset.
     */
    this.addSharePermission = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/permission', 'POST', opts.permission);
        return this.jiraClient.makeRequest(options, callback, 'Share Permission Added');
    }

    /**
     * Returns the default share scope of the logged-in user.
     *
     * @method getDefaultShareScore
     * @memberOf FilterClient#
     * @param opts Ignored.
     * @param [callback] Called when the default share scope has been retrieved.
     * @return {Promise} Resolved when the default share scope has been retrieved.
     */
    this.getDefaultShareScore = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/filter/defaultShareScope'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Sets the default share scope of the logged-in user.
     *
     * @method setDefaultShareScope
     * @memberOf FilterClient#
     * @param {Object} opts The request options sent to jira
     * @param {string} opts.scope The new default share scope. Available values are GLOBAL and PRIVATE.
     * @param [callback] Called when the default share scope has been set.
     * @return {Promise} Resolved when the default share scope has been set.
     */
    this.setDefaultShareScope = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/filter/defaultShareScope'),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: {
                scope: opts.scope
            }
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns the favourite filters of the logged-in user.
     *
     * @method getFavouriteFilters
     * @memberOf FilterClient#
     * @param opts Ignored.
     * @param [callback] Called when the list of favourites has been retrieved.
     * @return {Promise} Resolved when the list of favourites has been retrieved.
     */
    this.getFavoriteFilters = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/filter/favourite'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Build out the request options necessary to make a particular API call.
     *
     * @private
     * @method buildRequestOptions
     * @memberOf FilterClient#
     * @param {Object} opts The arguments passed to the method.
     * @param {number} opts.filterId The id of the filter to use in the path.
     * @param {Array} [opts.fields] The fields to include
     * @param {Array} [opts.expand] The fields to expand
     * @param {string} path The path of the endpoint following /filter/{id}
     * @param {string} method The request method.
     * @param {Object} [body] The request body, if any.
     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.
     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}
     */
    this.buildRequestOptions = function (opts, path, method, body, qs) {
        var basePath = '/filter/' + opts.filterId;
        if (!qs) qs = {};
        if (!body) body = {};

        if (opts.fields) {
            qs.fields = '';
            opts.fields.forEach(function (field) {
                qs.fields += field + ','
            });
            qs.fields = qs.fields.slice(0, -1);
        }

        if (opts.expand) {
            qs.expand = '';
            opts.expand.forEach(function (ex) {
                qs.expand += ex + ','
            });
            qs.expand = qs.expand.slice(0, -1);
        }

        return {
            uri: this.jiraClient.buildURL(basePath + path),
            method: method,
            body: body,
            qs: qs,
            followAllRedirects: true,
            json: true
        };
    };
}


/***/ }),

/***/ "./node_modules/jira-connector/api/group.js":
/*!**************************************************!*\
  !*** ./node_modules/jira-connector/api/group.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = GroupClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/group'
 *
 * These are considered experimental according to the Jira Docs, use at your own risk.
 *
 * @param {JiraClient} jiraClient
 * @constructor GroupClient
 */
function GroupClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Creates a group by given group parameter Returns REST representation for the requested group.
     *
     * @method createGroup
     * @memberOf GroupClient#
     * @param opts The request options sent to jira
     * @param opts.group The group to create.  See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2011}
     * @param [callback] Called when the group is created
     * @return {Promise} Resolved when the group is created
     */
    this.createGroup = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/group'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts.group
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns REST representation for the requested group. Allows to get list of active users belonging to the
     * specified group and its subgroups if "users" expand option is provided. You can page through users list by using
     * indexes in expand param. For example to get users from index 10 to index 15 use "users[10:15]" expand value.
     * This will return 6 users (if there are at least 16 users in this group). Indexes are 0-based and inclusive.
     * DEPRECATED. This resource is deprecated, please use group/member API instead. (15-Feb-2018)
     *
     * @method getGroup
     * @memberOf GroupClient#
     * @param opts The request options sent to the Jira API
     * @param opts.groupName A name of requested group.
     * @param opts.expand Array of fields to expand. Currently only available expand is "users".
     * @param [callback] Called when the group is retrieved.
     * @return {Promise} Resolved when the group is retrieved.
     */
    this.getGroup = function (opts, callback) {
        var qs = {
            groupname: opts.groupName
        };

        if (opts.expand) {
            qs.expand = '';
            opts.expand.forEach(function (ex) {
                qs.expand += ex + ','
            });
        }

        var options = {
            uri: this.jiraClient.buildURL('/group'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: qs
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * This resource returns a paginated list of users who are members of the specified group and its subgroups.
     * Users in the page are ordered by user names.
     * User of this resource is required to have sysadmin or admin permissions.
     *
     * @method getMembers
     * @memberOf GroupClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {String} opts.groupName A name of requested group.
     * @param {Boolean} opts.includeInactiveUsers inactive users will be included in the response if set to true. Default false.
     * @param {Number} opts.startAt the index of the first user in group to return (0 based).
     * @param {Number} opts.maxResults the maximum number of users to return (max 50).
     * @param [callback] Called when the group is retrieved.
     * @return {Promise} Resolved when the group is retrieved.
     */
    this.getMembers = function (opts, callback) {
        var qs = {
            groupname: opts.groupName,
            includeInactiveUsers: opts.includeInactiveUsers,
            startAt: opts.startAt,
            maxResults: opts.maxResults,
        };

        var options = {
            uri: this.jiraClient.buildURL('/group/member'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: qs
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Adds given user to a group. Returns the current state of the group.
     *
     * @method addUserToGroup
     * @memberOf GroupClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.groupName A name of requested group.
     * @param {string} opts.userName The name of the user to add to the group.
     * @param [callback] Called when the user has been added to the group.
     * @return {Promise} Resolved when the user has been added to the group.
     */
    this.addUserToGroup = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/group/user'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            qs: {
                groupname: opts.groupName
            },
            body: {
                name: opts.userName
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Removes given user from a group. Returns no content
     *
     * @method removeUserFromGroup
     * @memberOf GroupClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.groupName A name of requested group.
     * @param {string} opts.userName The name of the user to add to the group.
     * @param [callback] Called when the user has been added to the group.
     * @return {Promise} Resolved when the user has been added to the group.
     */
    this.removeUserFromGroup = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/group/user'),
            method: 'DELETE',
            json: true,
            followAllRedirects: true,
            qs: {
                groupname: opts.groupName,
                username: opts.userName
            }
        };

        return this.jiraClient.makeRequest(options, callback, 'User Removed from Group');
    };

    /**
     * Deletes a group by given group parameter. Returns no content
     *
     * @method deleteGroup
     * @memberOf GroupClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.groupName A group to delete.
     * @param {string} [opts.swapGroup] A group to transfer visibility restrictions of the group that is being deleted
     * @param [callback] Called when the group has been deleted.
     * @return {Promise} Resolved when the group has been deleted.
     */
    this.deleteGroup = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/group'),
            method: 'DELETE',
            json: true,
            followAllRedirects: true,
            qs: {
                groupname: opts.groupName,
                swapGroup: opts.swapGroup
            }
        };

        return this.jiraClient.makeRequest(options, callback, 'Group Deleted');
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/groupUserPicker.js":
/*!************************************************************!*\
  !*** ./node_modules/jira-connector/api/groupUserPicker.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = GroupUserPickerClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/groupuserpicker'
 * @param {JiraClient} jiraClient
 * @constructor GroupUserPickerClient
 */
function GroupUserPickerClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a list of users and groups matching query with highlighting. This resource cannot be accessed
     * anonymously.
     *
     * @method findUsersAndGroups
     * @memberOf GroupUserPickerClient#
     * @param {Object} opts The request options to send to the Jira API.
     * @param {string} opts.query A string used to search username, Name or e-mail address
     * @param {number} [opts.maxResults] the maximum number of users to return (defaults to 50). The maximum allowed
     *     value is 1000. If you specify a value that is higher than this number, your search results will be
     *     truncated.
     * @param {boolean} [opts.showAvatar] Whether to show the avatar
     * @param {string} [opts.fieldId] The custom field id, if this request comes from a custom field, such as a user
     *     picker. Optional.
     * @param {string} [opts.projectId] The list of project ids to further restrict the search This parameter can occur
     *     multiple times to pass in multiple project ids. Comma separated value is not supported. This parameter is
     *     only used when fieldId is present.
     * @param {string} [opts.issueTypeId] The list of issue type ids to further restrict the search. This parameter can
     *     occur multiple times to pass in multiple issue type ids. Comma separated value is not supported. Special
     *     values such as -1 (all standard issue types), -2 (all subtask issue types) are supported. This parameter is
     *     only used when fieldId is present.
     * @param [callback] Called when the search is completed.
     * @return {Promise} Resolved when the search is completed.
     */
    this.findUsersAndGroups = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/groupuserpicker'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                query: opts.query,
                maxResults: opts.maxResults,
                showAvatar: opts.showAvatar,
                fieldId: opts.fieldId,
                projectId: opts.projectId,
                issueTypeId: opts.issueTypeId
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/groups.js":
/*!***************************************************!*\
  !*** ./node_modules/jira-connector/api/groups.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = GroupsClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/groups'
 *
 * @param {JiraClient} jiraClient
 * @constructor GroupsClient
 */
function GroupsClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns groups with substrings matching a given query. This is mainly for use with the group picker, so the
     * returned groups contain html to be used as picker suggestions. The groups are also wrapped in a single response
     * object that also contains a header for use in the picker, specifically Showing X of Y matching groups. The
     * number of groups returned is limited by the system property "jira.ajax.autocomplete.limit" The groups will be
     * unique and sorted.
     *
     * @method findGroups
     * @memberOf GroupsClient#
     * @param {Object} opts The request options to use in the Jira API.
     * @param {string} opts.query A string against which to match groups.  Leave this blank to return all groups.
     * @param {string} opts.exclude A string specifying groups to exclude.
     * @param {number} opts.maxResults The maximum number of results to return.
     * @param [callback] Called when the groups have been retrieved.
     * @return {Promise} Resolved when the groups have been retrieved.
     */
    this.findGroups = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/groups/picker'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                query: opts.query,
                exclude: opts.exclude,
                maxResults: opts.maxResults
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/issue.js":
/*!**************************************************!*\
  !*** ./node_modules/jira-connector/api/issue.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var errorStrings = __webpack_require__(/*! ./../lib/error */ "./node_modules/jira-connector/lib/error.js");
var fs = __webpack_require__(/*! fs */ "fs");

module.exports = IssueClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/issue' and '/rest/agile/1.0/issue'
 * @constructor IssueClient
 * @param {JiraClient} jiraClient
 */
function IssueClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns the estimation of the issue and a filedId of the field that is
     * used for it.  The boardId parameter is required, and determines which
     * field will be updated on an issue.
     *
     * @method getIssueEstimation
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this
     *        object must contain EITHER an issueId or issueKey property;
     *        issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of teh issue.  EX: JWR-3
     * @param {string} [opts.boardId] The id of the board required to
     *        determine which field is used for estimation.
     * @param [callback] Called when the issue estimation has been retrieved.
     * @return {Promise} Resolved when the issue estimation has been retrieved.
     */
    this.getIssueEstimation = function (opts, callback) {
        var endpoint = '/issue/' + (opts.issueId || opts.issueKey) + '/estimation';
        var options = {
            uri: this.jiraClient.buildAgileURL(endpoint),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                boardId: opts.boardId,
                filter: opts.filter,
                startAt: opts.startAt,
                maxResults: opts.maxResults
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Updates the estimation of the issue.  The boardId parameter is required,
     * and determines which field will be updated on an issue.
     *
     * @method setIssueEstimation
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this
     *        object must contain EITHER an issueId or issueKey property;
     *        issueId will be used over issueKey if both are present.
     * @param {string} [opts.value] The value to set the issue estimation as.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of teh issue.  EX: JWR-3
     * @param {string} [opts.boardId] The id of the board required to
     *        determine which field is used for estimation.
     * @param [callback] Called when the issue estimation has been created.
     * @return {Promise} Resolved when the issue estimation has been created.
     */
    this.setIssueEstimation = function (opts, callback) {
        var endpoint = '/issue/' + (opts.issueId || opts.issueKey) + '/estimation';
        var options = {
            uri: this.jiraClient.buildAgileURL(endpoint),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: {
                value: opts.value,
                filter: opts.filter,
                startAt: opts.startAt,
                maxResults: opts.maxResults
            },
            qs: {
              boardId: opts.boardId
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Moves (ranks) issues before or after a given issue.
     *
     * @method setIssueRanks
     * @memberOf IssueClient#
     * @param {Object} ranking The ranking data in the form of PUT body to the
     *        Jira API.
     * @param [callback] Called when the issue rank has been created.
     * @return {Promise} Resolved when the issue rank has been created.
     */
    this.setIssueRanks = function (ranking, callback) {
        var options = {
            uri: this.jiraClient.buildAgileURL('/issue/rank'),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: ranking
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Creates an issue or a sub-task from a JSON representation.
     *
     * The fields that can be set on create, in either the fields parameter or the update parameter can be determined
     * using the /rest/api/2/issue/createmeta resource. If a field is not configured to appear on the create screen,
     * then it will not be in the createmeta, and a field validation error will occur if it is submitted.
     *
     * Creating a sub-task is similar to creating a regular issue, with two important differences:
     *
     * * the issueType field must correspond to a sub-task issue type (you can use /issue/createmeta to discover
     * sub-task issue types), and
     * * you must provide a parent field in the issue create request containing the id or key of the parent issue.
     *
     * @method createIssue
     * @memberof IssueClient#
     * @param {Object} issue The issue data in the form of POST body to the JIRA API.
     * See {@link https://docs.atlassian.com/jira/REST/latest/#d2e398}
     * @param [callback] Called when the issue has been created.
     * @return {Promise} Resolved when the issue has been created.
     */
    this.createIssue = function (issue, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issue'),
            method: 'POST',
            followAllRedirects: true,
            json: true,
            body: issue
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns the meta data for creating issues. This includes the available projects, issue types and fields,
     * including field types and whether or not those fields are required. Projects will not be returned if the user
     * does not have permission to create issues in that project.
     *
     * The fields in the createmeta correspond to the fields in the create screen for the project/issuetype. Fields not
     * in the screen will not be in the createmeta.
     *
     * Fields will only be returned if ```expand=projects.issuetypes.fields.```
     *
     * The results can be filtered by project and/or issue type, given by the query params.
     *
     * @method getCreateMetadata
     * @memberOf IssueClient#
     * @param {Object} [opts] The options for the API request.
     * @param {string} [opts.projectIds] combined with the projectKeys param, lists the projects with which to filter
     *     the results. If absent, all projects are returned. This parameter can be specified multiple times, and/or be
     *     a comma-separated list. Specifiying a project that does not exist (or that you cannot create issues in) is
     *     not an error, but it will not be in the results.
     * @param {string} [opts.projectKeys] combined with the projectIds param, lists the projects with which to filter
     *     the results. If null, all projects are returned. This parameter can be specified multiple times, and/or be a
     *     comma-separated list. Specifiying a project that does not exist (or that you cannot create issues in) is not
     *     an error, but it will not be in the results.
     * @param {string} [opts.issuetypeIds] combinded with issuetypeNames, lists the issue types with which to filter
     *     the results. If null, all issue types are returned. This parameter can be specified multiple times, and/or
     *     be a comma-separated list. Specifiying an issue type that does not exist is not an error.
     * @param {string} [opts.issuetypeNames] combinded with issuetypeIds, lists the issue types with which to filter
     *     the results. If null, all issue types are returned. This parameter can be specified multiple times, but is
     *     NOT interpreted as a comma-separated list. Specifiying an issue type that does not exist is not an error.
     * @param {string} [opts.expand] in order to get expanded field descriptions, specify 'projects.issuetypes.fields' here.
     * @param [callback] Called when the metadata has been retrieved.
     * @return {Promise} Resolved when the metadata has been retrieved.
     */
    this.getCreateMetadata = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issue/createmeta'),
            method: 'GET',
            followAllRedirects: true,
            json: true,
            qs: {
                projectIds: opts.projectIds,
                projectKeys: opts.projectKeys,
                issuetypeIds: opts.issuetypeIds,
                issuetypeNames: opts.issuetypeNames,
                expand: opts.expand
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Creates issues or sub-tasks from a JSON representation.
     *
     * Creates many issues in one bulk operation.
     *
     * Creating a sub-task is similar to creating a regular issue. More details can be found in createIssue section:
     * {@link IssueResource#createIssue(IssueUpdateBean)}}
     *
     * @method bulkCreate
     * @memberof IssueClient#
     * @param issues See {@link https://docs.atlassian.com/jira/REST/latest/#d2e828}
     * @param [callback] Called when the issues have been created.
     * @return {Promise} Resolved when the issues have been created.
     */
    this.bulkCreate = function (issues, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issue/bulk'),
            method: 'POST',
            followAllRedirects: true,
            json: true,
            body: issues
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns a full representation of the issue for the given issue key.
     *
     * An issue JSON consists of the issue key, a collection of fields, a link to the workflow transition sub-resource,
     * and (optionally) the HTML rendered values of any fields that support it (e.g. if wiki syntax is enabled for the
     * description or comments).
     *
     * The fields param (which can be specified multiple times) gives a comma-separated list of fields to include in
     * the response. This can be used to retrieve a subset of fields. A particular field can be excluded by prefixing
     * it with a minus.
     *
     * By default, all (\*all) fields are returned in this get-issue resource. Note: the default is different when doing
     * a jql search -- the default there is just navigable fields (\*navigable).
     *
     * * \*all - include all fields
     * * \*navigable - include just navigable fields
     * * summary,comment - include just the summary and comments
     * * -comment - include everything except comments (the default is *all for get-issue)
     * * \*all,-comment - include everything except comments
     *
     * JIRA will attempt to identify the issue by the issueIdOrKey path parameter. This can be an issue id, or an issue
     * key. If the issue cannot be found via an exact match, JIRA will also look for the issue in a case-insensitive
     * way, or by looking to see if the issue was moved. In either of these cases, the request will proceed as normal
     * (a 302 or other redirect will not be returned). The issue key contained in the response will indicate the
     * current value of issue's key.
     *
     * @method getIssue
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {boolean} [opts.agile] Whether or not to call the agile version of this endpoint.  Defaults to false.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {Object} [opts.fields] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e611}
     * @param {Object} [opts.expand] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e611}
     * @param {Object} [opts.properties] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e611}
     * @param [callback] Called when data has been retrieved
     * @return {Promise} Resolved when data has been retrieved
     */
    this.getIssue = function (opts, callback) {
        if (!opts.agile) {
            var options = this.buildRequestOptions(opts, '', 'GET');
        } else {
            var endpoint = '/issue/' + (opts.issueId || opts.issueKey);
            var options = {
                uri: this.jiraClient.buildAgileURL(endpoint),
                method: 'GET',
                json: true,
                followAllRedirects: true,
                qs: {
                    filter: opts.filter,
                    startAt: opts.startAt,
                    maxResults: opts.maxResults,
                    expand: opts.expand
                }
            };
        }

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Delete an issue. If the issue has subtasks you must set the parameter deleteSubtasks=true to delete the issue.
     * You cannot delete an issue without its subtasks also being deleted.
     *
     * @method deleteIssue
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} [opts.deleteSubtasks] "a String of true or false indicating that any subtasks should also
     *        be deleted. If the issue has no subtasks this parameter is ignored. If the issue has subtasks and this
     *        parameter is missing or false, then the issue will not be deleted and an error will be returned."
     * @param [callback] Called when data has been retrieved
     * @return {Promise} Resolved when data has been retrieved
     */
    this.deleteIssue = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'DELETE', null, {deleteSubtasks: opts.deleteSubtasks});

        return this.jiraClient.makeRequest(options, callback, 'Issue Deleted');
    };

    /**
     *  Edits an issue from a JSON representation.
     *
     * The issue can either be updated by setting explicit the field value(s) or by using an operation to change the
     * field value.
     *
     * The fields that can be updated, in either the fields parameter or the update parameter, can be determined using
     * the {@link IssueClient#getEditMetadata} method. If a field is not configured to appear on the edit
     * screen, then it will not be in the editmeta, and a field validation error will occur if it is submitted.
     *
     * Specifying a "field_id": field_value in the "fields" is a shorthand for a "set" operation in the "update"
     * section. Field should appear either in "fields" or "update", not in both.
     *
     * @method editIssue
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {Object} opts.issue See {@link https://docs.atlassian.com/jira/REST/latest/#d2e656}
     * @param [callback] Called when data has been retrieved
     * @return {Promise} Resolved when data has been retrieved
     */
    this.editIssue = function (opts, callback) {
        if (!opts.issue) {
            throw new Error(errorStrings.NO_ISSUE_ERROR);
        }
        var options = this.buildRequestOptions(opts, '', 'PUT', opts.issue, opts.qs);

        return this.jiraClient.makeRequest(options, callback, 'Issue Updated');
    };

    /**
     * Assigns an issue to a user. You can use this resource to assign issues when the user submitting the request has
     * the assign permission but not the edit issue permission. If the name is "-1" automatic assignee is used. A null
     * name will remove the assignee.
     *
     * @method assignIssue
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.assignee The name of the user to whom to assign the issue. -1 for default, null for no
     *     assignee.
     * @param [callback] Called when the issue has been assigned.
     * @return {Promise} Resolved when the issue has been assigned.
     */
    this.assignIssue = function (opts, callback) {
        if (!(typeof opts.assignee === "string" && opts.assignee.length || opts.assignee === null)) {
            throw new Error(errorStrings.NO_ASSIGNEE_ERROR);
        }

        var options = this.buildRequestOptions(opts, '/assignee', 'PUT', {name: opts.assignee});

        return this.jiraClient.makeRequest(options, callback, 'Issue Assigned');
    };

    /**
     * Get all the comments for an issue.
     *
     * @method getComments
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {Object} opts.expand See {@link https://docs.atlassian.com/jira/REST/latest/#d2e461}
     * @param [callback] Called when the issue has been assigned.
     * @return {Promise} Resolved when the issue has been assigned.
     */
    this.getComments = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/comment', 'GET');

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Add a comment to an issue
     *
     * @method addComment
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {Object} opts.comment See {@link https://docs.atlassian.com/jira/REST/latest/#d2e482}
     * @param [callback] Called when data has been retrieved
     * @return {Promise} Resolved when data has been retrieved
     */
    this.addComment = function (opts, callback) {
        var options;
        if(opts.comment.body) {
            options = this.buildRequestOptions(opts, '/comment', 'POST', opts.comment);
        } else {
            options = this.buildRequestOptions(opts, '/comment', 'POST', {body: opts.comment});
        }

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get a specific comment.
     *
     * @method getComment
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.commentId The id of the comment.
     * @param [callback] Called when the comment is retrieved.
     * @return {Promise} Resolved when the comment is retrieved.
     */
    this.getComment = function (opts, callback) {
        if (!opts.commentId) {
            throw new Error(errorStrings.NO_COMMENT_ID);
        }
        var options = this.buildRequestOptions(opts, '/comment/' + opts.commentId, 'GET');

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Updates an existing comment using its JSON representation.
     *
     * @method editComment
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.commentId The id of the comment.
     * @param {Object} opts.comment See {@link https://docs.atlassian.com/jira/REST/latest/#d2e539}
     * @param [callback] Called when data has been retrieved
     * @return {Promise} Resolved when data has been retrieved
     */
    this.editComment = function (opts, callback) {
        if (!opts.comment) {
            throw new Error(errorStrings.NO_COMMENT_ERROR);
        } else if (!opts.commentId) {
            throw new Error(errorStrings.NO_COMMENT_ID);
        }
        var options = this.buildRequestOptions(opts, '/comment/' + opts.commentId, 'PUT', opts.comment);

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Delete an existing comment.
     *
     * @method deleteComment
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.commentId The id of the comment.
     * @param [callback] Called when the comment is retrieved.
     * @return {Promise} Resolved when the comment is retrieved.
     */
    this.deleteComment = function (opts, callback) {
        if (!opts.commentId) {
            throw new Error(errorStrings.NO_COMMENT_ID);
        }
        var options = this.buildRequestOptions(opts, '/comment/' + opts.commentId, 'DELETE');

        return this.jiraClient.makeRequest(options, callback, 'Comment Deleted');
    };

    /**
     * Returns the meta data for editing an issue.
     *
     * The fields in the editmeta correspond to the fields in the edit screen for the issue. Fields not in the screen
     * will not be in the editemeta.
     *
     * @method getEditMetadata
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param [callback] Called when the metadata is retrieved.
     * @return {Promise} Resolved when the metadata is retrieved.
     */
    this.getEditMetadata = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/editmeta', 'GET');

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Sends a notification (email) to the list or recipients defined in the request.
     * A couple of notes: this may call back with the error 'No recipients were defined for notification.' if all
     * of the intended recipients have disabled notifications from Jira.
     *
     * @method sendEmailNotification
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *        issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {Object} opts.notification See {@link https://docs.atlassian.com/jira/REST/latest/#d2e435}
     * @param [callback] Called when the metadata is retrieved.
     * @return {Promise} Resolved when the metadata is retrieved.
     */
    this.sendEmailNotification = function (opts, callback) {
        if (!opts.notification) {
            throw new Error(errorStrings.NO_NOTIFICATION_ERROR);
        }

        var options = this.buildRequestOptions(opts, '/notify', 'POST', opts.notification);

        return this.jiraClient.makeRequest(options, callback, 'Notifications Sent');
    };

    /**
     * Get a REST sub-resource representing the remote issue links on the issue.
     *
     * @method getRemoteLinks
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.globalId The id of the remote issue link to be returned. If null (not provided) all remote
     *     links for the issue are returned. For a full explanation of Issue Link fields please refer to
     *     {@link https://developer.atlassian.com/display/JIRADEV/Fields+in+Remote+Issue+Links}
     * @param [callback] Called when the remote links are retrieved.
     * @return {Promise} Resolved when the remote links are retrieved.
     */
    this.getRemoteLinks = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/remotelink', 'GET', null, {globalId: opts.globalId});

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Creates (or updates) a remote issue link from a JSON representation. If a globalId is provided and a remote issue
     * link exists with that globalId, the remote issue link is updated. Otherwise, the remote issue link is created.
     *
     * @method createRemoteLink
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {Object} opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e945}
     * @param [callback] Called when the remote links are retrieved.
     * @return {Promise} Resolved when the remote links are retrieved.
     */
    this.createRemoteLink = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/remotelink', 'POST', opts.remoteLink);

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Updates (or creates) a remote issue link from a JSON representation. If a globalId is provided and a remote issue
     * link exists with that globalId, the remote issue link is updated. Otherwise, the remote issue link is created.
     *
     * @method updateRemoteLink
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {Object} opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e945}
     * @param [callback] Called when the remote links are retrieved.
     * @return {Promise} Resolved when the remote links are retrieved.
     */
    this.updateRemoteLink = function (opts, callback) {
        // The one API endpoint handles both updates and creation.
        this.createRemoteLink(opts, callback);
    };

    /**
     * Delete the remote issue link with the given global id on the issue.
     *
     * @method deleteRemoteLink
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.globalId The global id of the remote issue link
     * @param [callback] Called when the remote links are retrieved.
     * @return {Promise} Resolved when the remote links are retrieved.
     */
    this.deleteRemoteLink = function (opts, callback) {
        if (!opts.globalId) {
            throw new Error(errorStrings.NO_GLOBAL_ID_ERROR);
        }

        var options = this.buildRequestOptions(opts, '/remotelink', 'DELETE', null, {globalId: opts.globalId});

        return this.jiraClient.makeRequest(options, callback, 'RemoteLink Deleted');
    };

    /**
     * Get the remote issue link with the given id on the issue.
     *
     * @method getRemoteLinkById
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.linkId The id of the remote link
     * @param [callback] Called when the remote links are retrieved.
     * @return {Promise} Resolved when the remote links are retrieved.
     */
    this.getRemoteLinkById = function (opts, callback) {
        if (!opts.linkId) {
            throw new Error(errorStrings.NO_LINK_ID_ERROR);
        }

        var options = this.buildRequestOptions(opts, '/remotelink/' + opts.linkId, 'GET');

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get the remote issue link with the given id on the issue.
     *
     * @method updateRemoteLinkById
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.linkId The id of the remote link
     * @param {string} opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e1037}
     * @param [callback] Called when the remote links are retrieved.
     * @return {Promise} Resolved when the remote links are retrieved.
     */
    this.updateRemoteLinkById = function (opts, callback) {
        if (!opts.linkId) {
            throw new Error(errorStrings.NO_LINK_ID_ERROR);
        }

        var options = this.buildRequestOptions(opts, '/remotelink/' + opts.linkId, 'PUT', opts.remoteLink);

        return this.jiraClient.makeRequest(options, callback, 'RemoteLink Updated');
    };

    /**
     * Get the remote issue link with the given id on the issue.
     *
     * @method deleteRemoteLinkById
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.linkId The id of the remote link
     * @param [callback] Called when the remote links are retrieved.
     * @return {Promise} Resolved when the remote links are retrieved.
     */
    this.deleteRemoteLinkById = function (opts, callback) {
        if (!opts.linkId) {
            throw new Error(errorStrings.NO_LINK_ID_ERROR);
        }

        var options = this.buildRequestOptions(opts, '/remotelink/' + opts.linkId, 'DELETE');

        return this.jiraClient.makeRequest(options, callback, 'RemoteLink Deleted');
    };

    /**
     * Get a list of the transitions possible for this issue by the current user, along with fields that are required
     * and their types.
     *
     * Fields will only be returned if ```expand=transitions.fields.```
     *
     * The fields in the metadata correspond to the fields in the transition screen for that transition. Fields not in
     * the screen will not be in the metadata.
     *
     * @method getTransitions
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.transitionId If specified, will call back with only the transition with the specified id.
     * @param [callback] Called when the transitions are retrieved.
     * @return {Promise} Resolved when the transitions are retrieved.
     */
    this.getTransitions = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/transitions', 'GET', null, {transitionId: opts.transitionId});

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Perform a transition on an issue. When performing the transition you can udate or set other issue fields.
     *
     * The fields that can be set on transtion, in either the fields parameter or the update parameter can be
     * determined using the** /rest/api/2/issue/{issueIdOrKey}/transitions?expand=transitions.fields resource**. If a
     * field is not configured to appear on the transition screen, then it will not be in the transition metadata, and
     * a field validation error will occur if it is submitted.
     *
     * @method transitionIssue
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.transition See {@link https://docs.atlassian.com/jira/REST/latest/#d2e698}
     * @param [callback] Called when the transitions are retrieved.
     * @return {Promise} Resolved when the transitions are retrieved.
     */
    this.transitionIssue = function (opts, callback) {
        if (!opts.transition) {
            throw new Error(errorStrings.NO_TRANSITION_ERROR);
        }

        var options;
        if(!opts.transition.transition) { // To keep backwards compatibility
            options = this.buildRequestOptions(opts, '/transitions', 'POST', opts);
        } else {
            options = this.buildRequestOptions(opts, '/transitions', 'POST', opts.transition)
        }
        return this.jiraClient.makeRequest(options, callback, 'Issue Transitioned');
    };

    /**
     * Remove your vote from an issue. (i.e. "unvote")
     *
     * @method unvote
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param [callback] Called after the vote is removed.
     * @return {Promise} Resolved after the vote is removed.
     */
    this.unvote = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/votes', 'DELETE');

        return this.jiraClient.makeRequest(options, callback, 'Vote Removed');
    };

    /**
     * Cast your vote in favour of an issue.
     *
     * @method vote
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param [callback] Called after the vote is removed.
     * @return {Promise} Resolved after the vote is removed.
     */
    this.vote = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/votes', 'POST');

        return this.jiraClient.makeRequest(options, callback, 'Vote Added');
    };

    /**
     * Get a REST sub-resource representing the voters on the issue.
     *
     * @method getVotes
     * @memberof IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param [callback] Called after the votes are retrieved.
     * @return {Promise} Resolved after the votes are retrieved.
     */
    this.getVotes = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/votes', 'GET');

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns the list of watchers for the issue with the given key.
     *
     * @method getWatchers
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param [callback] Called after the watchers are retrieved.
     * @return {Promise} Resolved after the watchers are retrieved.
     */
    this.getWatchers = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/watchers', 'GET');

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Adds a user to an issue's watcher list.
     *
     * @method addWatcher
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.watcher The username of the user to add as a watcher.
     * @param [callback] Called after the watcher is added.
     * @return {Promise} Resolved after the watcher is added.
     */
    this.addWatcher = function (opts, callback) {
        if (!opts.watcher) {
            throw new Error(errorStrings.NO_WATCHER_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/watchers', 'POST', opts.watcher);

        return this.jiraClient.makeRequest(options, callback, 'Watcher Added');
    };

    /**
     * Adds a user to an issue's watcher list.
     *
     * @method removeWatcher
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.watcher The username of the user to remove as a watcher.
     * @param [callback] Called after the watcher is removed.
     * @return {Promise} Resolved after the watcher is removed.
     */
    this.removeWatcher = function (opts, callback) {
        if (!opts.watcher) {
            throw new Error(errorStrings.NO_WATCHER_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/watchers', 'DELETE', null, {username: opts.watcher});

        return this.jiraClient.makeRequest(options, callback, 'Watcher Removed');
    };

    /**
     * Gets all work logs for an issue.
     *
     * @method getWorkLogs
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param [callback] Called after the worklogs are retrieved.
     * @return {Promise} Resolved after the worklogs are retrieved.
     */
    this.getWorkLogs = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/worklog', 'GET');

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Adds a new worklog entry to an issue.
     *
     * @method addWorkLog
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} [opts.adjustEstimate] Allows you to provide specific instructions to update the remaining time
     *     estimate of the issue. Valid values are
     *     * "new" - sets the estimate to a specific value
     *     * "leave"- leaves the estimate as is
     *     * "manual" - specify a specific amount to increase remaining estimate by
     *     * "auto"- Default option. Will automatically adjust the value based on the
     *          new timeSpent specified on the worklog
     * @param {string} [opts.newEstimate] (required when "new" is selected for adjustEstimate) the new value for the
     *     remaining estimate field. e.g. "2d"
     * @param {string} [opts.reduceBy] (required when "manual" is selected for adjustEstimate) the amount to reduce the
     *     remaining estimate by e.g. "2d"
     * @param {Object} opts.worklog See {@link: https://docs.atlassian.com/jira/REST/latest/#d2e1106}
     * @param [callback] Called after the worklog is added.
     * @return {Promise} Resolved after the worklog is added.
     */
    this.addWorkLog = function (opts, callback) {
        if (!opts.worklog) {
            throw new Error(errorStrings.NO_WORKLOG_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/worklog', 'POST', opts.worklog, {
            newEstimate: opts.newEstimate,
            reduceBy: opts.reduceBy,
            adjustEstimate: opts.adjustEstimate
        });

        return this.jiraClient.makeRequest(options, callback, 'Worklog Added');
    };

    /**
     * Gets a specific worklog.
     *
     * @method getWorkLog
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.worklogId The id of the work log to retrieve.
     * @param [callback] Called after the worklog is retrieved.
     * @return {Promise} Resolved after the worklog is retrieved.
     */
    this.getWorkLog = function (opts, callback) {
        if (!opts.worklogId) {
            throw new Error(errorStrings.NO_WORKLOG_ID_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/worklog/' + opts.worklogId, 'GET');

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Updates an existing worklog entry using its JSON representation.
     *
     * @method updateWorkLog
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.worklogId The id of the work log to retrieve.
     * @param {string} [opts.adjustEstimate] Allows you to provide specific instructions to update the remaining time
     *     estimate of the issue. Valid values are
     *     * "new" - sets the estimate to a specific value
     *     * "leave"- leaves the estimate as is
     *     * "auto"- Default option. Will automatically adjust the value based on the
     *          new timeSpent specified on the worklog
     * @param {string} [opts.newEstimate] (required when "new" is selected for adjustEstimate) the new value for the
     *     remaining estimate field. e.g. "2d"
     * @param {Object} opts.worklog See {@link: https://docs.atlassian.com/jira/REST/latest/#d2e1161}
     * @param [callback] Called after the worklog is updated.
     * @return {Promise} Resolved after the worklog is updated.
     */
    this.updateWorkLog = function (opts, callback) {
        if (!opts.worklogId) {
            throw new Error(errorStrings.NO_WORKLOG_ID_ERROR);
        } else if (!opts.worklog) {
            throw new Error(errorStrings.NO_WORKLOG_ERROR);
        }

        var options = this.buildRequestOptions(opts, '/worklog/' + opts.worklogId, 'PUT', opts.worklog, {
            newEstimate: opts.newEstimate,
            adjustEstimate: opts.adjustEstimate
        });

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Deletes an existing worklog entry
     *
     * @method deleteWorkLog
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.worklogId The id of the work log to delete.
     * @param {string} [opts.adjustEstimate] Allows you to provide specific instructions to update the remaining time
     *     estimate of the issue. Valid values are
     *     * "new" - sets the estimate to a specific value
     *     * "leave"- leaves the estimate as is
     *     * "manual" - specify a specific amount to increase remaining estimate by
     *     * "auto"- Default option. Will automatically adjust the value based on the
     *          new timeSpent specified on the worklog
     * @param {string} [opts.newEstimate] (required when "new" is selected for adjustEstimate) the new value for the
     *     remaining estimate field. e.g. "2d"
     * @param {string} [opts.increaseBy] (required when "manual" is selected for adjustEstimate) the amount to reduce
     *     the remaining estimate by e.g. "2d"
     * @param [callback] Called after the work log is deleted.
     * @return {Promise} Resolved after the work log is deleted.
     */
    this.deleteWorkLog = function (opts, callback) {
        if (!opts.worklogId) {
            throw new Error(errorStrings.NO_WORKLOG_ID_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/worklog/' + opts.worklogId, 'DELETE', null, {
            newEstimate: opts.newEstimate,
            increaseBy: opts.increaseBy,
            adjustEstimate: opts.adjustEstimate
        });
        return this.jiraClient.makeRequest(options, callback, 'Work Log Deleted');
    };

    /**
     * Add an attachments to an issue.
     *
     * @method addAttachment
     * @memberOf IssueClient
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.filename The file name of attachment. If you pass an array of filenames, multiple attachments will be added.
     * @param [callback] Called when the attachment has been attached.
     * @return {Promise} Resolved when the attachment has been attached.
     */
    this.addAttachment = function (opts, callback) {
        if (!opts.filename) {
            throw new Error(errorStrings.NO_FILENAME_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/attachments', 'POST');
        delete options.body;
        if (opts.filename.constructor !== Array) opts.filename = [opts.filename];
        var attachments = opts.filename.map (function (filename) {return fs.createReadStream(filename)});
        options.formData = {file: attachments};
        options.headers = {
            "X-Atlassian-Token": "nocheck"
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns the keys of all properties for the issue identified by the key or by the id.  This function is maked as
     * experimental in the Jira API docs, use at your own risk.
     *
     * @method getProperties
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param [callback] Called when the properties are retrieved.
     * @return {Promise} Resolved when the properties are retrieved.
     */
    this.getProperties = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/properties', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Sets the value of the specified issue's property. You can use this resource to store a custom data against the
     * issue identified by the key or by the id. The user who stores the data is required to have permissions to edit
     * the issue.
     *
     * This function is maked as experimental in the Jira API docs, use at your own risk.
     *
     * @method setProperty
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.propertyKey The key of the property being set.
     * @param {Object} opts.propertyValue The value of the property being set.
     * @param [callback] Called when the property is set.
     * @return {Promise} Resolved when the property is set.
     */
    this.setProperty = function (opts, callback) {
        if (!opts.propertyKey) {
            throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);
        } else if (!opts.propertyValue) {
            throw new Error(errorStrings.NO_PROPERTY_VALUE_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/properties/' + opts.propertyKey, 'PUT', opts.propertyValue);
        return this.jiraClient.makeRequest(options, callback, 'Property Set');
    };

    /**
     * Returns the value of the property with a given key from the issue identified by the key or by the id. The user
     * who retrieves the property is required to have permissions to read the issue.
     *
     * This function is maked as experimental in the Jira API docs, use at your own risk.
     *
     * @method getProperty
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.propertyKey The key of the property being set.
     * @param [callback] Called when the property is retrieved.
     * @return {Promise} Resolved when the property is retrieved.
     */
    this.getProperty = function (opts, callback) {
        if (!opts.propertyKey) {
            throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/properties/' + opts.propertyKey, 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Removes the property from the issue identified by the key or by the id. Ths user removing the property is
     * required to have permissions to edit the issue.
     *
     * This function is maked as experimental in the Jira API docs, use at your own risk.
     *
     * @method getProperty
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or
     *     issueKey property; issueId will be used over issueKey if both are present.
     * @param {string} [opts.issueId] The id of the issue.  EX: 10002
     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3
     * @param {string} opts.propertyKey The key of the property being set.
     * @param [callback] Called when the property is deleted.
     * @return {Promise} Resolved when the property is deleted.
     */
    this.deleteProperty = function (opts, callback) {
        if (!opts.propertyKey) {
            throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);
        }
        var options = this.buildRequestOptions(opts, '/properties/' + opts.propertyKey, 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Property Deleted');
    };

    this.setWorklogProperty = function (opts, callback) {
        if (!opts.propertyKey) {
            throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);
        } else if (!opts.propertyValue) {
            throw new Error(errorStrings.NO_PROPERTY_VALUE_ERROR);
        }
      var options = this.buildRequestOptions(
        opts,
        '/worklog/' + opts.worklogId + '/properties/' + opts.propertyKey,
        'PUT',
        opts.propertyValue
      );
      return this.jiraClient.makeRequest(options, callback, 'Property Set');
    };

    this.getWorkLogProperties = function (opts, callback) {
      var options = this.buildRequestOptions(
        opts,
        '/worklog/' + opts.worklogId + '/properties/',
        'GET'
      );
      return this.jiraClient.makeRequest(options, callback);
    };

    this.getWorkLogProperty = function (opts, callback) {
      if (!opts.propertyKey) {
          throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);
      }
      var options = this.buildRequestOptions(
        opts,
        '/worklog/' + opts.worklogId + '/properties/' + opts.propertyKey,
        'GET'
      );
      return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Build out the request options necessary to make a particular API call.
     *
     * @private
     * @method buildRequestOptions
     * @param {Object} opts The arguments passed to the method.
     * @param {string} path The path of the endpoint following /issue/{idOrKey}
     * @param {string} method The request method.
     * @param {Object} [body] The request body, if any.
     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.
     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}
     */
    this.buildRequestOptions = function (opts, path, method, body, qs) {
        if (!opts.issueId && !opts.issueKey) {
            throw new Error(errorStrings.NO_ISSUE_IDENTIFIER);
        }
        var idOrKey = opts.issueId || opts.issueKey;
        var basePath = '/issue/' + idOrKey;
        if (!qs) qs = {};
        if (!body) body = {};

        if (opts.fields) {
            qs.fields = '';
            opts.fields.forEach(function (field) {
                qs.fields += field + ','
            });
        }

        if (opts.expand) {
            qs.expand = '';
            opts.expand.forEach(function (ex) {
                qs.expand += ex + ','
            });
        }

        if (opts.properties) {
            qs.properties = '';
            opts.properties.forEach(function (prop) {
                qs.properties += prop + ','
            });
        }

        return {
            uri: this.jiraClient.buildURL(basePath + path),
            method: method,
            body: body,
            qs: qs,
            followAllRedirects: true,
            json: true
        };
    }
    
    /**
     * Returns suggested issues which match the auto-completion query for the 
     * user which executes this request. This REST method will check the user's 
     * history and the user's browsing context and select this issues, which 
     * match the query.
     *
     * @method getIssuePicker
     * @memberOf IssueClient#
     * @param {Object} opts The options to pass to the API.
     * @param {string} [opts.query] the query
     * @param {string} [opts.currentJQL] the JQL in context of which the request 
     *                 is executed. Only issues which match this JQL query will be 
     *                 included in results.
     * @param {string} [opts.currentIssueKey] the key of the issue in context of 
     *                 which the request is executed. The issue which is in context 
     *                 will not be included in the auto-completion result, even if 
     *                 it matches the query.
     * @param {string} [opts.currentProjectId] the id of the project in context of 
     *                 which the request is executed. Suggested issues will be only 
     *                 from this project.
     * @param {boolean} [opts.showSubTasks] if set to false, subtasks will not be 
     *                  included in the list.
     * @param {boolean} [opts.showSubTaskParent] if set to false and request is 
     *                  executed in context of a subtask, the parent issue will 
     *                  not be included in the auto-completion result, even if it 
     *                  matches the query.
     * @param [callback] Called when the issues have been retrieved.
     * @return {Promise} Resolved when the issues have been retrieved.
     */
    this.getIssuePicker = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issue/picker'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                query: opts.query,
                currentJQL: opts.currentJQL,
                currentIssueKey: opts.currentIssueKey,
                currentProjectId: opts.currentProjectId,
                showSubTasks: opts.showSubTasks,
                showSubTaskParent: opts.showSubTaskParent
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

}


/***/ }),

/***/ "./node_modules/jira-connector/api/issueLink.js":
/*!******************************************************!*\
  !*** ./node_modules/jira-connector/api/issueLink.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var errorStrings = __webpack_require__(/*! ./../lib/error */ "./node_modules/jira-connector/lib/error.js");

module.exports = IssueLinkClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/issueLink'
 * @param {JiraClient} jiraClient
 * @constructor IssueLinkClient
 */
function IssueLinkClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Creates an issue link between two issues. The user requires the link issue permission for the issue which will
     * be linked to another issue. The specified link type in the request is used to create the link and will create a
     * link from the first issue to the second issue using the outward description. It also create a link from the
     * second issue to the first issue using the inward description of the issue link type. It will add the supplied
     * comment to the first issue. The comment can have a restriction who can view it. If group is specified, only
     * users of this group can view this comment, if roleLevel is specified only users who have the specified role can
     * view this comment. The user who creates the issue link needs to belong to the specified group or have the
     * specified role.
     *
     * @memberOf IssueLinkClient#
     * @method createIssueLink
     * @param opts The options for the request sent to the Jira API
     * @param opts.issueLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e5010}
     * @param [callback] Called when the link has been created.
     * @return {Promise} Resolved when the link has been created.
     */
    this.createIssueLink = function (opts, callback) {
        if (!opts.issueLink) {
            throw new Error(errorStrings.NO_ISSUE_LINK_ERROR);
        }

        var options = {
            method: 'POST',
            uri: this.jiraClient.buildURL('/issueLink'),
            json: true,
            followAllRedirects: true,
            body: opts.issueLink
        };

        return this.jiraClient.makeRequest(options, callback, 'Issue Link Created');
    };

    /**
     * Gets an issue link with the specified id.
     *
     * @method getIssueLink
     * @memberOf IssueLinkClient#
     * @param opts The options used in the request to the Jira API
     * @param opts.linkId The id of the link to retrieve.
     * @param [callback] Called when the Issue Link has been retrieved.
     * @return {Promise} Resolved when the Issue Link has been retrieved.
     */
    this.getIssueLink = function (opts, callback) {
        if (!opts.linkId) {
            throw new Error(errorStrings.NO_ISSUE_LINK_ID_ERROR);
        }

        var options = {
            method: 'GET',
            uri: this.jiraClient.buildURL('/issueLink/' + opts.linkId),
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Deletes an issue link with the specified id. To be able to delete an issue link you must be able to view both
     * issues and must have the link issue permission for at least one of the issues.
     *
     * @method deleteIssueLink
     * @memberOf IssueLinkClient#
     * @param opts The options used in the request to the Jira API
     * @param opts.linkId The id of the link to delete.
     * @param [callback] Called when the Issue Link has been deleted.
     * @return {Promise} Resolved when the Issue Link has been deleted.
     */
    this.deleteIssueLink = function (opts, callback) {
        if (!opts.linkId) {
            throw new Error(errorStrings.NO_ISSUE_LINK_ID_ERROR);
        }

        var options = {
            method: 'DELETE',
            uri: this.jiraClient.buildURL('/issueLink/' + opts.linkId),
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback, 'Issue Link Deleted');
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/issueLinkType.js":
/*!**********************************************************!*\
  !*** ./node_modules/jira-connector/api/issueLinkType.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var errorStrings = __webpack_require__(/*! ./../lib/error */ "./node_modules/jira-connector/lib/error.js");

module.exports = IssueLinkTypeClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/issueLinkType'
 * @param {JiraClient} jiraClient
 * @constructor IssueLinkTypeClient
 */
function IssueLinkTypeClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Get a list of available issue link types, if issue linking is enabled. Each issue link type has an id, a name
     * and a label for the outward and inward link relationship.
     *
     * @method getAvailableTypes
     * @memberOf IssueLinkTypeClient#
     * @param opts The request options for the API.  Ignored in this function.
     * @param [callback] Called when the available IssueLink types are retrieved.
     * @return {Promise} Resolved when the available IssueLink types are retrieved.
     */
    this.getAvailableTypes = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issueLinkType'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Create a new issue link type.
     *
     * @method createIssueLinkType
     * @memberOf IssueLinkTypeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.linkType See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2018}
     * @param [callback] Called when the IssueLink type has been created.
     * @return {Promise} Resolved when the IssueLink type has been created.
     */
    this.createIssueLinkType = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issueLinkType'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts.linkType
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Gets for a given issue link type id all information about this issue link type.
     *
     * @method getIssueLinkType
     * @memberOf IssueLinkTypeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.issueLinkTypeId The id of the IssueLink type to retrieve.
     * @param [callback] Called when the IssueLink type has been retrieved
     * @return {Promise} Resolved when the IssueLink type has been retrieved
     */
    this.getIssueLinkType = function (opts, callback) {
        if (!opts.issueLinkTypeId) {
            throw new Error(errorStrings.NO_ISSUE_LINK_TYPE_ID);
        }

        var options = {
            uri: this.jiraClient.buildURL('/issueLinkType/' + opts.issueLinkTypeId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Delete the specified issue link type.
     *
     * @method deleteIssueLinkType
     * @memberOf IssueLinkTypeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.issueLinkTypeId The id of the IssueLink type to delete.
     * @param [callback] Called when the IssueLink type has been delete
     * @return {Promise} Resolved when the IssueLink type has been delete
     */
    this.deleteIssueLinkType = function (opts, callback) {
        if (!opts.issueLinkTypeId) {
            throw new Error(errorStrings.NO_ISSUE_LINK_TYPE_ID);
        }

        var options = {
            uri: this.jiraClient.buildURL('/issueLinkType/' + opts.issueLinkTypeId),
            method: 'DELETE',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback, 'IssueLink type deleted.');
    };

    /**
     * Update the specified issue link type.
     *
     * @method editIssueLinkType
     * @memberOf IssueLinkTypeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.issueLinkTypeId The id of the IssueLink type to retrieve.
     * @param opts.linkType See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2071}
     * @param [callback] Called when the IssueLink type has been updated.
     * @return {Promise} Resolved when the IssueLink type has been updated.
     */
    this.editIssueLinkType = function (opts, callback) {
        if (!opts.issueLinkTypeId) {
            throw new Error(errorStrings.NO_ISSUE_LINK_TYPE_ID);
        }

        var options = {
            uri: this.jiraClient.buildURL('/issueLinkType/' + opts.issueLinkTypeId),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: opts.issueLinkType
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/issueType.js":
/*!******************************************************!*\
  !*** ./node_modules/jira-connector/api/issueType.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = IssueTypeClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/issuetype'
 *
 * @param {JiraClient} jiraClient
 * @constructor IssueTypeClient
 */
function IssueTypeClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a list of all issue types visible to the user
     *
     * @method getAllIssueTypes
     * @memberOf IssueTypeClient#
     * @param opts Ignored
     * @param {Function} [callback] Called when the issue types have been retrieved.
     * @return {Promise} Resolved when the issue types have been retrieved.
     */
    this.getAllIssueTypes = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issuetype'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Creates an issue type from a JSON representation and adds the issue newly
     * created issue type to the default issue type scheme.
     *
     * @method createIssueType
     * @memberOf IssueTypeClient#
     * @param {Object} issueType Object containing details of the new issueType.
     *      Schema:
     *      * "name" - The name of the issue type
     *      * "description" - Some description about the issue type
     *      * "type" - Can have either "subtask" or "standard" as value
     * @param {Function} [callback] Called when the issue type has been created.
     * @return {Promise} Resolved when the issue type has been created.
     */
    this.createIssueType = function (issueType, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issuetype'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: issueType,
        };

        return this.jiraClient.makeRequest(options, callback);
    };
    
    /**
     * Get a full representation of the issue type that has the given id.
     *
     * @method getIssueType
     * @memberOf IssueTypeClient#
     * @param {Object} opts The options sent to the Jira API
     * @param {String} opts.issueTypeId A String containing an issue type id
     * @param {Function} [callback] Called when the issue type has been retrieved.
     * @return {Promise} Resolved when the issue type has been retrieved.
     */
    this.getIssueType = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issuetype/' + opts.issueTypeId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Deletes the specified issue type.
     * If the issue type has any associated issues, these issues will be
     * migrated to the alternative issue type specified in the parameter.
     * You can determine the alternative issue types by calling the /rest/api/2/issuetype/{id}/alternatives resource.
     *
     * @method deleteIssueType
     * @memberOf IssueTypeClient#
     * @param {Object} opts The options to send to the JIRA API
     * @param {String} opts.issueTypeId ID of the issueType to be deleted.
     * @param {String} opts.alternativeIssueTypeId the id of an issue type to which issues
     *          associated with the removed issue type will be migrated.
     * @param {Function} [callback] Called when the issue type has been deleted.
     * @return {Promise} Resolved when the issue type has been deleted.
     */
    this.deleteIssueType = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issuetype/' + opts.issueTypeId),
            method: 'DELETE',
            json: true,
            followAllRedirects: true,
            qs: {
                alternativeIssueTypeId: opts.alternativeIssueTypeId,
            },
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Updates the specified issue type from a JSON representation.
     *
     * @method updateIssueType
     * @memberOf IssueTypeClient#
     * @param {Object} opts The options sent to the Jira API
     * @param {String} opts.issueTypeId ID of the issue type to update.
     * @param {Object} opts.issueType Object containing details of the issueType to be updated.
     *      Schema:
     *      * "name" - The name of the issue type
     *      * "description" - Some description about the issue type
     *      * "avatarId" - Integer containing the avatar ID
     * @param {Function} [callback] Called when the issue type has been updated.
     * @return {Promise} Resolved when the issue type has been updated.
     */
    this.updateIssueType = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issuetype/' + opts.issueTypeId),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: opts.issueType,
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns a list of all alternative issue types for the given issue type id.
     * The list will contain these issues types, to which issues assigned to the given
     * issue type can be migrated. The suitable alternatives are issue types which are
     * assigned to the same workflow, the same field configuration and the same screen scheme.
     *
     * @method getAlternativeIssueTypes
     * @memberOf IssueTypeClient#
     * @param {Object} opts The options sent to the Jira API
     * @param {String} opts.issueTypeId A String containing an issue type id
     * @param {Function} [callback] Called when the issue type has been retrieved.
     * @return {Promise} Resolved when the issue type has been retrieved.
     */
    this.getAlternativeIssueTypes = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/issuetype/' + opts.issueTypeId + '/alternatives'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/jql.js":
/*!************************************************!*\
  !*** ./node_modules/jira-connector/api/jql.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = JqlClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/jql/autocompletedata'
 *
 * @param {JiraClient} jiraClient
 * @constructor JqlClient
 */
function JqlClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns the auto complete data required for JQL searches.
     *
     * @method getAutoCompleteData
     * @memberOf JqlClient#
     * @param opts The options sent to the Jira API.  Ignored by this function.
     * @param [callback] Called when the autocomplete data is returned.
     * @return {Promise} Resolved when the autocomplete data is returned.
     */
    this.getAutoCompleteData = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/jql/autocompletedata'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback)
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/licenseRole.js":
/*!********************************************************!*\
  !*** ./node_modules/jira-connector/api/licenseRole.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = LicenseRoleClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/licenserole'
 * @param {JiraClient} jiraClient
 * @constructor LicenseRoleClient
 */
function LicenseRoleClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns all license roles in the system.
     *
     * @method getAllLicenseRoles
     * @memberOf LicenseRoleClient#
     * @param opts Ignored
     * @param [callback] Called when the license roles have been retrieved.
     * @return {Promise} Resolved when the license roles have been retrieved.
     */
    this.getAllLicenseRoles = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/licenserole'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Gets the passed license role if it exists.
     *
     * @method getLicenseRole
     * @memberOf LicenseRoleClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.roleId The id of the license role to retrieve.
     * @param [callback] Called when the license role is retrieved.
     * @return {Promise} Resolved when the license role is retrieved.
     */
    this.getLicenseRole = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/licenserole/' + opts.roleId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Updates the license role with the passed data. Only the groups of the role may be updated. Requests to change
     * the id or the name of the role will be silently ignored.
     *
     * @method editLicenseRole
     * @memberOf LicenseRoleClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.roleId The id of the license role to retrieve.
     * @param opts.role The new data to place in the role.  See
     *  {@link https://docs.atlassian.com/jira/REST/latest/#d2e365}
     * @param [callback] Called when the license role is edited.
     * @return {Promise} Resolved when the license role is edited.
     */
    this.editLicenseRole = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/licenserole/' + opts.roleId),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: opts.role
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/licenseValidator.js":
/*!*************************************************************!*\
  !*** ./node_modules/jira-connector/api/licenseValidator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = LicenseValidatorClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/licenseValidator'
 *
 * @param {JiraClient} jiraClient
 * @constructor LicenseValidatorClient
 */
function LicenseValidatorClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     *
     * @method validateLicense
     * @memberOf LicenseValidatorClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.license The license to validate.
     * @param [callback] Called when the license has been validated, or fails to validate.
     * @return {Promise} Resolved when the license has been validated, or fails to validate.
     */
    this.validateLicense = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/licenseValidator'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts.license
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/myPermissions.js":
/*!**********************************************************!*\
  !*** ./node_modules/jira-connector/api/myPermissions.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = MyPermissionsClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/mypermissions'
 *
 * @param {JiraClient} jiraClient
 * @constructor MyPermissionsClient
 */
function MyPermissionsClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns all permissions in the system and whether the currently logged in user has them. You can optionally
     * provide a specific context to get permissions for (projectKey OR projectId OR issueKey OR issueId)
     *
     * * When no context supplied the project related permissions will return true if the user has that permission in
     * ANY project
     * * If a project context is provided, project related permissions will return true if the user has the permissions
     * in the specified project. For permissions that are determined using issue data (e.g Current Assignee), true will
     * be returned if the user meets the permission criteria in ANY issue in that project
     * * If an issue context is provided, it will return whether or not the user has each permission in that specific
     * issue
     *
     * NB: The above means that for issue-level permissions (EDIT_ISSUE for example), hasPermission may be true when no
     * context is provided, or when a project context is provided, but may be false for any given (or all) issues. This
     * would occur (for example) if Reporters were given the EDIT_ISSUE permission. This is because any user could be a
     * reporter, except in the context of a concrete issue, where the reporter is known.
     *
     * Global permissions will still be returned for all scopes.
     *
     * @method getMyPermissions
     * @memberOf MyPermissionsClient#
     * @param opts The request options sent to the Jira API
     * @param [callback] Called when the permissions have been returned.
     * @return {Promise} Resolved when the permissions have been returned.
     */
    this.getMyPermissions = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/mypermissions'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                issueId: opts.issueId,
                issueKey: opts.issueKey,
                projectId: opts.projectId,
                projectKey: opts.projectKey,
            },
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}


/***/ }),

/***/ "./node_modules/jira-connector/api/myPreferences.js":
/*!**********************************************************!*\
  !*** ./node_modules/jira-connector/api/myPreferences.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = MyPreferencesClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/mypreferences'
 *
 * @param {JiraClient} jiraClient
 * @constructor MyPreferencesClient
 */
function MyPreferencesClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Gets preference of the currently logged in user. Preference key must be provided as input parameter (key).
     * The value is returned exactly as it is.
     *
     * @method getPreference
     * @memberOf MyPreferencesClient#
     * @param opts The request options send to the Jira API.
     * @param opts.key Key of the preference to be returned.
     * @param [callback] Called when the preference has been retrieved.
     * @return {Promise} Resolved when the preference has been retrieved.
     */
    this.getPreference = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/mypreferences'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                key: opts.key
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Sets preference of the currently logged in user. Preference key must be provided as input parameters (key).
     *
     * @method editPreference
     * @memberOf MyPreferencesClient#
     * @param opts The request options send to the Jira API.
     * @param opts.key Key of the preference to be edited.
     * @param opts.value The new value to set for the preference.
     * @param [callback] Called when the preference has been edited.
     * @return {Promise} Resolved when the preference has been edited.
     */
    this.editPreference = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/mypreferences'),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            qs: {
                key: opts.key
            },
            body: opts.value
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Removes preference of the currently logged in user. Preference key must be provided as input parameters (key).
     *
     * @method deletePreference
     * @memberOf MyPreferencesClient#
     * @param opts The request options send to the Jira API.
     * @param opts.key Key of the preference to be deleted.
     * @param [callback] Called when the preference has been deleted.
     * @return {Promise} Resolved when the preference has been deleted.
     */
    this.deletePreference = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/mypreferences'),
            method: 'DELETE',
            json: true,
            followAllRedirects: true,
            qs: {
                key: opts.key
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/myself.js":
/*!***************************************************!*\
  !*** ./node_modules/jira-connector/api/myself.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = MyselfClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/myself'
 *
 * @param {JiraClient} jiraClient
 * @constructor MyselfClient
 */
function MyselfClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns currently logged user. This resource cannot be accessed anonymously.
     *
     * @method getMyself
     * @memberOf MyselfClient#
     * @param opts Ignored
     * @param [callback] Called when the current user is retrieved.
     * @return {Promise} Resolved when the current user is retrieved.
     */
    this.getMyself = function (debug, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/myself'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            debug: debug,
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Modify currently logged user. The "value" fields present will override the existing value. Fields skipped in
     * request will not be changed. Only email and display name can be change that way.
     *
     * @method editMyself
     * @memberOf MyselfClient#
     * @param opts The request options send to the Jira API.
     * @param opts.newData The new data.  See {@link https://docs.atlassian.com/jira/REST/latest/#d2e1242}
     * @param [callback] Called when the user's data has been modified
     * @return {Promise} Resolved when the user's data has been modified
     */
    this.editMyself = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/myself'),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: opts.newData
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Modify caller password.
     *
     * @method changePassword
     * @memberOf MyselfClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.newData The new data
     * @param [callback] Called when the password has been changed.
     * @return {Promise} Resolved when the password has been changed.
     */
    this.changePassword = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/myself/password'),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: opts.newData
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}


/***/ }),

/***/ "./node_modules/jira-connector/api/password.js":
/*!*****************************************************!*\
  !*** ./node_modules/jira-connector/api/password.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = PasswordClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/password'
 *
 * @param {JiraClient} jiraClient
 * @constructor PasswordClient
 */
function PasswordClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns user-friendly statements governing the system's password policy.
     *
     * @method getPasswordPolicy
     * @memberOf PasswordClient#
     * @param opts The request options to send to the Jira API
     * @param {boolean} [opts.hasOldPassword=false] Whether or not the user will be required to enter their current
     *     password. Use false (the default) if this is a new user or if an administrator is forcibly changing another
     *     user's password.
     * @param [callback] Called when the password policy has been retrieved.
     * @return {Promise} Resolved when the password policy has been retrieved.
     */
    this.getPasswordPolicy = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/password/policy'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                hasOldPassword: opts.hasOldPassword
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/permission-scheme.js":
/*!**************************************************************!*\
  !*** ./node_modules/jira-connector/api/permission-scheme.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = PermissionSchemeClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/permissionscheme'
 *
 * @param {JiraClient} jiraClient
 * @constructor PermissionSchemeClient
 */
function PermissionSchemeClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a list of all permission schemes.
     *
     * By default only shortened beans are returned.
     * If you want to include permissions of all the schemes, then specify the permissions expand parameter.
     * Permissions will be included also if you specify any other expand parameter.
     *
     * @method getAllPermissionSchemes
     * @memberOf PermissionSchemeClient#
     * @param {Object} opts The request options sent to the Jira API.
     * @param {String|Array} opts.expand
     * @param [callback] Called when the schemes have been returned.
     * @return {Promise} Resolved when the schemes have been returned.
     */
    this.getAllPermissionSchemes = function (opts, callback) {
        var expand = opts.expand
        if (opts.expand && opts.expand instanceof Array) {
            expand = opts.expand.join(',');
        }
        var options = {
            uri: this.jiraClient.buildURL('/permissionscheme'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                expand: expand
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    }

    /**
     * Create a new permission scheme. This method can create schemes with a defined permission set, or without.
     *
     * @method createPermissionScheme
     * @memberOf PermissionSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.scheme See {@link https://developer.atlassian.com/cloud/jira/platform/rest/#api-api-2-permissionscheme-post}
     * @param [callback] Called when the scheme has been created.
     * @return {Promise} Resolved when the scheme has been created.
     */
    this.createPermissionScheme = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/permissionscheme'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts.scheme
        };

        return this.jiraClient.makeRequest(options, callback);
    }

    /**
     * Get a PermissionScheme. This resource cannot be accessed anonymously.
     *
     * @method getPermissionScheme
     * @memberOf PermissionSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.schemeId The id of the scheme to retrieve.
     * @param {Object} opts.expand The fields to be expanded.
     * @param [callback] Called when the scheme has been retrieved.
     * @return {Promise} Resolved when the scheme has been retrieved.
     */
    this.getPermissionScheme = function (opts, callback) {
        var expand = opts.expand
        if (opts.expand && opts.expand instanceof Array) {
            expand = opts.expand.join(',');
        }
        var options = {
            uri: this.jiraClient.buildURL('/permissionscheme/' + opts.schemeId),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                expand: expand
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Updates a permission scheme.
     * 
     * If the permissions list is present then it will be set in the permission scheme,
     * which basically means it will overwrite any permission grants that existed in the permission scheme.
     * Sending an empty list will remove all permission grants from the permission scheme.
     * 
     * To update just the name and description, do not send permissions list at all.
     * To add or remove a single permission grant instead of updating the whole list
     * at once use the {schemeId}/permission/ resource.
     *
     * @method editPermissionScheme
     * @memberOf PermissionSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.schemeId The id of the scheme to retrieve.
     * @param opts.scheme The body of the scheme to edit.
     * @param [callback] Called when the user has been edited.
     * @return {Promise} Resolved when the user has been edited.
     */
    this.editPermissionScheme = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/permissionscheme/' + opts.schemeId),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: opts.scheme
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Removes Permission Scheme.
     *
     * @method deletePermissionScheme
     * @memberOf PermissionSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.schemeId The name of the scheme to delete.
     * @param [callback] Called when the scheme has been deleted.
     * @return {Promise} Resolved when the scheme has been deleted.
     */
    this.deletePermissionScheme = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/permissionscheme/' + opts.schemeId),
            method: 'DELETE',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback, 'Permission Scheme removed.');
    };

    /**
     * Returns all permission grants of the given permission scheme.
     *
     * @method getPermissionSchemeGrants
     * @memberOf PermissionSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.schemeId The id of the scheme to which the permission grant belongs.
     * @param {Object} opts.expand The fields to be expanded.
     * @param [callback] Called when the scheme grants have been retrieved.
     * @return {Promise} Resolved when the scheme grants have been retrieved.
     */
    this.getPermissionSchemeGrants = function (opts, callback) {
        var expand = opts.expand
        if (opts.expand && opts.expand instanceof Array) {
            expand = opts.expand.join(',');
        }
        var options = {
            uri: this.jiraClient.buildURL('/permissionscheme/' + opts.schemeId + '/permission'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                expand: expand
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Creates a permission grant in a permission scheme.
     *
     * @method createPermissionGrantInScheme
     * @memberOf PermissionSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.schemeId The id of the scheme to which the permission grant belongs.
     * @param opts.grant See {@link https://docs.atlassian.com/software/jira/docs/api/REST/7.6.1/#api/2/permissionscheme-createPermissionGrant}
     * @param [callback] Called when the permission grant has been created.
     * @return {Promise} Resolved when the permission grant has been created.
     */
    this.createPermissionGrantInScheme = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/permissionscheme/' + opts.schemeId + '/permission'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts.grant
        };

        return this.jiraClient.makeRequest(options, callback);
    }

    /**
     * Deletes a permission grant from a permission scheme.
     *
     * @method deletePermissionGrantFromScheme
     * @memberOf PermissionSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.schemeId The name of the scheme to delete.
     * @param opts.permissionId The id of the permission to delete.
     * @param [callback] Called when the scheme has been deleted.
     * @return {Promise} Resolved when the scheme has been deleted.
     */
    this.deletePermissionGrantFromScheme = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/permissionscheme/' + opts.schemeId + '/permission/' + opts.permissionId),
            method: 'DELETE',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback, 'Permission removed from scheme.');
    };

    /**
     * Returns a permission grant identified by the given id.
     *
     * @method getPermissionSchemeGrantById
     * @memberOf PermissionSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.schemeId The id of the scheme to which the permission grant belongs.
     * @param opts.permissionId The id of the permission to fetch.
     * @param {Object} opts.expand The fields to be expanded.
     * @param [callback] Called when the scheme grants have been retrieved.
     * @return {Promise} Resolved when the scheme grants have been retrieved.
     */
    this.getPermissionSchemeGrantById = function (opts, callback) {
        var expand = opts.expand
        if (opts.expand && opts.expand instanceof Array) {
            expand = opts.expand.join(',');
        }
        var options = {
            uri: this.jiraClient.buildURL('/permissionscheme/' + opts.schemeId + '/permission/' + opts.permissionId),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                expand: expand
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/permissions.js":
/*!********************************************************!*\
  !*** ./node_modules/jira-connector/api/permissions.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = PermissionsClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/permissions'
 *
 * @param {JiraClient} jiraClient
 * @constructor PermissionsClient
 */
function PermissionsClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns all permissions that are present in the JIRA instance
     * - Global, Project and the global ones added by plugins
     *
     * @method getAllPermissions
     * @memberOf PermissionsClient#
     * @param opts The request options sent to the Jira API.
     * @param [callback] Called when the permissions have been returned.
     * @return {Promise} Resolved when the permissions have been returned.
     */
    this.getAllPermissions = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/permissions'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/priority.js":
/*!*****************************************************!*\
  !*** ./node_modules/jira-connector/api/priority.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = PriorityClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/priority'
 *
 * @param {JiraClient} jiraClient
 * @constructor PriorityClient
 */
function PriorityClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a list of all priorities visible to the user
     *
     * @method getAllPriorities
     * @memberOf PriorityClient#
     * @param opts Ignored
     * @param [callback] Called when the priorities have been retrieved.
     * @return {Promise} Resolved when the priorities have been retrieved.
     */
    this.getAllPriorities = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/priority'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get a full representation of the priority that has the given id.
     *
     * @method getPriority
     * @memberOf PriorityClient#
     * @param opts The options sent to the Jira API
     * @param opts.priorityId A String containing a priority id
     * @param [callback] Called when the priority has been retrieved.
     * @return {Promise} Resolved when the priority has been retrieved.
     */
    this.getPriority = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/priority/' + opts.priorityId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/project.js":
/*!****************************************************!*\
  !*** ./node_modules/jira-connector/api/project.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ProjectClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/project'
 * @param {JiraClient} jiraClient
 * @constructor ProjectClient
 */
function ProjectClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns all projects which are visible for the currently logged in user. If no user is logged in, it returns the
     * list of projects that are visible when using anonymous access.
     *
     * @method getAllProjects
     * @memberOf ProjectClient#
     * @param opts The request options sent to the Jira API.
     * @param [callback] Called when the projects have been retrieved.
     * @return {Promise} Resolved when the projects have been retrieved.
     */
    this.getAllProjects = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'GET');

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Deletes a project
     *
     * @method deleteProject
     * @memberOf ProjectClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.projectIdOrKey The project id or project key
     * @param [callback] Called when the project has been deleted.
     * @return {Promise} Resolved when the project has been deleted.
     */
    this.deleteProject = function(opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Project Deleted');
    };

    /**
     * Creates a project.
     *
     * @method createProject
     * @memberOf ProjectClient#
     * @param project The project properties. See {@link https://docs.atlassian.com/jira/REST/latest/#api/2/project}
     * @param [callback] Called when the project has been created.
     * @return {Promise} Resolved when the project has been created.
     */
    this.createProject = function (project, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/project'),
            method: 'POST',
            followAllRedirects: true,
            json: true,
            body: project
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Gets project propertes.
     *
     * @method getProjectProperties
     * @memberOf ProjectClient#
     * @param opts Options
     * @param opts.projectIdOrKey The project id or project key
     * @param [callback] Called when properties has been retrieved.
     * @return {Promise} Resolved when properties has been retrieved.
     */
    this.getProjectProperties = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/properties', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };




    /**
     * Contains a full representation of a project in JSON format.
     *
     * All project keys associated with the project will only be returned if expand=projectKeys.
     *
     * @method getProject
     * @memberOf ProjectClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.projectIdOrKey The project id or project key
     * @param [callback] Called when the project is retrieved.
     * @return {Promise} Resolved when the project is retrieved.
     */
    this.getProject = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Contains a full representation of a the specified project's components.
     *
     * @method getComponents
     * @memberOf ProjectClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.projectIdOrKey The project id or project key
     * @param [callback] Called when the components are retrieved.
     * @return {Promise} Resolved when the components are retrieved.
     */
    this.getComponents = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/components', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get all issue types with valid status values for a project
     *
     * @method getStatuses
     * @memberOf ProjectClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.projectIdOrKey The project id or project key
     * @param [callback] Called when the statuses have been retrieved.
     * @return {Promise} Resolved when the statuses have been retrieved.
     */
    this.getStatuses = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/statuses', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Contains a full representation of a the specified project's versions.
     *
     * @method getVersions
     * @memberOf ProjectClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.projectIdOrKey The project id or project key
     * @param [callback] Called when the versions have been retrieved.
     * @return {Promise} Resolved when the versions have been retrieved.
     */
    this.getVersions = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/versions', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Contains a list of roles in this project with links to full details.
     *
     * @method getRoles
     * @memberOf ProjectClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.projectIdOrKey The project id or project key
     * @param [callback] Called when the roles have been retrieved.
     * @return {Promise} Resolved when the roles have been retrieved.
     */
    this.getRoles = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/role', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Details on a given project role.
     *
     * @method getRole
     * @memberOf ProjectClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.projectIdOrKey The project id or project key
     * @param opts.roleId The id of the role to retrieve.
     * @param [callback] Called when the roles have been retrieved.
     * @return {Promise} Resolved when the roles have been retrieved.
     */
    this.getRole = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/role/' + opts.roleId, 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Updates a project role to contain the sent actors.
     *
     * @method updateRole
     * @memberOf ProjectClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.projectIdOrKey The project id or project key
     * @param opts.roleId The id of the role to retrieve.
     * @param opts.newRole See {@link https://docs.atlassian.com/jira/REST/latest/#d2e108}
     * @param [callback] Called when the roles have been retrieved.
     * @return {Promise} Resolved when the roles have been retrieved.
     */
    this.updateRole = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/role/' + opts.roleId, 'PUT', opts.newRole);
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Add an actor to a project role.
     *
     * @method addToRole
     * @memberOf ProjectClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.projectIdOrKey The project id or project key
     * @param opts.roleId The id of the role to retrieve.
     * @param opts.newRole See {@link https://docs.atlassian.com/jira/REST/latest/#d2e134}
     * @param [callback] Called when the roles have been retrieved.
     * @return {Promise} Resolved when the roles have been retrieved.
     */
    this.addToRole = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/role/' + opts.roleId, 'POST', opts.newRole);
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Build out the request options necessary to make a particular API call.
     *
     * @private
     * @method buildRequestOptions
     * @memberOf ProjectClient#
     * @param {Object} opts The arguments passed to the method.
     * @param {number} opts.projectIdOrKey The id of the project to use in the path.
     * @param {Array} [opts.fields] The fields to include
     * @param {Array} [opts.expand] The fields to expand
     * @param {string} path The path of the endpoint following /project/{id}
     * @param {string} method The request method.
     * @param {Object} [body] The request body, if any.
     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.
     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}
     */
    this.buildRequestOptions = function (opts, path, method, body, qs) {
        opts = opts || {};

        var basePath = opts.projectIdOrKey ? '/project/' + opts.projectIdOrKey : '/project';

        if (!qs) qs = {};
        if (!body) body = {};

        if (opts.fields) {
            qs.fields = '';
            opts.fields.forEach(function (field) {
                qs.fields += field + ','
            });
            qs.fields = qs.fields.slice(0, -1);
        }

        if (opts.expand) {
            qs.expand = '';
            opts.expand.forEach(function (ex) {
                qs.expand += ex + ','
            });
            qs.expand = qs.expand.slice(0, -1);
        }

        return {
            uri: this.jiraClient.buildURL(basePath + path),
            method: method,
            body: body,
            qs: qs,
            followAllRedirects: true,
            json: true
        };
    };
}


/***/ }),

/***/ "./node_modules/jira-connector/api/projectCategory.js":
/*!************************************************************!*\
  !*** ./node_modules/jira-connector/api/projectCategory.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ProjectCategoryClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/projectCategory'
 *
 * @param {JiraClient} jiraClient
 * @constructor ProjectCategoryClient
 */
function ProjectCategoryClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a list of all projectCategories visible to the user
     *
     * @method getAllProjectCategories
     * @memberOf ProjectCategoryClient#
     * @param opts Ignored
     * @param [callback] Called when the statusCategories have been retrieved.
     * @return {Promise} Resolved when the statusCategories have been retrieved.
     */
    this.getAllProjectCategories = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/projectCategory'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get a full representation of the projectCategory that has the given id.
     *
     * @method getProjectCategory
     * @memberOf ProjectCategoryClient#
     * @param opts The options sent to the Jira API
     * @param opts.projectCategoryId A String containing a projectCategory id
     * @param [callback] Called when the projectCategory has been retrieved.
     * @return {Promise} Resolved when the projectCategory has been retrieved.
     */
    this.getProjectCategory = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/projectCategory/' + opts.projectCategoryId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}


/***/ }),

/***/ "./node_modules/jira-connector/api/projectValidate.js":
/*!************************************************************!*\
  !*** ./node_modules/jira-connector/api/projectValidate.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ProjectValidateClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/projectvalidate'
 *
 * @param {JiraClient} jiraClient
 * @constructor ProjectValidateClient
 */
function ProjectValidateClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Validates a project key.  This endpoint is a little wonky, as it returns a list of errors as a valid response;
     * even if the key is invalid, it still returns a 200 response.
     * See {@link https://docs.atlassian.com/jira/REST/latest/#d2e297}
     *
     * @method validateProjectKey
     * @memberOf ProjectValidateClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.projectKey The key of the project.
     * @param [callback] Called when the key has been validated.
     * @return {Promise} Resolved when the key has been validated.
     */
    this.validateProjectKey = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/projectvalidate/key'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                key: opts.projectKey
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/reindex.js":
/*!****************************************************!*\
  !*** ./node_modules/jira-connector/api/reindex.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ReindexClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/reindex'
 *
 * @param {JiraClient} jiraClient
 * @constructor ReindexClient
 */
function ReindexClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Kicks off a reindex. Need Admin permissions to perform this reindex.
     *
     * @method doReindex
     * @memberOf ReindexClient#
     * @param opts The request options sent to the Jira API.
     * @param {string} [opts.type] Case insensitive String indicating type of reindex. If omitted, then defaults to
     *     BACKGROUND_PREFERRED
     * @param {boolean} [opts.indexComments=false] Indicates that comments should also be reindexed. Not relevant for
     *     foreground reindex, where comments are always reindexed.
     * @param {boolean} [opts.indexChangeHistory=false] Indicates that changeHistory should also be reindexed. Not
     *     relevant for foreground reindex, where changeHistory is always reindexed.
     * @param [callback] Called when the reindex has been started.
     * @return {Promise} Resolved when the reindex has been started.
     */
    this.doReindex = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/reindex'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            qs: {
                type: opts.type,
                indexComments: opts.indexComments,
                indexChangeHistory: opts.indexChangeHistory
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Gets information on the system reindexes. If a reindex is currently taking place then information about this
     * reindex is returned. If there is no active index task, then returns information about the latest reindex task
     * run, otherwise returns a 404 indicating that no reindex has taken place.
     *
     * @method getReindex
     * @memberOf ReindexClient#
     * @param opts The request options sent to the Jira API.
     * @param [opts.taskId] The id of an indexing task you wish to obtain details on. If omitted, then defaults to the
     *     standard behaviour and returns information on the active reindex task, or the last task to run if no reindex
     *     is taking place. . If there is no reindexing task with that id then a 404 is returned.
     * @param [callback] Called when the reindex data has been retrieved.
     * @return {Promise} Resolved when the reindex data has been retrieved.
     */
    this.getReindex = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/reindex'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                taskId: opts.taskId
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/resolution.js":
/*!*******************************************************!*\
  !*** ./node_modules/jira-connector/api/resolution.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ResolutionClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/resolution'
 *
 * @param {JiraClient} jiraClient
 * @constructor ResolutionClient
 */
function ResolutionClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a list of all resolutions visible to the user
     *
     * @method getAllResolutions
     * @memberOf ResolutionClient#
     * @param opts Ignored
     * @param [callback] Called when the resolutions have been retrieved.
     * @return {Promise} Resolved when the resolutions have been retrieved.
     */
    this.getAllResolutions = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/resolution'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get a full representation of the resolution that has the given id.
     *
     * @method getResolution
     * @memberOf ResolutionClient#
     * @param opts The options sent to the Jira API
     * @param opts.resolutionId A String containing a resolution id
     * @param [callback] Called when the resolution has been retrieved.
     * @return {Promise} Resolved when the resolution has been retrieved.
     */
    this.getResolution = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/resolution/' + opts.resolutionId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/roles.js":
/*!**************************************************!*\
  !*** ./node_modules/jira-connector/api/roles.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = RoleClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/role'
 *
 * @param {JiraClient} jiraClient
 * @constructor RoleClient
 */
function RoleClient(jiraClient) {
  this.jiraClient = jiraClient;

  /**
   * Get all the ProjectRoles available in Jira. Currently this list is global.
   *
   * @method getAll
   * @memberOf RoleClient#
   * @param opts The request options sent to the Jira API.
   * @param [callback] Called when the permissions have been returned.
   * @return {Promise} Resolved when the permissions have been returned.
   */
  this.getAll = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildURL('/role'),
      method: 'GET',
      json: true,
      followAllRedirects: true
    };

    return this.jiraClient.makeRequest(options, callback);
  }

  /**
   * Creates a new ProjectRole to be available in Jira.
   * The created role does not have any default actors assigned.
   *
   * @method createRole
   * @memberOf RoleClient#
   * @param opts The request options sent to the Jira API.
   * @param opts.role See {@link https://developer.atlassian.com/cloud/jira/platform/rest/#api-api-2-role-post}
   * @param [callback] Called when the scheme has been created.
   * @return {Promise} Resolved when the scheme has been created.
   */
  this.createRole = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildURL('/role'),
      method: 'POST',
      json: true,
      followAllRedirects: true,
      body: opts.role
    };

    return this.jiraClient.makeRequest(options, callback);
  }

  /**
   * Get a specific ProjectRole available in Jira.
   *
   * @method getRoleById
   * @memberOf RoleClient#
   * @param opts The request options sent to the Jira API.
   * @param [callback] Called when the permissions have been returned.
   * @return {Promise} Resolved when the permissions have been returned.
   */
  this.getRoleById = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildURL('/role/' + opts.roleId),
      method: 'GET',
      json: true,
      followAllRedirects: true,
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Fully updates a roles. Both name and description must be given.
   *
   * @method updateRole
   * @memberOf RoleClient#
   * @param opts The request options sent to the Jira API.
   * @param opts.roldId Identifier for teh role.
   * @param opts.role Object containing the name and description to be updated.
   * @param [callback] Called when the permissions have been returned.
   * @return {Promise} Resolved when the permissions have been returned.
   */
  this.updateRole = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildURL('/role/' + opts.roleId),
      method: 'PUT',
      json: true,
      followAllRedirects: true,
      body: opts.role,
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
  * Deletes a role. May return 403 in the future
  *
  * @method deleteRole
  * @memberOf RoleClient#
  * @param {Object} opts The request options sent to the Jira API.
  * @param {String} opts.roldId Identifier for the role.
  * @param {String} opts.swap if given, removes a role even if it is used in scheme by replacing the role with the given one
  * @param [callback] Called when the permissions have been returned.
  * @return {Promise} Resolved when the permissions have been returned.
  */
  this.deleteRole = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildURL('/role/' + opts.roleId),
      method: 'DELETE',
      json: true,
      followAllRedirects: true,
      qs: {
        swap: opts.swap
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
  * Gets default actors for the given role.
  *
  * @method getActors
  * @memberOf RoleClient#
  * @param {Object} opts The request options sent to the Jira API.
  * @param {String} opts.roldId Identifier for the role.
  * @param [callback] Called when the permissions have been returned.
  * @return {Promise} Resolved when the permissions have been returned.
  */
  this.getActors = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildURL('/role/' + opts.roleId + '/actors'),
      method: 'GET',
      json: true,
      followAllRedirects: true,
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
  * Adds default actors to the given role.
  * The request data should contain a list of usernames or a list of groups to add.
  *
  * @method addActors
  * @memberOf RoleClient#
  * @param {Object} opts The request options sent to the Jira API.
  * @param {String} opts.roldId Identifier for the role.
  * @param {Array} opts.group Array of group ids.
  * @param {Array} opts.user Array of user ids.
  * @param [callback] Called when the permissions have been returned.
  * @return {Promise} Resolved when the permissions have been returned.
  */
  this.addActors = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildURL('/role/' + opts.roleId + '/actors'),
      method: 'POST',
      json: true,
      followAllRedirects: true,
      body: {
        user: opts.user,
        group: opts.group,
      },
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
  * Removes default actor from the given role.
  *
  * @method removeActor
  * @memberOf RoleClient#
  * @param {Object} opts The request options sent to the Jira API.
  * @param {String} opts.roldId Identifier for the role.
  * @param {String} opts.group group id.
  * @param {String} opts.user user id.
  * @param [callback] Called when the permissions have been returned.
  * @return {Promise} Resolved when the permissions have been returned.
  */
  this.removeActor = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildURL('/role/' + opts.roleId + '/actors'),
      method: 'DELETE',
      json: true,
      followAllRedirects: true,
      qs: {
        user: opts.user,
        group: opts.group,
      },
    };

    return this.jiraClient.makeRequest(options, callback);
  };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/screens.js":
/*!****************************************************!*\
  !*** ./node_modules/jira-connector/api/screens.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ScreensClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/screens'
 *
 * @param {JiraClient} jiraClient
 * @constructor ScreensClient
 */
function ScreensClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Gets available fields for screen. i.e ones that haven't already been added.
     *
     * @method getAvailableFields
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to Jira
     * @param {number} opts.screenId The id of the screen to retrieve.
     * @param [callback] Called when the available fields have been retrieved
     * @return {Promise} Resolved when the available fields have been retrieved
     */
    this.getAvailableFields = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/availableFields', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns a list of all tabs for the given screen.
     *
     * @method getTabs
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to Jira
     * @param {number} opts.screenId The id of the screen to retrieve.
     * @param [callback] Called when the tabs have been retrieved.
     * @return {Promise} Resolved when the tabs have been retrieved.
     */
    this.getTabs = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/tabs', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Creates tab for given screen
     *
     * @method createTab
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to Jira
     * @param {number} opts.screenId The id of the screen in which to create a tab.
     * @param {string} opts.name The name of the tab to add.  Minimum required to create a tab.
     * @param [callback] Called when the tab has been created.
     * @return {Promise} Resolved when the tab has been created.
     */
    this.createTab = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/tabs', 'POST', {name: opts.name});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Renames the given tab on the given screen.
     *
     * @method renameTab
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to the jira API
     * @param {number} opts.screenId The id of the screen containing the tab to rename.
     * @param {number} opts.tabId The id of the tab to rename
     * @param {string} opts.name The new name of the tab.
     * @param [callback] Called when data has been retrieved
     * @return {Promise} Resolved when data has been retrieved
     */
    this.renameTab = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId, 'PUT', {name: opts.name});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Deletes the given tab from the given screen.
     *
     * @method deleteTab
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to the jira API
     * @param {number} opts.screenId The id of the screen containing the tab to delete.
     * @param {number} opts.tabId The id of the tab to delete
     * @param [callback] Called when data has been retrieved
     * @return {Promise} Resolved when data has been retrieved
     */
    this.deleteTab = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId, 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Tab Deleted');
    };

    /**
     * Adds field to the given tab
     *
     * @method addFieldToTab
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.screenId The id of the screen containing the tab.
     * @param {number} opts.tabId the id of the tab to which the fields will be added.
     * @param {string} opts.fieldId The field to add
     * @param [callback] Called when the fields have been added to the tab.
     * @return {Promise} Resolved when the fields have been added to the tab.
     */
    this.addFieldToTab = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId + '/fields', 'POST', opts.fieldId);
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Gets all fields for a given tab.
     *
     * @method getFieldsInTab
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.screenId The id of the screen containing the tab.
     * @param {number} opts.tabId the id of the tab for which to retrieve fields.
     * @param [callback] Called when the fields have been retrieved.
     * @return {Promise} Resolved when the fields have been retrieved.
     */
    this.getFieldsInTab = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId + '/fields', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Remove the given field from the given tab.
     *
     * @method removeFieldFromTab
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.screenId The id of the screen containing the tab.
     * @param {number} opts.tabId the id of the tab from which to remove the field.
     * @param {string} opts.fieldId The id of the field to remove from the tab.
     * @param [callback] Called when the field has been removed.
     * @return {Promise} Resolved when the field has been removed.
     */
    this.removeFieldFromTab = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId + '/fields/' + opts.fieldId, 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Field Removed From Tab');
    };

    /**
     * Move the given field on the given tab
     *
     * @method moveFieldOnTab
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.screenId The id of the screen containing the tab.
     * @param {number} opts.tabId the id of the tab containing the field.
     * @param {string} opts.fieldId The id of the field to remove from the tab.
     * @param {number} opts.newPosition The position to which the field should be moved.  May be one of:
     *  * Earlier
     *  * Later
     *  * First
     *  * Last
     * @param [callback] Called when the field has been removed.
     * @return {Promise} Resolved when the field has been removed.
     */
    this.moveFieldOnTab = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId + '/fields/' + opts.fieldId + '/move',
            'POST', {position: opts.newPosition});
        return this.jiraClient.makeRequest(options, callback, 'Field Moved');
    };

    /**
     * Moves tab position
     *
     * @method moveTabPosition
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to the Jira API.
     * @param {number} opts.screenId The id of the screen containing the tab.
     * @param {number} opts.tabId the id of the tab to move.
     * @param {number} opts.newPosition The new (zero-indexed) position of the tab.
     * @param [callback] Called when the tab has been moved.
     * @return {Promise} Resolved when the tab has been moved.
     */
    this.moveTabPosition = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId + '/move/' + opts.newPosition, 'POST');
        return this.jiraClient.makeRequest(options, callback, 'Tab Moved');
    };

    /**
     * Adds field or custom field to the default tab
     *
     * @method addFieldToDefaultTab
     * @memberOf ScreensClient#
     * @param {Object} opts The request options sent to the Jira API.
     * @param {string} opts.fieldId The id of the field to add to the default tab.
     * @param [callback] Called when the tab has been moved.
     * @return {Promise} Resolved when the tab has been moved.
     */
    this.addFieldToDefaultTab = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/screens/addToDefault/' + opts.fieldId),
            method: 'POST',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Build out the request options necessary to make a particular API call.
     *
     * @private
     * @method buildRequestOptions
     * @memberOf FilterClient#
     * @param {Object} opts The arguments passed to the method.
     * @param {number} opts.screenId The id of the screen to use in the path.
     * @param {Array} [opts.fields] The fields to include
     * @param {Array} [opts.expand] The fields to expand
     * @param {string} path The path of the endpoint following /screen/{id}
     * @param {string} method The request method.
     * @param {Object} [body] The request body, if any.
     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.
     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}
     */
    this.buildRequestOptions = function (opts, path, method, body, qs) {
        var basePath = '/screens/' + opts.screenId;
        if (!qs) qs = {};
        if (!body) body = {};

        if (opts.fields) {
            qs.fields = '';
            opts.fields.forEach(function (field) {
                qs.fields += field + ','
            });
            qs.fields = qs.fields.slice(0, -1);
        }

        if (opts.expand) {
            qs.expand = '';
            opts.expand.forEach(function (ex) {
                qs.expand += ex + ','
            });
            qs.expand = qs.expand.slice(0, -1);
        }

        return {
            uri: this.jiraClient.buildURL(basePath + path),
            method: method,
            body: body,
            qs: qs,
            followAllRedirects: true,
            json: true
        };
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/search.js":
/*!***************************************************!*\
  !*** ./node_modules/jira-connector/api/search.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = SearchClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/search'
 *
 * @param {JiraClient} jiraClient
 * @constructor SearchClient
 */
function SearchClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Searches for issues using JQL.
     *
     * Sorting the jql parameter is a full JQL expression, and includes an ORDER BY clause.
     *
     * The fields param (which can be specified multiple times) gives a comma-separated list of fields to include in
     * the response. This can be used to retrieve a subset of fields. A particular field can be excluded by prefixing
     * it with a minus.
     *
     * By default, only navigable (*navigable) fields are returned in this search resource. Note: the default is
     * different in the get-issue resource -- the default there all fields (*all).
     *
     * * *all - include all fields
     * * navigable - include just navigable fields
     * * summary,comment - include just the summary and comments
     * * -description - include navigable fields except the description (the default is *navigable for search)
     * * *all,-comment - include everything except comments
     *
     * Expanding Issues in the Search Result: It is possible to expand the issues returned by directly specifying the
     * expansion on the expand parameter passed in to this resources.
     *
     * For instance, to expand the "changelog" for all the issues on the search result, it is neccesary to specify
     * "changelog" as one of the values to expand.
     *
     * @method search
     * @memberOf SearchClient#
     * @param opts The options for the search.
     * @param {string} opts.jql The JQL query string
     * @param {number} [opts.startAt] The index of the first issue to return (0-based)
     * @param {number} [opts.maxResults] The maximum number of issues to return (defaults to 50). The maximum allowable
     *     value is dictated by the JIRA property 'jira.search.views.default.max'. If you specify a value that is
     *     higher than this number, your search results will be truncated.
     * @param {boolean} [opts.validateQuery=true] Whether to validate the JQL query
     * @param {array} [opts.fields] The list of fields to return for each issue. By default, all navigable fields are
     *     returned.
     * @param {array} [opts.expand] A list of the parameters to expand.
     * @param {array} [opts.properties] A list of the properties to include (5 max).
     * @param [callback] Called with the search results.
     * @return {Promise} Resolved with the search results.
     */
    this.search = function (opts, callback) {
        opts.method = opts.method || 'POST';

        var options = {
            uri: this.jiraClient.buildURL('/search'),
            method: opts.method,
            json: true,
            followAllRedirects: true,
            timeout: opts.timeout || 10000,
        };

        var search_options = {
            jql: opts.jql,
            startAt: opts.startAt,
            maxResults: opts.maxResults,
            validateQuery: opts.validateQuery,
            fields: opts.fields,
            expand: opts.expand,
            properties: opts.properties
        };

        if (opts.method === 'POST') {
            options.body = search_options;
        } else {
            options.qs = search_options;
        }


        return this.jiraClient.makeRequest(options, callback);
    }
}


/***/ }),

/***/ "./node_modules/jira-connector/api/securityLevel.js":
/*!**********************************************************!*\
  !*** ./node_modules/jira-connector/api/securityLevel.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = SecurityLevelClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/securitylevel'
 *
 * @param {JiraClient} jiraClient
 * @constructor SecurityLevelClient
 */
function SecurityLevelClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Get a full representation of the security level that has the given id.
     *
     * @method getSecurityLevel
     * @memberOf SecurityLevelClient#
     * @param opts The request options to send to the Jira API.
     * @param opts.securityLevelId The id of the security level to retrieve
     * @param [callback] Called when the security level has been retrieved.
     * @return {Promise} Resolved when the security level has been retrieved.
     */
    this.getSecurityLevel = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/securitylevel/' + opts.securityLevelId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/serverInfo.js":
/*!*******************************************************!*\
  !*** ./node_modules/jira-connector/api/serverInfo.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ServerInfoClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/serverInfo'
 * @param {JiraClient} jiraClient
 * @constructor ServerInfoClient
 */
function ServerInfoClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns general information about the current JIRA server.
     *
     * @method getServerInfo
     * @memberOf ServerInfoClient#
     * @param opts The request options sent to the Jira API.
     * @param {boolean} [opts.doHealthCheck] Whether to perform a health check on the server.
     * @param [callback] Called when the server info has been retrieved.
     * @return {Promise} Resolved when the server info has been retrieved.
     */
    this.getServerInfo = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/serverInfo'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                doHealthCheck: opts.doHealthCheck
            }
        };

        return this.jiraClient.makeRequest(options, callback);
    }
}

/***/ }),

/***/ "./node_modules/jira-connector/api/settings.js":
/*!*****************************************************!*\
  !*** ./node_modules/jira-connector/api/settings.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = SettingsClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/settings'
 * @param {JiraClient} jiraClient
 * @constructor SettingsClient
 */
function SettingsClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Sets the base URL that is configured for this JIRA instance.
     *
     * @method setBaseUrl
     * @memberOf SettingsClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.newUrl The new base url.
     * @param [callback] Called when the base url has been set.
     * @return {Promise} Resolved when the base url has been set.
     */
    this.setBaseUrl = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/settings/baseUrl'),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            body: opts.newUrl
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns the default system columns for issue navigator. Admin permission will be required.
     *
     * @method getIssueNavColumns
     * @memberOf SettingsClient#
     * @param opts Ignored
     * @param [callback] Called when the columns have been retrieved
     * @return {Promise} Resolved when the columns have been retrieved
     */
    this.getIssueNavColumns = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/settings/columns'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/sprint.js":
/*!***************************************************!*\
  !*** ./node_modules/jira-connector/api/sprint.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = AgileSprintClient;

/**
 * Used to access Jira REST endpoints in '/rest/agile/1.0/sprint'
 * @param {JiraClient} jiraClient
 * @constructor AgileSprintClient
 */
function AgileSprintClient(jiraClient) {
  this.jiraClient = jiraClient;

  /**
   * Creates a sprint from a JSON representation.
   *
   * @method createSprint
   * @memberOf AgileSprintClient#
   * @param {Object} sprint The sprint data in the form of POST body to the
   *   Jira API.
   * @param [callback] Called when the sprint has been created.
   * @return {Promise} Resolved when the sprint has been created.
   */
  this.createSprint = function (sprint, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL('/sprint'),
      method: 'POST',
      followAllRedirects: true,
      json: true,
      body: sprint
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Get a single sprint.
   *
   * @method getSprint
   * @memberOf AgileSprintClient#
   * @param {object} opts The request options sent to the Jira API.
   * @param opts.sprintId The sprint id.
   * @param [callback] Called when the sprint has been retrieved.
   * @return {Promise} Resolved when the sprint has been retrieved.
   */
  this.getSprint = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL('/sprint/' + opts.sprintId),
      method: 'GET',
      json: true,
      followAllRedirects: true,
      qs: {
        filter: opts.filter,
        startAt: opts.startAt,
        maxResults: opts.maxResults
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Perform a full update of a sprint.
   *
   * @method updateSprint
   * @memberOf AgileSprintClient#
   * @param {Object} sprint The sprint data in the form of PUT body to the
   *   Jira API.
   * @param {string} [sprint.sprintId] The id of the sprint.  EX: 331
   * @param [callback] Called when the sprint has been updated.
   * @return {Promise} Resolved when the sprint has been updated.
   */
  this.updateSprint = function (sprint, callback) {
    var sprintId = sprint.sprintId;
    delete sprint.sprintId;

    var options = {
      uri: this.jiraClient.buildAgileURL('/sprint/' + sprintId),
      method: 'PUT',
      followAllRedirects: true,
      json: true,
      body: sprint
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Perform a partial update of a sprint.
   *
   * @method partiallyUpdateSprint
   * @memberOf AgileSprintClient#
   * @param {Object} sprint The sprint data in the form of POST body to the
   *   Jira API.
   * @param {string} [sprint.sprintId] The id of the sprint.  EX: 331.
   * @param callback Called when the sprint has been updated.
   * @return {Promise} Resolved when the sprint has been updated.
   */
  this.partiallyUpdateSprint = function (sprint, callback) {
    var sprintId = sprint.sprintId;
    delete sprint.sprintId;

    var options = {
      uri: this.jiraClient.buildAgileURL('/sprint/' + sprintId),
      method: 'POST',
      followAllRedirects: true,
      json: true,
      body: sprint
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Delete an existing sprint.
   *
   * @method deleteSprint
   * @memberOf AgileSprintClient#
   * @param {Object} opts The request options sent to the Jira API.
   * @param {string} opts.sprintId The id of the sprint.  EX: 331
   * @param [callback] Called when the sprint is deleted.
   * @return {Promise} Resolved when the sprint is deleted.
   */
  this.deleteSprint = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL('/sprint/' + opts.sprintId),
      method: 'DELETE',
      json: true,
      followAllRedirects: true,
      qs: {
        filter: opts.filter,
        startAt: opts.startAt,
        maxResults: opts.maxResults
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Return all issues in a sprint, for a given sprint id.
   *
   * @method getSprintIssues
   * @memberOf AgileSprintClient#
   * @param {Object} opts The request options sent to the Jira API.
   * @param opts.sprintId The sprint id.
   * @param {string} jql Filters results using a JQL query.
   * @param {boolean} validateQuery Specifies whether to valide the JQL query.
   * @param {string} fields The list of fields to return for each issue.
   * @param {string} expand A comma-separated list of the parameters to expand.
   * @param [callback] Called when the issues are returned.
   * @return {Promise} Resolved when the issues are returned.
   */
  this.getSprintIssues = function (opts, callback) {
    var options = {
      uri: this.jiraClient.buildAgileURL('/sprint/' + opts.sprintId + '/issue'),
      method: 'GET',
      json: true,
      followAllRedirects: true,
      qs: {
        startAt: opts.startAt,
        maxResults: opts.maxResults,
        jql: opts.jql,
        validateQuery: opts.validateQuery,
        fields: opts.fields,
        expand: opts.expand
      }
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Move issues to a sprint, for a given sprint id.
   *
   * @method moveSprintIssues
   * @memberOf AgileSprintClient#
   * @param {Object} opts The issue data in the form of POST body to the
   *   Jira API.
   * @param {string} [opts.sprintId] The sprint id.
   * @param [callback] Called when the sprint has been retrieved.
   * @return {Promise} Resolved when the sprint has been retrieved.
   */
  this.moveSprintIssues = function (opts, callback) {
    var sprintId = opts.sprintId;
    delete opts.sprintId;

    var options = {
      uri: this.jiraClient.buildAgileURL('/sprint/' + sprintId + '/issue'),
      method: 'POST',
      followAllRedirects: true,
      json: true,
      body: opts
    };

    return this.jiraClient.makeRequest(options, callback);
  };

  /**
   * Swap the position of the sprint (given by sprint id) with the second
   * sprint.
   *
   * @method swapSprint
   * @memberOf AgileSprintClient#
   * @param {Object} swapped The data in the form of POST body to the Jira API.
   * @param {string} [swapped.sprintId] The id of the sprint.  EX: 311
   * @param [callback] Called when the sprint has been retrived.
   * @return {Promise} Resolved when the sprint has been retrived.
   */
  this.swapSprint = function (swapped, callback) {
    var sprintId = swapped.sprintId;
    delete swapped.sprintId;

    var options = {
      uri: this.jiraClient.buildAgileURL('/sprint/' + sprintId + '/swap'),
      method: 'POST',
      followAllRedirects: true,
      json: true,
      body: swapped
    };

    return this.jiraClient.makeRequest(options, callback);
  };

}


/***/ }),

/***/ "./node_modules/jira-connector/api/status.js":
/*!***************************************************!*\
  !*** ./node_modules/jira-connector/api/status.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = StatusClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/status'
 *
 * @param {JiraClient} jiraClient
 * @constructor StatusClient
 */
function StatusClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a list of all statuses visible to the user
     *
     * @method getAllStatuses
     * @memberOf StatusClient#
     * @param opts Ignored
     * @param [callback] Called when statuses have been retrieved.
     * @return {Promise} Resolved when statuses have been retrieved.
     */
    this.getAllStatuses = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/status'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get a full representation of the status that has the given id.
     *
     * @method getStatus
     * @memberOf StatusClient#
     * @param opts The options sent to the Jira API
     * @param opts.statusId A String containing a status id
     * @param [callback] Called when the status has been retrieved.
     * @return {Promise} Resolved when the status has been retrieved.
     */
    this.getStatus = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/status/' + opts.statusId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/statusCategory.js":
/*!***********************************************************!*\
  !*** ./node_modules/jira-connector/api/statusCategory.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = StatusCategoryClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/statuscategory'
 *
 * @param {JiraClient} jiraClient
 * @constructor StatusCategoryClient
 */
function StatusCategoryClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a list of all statusCategories visible to the user
     *
     * @method getAllStatusCategories
     * @memberOf StatusCategoryClient#
     * @param opts Ignored
     * @param [callback] Called when the statusCategories have been retrieved.
     * @return {Promise} Resolved when the statusCategories have been retrieved.
     */
    this.getAllStatusCategories = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/statuscategory'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get a full representation of the statusCategory that has the given id or key.
     *
     * @method getStatusCategory
     * @memberOf StatusCategoryClient#
     * @param opts The options sent to the Jira API
     * @param opts.statusCategoryIdOrKey A String containing a statusCategory id
     * @param [callback] Called when the statusCategory has been retrieved.
     * @return {Promise} Resolved when the statusCategory has been retrieved.
     */
    this.getStatusCategory = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/statuscategory/' + opts.statusCategoryIdOrKey),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/user.js":
/*!*************************************************!*\
  !*** ./node_modules/jira-connector/api/user.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");

module.exports = UserClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/user'
 *
 * @param {JiraClient} jiraClient
 * @constructor UserClient
 */
function UserClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Get a user. This resource cannot be accessed anonymously.
     *
     * @method getUser
     * @memberOf UserClient#
     * @param opts The request options sent to the Jira API
     * @param opts.username The name of the user to retrieve.
     * @param opts.userKey The key of the user to retrieve.
     * @param {Object} opts.expand The fields to be expanded.
     * @param [callback] Called when the user has been retrieved.
     * @return {Promise} Resolved when the user has been retrieved.
     */
    this.getUser = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username,
                key: opts.userKey,
                expand: opts.expand
            }
        };

        if (opts.expand) {
            options.qs.expand = '';
            opts.expand.forEach(function (ex) {
                options.qs.expand += ex + ','
            });
        }

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Removes user.
     *
     * @method deleteUser
     * @memberOf UserClient#
     * @param opts The request options sent to the Jira API
     * @param opts.username The name of the user to delete.
     * @param opts.userKey The key of the user to delete.
     * @param [callback] Called when the user has been deleted.
     * @return {Promise} Resolved when the user has been deleted.
     */
    this.deleteUser = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user'),
            method: 'DELETE',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username,
                key: opts.userKey
            }
        };

        return this.jiraClient.makeRequest(options, callback, 'User removed.');
    };

    /**
     * Create user. By default created user will not be notified with email. If password field is not set then password
     * will be randomly generated.
     *
     * @method createUser
     * @memberOf UserClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.user See {@link https://docs.atlassian.com/jira/REST/latest/#d2e4049}
     * @param [callback] Called when the user has been created.
     * @return {Promise} Resolved when the user has been created.
     */
    this.createUser = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts.user
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Modify user. The "value" fields present will override the existing value. Fields skipped in request will not be
     * changed.
     *
     * @method editUser
     * @memberOf UserClient#
     * @param opts The request options sent to the Jira API
     * @param opts.user See {@link https://docs.atlassian.com/jira/REST/latest/#d2e4081}
     * @param opts.username The name of the user to edit.
     * @param opts.userKey The key of the user to edit.
     * @param [callback] Called when the user has been edited.
     * @return {Promise} Resolved when the user has been edited.
     */
    this.editUser = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user'),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username,
                key: opts.userKey
            },
            body: opts.user
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns a list of users that match the search string and can be assigned issues for all the given projects. This
     * resource cannot be accessed anonymously.
     *
     * @method multiProjectSearchAssignable
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.username The name of the user to search.
     * @param {Array} opts.projectKeys The keys of the projects we are finding assignable users for
     * @param {number} [opts.startAt] The index of the first user to return (0-based)
     * @param {number} [opts.maxResults] The maximum number of users to return (defaults to 50). The maximum allowed
     *     value is 1000. If you specify a value that is higher than this number, your search results will be
     *     truncated.
     * @param [callback] Called when the search results have been retrieved.
     * @return {Promise} Resolved when the search results have been retrieved.
     */
    this.multiProjectSearchAssignable = function (opts, callback) {
        var projectKeyString = '';
        if (opts.projectKeys) {
            opts.projectKeys.forEach(function (key) {
                projectKeyString += key + ',';
            });
            projectKeyString = projectKeyString.slice(0, -1);
        }
        var options = {
            uri: this.jiraClient.buildURL('/user/assignable/multiProjectSearch'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username,
                projectKeys: projectKeyString,
                startAt: opts.startAt,
                maxResults: opts.maxResults
            }
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns a list of users that match the search string. This resource cannot be accessed anonymously. Please note
     * that this resource should be called with an issue key when a list of assignable users is retrieved for editing.
     * For create only a project key should be supplied. The list of assignable users may be incorrect if it's called
     * with the project key for editing.
     *
     * @method searchAssignable
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.username The username
     * @param {string} opts.project The key of the project we are finding assignable users for
     * @param {string} [opts.issueKey] The issue key for the issue being edited we need to find assignable users for.
     * @param {number} [opts.startAt] The index of the first user to return (0-based)
     * @param {number} [opts.maxResults] The maximum number of users to return (defaults to 50). The maximum allowed
     *     value is 1000. If you specify a value that is higher than this number, your search results will be
     *     truncated.
     * @param {number} [opts.actionDescriptorId]
     * @param [callback] Called when the search results have been retrieved.
     * @return {Promise} Resolved when the search results have been retrieved.
     */
    this.searchAssignable = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/assignable/search'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username,
                project: opts.project,
                issueKey: opts.issueKey,
                startAt: opts.startAt,
                maxResults: opts.maxResults,
                actionDescriptorId: opts.actionDescriptorId
            }
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Creates temporary avatar. Creating a temporary avatar is part of a 3-step process in uploading a new avatar for
     * a user: upload, crop, confirm.
     *
     * @method createTemporaryAvatar
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.username The username
     * @param {string} opts.filepath The path to the file to upload.
     * @param [callback] Called when the temporary avatar has been uploaded.
     * @return {Promise} Resolved when the temporary avatar has been uploaded.
     */
    this.createTemporaryAvatar = function (opts, callback) {
        var extension = path.extname(opts.filepath).slice(1);
        var baseName = path.basename(opts.filepath);
        var fileSize = fs.statSync(opts.filepath).size;

        extension = extension == 'jpg' ? 'jpeg' : extension;

        var options = {
            uri: this.jiraClient.buildURL('/user/avatar/temporary'),
            method: 'POST',
            followAllRedirects: true,
            qs: {
                username: opts.username,
                filename: baseName,
                size: fileSize
            },
            body: fs.readFileSync(opts.filepath),
            headers: {
                "X-Atlassian-Token": 'no-check',
                "Content-Type": 'image/' + extension
            }
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Converts temporary avatar into a real avatar
     *
     * @method convertTemporaryAvatar
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.username The username
     * @param {Object} opts.avatarId The id of the temporary avatar to convert.
     * @param [callback] Called when the avatar has been converted
     * @return {Promise} Resolved when the avatar has been converted
     */
    this.convertTemporaryAvatar = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/avatar/'),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username
            },
            body: {id: opts.avatarId},
            headers: {
                "X-Atlassian-Token": 'no-check'
            }
        };
        return this.jiraClient.makeRequest(options, callback, 'Avatar Converted');
    };

    /**
     * Deletes avatar
     *
     * @method deleteAvatar
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.username The username
     * @param {Object} opts.avatarId The id of the temporary avatar to delete.
     * @param [callback] Called when the avatar has been deleted.
     * @return {Promise} Resolved when the avatar has been deleted.
     */
    this.deleteAvatar = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/avatar/' + opts.avatarId),
            method: 'DELETE',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username
            }
        };
        return this.jiraClient.makeRequest(options, callback, 'Avatar Deleted');
    };

    /**
     * Returns all avatars which are visible for the currently logged in user.
     *
     * @method getAvatars
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.username The username
     * @param [callback] Called when the avatars have been retrieved.
     * @return {Promise} Resolved when the avatars have been retrieved.
     */
    this.getAvatars = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/avatars'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username
            }
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns the default columns for the given user. Admin permission will be required to get columns for a user
     * other than the currently logged in user.
     *
     * @method getDefaultColumns
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.username The username
     * @param [callback] Called when the columns have been retrieved.
     * @return {Promise} Resolved when the columns have been retrieved.
     */
    this.getDefaultColumns = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/columns'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username
            }
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Sets the default columns for the given user. Admin permission will be required to get columns for a user other
     * than the currently logged in user.
     *
     * @method setDefaultColumns
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.username The username
     * @param {Array} opts.columns The names of the new columns.  See {@link
        *     https://docs.atlassian.com/jira/REST/latest/#d2e4566}
     * @param [callback] Called when the columns have been set.
     * @return {Promise} Resolved when the columns have been set.
     */
    this.setDefaultColumns = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/columns'),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username
            },
            body: {
                columns: opts.columns
            }
        };
        return this.jiraClient.makeRequest(options, callback, 'Default Columns Set');
    };

    /**
     * Reset the default columns for the given user to the system default. Admin permission will be required to get
     * columns for a user other than the currently logged in user.
     *
     * @method resetDefaultColumns
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} opts.username The username
     * @param [callback] Called when the columns have been reset.
     * @return {Promise} Resolved when the columns have been reset.
     */
    this.resetDefaultColumns = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/columns'),
            method: 'DELETE',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username
            }
        };
        return this.jiraClient.makeRequest(options, callback, 'Default Columns Reset');
    };

    /**
     * Modify user password.
     *
     * @method changePassword
     * @memberOf UserClient#
     * @param opts The request options sent to the Jira API
     * @param opts.username The name of the user for which to change the password.
     * @param opts.userKey The key of the user for which to change the password.
     * @param opts.password The new password.
     * @param [callback] Called when the password has been set.
     * @return {Promise} Resolved when the password has been set.
     */
    this.changePassword = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/password'),
            method: 'PUT',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username,
                key: opts.userKey
            },
            body: {
                password: opts.password
            }
        };
        return this.jiraClient.makeRequest(options, callback, 'Password Changed');
    };

    /**
     * Returns a list of active users that match the search string and have all specified permissions for the project
     * or issue.
     *
     * This resource can be accessed by users with ADMINISTER_PROJECT permission for the project or global
     * ADMIN or SYSADMIN rights.
     *
     * @method searchPermissions
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the jira API
     * @param {string} opts.username The username filter, list includes all users if unspecified
     * @param {Array} opts.permissions Array of permissions for project or issue returned users must have, see
     *     [Permissions]{@link
        *     https://developer.atlassian.com/static/javadoc/jira/6.0/reference/com/atlassian/jira/security/Permissions.Permission.html}
        *     JavaDoc for the list of all possible permissions.
     * @param {string} [opts.issueKey] the issue key for the issue for which returned users have specified permissions.
     * @param {string} [opts.projectKey] the optional project key to search for users with if no issueKey is supplied.
     * @param {number} [opts.startAt] the index of the first user to return (0-based)
     * @param {number} [opts.maxResults] the maximum number of users to return (defaults to 50). The maximum allowed
     *     value is 1000. If you specify a value that is higher than this number, your search results will be
     *     truncated.
     * @param [callback] Called when the search results are retrieved.
     * @return {Promise} Resolved when the search results are retrieved.
     */
    this.searchPermissions = function (opts, callback) {
        var permissions = '';
        if (opts.permissions) {
            opts.permissions.forEach(function (s) {
                permissions += s + ','
            });
            permissions = permissions.slice(0, -1);
        }
        var options = {
            uri: this.jiraClient.buildURL('/user/permission/search'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username,
                permissions: permissions,
                issueKey: opts.issueKey,
                projectKey: opts.projectKey,
                startAt: opts.startAt,
                maxResults: opts.maxResults
            }
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns a list of users matching query with highlighting. This resource cannot be accessed anonymously.
     *
     * @method searchPicker
     * @memberOf UserClient#
     * @param opts The request options sent to the Jira API.
     * @param {string} opts.query
     * @param {number} [opts.maxResults=50]
     * @param {boolean} [opts.showAvatar=false]
     * @param {string} [opts.exclude]
     * @param [callback] Called when the search results are retrieved.
     * @return {Promise} Resolved when the search results are retrieved.
     */
    this.searchPicker = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/picker'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                query: opts.query,
                maxResults: opts.maxResults,
                showAvatar: opts.showAvatar,
                exclude: opts.exclude
            }
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns a list of users that match the search string. This resource cannot be accessed anonymously.
     *
     * @method search
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API.
     * @param {string} opts.username A query string used to search username, name or e-mail address
     * @param {number} [opts.startAt=0] the index of the first user to return (0-based)
     * @param {number} [opts.maxResults=50] the maximum number of users to return (defaults to 50). The maximum allowed
     *     value is 1000. If you specify a value that is higher than this number, your search results will be
     *     truncated.
     * @param {boolean} [opts.includeActive=true] If true, then active users are included in the results (default true)
     * @param {boolean} [opts.includeInactive=false] If true, then inactive users are included in the results (default
     *     false)
     * @param [callback] Called when the search results are retrieved.
     * @return {Promise} Resolved when the search results are retrieved.
     */
    this.search = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/search'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username,
                maxResults: opts.maxResults,
                startAt: opts.startAt,
                includeActive: opts.includeActive,
                includeInactive: opts.includeInactive
            }
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns a list of active users that match the search string. This resource cannot be accessed anonymously. Given
     * an issue key this resource will provide a list of users that match the search string and have the browse issue
     * permission for the issue provided.
     *
     * @method viewIssueSearch
     * @memberOf UserClient#
     * @param {Object} opts The request options sent to the Jira API.
     * @param {string} opts.username A query string used to search username, name or e-mail address
     * @param {string} [opts.issueKey] the issue key for the issue being edited we need to find viewable users for.
     * @param {string} [opts.projectKey] the optional project key to search for users with if no issueKey is supplied.
     * @param {number} [opts.startAt=0] the index of the first user to return (0-based)
     * @param {number} [opts.maxResults=50] the maximum number of users to return (defaults to 50). The maximum allowed
     * @param [callback] Called when data has been retrieved
     * @return {Promise} Resolved when data has been retrieved
     */
    this.viewIssueSearch = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/user/viewissue/search'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                username: opts.username,
                issueKey: opts.issueKey,
                projectKey: opts.projectKey,
                startAt: opts.startAt,
                maxResults: opts.maxResults
            }
        };
        return this.jiraClient.makeRequest(options, callback);
    };
}


/***/ }),

/***/ "./node_modules/jira-connector/api/version.js":
/*!****************************************************!*\
  !*** ./node_modules/jira-connector/api/version.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = VersionClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/version'
 * @param {JiraClient} jiraClient
 * @constructor VersionClient
 */
function VersionClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Creates a version
     *
     * @method createVersion
     * @memberOf VersionClient#
     * @param {Object} opts The request options sent to Jira.
     * @param {Object} opts.version See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3549}
     * @param [callback] Called when the version has been created.
     * @return {Promise} Resolved when the version has been created.
     */
    this.createVersion = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/version'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts.version
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Modify a version's sequence within a project. The move version bean has 2 alternative field value pairs
     * (opts.position or opts.after).  One and only one of these two must be provided.
     *
     * @method moveVersion
     * @memberOf VersionClient#
     * @param {Object} opts The request options sent to the Jira API.
     * @param {string} opts.versionId The id of the version to move.
     * @param {string} [opts.position] An absolute position, which may have a value of 'First', 'Last', 'Earlier' or
     *     'Later'. Must be provided if opts.after is missing.
     * @param {string} [opts.after] A version to place this version after. The value should be the self link of another
     *     version. Must be provided if opts.position is missing
     * @param [callback] Called when the version has been moved.
     * @return {Promise} Resolved when the version has been moved.
     */
    this.moveVersion = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/move', 'POST', {position: opts.position, after: opts.after});
        return this.jiraClient.makeRequest(options, callback);
    };
    
     /**
     * Get a all versions from specific board.
     *
     * @method getAllVersions
     * @memberOf VersionClient#
     * @param {Object} opts The request options sent to the Jira API.
     * @param {string|number} opts.boardId The id of the board which contains versions to retrieve.
     * @param [callback] Called when all versions are retrieved.
     * @return {Promise} Resolved when all versions are retrieved.
     */
    this.getAllVersions = function(opts, callback) {
        var options = {
            uri: this.jiraClient.buildAgileURL(`/board/${opts.boardId}/version`),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                filter: opts.filter,
                startAt: opts.startAt,
                maxResults: opts.maxResults
            }
        }
        return this.jiraClient.makeRequest(options, callback);
    }
    
    /**
     * Get a project version.
     *
     * @method getVersion
     * @memberOf VersionClient#
     * @param {Object} opts The request options sent to the Jira API.
     * @param {string|number} opts.versionId The id of the version to retrieve.
     * @param [callback] Called when the version is retrieved.
     * @return {Promise} Resolved when the version is retrieved.
     */
    this.getVersion = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Modify an existing version; any omitted fields will be ignored.
     *
     * @method editVersion
     * @memberOf VersionClient#
     * @param {Object} opts The request options sent to Jira.
     * @param {string} opts.versionId The id of the version to edit.
     * @param {Object} opts.version See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3619}
     * @param [callback] Called when the version has been modified.
     * @return {Promise} Resolved when the version has been modified.
     */
    this.editVersion = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'PUT', opts.version);
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get a bean containing the number of fixed in and affected issues for the given version.
     *
     * @method getRelatedIssueCounts
     * @memberOf VersionClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.versionId The version for which to retrieve related issues.
     * @param [callback] Called when the count has been retrieved.
     * @return {Promise} Resolved when the count has been retrieved.
     */
    this.getRelatedIssueCounts = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/relatedIssueCounts', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get the number of unresolved issues for the given version
     *
     * @method getUnresolvedIssueCount
     * @memberOf VersionClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.versionId The version for which to retrieve unresolved issues.
     * @param [callback] Called when the count has been retrieved.
     * @return {Promise} Resolved when the count has been retrieved.
     */
    this.getUnresolvedIssueCount = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/unresolvedIssueCount', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get the remote version links associated with the given version id.
     *
     * @method getRemoteLinks
     * @memberOf VersionClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.versionId The version for which to retrieve remote links.
     * @param [callback] Called when the links have been retrieved.
     * @return {Promise} Resolved when the links have been retrieved.
     */
    this.getRemoteLinks = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/remotelink', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Create a remote version link via POST. The link's global id will be taken from the JSON payload if provided;
     * otherwise, it will be generated.
     *
     * @method createRemoteLink
     * @memberOf VersionClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.versionId The version for which to retrieve unresolved issues.
     * @param opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3753}
     * @param [callback] Called when the remote link has been created.
     * @return {Promise} Resolved when the remote link has been created.
     */
    this.createRemoteLink = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/remotelink', 'POST', opts.remoteLink);
        return this.jiraClient.makeRequest(options, callback, 'Remotelink Created');
    };

    /**
     * Get a REST sub-resource representing a remote version link.
     *
     * @method getRemoteLinks
     * @memberOf VersionClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.versionId The version for which to retrieve the remote link
     * @param opts.remoteLinkId The global id of the remote link
     * @param [callback] Called when the link has been retrieved.
     * @return {Promise} Resolved when the link has been retrieved.
     */
    this.getRemoteLink = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/remotelink/' + opts.remoteLinkId, 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Delete a remote version link.
     *
     * @method deleteRemoteLink
     * @memberOf VersionClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.versionId The version id
     * @param opts.remoteLinkId The global id of the remote link
     * @param [callback] Called when the link has been deleted.
     * @return {Promise} Resolved when the link has been deleted.
     */
    this.deleteRemoteLink = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/remotelink/' + opts.remoteLinkId, 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Remote Link Deleted');
    };

    /**
     * Delete a project version.
     *
     * @method deleteVersion
     * @memberOf VersionClient#
     * @param {Object} opts The request options sent to the Jira API.
     * @param {string|number} opts.versionId The id of the version to delete.
     * @param [callback] Called when the version is deleted.
     * @return {Promise} Resolved when the version is deleted.
     */
    this.deleteVersion = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Version Deleted');
    };

    /**
     * Delete all remote version links for a given version id.
     *
     * @method deleteAllRemoteLinks
     * @memberOf VersionClient#
     * @param {Object} opts The request options sent to the Jira API.
     * @param {string|number} opts.versionId The id of the version to delete.
     * @param [callback] Called when the version is deleted.
     * @return {Promise} Resolved when the version is deleted.
     */
    this.deleteAllRemoteLinks = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/remotelink', 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Remote Links Deleted');
    };

    /**
     * Returns the remote version links for a given global id.
     *
     * @method getGlobalRemoteLink
     * @memberOf VersionClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.globalId The global id of the remote resource that is linked to the versions
     * @param [callback] Called when the remote link is returned.
     * @return {Promise} Resolved when the remote link is returned.
     */
    this.getGlobalRemoteLink = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/version/remotelink'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {globalId: opts.globalId}
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Build out the request options necessary to make a particular API call.
     *
     * @private
     * @method buildRequestOptions
     * @memberOf FilterClient#
     * @param {Object} opts The arguments passed to the method.
     * @param {number} opts.versionId The id of the screen to use in the path.
     * @param {Array} [opts.fields] The fields to include
     * @param {Array} [opts.expand] The fields to expand
     * @param {string} path The path of the endpoint following /version/{id}
     * @param {string} method The request method.
     * @param {Object} [body] The request body, if any.
     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.
     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}
     */
    this.buildRequestOptions = function (opts, path, method, body, qs) {
        var basePath = '/version/' + opts.versionId;
        if (!qs) qs = {};
        if (!body) body = {};

        if (opts.fields) {
            qs.fields = '';
            opts.fields.forEach(function (field) {
                qs.fields += field + ','
            });
            qs.fields = qs.fields.slice(0, -1);
        }

        if (opts.expand) {
            qs.expand = '';
            opts.expand.forEach(function (ex) {
                qs.expand += ex + ','
            });
            qs.expand = qs.expand.slice(0, -1);
        }

        return {
            uri: this.jiraClient.buildURL(basePath + path),
            method: method,
            body: body,
            qs: qs,
            followAllRedirects: true,
            json: true
        };
    };
}


/***/ }),

/***/ "./node_modules/jira-connector/api/webhook.js":
/*!****************************************************!*\
  !*** ./node_modules/jira-connector/api/webhook.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = WebhookClient;

/**
 * Used to access Jira REST endpoints in '/rest/webhook/1.0/webhook'
 *
 * @param {JiraClient} jiraClient
 * @constructor WebhookClient
 */
function WebhookClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns a list of all registered webhooks.
     *
     * @method getAllWebhooks
     * @memberOf WebhookClient#
     * @param opts Ignored
     * @param [callback] Called when the webhooks have been retrieved.
     * @return {Promise} Resolved when the webhooks have been retrieved.
     */
    this.getAllWebhooks = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildWebhookURL('/webhook'),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns a webhook with a specific ID.
     *
     * @method getWebhook
     * @memberOf WebhookClient#
     * @param opts The options sent to the JIRA API.
     * @param opts.webhookId The numerical webhook ID.
     * @param [callback] Called when the webhook has been retrieved.
     * @return {Promise} Resolved when the webhook has been retrieved.
     */
    this.getWebhook = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildWebhookURL('/webhook/' + opts.webhookId),
            method: 'GET',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Registers a new webhook.
     *
     * @method createWebhook
     * @memberOf WebhookClient#
     * @param opts The options sent to the JIRA API.
     * @param opts.name The name of the webhook.
     * @param opts.url The URL of the webhook.
     * @param opts.events An array of events with which the webhook should be registered. See
     *   {@link https://developer.atlassian.com/jiradev/jira-apis/webhooks#Webhooks-configureConfiguringawebhook}.
     * @param opts.enabled Whether the webhook is enabled.
     * @param opts.filter An object containing filter configuration.
     * @param opts.filter.issue-related-events-section A filter for issues, written in JQL.
     * @param opts.excludeBody Whether to send an empty body to the webhook URL.
     * @param [callback] Called when the webhook has been retrieved.
     * @return {Promise} Resolved when the webhook has been retrieved.
     */
    this.createWebhook = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildWebhookURL('/webhook'),
            method: 'POST',
            json: true,
            body: opts,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Deletes a registered webhook.
     *
     * @method deleteWebhook
     * @memberOf WebhookClient#
     * @param opts The options sent to the JIRA API.
     * @param opts.webhookId The numerical webhook ID.
     * @param [callback] Called when the webhook has been retrieved.
     * @return {Promise} Resolved when the webhook has been retrieved.
     */
    this.deleteWebhook = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildWebhookURL('/webhook/' + opts.webhookId),
            method: 'DELETE',
            json: true,
            followAllRedirects: true
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}


/***/ }),

/***/ "./node_modules/jira-connector/api/workflow.js":
/*!*****************************************************!*\
  !*** ./node_modules/jira-connector/api/workflow.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = WorkflowClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/workflow'
 *
 * @param {JiraClient} jiraClient
 * @constructor WorkflowClient
 */
function WorkflowClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns all workflows.
     *
     * @method getWorkflows
     * @memberOf WorkflowClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {string} [opts.workflowName] The name of the workflow to retrieve.
     * @param [callback] Called when the workflow(s) have been retrieved.
     * @return {Promise} Resolved when the workflow(s) have been retrieved.
     */
    this.getWorkflows = function (opts, callback) {
        var qs = {};
        if (opts && typeof opts === 'object' && opts.hasOwnProperty('workflowName')) {
            qs.workflowName = opts.workflowName;
        }
        var options = {
            uri: this.jiraClient.buildURL('/workflow'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: qs
        };

        return this.jiraClient.makeRequest(options, callback);
    };
}


/***/ }),

/***/ "./node_modules/jira-connector/api/workflowScheme.js":
/*!***********************************************************!*\
  !*** ./node_modules/jira-connector/api/workflowScheme.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = WorkflowSchemeClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/workflowscheme'
 * @param {JiraClient} jiraClient
 * @constructor WorkflowSchemeClient
 */
function WorkflowSchemeClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Create a new workflow scheme. The body contains a representation of the new scheme. Values not passed are
     * assumed to be set to their defaults.
     *
     * @method createWorkflowScheme
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowScheme See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2196}
     * @param [callback] Called when the workflow scheme has been created.
     * @return {Promise} Resolved when the workflow scheme has been created.
     */
    this.createWorkflowScheme = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/workflowscheme'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: opts.workflowScheme
        };
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Update the passed workflow scheme. The body of the request is a representation of the workflow scheme. Values
     * not passed are assumed to indicate no change for that field. The passed representation can have its
     * updateDraftIfNeeded flag set to true to indicate that the draft should be created and/or updated when the actual
     * scheme cannot be edited (e.g. when the scheme is being used by a project). Values not appearing the body will
     * not be touched.
     *
     * @method editWorkflowScheme
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.workflowScheme See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2305}
     * @param [callback] Called when the workflow scheme has been edited.
     * @return {Promise} Resolved when the workflow scheme has been edited.
     */
    this.editWorkflowScheme = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'PUT', opts.workflowScheme);
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get the requested workflow scheme
     *
     * @method getWorkflowScheme
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param [opts.returnDraftIfExists=false] when true indicates that a scheme's draft, if it exists, should be
     *     queried instead of the scheme itself.
     * @param [callback] Called when the workflow scheme has been retrieved.
     * @return {Promise} Resolved when the workflow scheme has been retrieved.
     */
    this.getWorkflowScheme = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'GET', null, {returnDraftIfExists: opts.returnDraftIfExists});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Delete the passed workflow scheme.
     *
     * @method deleteWorkflowScheme
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param [callback] Called when the workflow scheme has been deleted.
     * @return {Promise} Resolved when the workflow scheme has been deleted.
     */
    this.deleteWorkflowScheme = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '', 'DELETE');
        return this.jiraClient.makeRequest(options, callback, 'Workflow Scheme Deleted');
    };

    /**
     * Create a draft for the passed scheme. The draft will be a copy of the state of the parent.
     *
     * @method createDraft
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param [callback] Called when the draft has been created.
     * @return {Promise} Resolved when the draft has been created.
     */
    this.createDraft = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/createdraft', 'POST');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get the default workflow from the passed workflow scheme.
     *
     * @method getDefaultWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.returnDraftIfExists when true indicates that a scheme's draft, if it exists, should be queried
     *     instead of the scheme itself.
     * @param [callback] Called when the default workflow is returned.
     * @return {Promise} Resolved when the default workflow is returned.
     */
    this.getDefaultWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/default', 'GET', null, {returnDraftIfExists: opts.returnDraftIfExists});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Remove the default workflow from the passed workflow scheme.
     *
     * @method removeDefaultWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.updateDraftIfNeeded when true will create and return a draft when the workflow scheme cannot be
     *     edited (e.g. when it is being used by a project).
     * @param [callback] Called when the defaul workflow has been removed.
     * @return {Promise} Resolved when the defaul workflow has been removed.
     */
    this.removeDefaultWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/default', 'DELETE', null, {updateDraftIfNeeded: opts.updateDraftIfNeeded});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Remove the default workflow from the passed workflow scheme.
     *
     * @method setDefaultWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.workflowName The name of the new deafault workflow
     * @param opts.updateDraftIfNeeded when true will create and return a draft when the workflow scheme cannot be
     *     edited (e.g. when it is being used by a project).
     * @param [callback] Called when the default workflow has been updated.
     * @return {Promise} Resolved when the default workflow has been updated.
     */
    this.setDefaultWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/default', 'PUT', {
            workflow: opts.workflowName,
            updateDraftIfNeeded: opts.updateDraftIfNeeded
        });
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get the requested draft workflow scheme
     *
     * @method getDraft
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param [callback] Called when the draft has been retrieved.
     * @return {Promise} Resolved when the draft has been retrieved.
     */
    this.getDraft = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Update a draft workflow scheme. The draft will created if necessary. The body is a representation of the
     * workflow scheme. Values not passed are assumed to indicate no change for that field.
     *
     * @method editDraft
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.draft See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2575}
     * @param [callback] Called when the draft has been edited.
     * @return {Promise} Resolved when the draft has been edited.
     */
    this.editDraft = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft', 'PUT', opts.draft);
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Delete the passed draft workflow scheme.
     *
     * @method deleteDraft
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param [callback] Called when the draft has been deleted.
     * @return {Promise} Resolved when the draft has been deleted.
     */
    this.deleteDraft = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft', 'DELETE');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Get the default workflow from the passed draft workflow scheme
     *
     * @method getDraftDefaultWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param [callback] Called when the default workflow is returned.
     * @return {Promise} Resolved when the default workflow is returned.
     */
    this.getDraftDefaultWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft/default', 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Remove the default workflow from the passed workflow scheme.
     *
     * @method setDraftDefaultWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.workflowName The name of the new default workflow
     * @param [callback] Called when the default workflow has been updated.
     * @return {Promise} Resolved when the default workflow has been updated.
     */
    this.setDraftDefaultWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft/default', 'PUT', {
            workflow: opts.workflowName,
            updateDraftIfNeeded: opts.updateDraftIfNeeded
        });
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Remove the default workflow from the passed draft workflow scheme.
     *
     * @method removeDraftDefaultWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param [callback] Called when the defaul workflow has been removed.
     * @return {Promise} Resolved when the defaul workflow has been removed.
     */
    this.removeDraftDefaultWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft/default', 'DELETE');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns the issue type mapping for the passed workflow scheme.
     *
     * @method getIssueType
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.issueType The issue type
     * @param opts.returnDraftIfExists when true indicates that a scheme's draft, if it exists, should be queried
     *     instead of the scheme itself.
     * @param [callback] Called when the issue type has been retrieved.
     * @return {Promise} Resolved when the issue type has been retrieved.
     */
    this.getIssueType = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/issuetype/' + opts.issueType, 'GET', null,
            {returnDraftIfExists: opts.returnDraftIfExists});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Set the issue type mapping for the passed scheme. The passed representation can have its updateDraftIfNeeded
     * flag set to true to indicate that the draft should be created/updated when the actual scheme cannot be edited.
     *
     * @method editIssueType
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.issueType The issue type
     * @param opts.workflow The new workflow
     * @param opts.updateDraftIfNeeded when true will create and return a draft when the workflow scheme cannot be
     *     edited (e.g. when it is being used by a project).
     * @param [callback] Called when the issue type has been edited
     * @return {Promise} Resolved when the issue type has been edited
     */
    this.editIssueType = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/issuetype/' + opts.issueType, 'PUT', {
            workflow: opts.workflow,
            updateDraftIfNeeded: opts.updateDraftIfNeeded
        });
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Remove the specified issue type mapping from the scheme.
     *
     * @method removeIssueType
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.issueType The issue type
     * @param [callback] Called when the issue type mapping has been removed.
     * @return {Promise} Resolved when the issue type mapping has been removed.
     */
    this.removeIssueType = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/issuetype/' + opts.issueType, 'DELETE', null, {
            updateDraftIfNeeded: opts.updateDraftIfNeeded
        });
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns the issue type mapping for the passed draft workflow scheme.
     *
     * @method getDraftIssueType
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API.
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.issueType The issue type
     * @param [callback] Called when the issue type has been retrieved.
     * @return {Promise} Resolved when the issue type has been retrieved.
     */
    this.getDraftIssueType = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft/issuetype/' + opts.issueType, 'GET');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Set the issue type mapping for the passed draft scheme.
     *
     * @method editDraftIssueType
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.issueType The issue type
     * @param opts.workflow The new workflow
     * @param [callback] Called when the issue type has been edited
     * @return {Promise} Resolved when the issue type has been edited
     */
    this.editDraftIssueType = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft/issuetype/' + opts.issueType, 'PUT', {workflow: opts.workflow});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Remove the specified issue type mapping from the scheme.
     *
     * @method removeDraftIssueType
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.issueType The issue type
     * @param [callback] Called when the issue type mapping has been removed.
     * @return {Promise} Resolved when the issue type mapping has been removed.
     */
    this.removeDraftIssueType = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft/issuetype/' + opts.issueType, 'DELETE');
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns the workflow mappings or requested mapping to the caller for the passed scheme.
     *
     * @method getWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.workflowName The name of the workflow.
     * @param [callback] Called when the workflow has been retrieved.
     * @return {Promise} Resolved when the workflow has been retrieved.
     */
    this.getWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/workflow', 'GET', null, {
            workflowName: opts.workflowName
        });
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Returns the workflow mappings or requested mapping to the caller for the passed draft scheme.
     *
     * @method getDraftWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param opts The request options sent to the Jira API
     * @param opts.workflowSchemeId The id of the workflow scheme.
     * @param opts.workflowName The name of the workflow.
     * @param [callback] Called when the workflow has been retrieved.
     * @return {Promise} Resolved when the workflow has been retrieved.
     */
    this.getDraftWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft/workflow', 'GET', null, {
            workflowName: opts.workflowName
        });
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Update the scheme to include the passed mapping. The body is a representation of the workflow mapping. Values
     * not passed are assumed to indicate no change for that field.
     *
     * @method editWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.workflowSchemeId The id of the workflow scheme.
     * @param {string} opts.workflowName The name of the workflow.
     * @param {Array} opts.issueTypes The new issue types to inclue in the workflow.
     *      See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2509}
     * @param [callback] Called when the workflow has been edited.
     * @return {Promise} Resolved when the workflow has been edited.
     */
    this.editWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/workflow', 'PUT', {
            workflow: opts.workflowName,
            issueTypes: opts.issueTypes
        }, {workflowName: opts.workflowName});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Update the draft scheme to include the passed mapping. The body is a representation of the workflow mapping.
     * Values not passed are assumed to indicate no change for that field.
     *
     * @method editDraftWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.workflowSchemeId The id of the workflow scheme.
     * @param {string} opts.workflowName The name of the workflow.
     * @param {Array} opts.issueTypes The new issue types to inclue in the workflow.
     *      See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2670 }
     * @param [callback] Called when the workflow has been edited.
     * @return {Promise} Resolved when the workflow has been edited.
     */
    this.editDraftWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft/workflow', 'PUT', {
            workflow: opts.workflowName,
            issueTypes: opts.issueTypes
        }, {workflowName: opts.workflowName});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Delete the passed workflow from the workflow scheme.
     *
     * @method deleteWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.workflowSchemeId The id of the workflow scheme.
     * @param {string} opts.workflowName The name of the workflow.
     * @param [callback] Called when the workflow has been edited.
     * @return {Promise} Resolved when the workflow has been edited.
     */
    this.deleteWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/workflow', 'DELETE', null, {workflowName: opts.workflowName});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Delete the passed workflow from the workflow draft scheme.
     *
     * @method deleteDraftWorkflow
     * @memberOf WorkflowSchemeClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.workflowSchemeId The id of the workflow scheme.
     * @param {string} opts.workflowName The name of the workflow.
     * @param [callback] Called when the workflow has been edited.
     * @return {Promise} Resolved when the workflow has been edited.
     */
    this.deleteDraftWorkflow = function (opts, callback) {
        var options = this.buildRequestOptions(opts, '/draft/workflow', 'DELETE', null, {workflowName: opts.workflowName});
        return this.jiraClient.makeRequest(options, callback);
    };

    /**
     * Build out the request options necessary to make a particular API call.
     *
     * @private
     * @method buildRequestOptions
     * @memberOf WorkflowSchemeClient#
     * @param {Object} opts The arguments passed to the method.
     * @param {number} opts.workflowSchemeId The id of the workflowScheme to use in the path.
     * @param {Array} [opts.fields] The fields to include
     * @param {Array} [opts.expand] The fields to expand
     * @param {string} path The path of the endpoint following /workflowScheme/{id}
     * @param {string} method The request method.
     * @param {Object} [body] The request body, if any.
     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.
     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}
     */
    this.buildRequestOptions = function (opts, path, method, body, qs) {
        var basePath = '/workflowscheme/' + opts.workflowSchemeId;
        if (!qs) qs = {};
        if (!body) body = {};

        if (opts.fields) {
            qs.fields = '';
            opts.fields.forEach(function (field) {
                qs.fields += field + ','
            });
            qs.fields = qs.fields.slice(0, -1);
        }

        if (opts.expand) {
            qs.expand = '';
            opts.expand.forEach(function (ex) {
                qs.expand += ex + ','
            });
            qs.expand = qs.expand.slice(0, -1);
        }

        return {
            uri: this.jiraClient.buildURL(basePath + path),
            method: method,
            body: body,
            qs: qs,
            followAllRedirects: true,
            json: true
        };
    };
}

/***/ }),

/***/ "./node_modules/jira-connector/api/worklog.js":
/*!****************************************************!*\
  !*** ./node_modules/jira-connector/api/worklog.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = WorklogClient;

/**
 * Used to access Jira REST endpoints in '/rest/api/2/worklog'
 *
 * @param {JiraClient} jiraClient
 * @constructor WorkLogClient
 */
function WorklogClient(jiraClient) {
    this.jiraClient = jiraClient;

    /**
     * Returns worklogs id and delete time of worklogs that were deleted since given time. The returns set of worklogs is 
     * limited to 1000 elements. This API will not return worklogs deleted during last minute.
     *
     * @method getWorklogDeleted
     * @memberOf WorklogClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.since A date time in unix timestamp format since when deleted worklogs will be returned.
     *      Default: 0
     * @param [callback] Called when the search results are retrieved.
     * @return {Promise} Resolved when the search results are retrieved.
     */ 
    this.getWorklogDeleted = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/worklog/deleted'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                since: opts.since
            }
        };
        return this.jiraClient.makeRequest(options, callback)
    };

    /**
     * Returns Returns worklogs for given worklog ids. Only worklogs to which the calling user has permissions, 
     * will be included in the result. The returns set of worklogs is limited to 1000 elements.
     *
     * @method worklogList
     * @memberOf WorklogClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {array} [opts.ids] a JSON array named ids which contains a list of issue IDs
     * @param [callback] Called when the search results are retrieved.
     * @return {Promise} Resolved when the search results are retrieved.
     */ 
    this.worklogList = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/worklog/list'),
            method: 'POST',
            json: true,
            followAllRedirects: true,
            body: {
                ids: opts.ids
            }
        };
        return this.jiraClient.makeRequest(options, callback)
    };

    /**
     * Returns worklogs id and update time of worklogs that were updated since given time. The returns set of worklogs is 
     * limited to 1000 elements. This API will not return worklogs deleted during last minute.
     *
     * @method getWorklogDeleted
     * @memberOf WorklogClient#
     * @param {Object} opts The request options sent to the Jira API
     * @param {number} opts.since A date time in unix timestamp format since when updated worklogs will be returned.
     *      Default: 0
     * @param [callback] Called when the search results are retrieved.
     * @return {Promise} Resolved when the search results are retrieved.
     */ 
    this.getWorklogUpdated = function (opts, callback) {
        var options = {
            uri: this.jiraClient.buildURL('/worklog/updated'),
            method: 'GET',
            json: true,
            followAllRedirects: true,
            qs: {
                since: opts.since
            }
        };
        return this.jiraClient.makeRequest(options, callback)
    }
}


/***/ }),

/***/ "./node_modules/jira-connector/index.js":
/*!**********************************************!*\
  !*** ./node_modules/jira-connector/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Core packages
var url = __webpack_require__(/*! url */ "url");

// Npm packages
var request = __webpack_require__(/*! request */ "./node_modules/request/index.js");

// Custom packages
var applicationProperties = __webpack_require__(/*! ./api/application-properties */ "./node_modules/jira-connector/api/application-properties.js");
var attachment = __webpack_require__(/*! ./api/attachment */ "./node_modules/jira-connector/api/attachment.js");
var auditing = __webpack_require__(/*! ./api/auditing */ "./node_modules/jira-connector/api/auditing.js");
var auth = __webpack_require__(/*! ./api/auth */ "./node_modules/jira-connector/api/auth.js");
var avatar = __webpack_require__(/*! ./api/avatar */ "./node_modules/jira-connector/api/avatar.js");
var board = __webpack_require__(/*! ./api/board */ "./node_modules/jira-connector/api/board.js");
var comment = __webpack_require__(/*! ./api/comment */ "./node_modules/jira-connector/api/comment.js");
var component = __webpack_require__(/*! ./api/component */ "./node_modules/jira-connector/api/component.js");
var customFieldOption = __webpack_require__(/*! ./api/customFieldOption */ "./node_modules/jira-connector/api/customFieldOption.js");
var dashboard = __webpack_require__(/*! ./api/dashboard */ "./node_modules/jira-connector/api/dashboard.js");
var errorStrings = __webpack_require__(/*! ./lib/error */ "./node_modules/jira-connector/lib/error.js");
var field = __webpack_require__(/*! ./api/field */ "./node_modules/jira-connector/api/field.js");
var filter = __webpack_require__(/*! ./api/filter */ "./node_modules/jira-connector/api/filter.js");
var group = __webpack_require__(/*! ./api/group */ "./node_modules/jira-connector/api/group.js");
var groupUserPicker = __webpack_require__(/*! ./api/groupUserPicker */ "./node_modules/jira-connector/api/groupUserPicker.js");
var groups = __webpack_require__(/*! ./api/groups */ "./node_modules/jira-connector/api/groups.js");
var issue = __webpack_require__(/*! ./api/issue */ "./node_modules/jira-connector/api/issue.js");
var issueLink = __webpack_require__(/*! ./api/issueLink */ "./node_modules/jira-connector/api/issueLink.js");
var issueLinkType = __webpack_require__(/*! ./api/issueLinkType */ "./node_modules/jira-connector/api/issueLinkType.js");
var issueType = __webpack_require__(/*! ./api/issueType */ "./node_modules/jira-connector/api/issueType.js");
var jql = __webpack_require__(/*! ./api/jql */ "./node_modules/jira-connector/api/jql.js");
var licenseRole = __webpack_require__(/*! ./api/licenseRole */ "./node_modules/jira-connector/api/licenseRole.js");
var licenseValidator = __webpack_require__(/*! ./api/licenseValidator */ "./node_modules/jira-connector/api/licenseValidator.js");
var myPermissions = __webpack_require__(/*! ./api/myPermissions */ "./node_modules/jira-connector/api/myPermissions.js");
var myPreferences = __webpack_require__(/*! ./api/myPreferences */ "./node_modules/jira-connector/api/myPreferences.js");
var myself = __webpack_require__(/*! ./api/myself */ "./node_modules/jira-connector/api/myself.js");
var oauth_util = __webpack_require__(/*! ./lib/oauth_util */ "./node_modules/jira-connector/lib/oauth_util.js");
var password = __webpack_require__(/*! ./api/password */ "./node_modules/jira-connector/api/password.js");
var permissions = __webpack_require__(/*! ./api/permissions */ "./node_modules/jira-connector/api/permissions.js");
var permissionScheme = __webpack_require__(/*! ./api/permission-scheme */ "./node_modules/jira-connector/api/permission-scheme.js");
var priority = __webpack_require__(/*! ./api/priority */ "./node_modules/jira-connector/api/priority.js");
var project = __webpack_require__(/*! ./api/project */ "./node_modules/jira-connector/api/project.js");
var projectCategory = __webpack_require__(/*! ./api/projectCategory */ "./node_modules/jira-connector/api/projectCategory.js");
var projectValidate = __webpack_require__(/*! ./api/projectValidate */ "./node_modules/jira-connector/api/projectValidate.js");
var reindex = __webpack_require__(/*! ./api/reindex */ "./node_modules/jira-connector/api/reindex.js");
var resolution = __webpack_require__(/*! ./api/resolution */ "./node_modules/jira-connector/api/resolution.js");
var roles = __webpack_require__(/*! ./api/roles */ "./node_modules/jira-connector/api/roles.js");
var screens = __webpack_require__(/*! ./api/screens */ "./node_modules/jira-connector/api/screens.js");
var search = __webpack_require__(/*! ./api/search */ "./node_modules/jira-connector/api/search.js");
var securityLevel = __webpack_require__(/*! ./api/securityLevel */ "./node_modules/jira-connector/api/securityLevel.js");
var serverInfo = __webpack_require__(/*! ./api/serverInfo */ "./node_modules/jira-connector/api/serverInfo.js");
var settings = __webpack_require__(/*! ./api/settings */ "./node_modules/jira-connector/api/settings.js");
var sprint = __webpack_require__(/*! ./api/sprint */ "./node_modules/jira-connector/api/sprint.js");
var status = __webpack_require__(/*! ./api/status */ "./node_modules/jira-connector/api/status.js");
var statusCategory = __webpack_require__(/*! ./api/statusCategory */ "./node_modules/jira-connector/api/statusCategory.js");
var user = __webpack_require__(/*! ./api/user */ "./node_modules/jira-connector/api/user.js");
var version = __webpack_require__(/*! ./api/version */ "./node_modules/jira-connector/api/version.js");
var webhook = __webpack_require__(/*! ./api/webhook */ "./node_modules/jira-connector/api/webhook.js");
var workflow = __webpack_require__(/*! ./api/workflow */ "./node_modules/jira-connector/api/workflow.js");
var workflowScheme = __webpack_require__(/*! ./api/workflowScheme */ "./node_modules/jira-connector/api/workflowScheme.js");
var worklog = __webpack_require__(/*! ./api/worklog */ "./node_modules/jira-connector/api/worklog.js");

/**
 * Represents a client for the Jira REST API
 *
 * @constructor JiraClient
 * @property {AgileBoardClient} board
 * @property {AgileSprintClient} sprint
 *
 * @property {ApplicationPropertiesClient} applicationProperties
 * @property {AttachmentClient} attachment
 * @property {AuditingClient} auditing
 * @property {AuthClient} auth
 * @property {AvatarClient} avatar
 * @property {CommentClient} comment
 * @property {ComponentClient} component
 * @property {CustomFieldOptionClient} customFieldOption
 * @property {DashboardClient} dashboard
 * @property {FieldClient} field
 * @property {FilterClient} filter
 * @property {GroupClient} group
 * @property {GroupUserPickerClient} groupUserPicker
 * @property {GroupsClient} groups
 * @property {IssueClient} issue
 * @property {IssueLinkClient} issueLink
 * @property {IssueLinkTypeClient} issueLinkType
 * @property {IssueTypeClient} issueType
 * @property {JqlClient} jql
 * @property {LicenseRoleClient} licenseRole
 * @property {LicenseValidatorClient} licenseValidator
 * @property {MyPermissionsClient} myPermissions
 * @property {MyPreferencesClient} myPreferences
 * @property {MyselfClient} myself
 * @property {PasswordClient} password
 * @property {PermissionsClient} permissions
 * @property {PermissionSchemeClient} permissionScheme
 * @property {PriorityClient} priority
 * @property {ProjectCategoryClient} projectCategory
 * @property {ProjectClient} project
 * @property {ProjectValidateClient} projectValidate
 * @property {ReindexClient} reindex
 * @property {ResolutionClient} resolution
 * @property {RoleClient} roles
 * @property {ScreensClient} screens
 * @property {SearchClient} search
 * @property {SecurityLevelClient} securityLevel
 * @property {ServerInfoClient} serverInfo
 * @property {SettingsClient} settings
 * @property {StatusCategoryClient} statusCategory
 * @property {StatusClient} status
 * @property {UserClient} user
 * @property {VersionClient} version
 * @property {WebhookClient} webhook
 * @property {WorkflowClient} workflow
 * @property {WorkflowSchemeClient} workflowScheme
 * @property {WorklogClient} worklog
 *
 * @param config The information needed to access the Jira API
 * @param {string} config.host The hostname of the Jira API.
 * @param {string} [config.protocol=https] The protocol used to accses the Jira API.
 * @param {number} [config.port=443] The port number used to connect to Jira.
 * @param {string} [config.path_prefix="/"] The prefix to use in front of the path, if Jira isn't at "/"
 * @param {string} [config.version=2] The version of the Jira API to which you will be connecting.  Currently, only
 *     version 2 is supported.
 * @param config.auth The authentication information used tp connect to Jira. Must contain EITHER username and password
 *     OR oauth information.  Oauth information will be used over username/password authentication.
 * @param {string} [config.basic_auth.username] The username of the user that will be authenticated. MUST be included
 *     if using username and password authentication.
 * @param {string} [config.basic_auth.password] The password of the user that will be authenticated. MUST be included
 *     if using username and password authentication.
 * @param {string} [config.oauth.consumer_key] The consumer key used in the Jira Application Link for oauth
 *     authentication.  MUST be included if using OAuth.
 * @param {string} [config.oauth.private_key] The private key used for OAuth security. MUST be included if using OAuth.
 * @param {string} [config.oauth.token] The VERIFIED token used to connect to the Jira API.  MUST be included if using
 *     OAuth.
 * @param {string} [config.oauth.token_secret] The secret for the above token.  MUST be included if using Oauth.
 * @param {CookieJar} [config.cookie_jar] The CookieJar to use for every requests.
 * @param {Promise} [config.promise] Any function (constructor) compatible with Promise (bluebird, Q,...).
 *      Default - native Promise.
 * @param {Request} [config.request] Any function (constructor) compatible with Request (request, supertest,...).
 *      Default - require('request').
 */

var JiraClient = module.exports = function (config) {
    if(!config.host) {
        throw new Error(errorStrings.NO_HOST_ERROR);
    }
    this.host = config.host;
    this.protocol = config.protocol ? config.protocol : 'https';
    this.path_prefix = config.path_prefix ? config.path_prefix : '/';
    this.port = config.port;
    this.apiVersion = 2; // TODO Add support for other versions.
    this.agileApiVersion = '1.0';
    this.authApiVersion = '1';
    this.webhookApiVersion = '1.0';
    this.promise = config.promise || Promise;
    this.requestLib = config.request || request;
    this.rejectUnauthorized = config.rejectUnauthorized;

    if (config.oauth) {
        if (!config.oauth.consumer_key) {
            throw new Error(errorStrings.NO_CONSUMER_KEY_ERROR);
        } else if (!config.oauth.private_key) {
            throw new Error(errorStrings.NO_PRIVATE_KEY_ERROR);
        } else if (!config.oauth.token) {
            throw new Error(errorStrings.NO_OAUTH_TOKEN_ERROR);
        } else if (!config.oauth.token_secret) {
            throw new Error(errorStrings.NO_OAUTH_TOKEN_SECRET_ERROR);
        }

        this.oauthConfig = config.oauth;
        this.oauthConfig.signature_method = 'RSA-SHA1';

    } else if (config.basic_auth) {
        if (config.basic_auth.base64) {
            this.basic_auth = {
              base64: config.basic_auth.base64
            }
        } else {
            if (!config.basic_auth.username) {
                throw new Error(errorStrings.NO_USERNAME_ERROR);
            } else if (!config.basic_auth.password) {
                throw new Error(errorStrings.NO_PASSWORD_ERROR);
            }

            this.basic_auth = {
                user: config.basic_auth.username,
                pass: config.basic_auth.password
            };
        }
    }

    if (config.cookie_jar) {
        this.cookie_jar = config.cookie_jar;
    }

    this.applicationProperties = new applicationProperties(this);
    this.attachment = new attachment(this);
    this.auditing = new auditing(this);
    this.auth = new auth(this);
    this.avatar = new avatar(this);
    this.board = new board(this);
    this.comment = new comment(this);
    this.component = new component(this);
    this.customFieldOption = new customFieldOption(this);
    this.dashboard = new dashboard(this);
    this.field = new field(this);
    this.filter = new filter(this);
    this.group = new group(this);
    this.groupUserPicker = new groupUserPicker(this);
    this.groups = new groups(this);
    this.issue = new issue(this);
    this.issueLink = new issueLink(this);
    this.issueLinkType = new issueLinkType(this);
    this.issueType = new issueType(this);
    this.jql = new jql(this);
    this.licenseRole = new licenseRole(this);
    this.licenseValidator = new licenseValidator(this);
    this.myPermissions = new myPermissions(this);
    this.myPreferences = new myPreferences(this);
    this.myself = new myself(this);
    this.password = new password(this);
    this.permissions = new permissions(this);
    this.permissionScheme = new permissionScheme(this);
    this.priority = new priority(this);
    this.project = new project(this);
    this.projectCategory = new projectCategory(this);
    this.projectValidate = new projectValidate(this);
    this.reindex = new reindex(this);
    this.resolution = new resolution(this);
    this.roles = new roles(this);
    this.screens = new screens(this);
    this.search = new search(this);
    this.securityLevel = new securityLevel(this);
    this.serverInfo = new serverInfo(this);
    this.settings = new settings(this);
    this.sprint = new sprint(this);
    this.status = new status(this);
    this.statusCategory = new statusCategory(this);
    this.user = new user(this);
    this.version = new version(this);
    this.webhook = new webhook(this);
    this.workflow = new workflow(this);
    this.workflowScheme = new workflowScheme(this);
    this.worklog = new worklog(this);
};

(function () {

    /**
     * Simple utility to build a REST endpoint URL for the Jira API.
     *
     * @method buildURL
     * @memberOf JiraClient#
     * @param path The path of the URL without concern for the root of the REST API.
     * @returns {string} The constructed URL.
     */
    this.buildURL = function (path) {
        var apiBasePath = this.path_prefix + 'rest/api/';
        var version = this.apiVersion;
        var requestUrl = url.format({
            protocol: this.protocol,
            hostname: this.host,
            port: this.port,
            pathname: apiBasePath + version + path
        });

        return decodeURIComponent(requestUrl);
    };

    /**
     * Simple utility to build a REST endpoint URL for the Jira Agile API.
     *
     * @method buildAgileURL
     * @memberOf JiraClient#
     * @param path The path of the URL without concern for the root of the REST API.
     * @returns {string} The constructed URL.
     */
    this.buildAgileURL = function (path) {
        var apiBasePath = this.path_prefix + 'rest/agile/';
        var version = this.agileApiVersion;
        var requestUrl = url.format({
            protocol: this.protocol,
            hostname: this.host,
            port: this.port,
            pathname: apiBasePath + version + path
        });

        return decodeURIComponent(requestUrl);
    };

    /**
     * Simple utility to build a REST endpoint URL for the Jira Auth API.
     *
     * @method buildAuthURL
     * @memberOf JiraClient#
     * @param path The path of the URL without concern for the root of the REST API.
     * @returns {string} The constructed URL.
     */
    this.buildAuthURL = function (path) {
        var apiBasePath = this.path_prefix + 'rest/auth/';
        var version = this.authApiVersion;
        var requestUrl = url.format({
            protocol: this.protocol,
            hostname: this.host,
            port: this.port,
            pathname: apiBasePath + version + path
        });

        return decodeURIComponent(requestUrl);
    };

    /**
     * Simple utility to build a REST endpoint URL for the Jira webhook API.
     *
     * @method buildWebhookURL
     * @memberOf JiraClient#
     * @param path The path of the URL without concern for the root of the REST API.
     * @returns {string} The constructed URL.
     */
    this.buildWebhookURL = function (path) {
        var apiBasePath = this.path_prefix + 'rest/webhooks/';
        var version = this.webhookApiVersion;
        var requestUrl = url.format({
            protocol: this.protocol,
            hostname: this.host,
            port: this.port,
            pathname: apiBasePath + version + path
        });

        return decodeURIComponent(requestUrl);
    };

    /**
     * Make a request to the Jira API and call back with it's response.
     *
     * @method makeRequest
     * @memberOf JiraClient#
     * @param options The request options.
     * @param [callback] Called with the APIs response.
     * @param {string} [successString] If supplied, this is reported instead of the response body.
     * @return {Promise} Resolved with APIs response or rejected with error
     */
    this.makeRequest = function (options, callback, successString) {
        let requestLib = this.requestLib;
        options.rejectUnauthorized = this.rejectUnauthorized;

        if (this.oauthConfig) {
            options.oauth = this.oauthConfig;
        } else if (this.basic_auth) {
            if (this.basic_auth.base64) {
              if (!options.headers) {
                options.headers = {}
              }
              options.headers['Authorization'] = 'Basic ' + this.basic_auth.base64
            } else {
              options.auth = this.basic_auth;
            }
        }
        if (this.cookie_jar) {
            options.jar = this.cookie_jar;
        }

        if (callback) {
            requestLib(options, function (err, response, body) {
                if (err || response.statusCode.toString()[0] != 2) {
                    return callback(err ? err : body, null, response);
                }

            if (typeof body == 'string') {
                try {
                    body = JSON.parse(body);
                } catch (jsonErr) {
                    return callback(jsonErr, null, response);
                }
            }

                return callback(null, successString ? successString : body, response);
            });
        } else if (this.promise) {
            return new this.promise(function (resolve, reject) {

                var req = requestLib(options);
                var requestObj = null;

                req.on('request', function(request) {
                  requestObj = request;
                });

                req.on('response', function(response) {

                    // Saving error
                    var error = response.statusCode.toString()[0] !== '2';

                    // Collecting data
                    var body = [];
                    var push = body.push.bind(body);
                    response.on('data', push);

                    // Data collected
                    response.on('end', function () {

                        var result = body.join('');

                        // Parsing JSON
                        if (result[0] === '[' || result[0] === '{') {
                            try {
                                result = JSON.parse(result);
                            } catch(e) {
                                // nothing to do
                            }
                        }

                        if (error) {
                            response.body = result;
                            if (options.debug) {
                              reject({
                                result: JSON.stringify(response),
                                debug: {
                                  options: options,
                                  request: {
                                    headers: requestObj._headers,
                                  },
                                  response: {
                                    headers: response.headers,
                                  },
                                }
                              });
                            } else {
                              reject(JSON.stringify(response));
                            }
                            return;
                        }

                      if (options.debug) {
                        resolve({
                          result,
                          debug: {
                            options: options,
                            request: {
                              headers: requestObj._headers,
                            },
                            response: {
                              headers: response.headers,
                            },
                          }
                        });
                      } else {
                        resolve(result);
                      }
                    });

                });

                req.on('error', reject);

            });
        }

    };

}).call(JiraClient.prototype);

JiraClient.oauth_util = __webpack_require__(/*! ./lib/oauth_util */ "./node_modules/jira-connector/lib/oauth_util.js");

exports.oauth_util = oauth_util;


/***/ }),

/***/ "./node_modules/jira-connector/lib/error.js":
/*!**************************************************!*\
  !*** ./node_modules/jira-connector/lib/error.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.NO_HOST_ERROR = 'Missing \'host\' property.';
exports.NO_CONSUMER_KEY_ERROR = 'Missing \'oauth_consumer_key\' property.';
exports.NO_PRIVATE_KEY_ERROR = 'Missing \'oauth_private_key\' property.';
exports.NO_OAUTH_TOKEN_ERROR = 'Missing \'oauth_token\' property.';
exports.NO_OAUTH_TOKEN_SECRET_ERROR = 'Missing \'oauth_token_secret\' property.';
exports.NO_USERNAME_ERROR = 'Missing \'username\' property.';
exports.NO_PASSWORD_ERROR = 'Missing \'password\' property.';
exports.NO_AUTHENTICATION_ERROR = 'Missing \'auth\' property.';
exports.NO_VERIFIER_ERROR = 'Missing \'oauth_verifier\' property.';
exports.INVALID_AUTHENTICATION_PROPERTY_ERROR = 'Invalid \'auth\' property.';
exports.NO_ISSUE_IDENTIFIER = 'Missing Issue ID or Key';
exports.NO_COMMENT_ID = 'Missing \'commentID\' property.';
exports.NO_COMMENT_ERROR = 'Missing \'comment\' property.';
exports.NO_NOTIFICATION_ERROR = 'Missing \'notification\' property';
exports.NO_GLOBAL_ID_ERROR = 'Missing \'globalId\' property.';
exports.NO_LINK_ID_ERROR = 'Missing \'linkId\' property.';
exports.NO_TRANSITION_ERROR = 'Missing \'transition\' property.';
exports.NO_ISSUE_ERROR = 'Missing \'issue\' property';
exports.NO_ASSIGNEE_ERROR = 'Missing \'assignee\' property';
exports.NO_WATCHER_ERROR = 'Missing \'watcher\' property';
exports.NO_WORKLOG_ERROR = 'Missing \'worklog\' property';
exports.NO_WORKLOG_ID_ERROR = 'Missing \'worklogId\' property';
exports.NO_FILENAME_ERROR = 'Missing \'filename\' property';
exports.NO_PROPERTY_KEY_ERROR = 'Missing \'propertyKey\' property';
exports.NO_PROPERTY_VALUE_ERROR = 'Missing \'propertyValue\' property';
exports.NO_ATTACHMENT_ID_ERROR = 'Missing \'attachmentId\' property';
exports.NO_AUDIT_ERROR = 'Missing \'audit\' property';
exports.NO_AVATAR_TYPE_ERROR = 'Missing \'avatarType\' property';
exports.NO_COMMENT_PROPERTY_KEY_ERROR = 'Missing \'propertyKey\' property';
exports.NO_COMMENT_PROPERTY_VALUE_ERROR = 'Missing \'propertyValue\' property';
exports.NO_ISSUE_LINK_ERROR = 'Missing\'issueLink\' property';
exports.NO_ISSUE_LINK_ID_ERROR = 'Missing\'linkId\' property';
exports.NO_ISSUE_LINK_TYPE_ID = 'Missing \'issueLinkTypeId\' property.';
exports.NO_FIELD_OPTION_ID_ERROR = 'Missing \'fieldOptionId\' property.';

/***/ }),

/***/ "./node_modules/jira-connector/lib/oauth_util.js":
/*!*******************************************************!*\
  !*** ./node_modules/jira-connector/lib/oauth_util.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// npm packages
var Oauth = __webpack_require__(/*! oauth */ "./node_modules/oauth/index.js");

// Core packages
var url = __webpack_require__(/*! url */ "url");

// Custom Packages
var errorStrings = __webpack_require__(/*! ./error */ "./node_modules/jira-connector/lib/error.js");

/**
 * @namespace OauthUtil
 */

/**
 * Attempts to get an OAuth verification URL using the given API configuration.
 *
 * @memberOf OauthUtil
 * @param {Object} config The information needed to access the Jira API
 * @param {string} config.host The hostname of the Jira API.
 * @param {string} [config.protocol=https] - The protocol used to accses the Jira API.
 * @param {number} [config.port=443] - The port number used to connect to Jira.
 * @param {string} [config.path_prefix="/"] The prefix to use in front of the path, if Jira isn't at "/"
 * @param {string} [config.version=2] - The version of the Jira API to which you will be connecting.  Currently, only
 *     version 2 is supported.
 * @param {Object} config.oauth The oauth information
 * @param {string} config.oauth.consumer_key The consumer key of the application accessing Jira.
 * @param {string} config.oauth.private_key The private key of the application accessing Jira.
 * @param {string} [config.oauth.callback_url] The callback URL to be called after the token is generated.  If this is
 *     not included, the user will be given a verification code after authorizing the token, instead of Jira making a
 *     callback to the application.
 * @param {OauthUtil~getOauthUrlCallback} callback The function called when the URL has been retrieved.
 */
exports.getAuthorizeURL = function (config, callback) {
    var prefix = config.path_prefix ? config.path_prefix : '';
    var AUTH_TOKEN_APPEND = '/oauth/authorize';
    var SERVLET_BASE_URL = prefix + '/plugins/servlet';

    var authURL = url.format({
        protocol: config.protocol ? config.protocol : 'https',
        hostname: config.host,
        port: config.port ? config.port : null,
        pathname: SERVLET_BASE_URL + AUTH_TOKEN_APPEND
    });

    var oauth = generateOAuthObject(config);

    oauth.getOAuthRequestToken(function (err, token, token_secret) {
        if (err) {
            return callback(err);
        }
        return callback(null, {url: authURL + "?oauth_token=" + token, token: token, token_secret: token_secret});
    });
};

/**
 * Given an OAuth token, the token secret, and an access verification code (provided by Jira), swap an OAuth request
 * token with an OAuth access token.
 *
 * @memberOf OauthUtil
 * @param {Object} config The information needed to access the Jira API
 * @param {string} config.host The hostname of the Jira API.
 * @param {string} [config.protocol=https] - The protocol used to accses the Jira API.
 * @param {number} [config.port=443] - The port number used to connect to Jira.
 * @param {string} [config.version=2] - The version of the Jira API to which you will be connecting.  Currently, only
 *     version 2 is supported.
 * @param {Object} config.oauth The oauth information
 * @param {string} config.oauth.consumer_key The consumer key of the application accessing Jira.
 * @param {string} config.oauth.private_key The private key of the application accessing Jira.
 * @param {string} config.oauth.token The OAuth Token supplied by Jira.
 * @param {string} config.oauth.token_secret The OAuth Token secret supplied by Jira.
 * @param {string} config.oauth.oauth_verifier The verified code given to the user after authorizing the OAuth token.
 * @param {OauthUtil~swapRequestTokenCallback} callback The function called when the token has been swapped.
 */
exports.swapRequestTokenWithAccessToken = function(config, callback) {
    if(!config.oauth.oauth_verifier) {
        throw new Error(errorStrings.NO_VERIFIER_ERROR);
    }

    var oauth = generateOAuthObject(config);

    var token = config.oauth.token;
    var secret = config.oauth.token_secret;
    var verifier = config.oauth.oauth_verifier;

    oauth.getOAuthAccessToken(token, secret, verifier, callback);
};

/**
 * Utility function to generate an OAuth object.
 *
 * @memberOf OauthUtil
 * @param {Object} config The information needed to access the Jira API
 * @param {string} config.host The hostname of the Jira API.
 * @param {string} [config.protocol=https] - The protocol used to accses the Jira API.
 * @param {number} [config.port=443] - The port number used to connect to Jira.
 * @param {string} [config.path_prefix="/"] The prefix to use in front of the path, if Jira isn't at "/"
 * @param {string} [config.version=2] - The version of the Jira API to which you will be connecting.  Currently, only
 *     version 2 is supported.
 * @param {Object} config.oauth The oauth information
 * @param {string} config.oauth.consumer_key The consumer key of the application accessing Jira.
 * @param {string} config.oauth.private_key The private key of the application accessing Jira.
 * @param {string} [config.oauth.callback_url] The callback URL to be called after the token is generated.  If this is
 *     not included, the user will be given a verification code after authorizing the token, instead of Jira making a
 *     callback to the application.
 *
 * @returns {exports.OAuth} The generated object.
 */
function generateOAuthObject(config) {
    var prefix = config.path_prefix ? config.path_prefix : '';
    var SERVLET_BASE_URL = prefix + '/plugins/servlet';
    var REQ_TOKEN_APPEND = '/oauth/request-token';

    var ACCESS_TOKEN_APPEND = '/oauth/access-token';
    var sig = 'RSA-SHA1';

    if (!config.host) {
        throw new Error(errorStrings.NO_HOST_ERROR);
    } else if (!config.oauth.consumer_key) {
        throw new Error(errorStrings.NO_CONSUMER_KEY_ERROR);
    } else if (!config.oauth.private_key) {
        throw new Error(errorStrings.NO_PRIVATE_KEY_ERROR);
    }

    var consumer_key = config.oauth.consumer_key;
    var private_key = config.oauth.private_key;

    var reqURL = url.format({
        protocol: config.protocol ? config.protocol : 'https',
        hostname: config.host,
        port: config.port ? config.port : null,
        pathname: SERVLET_BASE_URL + REQ_TOKEN_APPEND
    });

    var accessURL = url.format({
        protocol: config.protocol ? config.protocol : 'https',
        hostname: config.host,
        port: config.port ? config.port : null,
        pathname: SERVLET_BASE_URL + ACCESS_TOKEN_APPEND
    });

    var cb = config.oauth.callback_url ? config.oauth.callback_url : 'oob';

    return new Oauth.OAuth(reqURL, accessURL, consumer_key, private_key, '1.0', cb, sig);
}

/**
 * Callback used by getOauthUrl.
 * @callback OauthUtil~getOauthUrlCallback
 * @param {*} error The error which occurred, if any.
 * @param {Object} oauth The OAuth information retrieved from the Jira API.
 * @param {String} oauth.url The URL that should be visited by the user to verify the OAuth access.
 * @param {String} oauth.token The OAuth Token retrieved from the Jira API.
 * @param {String} oauth.token_secret The OAuth Token Secret retrieved from the Jira API.
 */

/**
 * Callback used by swapRequestTokenWithAccessToken
 * @callback OauthUtil~swapRequestTokenCallback
 * @param {*} error The error which occurred, if any.
 * @param {string} access_token The access token retrieved from Jira.
 */


/***/ }),

/***/ "./node_modules/jsbn/index.js":
/*!************************************!*\
  !*** ./node_modules/jsbn/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function(){

    // Copyright (c) 2005  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Basic JavaScript BN library - subset useful for RSA encryption.

    // Bits per digit
    var dbits;

    // JavaScript engine analysis
    var canary = 0xdeadbeefcafe;
    var j_lm = ((canary&0xffffff)==0xefcafe);

    // (public) Constructor
    function BigInteger(a,b,c) {
      if(a != null)
        if("number" == typeof a) this.fromNumber(a,b,c);
        else if(b == null && "string" != typeof a) this.fromString(a,256);
        else this.fromString(a,b);
    }

    // return new, unset BigInteger
    function nbi() { return new BigInteger(null); }

    // am: Compute w_j += (x*this_i), propagate carries,
    // c is initial carry, returns final carry.
    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
    // We need to select the fastest one that works in this environment.

    // am1: use a single mult and divide to get the high bits,
    // max digit bits should be 26 because
    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
    function am1(i,x,w,j,c,n) {
      while(--n >= 0) {
        var v = x*this[i++]+w[j]+c;
        c = Math.floor(v/0x4000000);
        w[j++] = v&0x3ffffff;
      }
      return c;
    }
    // am2 avoids a big mult-and-extract completely.
    // Max digit bits should be <= 30 because we do bitwise ops
    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
    function am2(i,x,w,j,c,n) {
      var xl = x&0x7fff, xh = x>>15;
      while(--n >= 0) {
        var l = this[i]&0x7fff;
        var h = this[i++]>>15;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
        w[j++] = l&0x3fffffff;
      }
      return c;
    }
    // Alternately, set max digit bits to 28 since some
    // browsers slow down when dealing with 32-bit numbers.
    function am3(i,x,w,j,c,n) {
      var xl = x&0x3fff, xh = x>>14;
      while(--n >= 0) {
        var l = this[i]&0x3fff;
        var h = this[i++]>>14;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x3fff)<<14)+w[j]+c;
        c = (l>>28)+(m>>14)+xh*h;
        w[j++] = l&0xfffffff;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
      BigInteger.prototype.am = am2;
      dbits = 30;
    }
    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {
      BigInteger.prototype.am = am1;
      dbits = 26;
    }
    else { // Mozilla/Netscape seems to prefer am3
      BigInteger.prototype.am = am3;
      dbits = 28;
    }

    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = ((1<<dbits)-1);
    BigInteger.prototype.DV = (1<<dbits);

    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2,BI_FP);
    BigInteger.prototype.F1 = BI_FP-dbits;
    BigInteger.prototype.F2 = 2*dbits-BI_FP;

    // Digit conversions
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr,vv;
    rr = "0".charCodeAt(0);
    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

    function int2char(n) { return BI_RM.charAt(n); }
    function intAt(s,i) {
      var c = BI_RC[s.charCodeAt(i)];
      return (c==null)?-1:c;
    }

    // (protected) copy this to r
    function bnpCopyTo(r) {
      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }

    // (protected) set from integer value x, -DV <= x < DV
    function bnpFromInt(x) {
      this.t = 1;
      this.s = (x<0)?-1:0;
      if(x > 0) this[0] = x;
      else if(x < -1) this[0] = x+this.DV;
      else this.t = 0;
    }

    // return bigint initialized to value
    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

    // (protected) set from string and radix
    function bnpFromString(s,b) {
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 256) k = 8; // byte array
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else { this.fromRadix(s,b); return; }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while(--i >= 0) {
        var x = (k==8)?s[i]&0xff:intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-") mi = true;
          continue;
        }
        mi = false;
        if(sh == 0)
          this[this.t++] = x;
        else if(sh+k > this.DB) {
          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
          this[this.t++] = (x>>(this.DB-sh));
        }
        else
          this[this.t-1] |= x<<sh;
        sh += k;
        if(sh >= this.DB) sh -= this.DB;
      }
      if(k == 8 && (s[0]&0x80) != 0) {
        this.s = -1;
        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
      }
      this.clamp();
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) clamp off excess high words
    function bnpClamp() {
      var c = this.s&this.DM;
      while(this.t > 0 && this[this.t-1] == c) --this.t;
    }

    // (public) return string representation in given radix
    function bnToString(b) {
      if(this.s < 0) return "-"+this.negate().toString(b);
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1<<k)-1, d, m = false, r = "", i = this.t;
      var p = this.DB-(i*this.DB)%k;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
        while(i >= 0) {
          if(p < k) {
            d = (this[i]&((1<<p)-1))<<(k-p);
            d |= this[--i]>>(p+=this.DB-k);
          }
          else {
            d = (this[i]>>(p-=k))&km;
            if(p <= 0) { p += this.DB; --i; }
          }
          if(d > 0) m = true;
          if(m) r += int2char(d);
        }
      }
      return m?r:"0";
    }

    // (public) -this
    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

    // (public) |this|
    function bnAbs() { return (this.s<0)?this.negate():this; }

    // (public) return + if this > a, - if this < a, 0 if equal
    function bnCompareTo(a) {
      var r = this.s-a.s;
      if(r != 0) return r;
      var i = this.t;
      r = i-a.t;
      if(r != 0) return (this.s<0)?-r:r;
      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
      return 0;
    }

    // returns bit length of the integer x
    function nbits(x) {
      var r = 1, t;
      if((t=x>>>16) != 0) { x = t; r += 16; }
      if((t=x>>8) != 0) { x = t; r += 8; }
      if((t=x>>4) != 0) { x = t; r += 4; }
      if((t=x>>2) != 0) { x = t; r += 2; }
      if((t=x>>1) != 0) { x = t; r += 1; }
      return r;
    }

    // (public) return the number of bits in "this"
    function bnBitLength() {
      if(this.t <= 0) return 0;
      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
    }

    // (protected) r = this << n*DB
    function bnpDLShiftTo(n,r) {
      var i;
      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
      for(i = n-1; i >= 0; --i) r[i] = 0;
      r.t = this.t+n;
      r.s = this.s;
    }

    // (protected) r = this >> n*DB
    function bnpDRShiftTo(n,r) {
      for(var i = n; i < this.t; ++i) r[i-n] = this[i];
      r.t = Math.max(this.t-n,0);
      r.s = this.s;
    }

    // (protected) r = this << n
    function bnpLShiftTo(n,r) {
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<cbs)-1;
      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
      for(i = this.t-1; i >= 0; --i) {
        r[i+ds+1] = (this[i]>>cbs)|c;
        c = (this[i]&bm)<<bs;
      }
      for(i = ds-1; i >= 0; --i) r[i] = 0;
      r[ds] = c;
      r.t = this.t+ds+1;
      r.s = this.s;
      r.clamp();
    }

    // (protected) r = this >> n
    function bnpRShiftTo(n,r) {
      r.s = this.s;
      var ds = Math.floor(n/this.DB);
      if(ds >= this.t) { r.t = 0; return; }
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<bs)-1;
      r[0] = this[ds]>>bs;
      for(var i = ds+1; i < this.t; ++i) {
        r[i-ds-1] |= (this[i]&bm)<<cbs;
        r[i-ds] = this[i]>>bs;
      }
      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
      r.t = this.t-ds;
      r.clamp();
    }

    // (protected) r = this - a
    function bnpSubTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]-a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c -= a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c -= a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = (c<0)?-1:0;
      if(c < -1) r[i++] = this.DV+c;
      else if(c > 0) r[i++] = c;
      r.t = i;
      r.clamp();
    }

    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    function bnpMultiplyTo(a,r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i+y.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
      r.s = 0;
      r.clamp();
      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
    }

    // (protected) r = this^2, r != this (HAC 14.16)
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2*x.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < x.t-1; ++i) {
        var c = x.am(i,x[i],r,2*i,0,1);
        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
          r[i+x.t] -= x.DV;
          r[i+x.t+1] = 1;
        }
      }
      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
      r.s = 0;
      r.clamp();
    }

    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    function bnpDivRemTo(m,q,r) {
      var pm = m.abs();
      if(pm.t <= 0) return;
      var pt = this.abs();
      if(pt.t < pm.t) {
        if(q != null) q.fromInt(0);
        if(r != null) this.copyTo(r);
        return;
      }
      if(r == null) r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
      else { pm.copyTo(y); pt.copyTo(r); }
      var ys = y.t;
      var y0 = y[ys-1];
      if(y0 == 0) return;
      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
      var i = r.t, j = i-ys, t = (q==null)?nbi():q;
      y.dlShiftTo(j,t);
      if(r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t,r);
      }
      BigInteger.ONE.dlShiftTo(ys,t);
      t.subTo(y,y);  // "negative" y so we can replace sub with am later
      while(y.t < ys) y[y.t++] = 0;
      while(--j >= 0) {
        // Estimate quotient digit
        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out
          y.dlShiftTo(j,t);
          r.subTo(t,r);
          while(r[i] < --qd) r.subTo(t,r);
        }
      }
      if(q != null) {
        r.drShiftTo(ys,q);
        if(ts != ms) BigInteger.ZERO.subTo(q,q);
      }
      r.t = ys;
      r.clamp();
      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder
      if(ts < 0) BigInteger.ZERO.subTo(r,r);
    }

    // (public) this mod a
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a,null,r);
      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
      return r;
    }

    // Modular reduction using "classic" algorithm
    function Classic(m) { this.m = m; }
    function cConvert(x) {
      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert(x) { return x; }
    function cReduce(x) { x.divRemTo(this.m,null,x); }
    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;

    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    function bnpInvDigit() {
      if(this.t < 1) return 0;
      var x = this[0];
      if((x&1) == 0) return 0;
      var y = x&3;       // y == 1/x mod 2^2
      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4
      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8
      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16
      // last step - calculate inverse mod DV directly;
      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
      // we really want the negative inverse, and -DV < y < DV
      return (y>0)?this.DV-y:-y;
    }

    // Montgomery reduction
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp&0x7fff;
      this.mph = this.mp>>15;
      this.um = (1<<(m.DB-15))-1;
      this.mt2 = 2*m.t;
    }

    // xR mod m
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t,r);
      r.divRemTo(this.m,null,r);
      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
      return r;
    }

    // x/R mod m
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }

    // x = x/R mod m (HAC 14.32)
    function montReduce(x) {
      while(x.t <= this.mt2) // pad x so am has enough room later
        x[x.t++] = 0;
      for(var i = 0; i < this.m.t; ++i) {
        // faster way of calculating u0 = x[i]*mp mod DV
        var j = x[i]&0x7fff;
        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
        // use am to combine the multiply-shift-add into one call
        j = i+this.m.t;
        x[j] += this.m.am(0,u0,x,i,0,this.m.t);
        // propagate carry
        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
      }
      x.clamp();
      x.drShiftTo(this.m.t,x);
      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = "x^2/R mod m"; x != r
    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = "xy/R mod m"; x,y != r
    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;

    // (protected) true iff this is even
    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    function bnpExp(e,z) {
      if(e > 0xffffffff || e < 1) return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
      g.copyTo(r);
      while(--i >= 0) {
        z.sqrTo(r,r2);
        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
        else { var t = r; r = r2; r2 = t; }
      }
      return z.revert(r);
    }

    // (public) this^e % m, 0 <= e < 2^32
    function bnModPowInt(e,m) {
      var z;
      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
      return this.exp(e,z);
    }

    // protected
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;

    // public
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;

    // "constants"
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);

    // Copyright (c) 2005-2009  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Extended JavaScript BN functions, required for RSA private ops.

    // Version 1.1: new BigInteger("0", 10) returns "proper" zero
    // Version 1.2: square() API, isProbablePrime fix

    // (public)
    function bnClone() { var r = nbi(); this.copyTo(r); return r; }

    // (public) return value as integer
    function bnIntValue() {
      if(this.s < 0) {
        if(this.t == 1) return this[0]-this.DV;
        else if(this.t == 0) return -1;
      }
      else if(this.t == 1) return this[0];
      else if(this.t == 0) return 0;
      // assumes 16 < DB < 32
      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
    }

    // (public) return value as byte
    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

    // (public) return value as short (assumes DB>=16)
    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

    // (protected) return x s.t. r^x < DV
    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

    // (public) 0 if this == 0, 1 if this > 0
    function bnSigNum() {
      if(this.s < 0) return -1;
      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
      else return 1;
    }

    // (protected) convert to radix string
    function bnpToRadix(b) {
      if(b == null) b = 10;
      if(this.signum() == 0 || b < 2 || b > 36) return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b,cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d,y,z);
      while(y.signum() > 0) {
        r = (a+z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d,y,z);
      }
      return z.intValue().toString(b) + r;
    }

    // (protected) convert from radix string
    function bnpFromRadix(s,b) {
      this.fromInt(0);
      if(b == null) b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
      for(var i = 0; i < s.length; ++i) {
        var x = intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w = b*w+x;
        if(++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w,0);
          j = 0;
          w = 0;
        }
      }
      if(j > 0) {
        this.dMultiply(Math.pow(b,j));
        this.dAddOffset(w,0);
      }
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) alternate constructor
    function bnpFromNumber(a,b,c) {
      if("number" == typeof b) {
        // new BigInteger(int,int,RNG)
        if(a < 2) this.fromInt(1);
        else {
          this.fromNumber(a,c);
          if(!this.testBit(a-1))	// force MSB set
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
          if(this.isEven()) this.dAddOffset(1,0); // force odd
          while(!this.isProbablePrime(b)) {
            this.dAddOffset(2,0);
            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
          }
        }
      }
      else {
        // new BigInteger(int,RNG)
        var x = new Array(), t = a&7;
        x.length = (a>>3)+1;
        b.nextBytes(x);
        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
        this.fromString(x,256);
      }
    }

    // (public) convert to bigendian byte array
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB-(i*this.DB)%8, d, k = 0;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
          r[k++] = d|(this.s<<(this.DB-p));
        while(i >= 0) {
          if(p < 8) {
            d = (this[i]&((1<<p)-1))<<(8-p);
            d |= this[--i]>>(p+=this.DB-8);
          }
          else {
            d = (this[i]>>(p-=8))&0xff;
            if(p <= 0) { p += this.DB; --i; }
          }
          if((d&0x80) != 0) d |= -256;
          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
          if(k > 0 || d != this.s) r[k++] = d;
        }
      }
      return r;
    }

    function bnEquals(a) { return(this.compareTo(a)==0); }
    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }

    // (protected) r = this op a (bitwise)
    function bnpBitwiseTo(a,op,r) {
      var i, f, m = Math.min(a.t,this.t);
      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
      if(a.t < this.t) {
        f = a.s&this.DM;
        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
        r.t = this.t;
      }
      else {
        f = this.s&this.DM;
        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
        r.t = a.t;
      }
      r.s = op(this.s,a.s);
      r.clamp();
    }

    // (public) this & a
    function op_and(x,y) { return x&y; }
    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

    // (public) this | a
    function op_or(x,y) { return x|y; }
    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

    // (public) this ^ a
    function op_xor(x,y) { return x^y; }
    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

    // (public) this & ~a
    function op_andnot(x,y) { return x&~y; }
    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

    // (public) ~this
    function bnNot() {
      var r = nbi();
      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }

    // (public) this << n
    function bnShiftLeft(n) {
      var r = nbi();
      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
      return r;
    }

    // (public) this >> n
    function bnShiftRight(n) {
      var r = nbi();
      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
      return r;
    }

    // return index of lowest 1-bit in x, x < 2^31
    function lbit(x) {
      if(x == 0) return -1;
      var r = 0;
      if((x&0xffff) == 0) { x >>= 16; r += 16; }
      if((x&0xff) == 0) { x >>= 8; r += 8; }
      if((x&0xf) == 0) { x >>= 4; r += 4; }
      if((x&3) == 0) { x >>= 2; r += 2; }
      if((x&1) == 0) ++r;
      return r;
    }

    // (public) returns index of lowest 1-bit (or -1 if none)
    function bnGetLowestSetBit() {
      for(var i = 0; i < this.t; ++i)
        if(this[i] != 0) return i*this.DB+lbit(this[i]);
      if(this.s < 0) return this.t*this.DB;
      return -1;
    }

    // return number of 1 bits in x
    function cbit(x) {
      var r = 0;
      while(x != 0) { x &= x-1; ++r; }
      return r;
    }

    // (public) return number of set bits
    function bnBitCount() {
      var r = 0, x = this.s&this.DM;
      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
      return r;
    }

    // (public) true iff nth bit is set
    function bnTestBit(n) {
      var j = Math.floor(n/this.DB);
      if(j >= this.t) return(this.s!=0);
      return((this[j]&(1<<(n%this.DB)))!=0);
    }

    // (protected) this op (1<<n)
    function bnpChangeBit(n,op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r,op,r);
      return r;
    }

    // (public) this | (1<<n)
    function bnSetBit(n) { return this.changeBit(n,op_or); }

    // (public) this & ~(1<<n)
    function bnClearBit(n) { return this.changeBit(n,op_andnot); }

    // (public) this ^ (1<<n)
    function bnFlipBit(n) { return this.changeBit(n,op_xor); }

    // (protected) r = this + a
    function bnpAddTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]+a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c += a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c += a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = (c<0)?-1:0;
      if(c > 0) r[i++] = c;
      else if(c < -1) r[i++] = this.DV+c;
      r.t = i;
      r.clamp();
    }

    // (public) this + a
    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

    // (public) this - a
    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

    // (public) this * a
    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

    // (public) this^2
    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

    // (public) this / a
    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

    // (public) this % a
    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

    // (public) [this/a,this%a]
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a,q,r);
      return new Array(q,r);
    }

    // (protected) this *= n, this >= 0, 1 < n < DV
    function bnpDMultiply(n) {
      this[this.t] = this.am(0,n-1,this,0,0,this.t);
      ++this.t;
      this.clamp();
    }

    // (protected) this += n << w words, this >= 0
    function bnpDAddOffset(n,w) {
      if(n == 0) return;
      while(this.t <= w) this[this.t++] = 0;
      this[w] += n;
      while(this[w] >= this.DV) {
        this[w] -= this.DV;
        if(++w >= this.t) this[this.t++] = 0;
        ++this[w];
      }
    }

    // A "null" reducer
    function NullExp() {}
    function nNop(x) { return x; }
    function nMulTo(x,y,r) { x.multiplyTo(y,r); }
    function nSqrTo(x,r) { x.squareTo(r); }

    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;

    // (public) this^e
    function bnPow(e) { return this.exp(e,new NullExp()); }

    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    function bnpMultiplyLowerTo(a,n,r) {
      var i = Math.min(this.t+a.t,n);
      r.s = 0; // assumes a,this >= 0
      r.t = i;
      while(i > 0) r[--i] = 0;
      var j;
      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
      r.clamp();
    }

    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    function bnpMultiplyUpperTo(a,n,r) {
      --n;
      var i = r.t = this.t+a.t-n;
      r.s = 0; // assumes a,this >= 0
      while(--i >= 0) r[i] = 0;
      for(i = Math.max(n-this.t,0); i < a.t; ++i)
        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
      r.clamp();
      r.drShiftTo(1,r);
    }

    // Barrett modular reduction
    function Barrett(m) {
      // setup Barrett
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }

    function barrettConvert(x) {
      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
      else if(x.compareTo(this.m) < 0) return x;
      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
    }

    function barrettRevert(x) { return x; }

    // x = x mod m (HAC 14.42)
    function barrettReduce(x) {
      x.drShiftTo(this.m.t-1,this.r2);
      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
      x.subTo(this.r2,x);
      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = x^2 mod m; x != r
    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = x*y mod m; x,y != r
    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;

    // (public) this^e % m (HAC 14.85)
    function bnModPow(e,m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if(i <= 0) return r;
      else if(i < 18) k = 1;
      else if(i < 48) k = 3;
      else if(i < 144) k = 4;
      else if(i < 768) k = 5;
      else k = 6;
      if(i < 8)
        z = new Classic(m);
      else if(m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);

      // precomputation
      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
      g[1] = z.convert(this);
      if(k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1],g2);
        while(n <= km) {
          g[n] = nbi();
          z.mulTo(g2,g[n-2],g[n]);
          n += 2;
        }
      }

      var j = e.t-1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e[j])-1;
      while(j >= 0) {
        if(i >= k1) w = (e[j]>>(i-k1))&km;
        else {
          w = (e[j]&((1<<(i+1))-1))<<(k1-i);
          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
        }

        n = k;
        while((w&1) == 0) { w >>= 1; --n; }
        if((i -= n) < 0) { i += this.DB; --j; }
        if(is1) {	// ret == 1, don't bother squaring or multiplying it
          g[w].copyTo(r);
          is1 = false;
        }
        else {
          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
          z.mulTo(r2,g[w],r);
        }

        while(j >= 0 && (e[j]&(1<<i)) == 0) {
          z.sqrTo(r,r2); t = r; r = r2; r2 = t;
          if(--i < 0) { i = this.DB-1; --j; }
        }
      }
      return z.revert(r);
    }

    // (public) gcd(this,a) (HAC 14.54)
    function bnGCD(a) {
      var x = (this.s<0)?this.negate():this.clone();
      var y = (a.s<0)?a.negate():a.clone();
      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if(g < 0) return x;
      if(i < g) g = i;
      if(g > 0) {
        x.rShiftTo(g,x);
        y.rShiftTo(g,y);
      }
      while(x.signum() > 0) {
        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
        if(x.compareTo(y) >= 0) {
          x.subTo(y,x);
          x.rShiftTo(1,x);
        }
        else {
          y.subTo(x,y);
          y.rShiftTo(1,y);
        }
      }
      if(g > 0) y.lShiftTo(g,y);
      return y;
    }

    // (protected) this % n, n < 2^26
    function bnpModInt(n) {
      if(n <= 0) return 0;
      var d = this.DV%n, r = (this.s<0)?n-1:0;
      if(this.t > 0)
        if(d == 0) r = this[0]%n;
        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
      return r;
    }

    // (public) 1/this % m (HAC 14.61)
    function bnModInverse(m) {
      var ac = m.isEven();
      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while(u.signum() != 0) {
        while(u.isEven()) {
          u.rShiftTo(1,u);
          if(ac) {
            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
            a.rShiftTo(1,a);
          }
          else if(!b.isEven()) b.subTo(m,b);
          b.rShiftTo(1,b);
        }
        while(v.isEven()) {
          v.rShiftTo(1,v);
          if(ac) {
            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
            c.rShiftTo(1,c);
          }
          else if(!d.isEven()) d.subTo(m,d);
          d.rShiftTo(1,d);
        }
        if(u.compareTo(v) >= 0) {
          u.subTo(v,u);
          if(ac) a.subTo(c,a);
          b.subTo(d,b);
        }
        else {
          v.subTo(u,v);
          if(ac) c.subTo(a,c);
          d.subTo(b,d);
        }
      }
      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if(d.compareTo(m) >= 0) return d.subtract(m);
      if(d.signum() < 0) d.addTo(m,d); else return d;
      if(d.signum() < 0) return d.add(m); else return d;
    }

    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
    var lplim = (1<<26)/lowprimes[lowprimes.length-1];

    // (public) test primality with certainty >= 1-.5^t
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
        for(i = 0; i < lowprimes.length; ++i)
          if(x[0] == lowprimes[i]) return true;
        return false;
      }
      if(x.isEven()) return false;
      i = 1;
      while(i < lowprimes.length) {
        var m = lowprimes[i], j = i+1;
        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while(i < j) if(m%lowprimes[i++] == 0) return false;
      }
      return x.millerRabin(t);
    }

    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if(k <= 0) return false;
      var r = n1.shiftRight(k);
      t = (t+1)>>1;
      if(t > lowprimes.length) t = lowprimes.length;
      var a = nbi();
      for(var i = 0; i < t; ++i) {
        //Pick bases at random, instead of starting at 2
        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
        var y = a.modPow(r,this);
        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while(j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2,this);
            if(y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if(y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }

    // protected
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;

    // public
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

    // JSBN-specific extension
    BigInteger.prototype.square = bnSquare;

    // Expose the Barrett function
    BigInteger.prototype.Barrett = Barrett

    // BigInteger interfaces not implemented in jsbn:

    // BigInteger(int signum, byte[] magnitude)
    // double doubleValue()
    // float floatValue()
    // int hashCode()
    // long longValue()
    // static BigInteger valueOf(long val)

	// Random number generator - requires a PRNG backend, e.g. prng4.js

	// For best results, put code like
	// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
	// in your main HTML document.

	var rng_state;
	var rng_pool;
	var rng_pptr;

	// Mix in a 32-bit integer into the pool
	function rng_seed_int(x) {
	  rng_pool[rng_pptr++] ^= x & 255;
	  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
	  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
	  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
	  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
	}

	// Mix in the current time (w/milliseconds) into the pool
	function rng_seed_time() {
	  rng_seed_int(new Date().getTime());
	}

	// Initialize the pool with junk if needed.
	if(rng_pool == null) {
	  rng_pool = new Array();
	  rng_pptr = 0;
	  var t;
	  if(typeof window !== "undefined" && window.crypto) {
		if (window.crypto.getRandomValues) {
		  // Use webcrypto if available
		  var ua = new Uint8Array(32);
		  window.crypto.getRandomValues(ua);
		  for(t = 0; t < 32; ++t)
			rng_pool[rng_pptr++] = ua[t];
		}
		else if(navigator.appName == "Netscape" && navigator.appVersion < "5") {
		  // Extract entropy (256 bits) from NS4 RNG if available
		  var z = window.crypto.random(32);
		  for(t = 0; t < z.length; ++t)
			rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
		}
	  }
	  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()
		t = Math.floor(65536 * Math.random());
		rng_pool[rng_pptr++] = t >>> 8;
		rng_pool[rng_pptr++] = t & 255;
	  }
	  rng_pptr = 0;
	  rng_seed_time();
	  //rng_seed_int(window.screenX);
	  //rng_seed_int(window.screenY);
	}

	function rng_get_byte() {
	  if(rng_state == null) {
		rng_seed_time();
		rng_state = prng_newstate();
		rng_state.init(rng_pool);
		for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
		  rng_pool[rng_pptr] = 0;
		rng_pptr = 0;
		//rng_pool = null;
	  }
	  // TODO: allow reseeding after first request
	  return rng_state.next();
	}

	function rng_get_bytes(ba) {
	  var i;
	  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
	}

	function SecureRandom() {}

	SecureRandom.prototype.nextBytes = rng_get_bytes;

	// prng4.js - uses Arcfour as a PRNG

	function Arcfour() {
	  this.i = 0;
	  this.j = 0;
	  this.S = new Array();
	}

	// Initialize arcfour context from key, an array of ints, each from [0..255]
	function ARC4init(key) {
	  var i, j, t;
	  for(i = 0; i < 256; ++i)
		this.S[i] = i;
	  j = 0;
	  for(i = 0; i < 256; ++i) {
		j = (j + this.S[i] + key[i % key.length]) & 255;
		t = this.S[i];
		this.S[i] = this.S[j];
		this.S[j] = t;
	  }
	  this.i = 0;
	  this.j = 0;
	}

	function ARC4next() {
	  var t;
	  this.i = (this.i + 1) & 255;
	  this.j = (this.j + this.S[this.i]) & 255;
	  t = this.S[this.i];
	  this.S[this.i] = this.S[this.j];
	  this.S[this.j] = t;
	  return this.S[(t + this.S[this.i]) & 255];
	}

	Arcfour.prototype.init = ARC4init;
	Arcfour.prototype.next = ARC4next;

	// Plug in your RNG constructor here
	function prng_newstate() {
	  return new Arcfour();
	}

	// Pool size must be a multiple of 4 and greater than 32.
	// An array of bytes the size of the pool will be passed to init()
	var rng_psize = 256;

  BigInteger.SecureRandom = SecureRandom;
  BigInteger.BigInteger = BigInteger;
  if (true) {
    exports = module.exports = BigInteger;
  } else {}

}).call(this);


/***/ }),

/***/ "./node_modules/json-schema-traverse/index.js":
/*!****************************************************!*\
  !*** ./node_modules/json-schema-traverse/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


/***/ }),

/***/ "./node_modules/json-schema/lib/validate.js":
/*!**************************************************!*\
  !*** ./node_modules/json-schema/lib/validate.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * JSONSchema Validator - Validates JavaScript objects using JSON Schemas
 *	(http://www.json.com/json-schema-proposal/)
 *
 * Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)
 * Licensed under the MIT (MIT-LICENSE.txt) license.
To use the validator call the validate function with an instance object and an optional schema object.
If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
that schema will be used to validate and the schema parameter is not necessary (if both exist,
both validations will occur).
The validate method will return an array of validation errors. If there are no errors, then an
empty list will be returned. A validation error will have two properties:
"property" which indicates which property had the error
"message" which indicates what the error was
 */
(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
            return factory();
        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {// setup primitive classes to be JSON Schema types
var exports = validate
exports.Integer = {type:"integer"};
var primitiveConstructors = {
	String: String,
	Boolean: Boolean,
	Number: Number,
	Object: Object,
	Array: Array,
	Date: Date
}
exports.validate = validate;
function validate(/*Any*/instance,/*Object*/schema) {
		// Summary:
		//  	To use the validator call JSONSchema.validate with an instance object and an optional schema object.
		// 		If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
		// 		that schema will be used to validate and the schema parameter is not necessary (if both exist,
		// 		both validations will occur).
		// 		The validate method will return an object with two properties:
		// 			valid: A boolean indicating if the instance is valid by the schema
		// 			errors: An array of validation errors. If there are no errors, then an
		// 					empty list will be returned. A validation error will have two properties:
		// 						property: which indicates which property had the error
		// 						message: which indicates what the error was
		//
		return validate(instance, schema, {changing: false});//, coerce: false, existingOnly: false});
	};
exports.checkPropertyChange = function(/*Any*/value,/*Object*/schema, /*String*/property) {
		// Summary:
		// 		The checkPropertyChange method will check to see if an value can legally be in property with the given schema
		// 		This is slightly different than the validate method in that it will fail if the schema is readonly and it will
		// 		not check for self-validation, it is assumed that the passed in value is already internally valid.
		// 		The checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for
		// 		information.
		//
		return validate(value, schema, {changing: property || "property"});
	};
var validate = exports._validate = function(/*Any*/instance,/*Object*/schema,/*Object*/options) {

	if (!options) options = {};
	var _changing = options.changing;

	function getType(schema){
		return schema.type || (primitiveConstructors[schema.name] == schema && schema.name.toLowerCase());
	}
	var errors = [];
	// validate a value against a property definition
	function checkProp(value, schema, path,i){

		var l;
		path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
		function addError(message){
			errors.push({property:path,message:message});
		}

		if((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))){
			if(typeof schema == 'function'){
				if(!(value instanceof schema)){
					addError("is not an instance of the class/constructor " + schema.name);
				}
			}else if(schema){
				addError("Invalid schema/property definition " + schema);
			}
			return null;
		}
		if(_changing && schema.readonly){
			addError("is a readonly field, it can not be changed");
		}
		if(schema['extends']){ // if it extends another schema, it must pass that schema as well
			checkProp(value,schema['extends'],path,i);
		}
		// validate a value against a type definition
		function checkType(type,value){
			if(type){
				if(typeof type == 'string' && type != 'any' &&
						(type == 'null' ? value !== null : typeof value != type) &&
						!(value instanceof Array && type == 'array') &&
						!(value instanceof Date && type == 'date') &&
						!(type == 'integer' && value%1===0)){
					return [{property:path,message:(typeof value) + " value found, but a " + type + " is required"}];
				}
				if(type instanceof Array){
					var unionErrors=[];
					for(var j = 0; j < type.length; j++){ // a union type
						if(!(unionErrors=checkType(type[j],value)).length){
							break;
						}
					}
					if(unionErrors.length){
						return unionErrors;
					}
				}else if(typeof type == 'object'){
					var priorErrors = errors;
					errors = [];
					checkProp(value,type,path);
					var theseErrors = errors;
					errors = priorErrors;
					return theseErrors;
				}
			}
			return [];
		}
		if(value === undefined){
			if(schema.required){
				addError("is missing and it is required");
			}
		}else{
			errors = errors.concat(checkType(getType(schema),value));
			if(schema.disallow && !checkType(schema.disallow,value).length){
				addError(" disallowed value was matched");
			}
			if(value !== null){
				if(value instanceof Array){
					if(schema.items){
						var itemsIsArray = schema.items instanceof Array;
						var propDef = schema.items;
						for (i = 0, l = value.length; i < l; i += 1) {
							if (itemsIsArray)
								propDef = schema.items[i];
							if (options.coerce)
								value[i] = options.coerce(value[i], propDef);
							errors.concat(checkProp(value[i],propDef,path,i));
						}
					}
					if(schema.minItems && value.length < schema.minItems){
						addError("There must be a minimum of " + schema.minItems + " in the array");
					}
					if(schema.maxItems && value.length > schema.maxItems){
						addError("There must be a maximum of " + schema.maxItems + " in the array");
					}
				}else if(schema.properties || schema.additionalProperties){
					errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));
				}
				if(schema.pattern && typeof value == 'string' && !value.match(schema.pattern)){
					addError("does not match the regex pattern " + schema.pattern);
				}
				if(schema.maxLength && typeof value == 'string' && value.length > schema.maxLength){
					addError("may only be " + schema.maxLength + " characters long");
				}
				if(schema.minLength && typeof value == 'string' && value.length < schema.minLength){
					addError("must be at least " + schema.minLength + " characters long");
				}
				if(typeof schema.minimum !== undefined && typeof value == typeof schema.minimum &&
						schema.minimum > value){
					addError("must have a minimum value of " + schema.minimum);
				}
				if(typeof schema.maximum !== undefined && typeof value == typeof schema.maximum &&
						schema.maximum < value){
					addError("must have a maximum value of " + schema.maximum);
				}
				if(schema['enum']){
					var enumer = schema['enum'];
					l = enumer.length;
					var found;
					for(var j = 0; j < l; j++){
						if(enumer[j]===value){
							found=1;
							break;
						}
					}
					if(!found){
						addError("does not have a value in the enumeration " + enumer.join(", "));
					}
				}
				if(typeof schema.maxDecimal == 'number' &&
					(value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}")))){
					addError("may only have " + schema.maxDecimal + " digits of decimal places");
				}
			}
		}
		return null;
	}
	// validate an object against a schema
	function checkObj(instance,objTypeDef,path,additionalProp){

		if(typeof objTypeDef =='object'){
			if(typeof instance != 'object' || instance instanceof Array){
				errors.push({property:path,message:"an object is required"});
			}
			
			for(var i in objTypeDef){ 
				if(objTypeDef.hasOwnProperty(i)){
					var value = instance[i];
					// skip _not_ specified properties
					if (value === undefined && options.existingOnly) continue;
					var propDef = objTypeDef[i];
					// set default
					if(value === undefined && propDef["default"]){
						value = instance[i] = propDef["default"];
					}
					if(options.coerce && i in instance){
						value = instance[i] = options.coerce(value, propDef);
					}
					checkProp(value,propDef,path,i);
				}
			}
		}
		for(i in instance){
			if(instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp===false){
				if (options.filter) {
					delete instance[i];
					continue;
				} else {
					errors.push({property:path,message:(typeof value) + "The property " + i +
						" is not defined in the schema and the schema does not allow additional properties"});
				}
			}
			var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
			if(requires && !(requires in instance)){
				errors.push({property:path,message:"the presence of the property " + i + " requires that " + requires + " also be present"});
			}
			value = instance[i];
			if(additionalProp && (!(objTypeDef && typeof objTypeDef == 'object') || !(i in objTypeDef))){
				if(options.coerce){
					value = instance[i] = options.coerce(value, additionalProp);
				}
				checkProp(value,additionalProp,path,i);
			}
			if(!_changing && value && value.$schema){
				errors = errors.concat(checkProp(value,value.$schema,path,i));
			}
		}
		return errors;
	}
	if(schema){
		checkProp(instance,schema,'',_changing || '');
	}
	if(!_changing && instance && instance.$schema){
		checkProp(instance,instance.$schema,'','');
	}
	return {valid:!errors.length,errors:errors};
};
exports.mustBeValid = function(result){
	//	summary:
	//		This checks to ensure that the result is valid and will throw an appropriate error message if it is not
	// result: the result returned from checkPropertyChange or validate
	if(!result.valid){
		throw new TypeError(result.errors.map(function(error){return "for property " + error.property + ': ' + error.message;}).join(", \n"));
	}
}

return exports;
}));


/***/ }),

/***/ "./node_modules/json-stringify-safe/stringify.js":
/*!*******************************************************!*\
  !*** ./node_modules/json-stringify-safe/stringify.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports = module.exports = stringify
exports.getSerialize = serializer

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
}

function serializer(replacer, cycleReplacer) {
  var stack = [], keys = []

  if (cycleReplacer == null) cycleReplacer = function(key, value) {
    if (stack[0] === value) return "[Circular ~]"
    return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
  }

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this)
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
    }
    else stack.push(value)

    return replacer == null ? value : replacer.call(this, key, value)
  }
}


/***/ }),

/***/ "./node_modules/jsprim/lib/jsprim.js":
/*!*******************************************!*\
  !*** ./node_modules/jsprim/lib/jsprim.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * lib/jsprim.js: utilities for primitive JavaScript types
 */

var mod_assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var mod_util = __webpack_require__(/*! util */ "util");

var mod_extsprintf = __webpack_require__(/*! extsprintf */ "./node_modules/extsprintf/lib/extsprintf.js");
var mod_verror = __webpack_require__(/*! verror */ "./node_modules/verror/lib/verror.js");
var mod_jsonschema = __webpack_require__(/*! json-schema */ "./node_modules/json-schema/lib/validate.js");

/*
 * Public interface
 */
exports.deepCopy = deepCopy;
exports.deepEqual = deepEqual;
exports.isEmpty = isEmpty;
exports.hasKey = hasKey;
exports.forEachKey = forEachKey;
exports.pluck = pluck;
exports.flattenObject = flattenObject;
exports.flattenIter = flattenIter;
exports.validateJsonObject = validateJsonObjectJS;
exports.validateJsonObjectJS = validateJsonObjectJS;
exports.randElt = randElt;
exports.extraProperties = extraProperties;
exports.mergeObjects = mergeObjects;

exports.startsWith = startsWith;
exports.endsWith = endsWith;

exports.parseInteger = parseInteger;

exports.iso8601 = iso8601;
exports.rfc1123 = rfc1123;
exports.parseDateTime = parseDateTime;

exports.hrtimediff = hrtimeDiff;
exports.hrtimeDiff = hrtimeDiff;
exports.hrtimeAccum = hrtimeAccum;
exports.hrtimeAdd = hrtimeAdd;
exports.hrtimeNanosec = hrtimeNanosec;
exports.hrtimeMicrosec = hrtimeMicrosec;
exports.hrtimeMillisec = hrtimeMillisec;


/*
 * Deep copy an acyclic *basic* Javascript object.  This only handles basic
 * scalars (strings, numbers, booleans) and arbitrarily deep arrays and objects
 * containing these.  This does *not* handle instances of other classes.
 */
function deepCopy(obj)
{
	var ret, key;
	var marker = '__deepCopy';

	if (obj && obj[marker])
		throw (new Error('attempted deep copy of cyclic object'));

	if (obj && obj.constructor == Object) {
		ret = {};
		obj[marker] = true;

		for (key in obj) {
			if (key == marker)
				continue;

			ret[key] = deepCopy(obj[key]);
		}

		delete (obj[marker]);
		return (ret);
	}

	if (obj && obj.constructor == Array) {
		ret = [];
		obj[marker] = true;

		for (key = 0; key < obj.length; key++)
			ret.push(deepCopy(obj[key]));

		delete (obj[marker]);
		return (ret);
	}

	/*
	 * It must be a primitive type -- just return it.
	 */
	return (obj);
}

function deepEqual(obj1, obj2)
{
	if (typeof (obj1) != typeof (obj2))
		return (false);

	if (obj1 === null || obj2 === null || typeof (obj1) != 'object')
		return (obj1 === obj2);

	if (obj1.constructor != obj2.constructor)
		return (false);

	var k;
	for (k in obj1) {
		if (!obj2.hasOwnProperty(k))
			return (false);

		if (!deepEqual(obj1[k], obj2[k]))
			return (false);
	}

	for (k in obj2) {
		if (!obj1.hasOwnProperty(k))
			return (false);
	}

	return (true);
}

function isEmpty(obj)
{
	var key;
	for (key in obj)
		return (false);
	return (true);
}

function hasKey(obj, key)
{
	mod_assert.equal(typeof (key), 'string');
	return (Object.prototype.hasOwnProperty.call(obj, key));
}

function forEachKey(obj, callback)
{
	for (var key in obj) {
		if (hasKey(obj, key)) {
			callback(key, obj[key]);
		}
	}
}

function pluck(obj, key)
{
	mod_assert.equal(typeof (key), 'string');
	return (pluckv(obj, key));
}

function pluckv(obj, key)
{
	if (obj === null || typeof (obj) !== 'object')
		return (undefined);

	if (obj.hasOwnProperty(key))
		return (obj[key]);

	var i = key.indexOf('.');
	if (i == -1)
		return (undefined);

	var key1 = key.substr(0, i);
	if (!obj.hasOwnProperty(key1))
		return (undefined);

	return (pluckv(obj[key1], key.substr(i + 1)));
}

/*
 * Invoke callback(row) for each entry in the array that would be returned by
 * flattenObject(data, depth).  This is just like flattenObject(data,
 * depth).forEach(callback), except that the intermediate array is never
 * created.
 */
function flattenIter(data, depth, callback)
{
	doFlattenIter(data, depth, [], callback);
}

function doFlattenIter(data, depth, accum, callback)
{
	var each;
	var key;

	if (depth === 0) {
		each = accum.slice(0);
		each.push(data);
		callback(each);
		return;
	}

	mod_assert.ok(data !== null);
	mod_assert.equal(typeof (data), 'object');
	mod_assert.equal(typeof (depth), 'number');
	mod_assert.ok(depth >= 0);

	for (key in data) {
		each = accum.slice(0);
		each.push(key);
		doFlattenIter(data[key], depth - 1, each, callback);
	}
}

function flattenObject(data, depth)
{
	if (depth === 0)
		return ([ data ]);

	mod_assert.ok(data !== null);
	mod_assert.equal(typeof (data), 'object');
	mod_assert.equal(typeof (depth), 'number');
	mod_assert.ok(depth >= 0);

	var rv = [];
	var key;

	for (key in data) {
		flattenObject(data[key], depth - 1).forEach(function (p) {
			rv.push([ key ].concat(p));
		});
	}

	return (rv);
}

function startsWith(str, prefix)
{
	return (str.substr(0, prefix.length) == prefix);
}

function endsWith(str, suffix)
{
	return (str.substr(
	    str.length - suffix.length, suffix.length) == suffix);
}

function iso8601(d)
{
	if (typeof (d) == 'number')
		d = new Date(d);
	mod_assert.ok(d.constructor === Date);
	return (mod_extsprintf.sprintf('%4d-%02d-%02dT%02d:%02d:%02d.%03dZ',
	    d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(),
	    d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(),
	    d.getUTCMilliseconds()));
}

var RFC1123_MONTHS = [
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var RFC1123_DAYS = [
    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

function rfc1123(date) {
	return (mod_extsprintf.sprintf('%s, %02d %s %04d %02d:%02d:%02d GMT',
	    RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(),
	    RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(),
	    date.getUTCHours(), date.getUTCMinutes(),
	    date.getUTCSeconds()));
}

/*
 * Parses a date expressed as a string, as either a number of milliseconds since
 * the epoch or any string format that Date accepts, giving preference to the
 * former where these two sets overlap (e.g., small numbers).
 */
function parseDateTime(str)
{
	/*
	 * This is irritatingly implicit, but significantly more concise than
	 * alternatives.  The "+str" will convert a string containing only a
	 * number directly to a Number, or NaN for other strings.  Thus, if the
	 * conversion succeeds, we use it (this is the milliseconds-since-epoch
	 * case).  Otherwise, we pass the string directly to the Date
	 * constructor to parse.
	 */
	var numeric = +str;
	if (!isNaN(numeric)) {
		return (new Date(numeric));
	} else {
		return (new Date(str));
	}
}


/*
 * Number.*_SAFE_INTEGER isn't present before node v0.12, so we hardcode
 * the ES6 definitions here, while allowing for them to someday be higher.
 */
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;


/*
 * Default options for parseInteger().
 */
var PI_DEFAULTS = {
	base: 10,
	allowSign: true,
	allowPrefix: false,
	allowTrailing: false,
	allowImprecise: false,
	trimWhitespace: false,
	leadingZeroIsOctal: false
};

var CP_0 = 0x30;
var CP_9 = 0x39;

var CP_A = 0x41;
var CP_B = 0x42;
var CP_O = 0x4f;
var CP_T = 0x54;
var CP_X = 0x58;
var CP_Z = 0x5a;

var CP_a = 0x61;
var CP_b = 0x62;
var CP_o = 0x6f;
var CP_t = 0x74;
var CP_x = 0x78;
var CP_z = 0x7a;

var PI_CONV_DEC = 0x30;
var PI_CONV_UC = 0x37;
var PI_CONV_LC = 0x57;


/*
 * A stricter version of parseInt() that provides options for changing what
 * is an acceptable string (for example, disallowing trailing characters).
 */
function parseInteger(str, uopts)
{
	mod_assert.string(str, 'str');
	mod_assert.optionalObject(uopts, 'options');

	var baseOverride = false;
	var options = PI_DEFAULTS;

	if (uopts) {
		baseOverride = hasKey(uopts, 'base');
		options = mergeObjects(options, uopts);
		mod_assert.number(options.base, 'options.base');
		mod_assert.ok(options.base >= 2, 'options.base >= 2');
		mod_assert.ok(options.base <= 36, 'options.base <= 36');
		mod_assert.bool(options.allowSign, 'options.allowSign');
		mod_assert.bool(options.allowPrefix, 'options.allowPrefix');
		mod_assert.bool(options.allowTrailing,
		    'options.allowTrailing');
		mod_assert.bool(options.allowImprecise,
		    'options.allowImprecise');
		mod_assert.bool(options.trimWhitespace,
		    'options.trimWhitespace');
		mod_assert.bool(options.leadingZeroIsOctal,
		    'options.leadingZeroIsOctal');

		if (options.leadingZeroIsOctal) {
			mod_assert.ok(!baseOverride,
			    '"base" and "leadingZeroIsOctal" are ' +
			    'mutually exclusive');
		}
	}

	var c;
	var pbase = -1;
	var base = options.base;
	var start;
	var mult = 1;
	var value = 0;
	var idx = 0;
	var len = str.length;

	/* Trim any whitespace on the left side. */
	if (options.trimWhitespace) {
		while (idx < len && isSpace(str.charCodeAt(idx))) {
			++idx;
		}
	}

	/* Check the number for a leading sign. */
	if (options.allowSign) {
		if (str[idx] === '-') {
			idx += 1;
			mult = -1;
		} else if (str[idx] === '+') {
			idx += 1;
		}
	}

	/* Parse the base-indicating prefix if there is one. */
	if (str[idx] === '0') {
		if (options.allowPrefix) {
			pbase = prefixToBase(str.charCodeAt(idx + 1));
			if (pbase !== -1 && (!baseOverride || pbase === base)) {
				base = pbase;
				idx += 2;
			}
		}

		if (pbase === -1 && options.leadingZeroIsOctal) {
			base = 8;
		}
	}

	/* Parse the actual digits. */
	for (start = idx; idx < len; ++idx) {
		c = translateDigit(str.charCodeAt(idx));
		if (c !== -1 && c < base) {
			value *= base;
			value += c;
		} else {
			break;
		}
	}

	/* If we didn't parse any digits, we have an invalid number. */
	if (start === idx) {
		return (new Error('invalid number: ' + JSON.stringify(str)));
	}

	/* Trim any whitespace on the right side. */
	if (options.trimWhitespace) {
		while (idx < len && isSpace(str.charCodeAt(idx))) {
			++idx;
		}
	}

	/* Check for trailing characters. */
	if (idx < len && !options.allowTrailing) {
		return (new Error('trailing characters after number: ' +
		    JSON.stringify(str.slice(idx))));
	}

	/* If our value is 0, we return now, to avoid returning -0. */
	if (value === 0) {
		return (0);
	}

	/* Calculate our final value. */
	var result = value * mult;

	/*
	 * If the string represents a value that cannot be precisely represented
	 * by JavaScript, then we want to check that:
	 *
	 * - We never increased the value past MAX_SAFE_INTEGER
	 * - We don't make the result negative and below MIN_SAFE_INTEGER
	 *
	 * Because we only ever increment the value during parsing, there's no
	 * chance of moving past MAX_SAFE_INTEGER and then dropping below it
	 * again, losing precision in the process. This means that we only need
	 * to do our checks here, at the end.
	 */
	if (!options.allowImprecise &&
	    (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
		return (new Error('number is outside of the supported range: ' +
		    JSON.stringify(str.slice(start, idx))));
	}

	return (result);
}


/*
 * Interpret a character code as a base-36 digit.
 */
function translateDigit(d)
{
	if (d >= CP_0 && d <= CP_9) {
		/* '0' to '9' -> 0 to 9 */
		return (d - PI_CONV_DEC);
	} else if (d >= CP_A && d <= CP_Z) {
		/* 'A' - 'Z' -> 10 to 35 */
		return (d - PI_CONV_UC);
	} else if (d >= CP_a && d <= CP_z) {
		/* 'a' - 'z' -> 10 to 35 */
		return (d - PI_CONV_LC);
	} else {
		/* Invalid character code */
		return (-1);
	}
}


/*
 * Test if a value matches the ECMAScript definition of trimmable whitespace.
 */
function isSpace(c)
{
	return (c === 0x20) ||
	    (c >= 0x0009 && c <= 0x000d) ||
	    (c === 0x00a0) ||
	    (c === 0x1680) ||
	    (c === 0x180e) ||
	    (c >= 0x2000 && c <= 0x200a) ||
	    (c === 0x2028) ||
	    (c === 0x2029) ||
	    (c === 0x202f) ||
	    (c === 0x205f) ||
	    (c === 0x3000) ||
	    (c === 0xfeff);
}


/*
 * Determine which base a character indicates (e.g., 'x' indicates hex).
 */
function prefixToBase(c)
{
	if (c === CP_b || c === CP_B) {
		/* 0b/0B (binary) */
		return (2);
	} else if (c === CP_o || c === CP_O) {
		/* 0o/0O (octal) */
		return (8);
	} else if (c === CP_t || c === CP_T) {
		/* 0t/0T (decimal) */
		return (10);
	} else if (c === CP_x || c === CP_X) {
		/* 0x/0X (hexadecimal) */
		return (16);
	} else {
		/* Not a meaningful character */
		return (-1);
	}
}


function validateJsonObjectJS(schema, input)
{
	var report = mod_jsonschema.validate(input, schema);

	if (report.errors.length === 0)
		return (null);

	/* Currently, we only do anything useful with the first error. */
	var error = report.errors[0];

	/* The failed property is given by a URI with an irrelevant prefix. */
	var propname = error['property'];
	var reason = error['message'].toLowerCase();
	var i, j;

	/*
	 * There's at least one case where the property error message is
	 * confusing at best.  We work around this here.
	 */
	if ((i = reason.indexOf('the property ')) != -1 &&
	    (j = reason.indexOf(' is not defined in the schema and the ' +
	    'schema does not allow additional properties')) != -1) {
		i += 'the property '.length;
		if (propname === '')
			propname = reason.substr(i, j - i);
		else
			propname = propname + '.' + reason.substr(i, j - i);

		reason = 'unsupported property';
	}

	var rv = new mod_verror.VError('property "%s": %s', propname, reason);
	rv.jsv_details = error;
	return (rv);
}

function randElt(arr)
{
	mod_assert.ok(Array.isArray(arr) && arr.length > 0,
	    'randElt argument must be a non-empty array');

	return (arr[Math.floor(Math.random() * arr.length)]);
}

function assertHrtime(a)
{
	mod_assert.ok(a[0] >= 0 && a[1] >= 0,
	    'negative numbers not allowed in hrtimes');
	mod_assert.ok(a[1] < 1e9, 'nanoseconds column overflow');
}

/*
 * Compute the time elapsed between hrtime readings A and B, where A is later
 * than B.  hrtime readings come from Node's process.hrtime().  There is no
 * defined way to represent negative deltas, so it's illegal to diff B from A
 * where the time denoted by B is later than the time denoted by A.  If this
 * becomes valuable, we can define a representation and extend the
 * implementation to support it.
 */
function hrtimeDiff(a, b)
{
	assertHrtime(a);
	assertHrtime(b);
	mod_assert.ok(a[0] > b[0] || (a[0] == b[0] && a[1] >= b[1]),
	    'negative differences not allowed');

	var rv = [ a[0] - b[0], 0 ];

	if (a[1] >= b[1]) {
		rv[1] = a[1] - b[1];
	} else {
		rv[0]--;
		rv[1] = 1e9 - (b[1] - a[1]);
	}

	return (rv);
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of nanoseconds.
 */
function hrtimeNanosec(a)
{
	assertHrtime(a);

	return (Math.floor(a[0] * 1e9 + a[1]));
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of microseconds.
 */
function hrtimeMicrosec(a)
{
	assertHrtime(a);

	return (Math.floor(a[0] * 1e6 + a[1] / 1e3));
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of milliseconds.
 */
function hrtimeMillisec(a)
{
	assertHrtime(a);

	return (Math.floor(a[0] * 1e3 + a[1] / 1e6));
}

/*
 * Add two hrtime readings A and B, overwriting A with the result of the
 * addition.  This function is useful for accumulating several hrtime intervals
 * into a counter.  Returns A.
 */
function hrtimeAccum(a, b)
{
	assertHrtime(a);
	assertHrtime(b);

	/*
	 * Accumulate the nanosecond component.
	 */
	a[1] += b[1];
	if (a[1] >= 1e9) {
		/*
		 * The nanosecond component overflowed, so carry to the seconds
		 * field.
		 */
		a[0]++;
		a[1] -= 1e9;
	}

	/*
	 * Accumulate the seconds component.
	 */
	a[0] += b[0];

	return (a);
}

/*
 * Add two hrtime readings A and B, returning the result as a new hrtime array.
 * Does not modify either input argument.
 */
function hrtimeAdd(a, b)
{
	assertHrtime(a);

	var rv = [ a[0], a[1] ];

	return (hrtimeAccum(rv, b));
}


/*
 * Check an object for unexpected properties.  Accepts the object to check, and
 * an array of allowed property names (strings).  Returns an array of key names
 * that were found on the object, but did not appear in the list of allowed
 * properties.  If no properties were found, the returned array will be of
 * zero length.
 */
function extraProperties(obj, allowed)
{
	mod_assert.ok(typeof (obj) === 'object' && obj !== null,
	    'obj argument must be a non-null object');
	mod_assert.ok(Array.isArray(allowed),
	    'allowed argument must be an array of strings');
	for (var i = 0; i < allowed.length; i++) {
		mod_assert.ok(typeof (allowed[i]) === 'string',
		    'allowed argument must be an array of strings');
	}

	return (Object.keys(obj).filter(function (key) {
		return (allowed.indexOf(key) === -1);
	}));
}

/*
 * Given three sets of properties "provided" (may be undefined), "overrides"
 * (required), and "defaults" (may be undefined), construct an object containing
 * the union of these sets with "overrides" overriding "provided", and
 * "provided" overriding "defaults".  None of the input objects are modified.
 */
function mergeObjects(provided, overrides, defaults)
{
	var rv, k;

	rv = {};
	if (defaults) {
		for (k in defaults)
			rv[k] = defaults[k];
	}

	if (provided) {
		for (k in provided)
			rv[k] = provided[k];
	}

	if (overrides) {
		for (k in overrides)
			rv[k] = overrides[k];
	}

	return (rv);
}


/***/ }),

/***/ "./node_modules/keybase-bot/index.js":
/*!*******************************************!*\
  !*** ./node_modules/keybase-bot/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var snakeCase = _interopDefault(__webpack_require__(/*! lodash.snakecase */ "./node_modules/lodash.snakecase/index.js"));
var camelCase = _interopDefault(__webpack_require__(/*! lodash.camelcase */ "./node_modules/lodash.camelcase/index.js"));
var kebabCase = _interopDefault(__webpack_require__(/*! lodash.kebabcase */ "./node_modules/lodash.kebabcase/index.js"));
var os = _interopDefault(__webpack_require__(/*! os */ "os"));
var crypto = _interopDefault(__webpack_require__(/*! crypto */ "crypto"));
var child_process = __webpack_require__(/*! child_process */ "child_process");
var readline = _interopDefault(__webpack_require__(/*! readline */ "readline"));
var mkdirp = _interopDefault(__webpack_require__(/*! mkdirp */ "./node_modules/mkdirp/index.js"));
var util = __webpack_require__(/*! util */ "util");
var fs = __webpack_require__(/*! fs */ "fs");
var fs__default = _interopDefault(fs);
var path = _interopDefault(__webpack_require__(/*! path */ "path"));

/**
  Takes a Keybase API input JavaScript object and recursively formats it into snake_case or kebab-case instead of camelCase for the service.
  * @ignore
  * @param obj - The object to be formatted.
  * @param apiType - The type of api the the input is being served to. Currently Keybase has chat, team, and wallet apis.
  * @returns - The new, formatted object.
  * @example
  * const inputOptions = formatAPIObject({unreadOnly: true})
  * console.log(inputOptions) // {unread_only: true}
 */
function formatAPIObjectInput(obj, apiType) {
  if (obj === null || obj === undefined || typeof obj !== 'object') {
    return obj;
  } else if (Array.isArray(obj)) {
    return obj.map(item => formatAPIObjectInput(item, apiType));
  } else {
    return Object.keys(obj).reduce((newObj, key) => {
      // TODO: hopefully we standardize how the Keybase API handles input keys
      let formattedKey;

      if (apiType === 'wallet') {
        formattedKey = kebabCase(key);
      } else {
        formattedKey = snakeCase(key);
      }

      if (typeof obj[key] === 'object') {
        return { ...newObj,
          [formattedKey]: formatAPIObjectInput(obj[key], apiType)
        };
      }

      return { ...newObj,
        [formattedKey]: obj[key]
      };
    }, {});
  }
}
/*
 * An internal blacklist of parent levels at which formatAPIObjectOutput transformations
 * shouldn't be performed. A `null` value matches everything.
 */

const transformsBlacklist = {
  chat: {
    read: [['messages', null, 'msg', 'reactions', 'reactions', null]]
  }
  /**
   * Context of the object formatting process.
   * @ignore
   */

};

/*
 * Matches a context against the list of blacklisted parent levels.
 * @ignore
 * @param context - The context to match.
 * @returns - Whether the context is blacklisted from being formatted.
 */
function matchBlacklist(context) {
  if (!context || !transformsBlacklist[context.apiName] || !transformsBlacklist[context.apiName][context.method]) {
    return false;
  }

  const parentLength = context.parent ? context.parent.length : 0;

  for (const matcher of transformsBlacklist[context.apiName][context.method]) {
    if (matcher.length !== parentLength) {
      continue;
    } // Iterate over the items of the matcher


    let mismatch = false;

    for (const [matcherIndex, desiredValue] of matcher.entries()) {
      if (desiredValue === null) {
        continue;
      }

      if (typeof context.parent === 'object' && context.parent[matcherIndex] !== desiredValue) {
        mismatch = true;
        break;
      }
    }

    if (!mismatch) {
      return true;
    }
  }

  return false;
}
/*
 * Appends a new key to the parents array in the formatting context.
 * @ignore
 * @param context - The context to copy and modify.
 * @param key - The key to apprent to the parent array.
 * @returns - A new context.
 */


function buildContext(context, key) {
  if (!context) {
    return context;
  }

  const copiedContext = { ...context
  };

  if (!copiedContext.parent) {
    copiedContext.parent = [key];
  } else {
    copiedContext.parent = copiedContext.parent.slice();
    copiedContext.parent.push(key);
  }

  return copiedContext;
}
/**
  Takes a Keybase output object and formats it in a more digestable JavaScript style by using camelCase instead of snake_case.
  * @ignore
  * @param obj - The object to be formatted.
  * @param context - An optional context with information about the called method required to perform blacklist lookups.
  * @returns - The new, formatted object.
  * @example
  * const outputRes = formatAPIObject({unread_only: true})
  * console.log(outputRes) // {unreadOnly: true}
 */


function formatAPIObjectOutput(obj, context) {
  if (obj == null || typeof obj !== 'object') {
    return obj;
  } else if (Array.isArray(obj)) {
    return obj.map((item, i) => formatAPIObjectOutput(item, buildContext(context, i)));
  } else {
    return Object.keys(obj).reduce((newObj, key) => {
      const formattedKey = matchBlacklist(context) ? key : camelCase(key);

      if (typeof obj[key] === 'object') {
        return { ...newObj,
          [formattedKey]: formatAPIObjectOutput(obj[key], buildContext(context, key))
        };
      }

      return { ...newObj,
        [formattedKey]: obj[key]
      };
    }, {});
  }
}

const keybaseExec = (workingDir, homeDir, args, options = {
  stdinBuffer: undefined,
  onStdOut: undefined
}) => {
  const runArgs = [...args];

  if (homeDir) {
    runArgs.unshift('--home', homeDir);
  }

  const child = child_process.spawn(path.join(workingDir, 'keybase'), runArgs);
  const stdOutBuffer = [];
  const stdErrBuffer = [];

  if (options.stdinBuffer) {
    child.stdin.write(options.stdinBuffer);
  }

  child.stdin.end();
  const lineReaderStdout = readline.createInterface({
    input: child.stdout
  }); // Use readline interface to parse each line (\n separated) when provided
  // with onStdOut callback

  if (options.onStdOut) {
    lineReaderStdout.on('line', options.onStdOut);
  } else {
    child.stdout.on('data', chunk => {
      stdOutBuffer.push(chunk);
    });
  } // Capture STDERR and use as error message if needed


  child.stderr.on('data', chunk => {
    stdErrBuffer.push(chunk);
  });
  return new Promise((resolve, reject) => {
    child.on('close', code => {
      let finalStdOut = null; // Pass back

      if (code) {
        const errorMessage = Buffer.concat(stdErrBuffer).toString('utf8');
        reject(new Error(errorMessage));
      } else {
        const stdout = Buffer.concat(stdOutBuffer).toString('utf8');

        try {
          finalStdOut = options.json ? JSON.parse(stdout) : stdout;
        } catch (e) {
          reject(e);
        }
      }

      resolve(finalStdOut);
    });
  });
};

function randomTempDir() {
  const name = crypto.randomBytes(16).toString('hex');
  return path.join(os.tmpdir(), `keybase_bot_${name}`);
}

async function rmdirRecursive(dirName) {
  const fsLstat = util.promisify(fs__default.lstat);
  const fsUnlink = util.promisify(fs__default.unlink);
  const fsRmdir = util.promisify(fs__default.rmdir);
  const fsReaddir = util.promisify(fs__default.readdir);
  const dirStat = await fsLstat(dirName);

  if (dirStat) {
    for (const entry of await fsReaddir(dirName)) {
      const entryPath = path.join(dirName, entry);
      const stat = await fsLstat(entryPath);

      if (stat.isDirectory()) {
        await rmdirRecursive(entryPath);
      } else {
        await fsUnlink(entryPath);
      }
    }

    await fsRmdir(dirName);
  }
}

/**
 * Useful information like the username, device, home directory of your bot and
 * configuration options.
 */

/**
 * Returns { username, devicename, homeDir } from `keybase status --json`.
 * @ignore
 * @param workingDir - the directory containing the binary, according to top level Bot
 * @param homeDir - The home directory of the service you want to fetch the status from.
 * @example
 * keybaseStatus('/my/dir').then(status => console.log(status.username))
 */
async function keybaseStatus(workingDir, homeDir) {
  const status = await keybaseExec(workingDir, homeDir, ['status', '--json'], {
    json: true
  });

  if (status && status.Username && status.Device && status.Device.name) {
    return {
      username: status.Username,
      devicename: status.Device.name,
      homeDir
    };
  } else {
    throw new Error('Failed to get current username and device name.');
  }
}

/**
 * Checks whether the keybase service is running by calling `keybase status --json`.
 * @ignore
 * @param workingDir - the directory containing the binary, according to top level Bot
 * @param homeDir - The home directory of the service you want to fetch the status from.
 * @example
 * pingKeybaseService('/my/dir').then(status => console.log("service running", status))
 */

async function pingKeybaseService(workingDir, homeDir) {
  // TODO: use a faster technique when core releases one
  try {
    await keybaseExec(workingDir, homeDir, ['--no-auto-fork', 'status', '--json'], {
      json: true
    });
    return true;
  } catch (err) {
    return false;
  }
}

const aExec = util.promisify(child_process.exec);
/**
 * Returns the full path to the keybase binary or throws an error
 * @ignore
 * @example
 * whichKeybase().then((path) => console.log(path))
 */

async function whichKeybase() {
  const {
    stdout
  } = await aExec('which keybase');

  if (!stdout || !stdout.trim().length) {
    throw new Error('Could not find keybase binary');
  }

  const res = stdout.trim();
  return res;
}

function timeout(time) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve();
    }, time);
  });
}

class Service {
  constructor(workingDir) {
    this.workingDir = workingDir;
    this.initialized = false;
    this.verbose = false;
    this.botLite = true;
    this.disableTyping = true;
  }

  async init(username, paperkey, options) {
    if (!username || typeof username !== 'string') {
      throw new Error(`Please provide a username to initialize the bot. Got: ${JSON.stringify(username)}`);
    }

    if (!paperkey || typeof paperkey !== 'string') {
      // Don't want to accidentally print the paperkey to STDERR.
      throw new Error(`Please provide a paperkey to initialize the bot.`);
    }

    if (this.initialized) {
      throw new Error('Cannot initialize an already initialized bot.');
    }

    this.homeDir = this.workingDir;
    this.serviceLogFile = path.join(this.homeDir, 'Library', 'Logs', 'keybase.service.log');
    this.botLite = options ? Boolean(typeof options.botLite !== 'boolean' || options.botLite) : true;
    this.disableTyping = options ? Boolean(typeof options.disableTyping !== 'boolean' || options.disableTyping) : true; // Unlike with clients we don't need to store the service, since it shuts down with ctrl stop

    try {
      await this.startupService();
      await keybaseExec(this.workingDir, this.homeDir, ['oneshot', '--username', username], {
        stdinBuffer: paperkey
      }); // Set the typing notification settings for the bot

      await keybaseExec(this.workingDir, this.homeDir, ['chat', 'notification-settings', 'disable-typing', this.disableTyping.toString()]);
      const currentInfo = await keybaseStatus(this.workingDir, this.homeDir);

      if (currentInfo && currentInfo.username && currentInfo.devicename) {
        this.initialized = 'paperkey';
        this.username = currentInfo.username;
        this.devicename = currentInfo.devicename;
        this.verbose = options ? Boolean(options.verbose) : false;
      }

      if (this.username !== username) {
        throw new Error('Failed to initialize service.');
      }
    } catch (err) {
      await this._killCustomService();
      throw err;
    }
  }

  async initFromRunningService(homeDir, options) {
    if (this.initialized) {
      throw new Error('Cannot initialize an already initialized bot.');
    }

    this.homeDir = homeDir;
    const currentInfo = await keybaseStatus(this.workingDir, this.homeDir);

    if (currentInfo && currentInfo.username && currentInfo.devicename) {
      this.initialized = 'runningService';
      this.username = currentInfo.username;
      this.devicename = currentInfo.devicename;
      this.verbose = options ? Boolean(options.verbose) : false;
    }
  }

  async _killCustomService() {
    // these 2 commands might be unnecessary; since the service was `spawn`ed not detached
    // they will also shutdown via SIGINT. We don't want to make service detached because it'd be nice for
    // them to auto-shutdown if the user kills the process
    try {
      await keybaseExec(this.workingDir, this.homeDir, ['logout']);
    } catch (e) {}

    try {
      await keybaseExec(this.workingDir, this.homeDir, ['ctl', 'stop', '--shutdown']);
    } catch (e) {} // wait until the process quits by watching the running property


    let i = 0;

    while (true) {
      await timeout(100);

      if (!this.running) {
        break;
      }

      if (++i >= 100) {
        throw new Error(`The service didn't finish shutting down in time (${this.workingDir})`);
      }
    }
  }

  async deinit() {
    if (!this.initialized) {
      throw new Error('Cannot deinitialize an uninitialized bot.');
    } // If we init the bot using paperkey credentials, then we want to stop the service and remove our generated directory.


    if (this.initialized === 'paperkey') {
      await this._killCustomService();
    }

    this.initialized = false;
  }

  myInfo() {
    if (this.username && this.devicename) {
      return {
        username: this.username,
        devicename: this.devicename,
        homeDir: this.homeDir ? this.homeDir : undefined,
        botLite: this.botLite,
        disableTyping: this.disableTyping
      };
    }

    return null;
  }
  /**
   *
   * @ignore
   * This is a bit different from normal keybaseExecs and is unique to the service
   * starting up
   * @example
   * service.startupService()
   */


  async startupService() {
    const args = ['service'];

    if (this.homeDir) {
      args.unshift('--home', this.homeDir);
    }

    if (this.serviceLogFile) {
      args.unshift('-d', '--log-file', this.serviceLogFile);
    }

    if (this.botLite) {
      args.unshift('--enable-bot-lite-mode');
    }

    const child = child_process.spawn('keybase', args, {
      env: process.env
    }); // keep track of the subprocess' state

    this.running = true;
    child.on('exit', code => {
      this.running = false;
    });
    return new Promise(async (resolve, reject) => {
      child.on('close', code => {
        // any code here including 0 is bad here, if it happens before resolve
        //, since this service should stay running
        reject(new Error(`keybase service exited with code ${code} (${this.workingDir})`));
      }); // Wait for the service to start up - give it 10s.

      let i = 0;

      while (!(await pingKeybaseService(this.workingDir, this.homeDir))) {
        await timeout(100);

        if (++i >= 100) {
          throw new Error("Couldn't start up service fast enough");
        }
      }

      resolve();
    });
  }

}

const API_VERSIONS = {
  chat: 1,
  team: 1,
  wallet: 1
};

/**
 * A Client base.
 * @ignore
 */
class ClientBase {
  constructor(workingDir) {
    this._workingDir = workingDir;
    this.initialized = false;
    this.verbose = false;
    this.spawnedProcesses = [];
  }

  async _init(homeDir, options) {
    const initBotInfo = await keybaseStatus(this._workingDir, homeDir);
    this.homeDir = homeDir;
    this.username = initBotInfo.username;
    this.devicename = initBotInfo.devicename;
    this.initialized = true;
  }

  async _deinit() {
    for (const child of this.spawnedProcesses) {
      child.kill();
    }
  }

  async _runApiCommand(arg) {
    const options = arg.options ? formatAPIObjectInput(arg.options, arg.apiName) : undefined;
    const input = {
      method: arg.method,
      params: {
        version: API_VERSIONS[arg.apiName],
        options
      }
    };
    const inputString = JSON.stringify(input);
    const size = inputString.length;
    const output = await keybaseExec(this._workingDir, this.homeDir, [arg.apiName, 'api'], {
      stdinBuffer: Buffer.alloc(size, inputString, 'utf8'),
      json: true
    });

    if (output.hasOwnProperty('error')) {
      throw new Error(output.error.message);
    }

    const res = formatAPIObjectOutput(output.result, {
      apiName: arg.apiName,
      method: arg.method
    });
    return res;
  }

  async _guardInitialized() {
    if (!this.initialized) {
      throw new Error('The client is not yet initialized.');
    }
  }

  _pathToKeybaseBinary() {
    return path.join(this._workingDir, 'keybase');
  }

}

/** The chat module of your Keybase bot. For more info about the API this module uses, you may want to check out `keybase chat api`. */
class Chat extends ClientBase {
  /**
   * Lists your chats, with info on which ones have unread messages.
   * @memberof Chat
   * @param options - An object of options that can be passed to the method.
   * @returns - An array of chat conversations. If there are no conversations, the array is empty.
   * @example
   * bot.chat.list({unreadOnly: true}).then(chatConversations => console.log(chatConversations))
   */
  async list(options) {
    await this._guardInitialized();
    const res = await this._runApiCommand({
      apiName: 'chat',
      method: 'list',
      options
    });

    if (!res) {
      throw new Error('Keybase chat list returned nothing.');
    }

    return res.conversations || [];
  }
  /**
   * Reads the messages in a channel. You can read with or without marking as read.
   * @memberof Chat
   * @param channel - The chat channel to read messages in.
   * @param options - An object of options that can be passed to the method.
   * @returns - A summary of data about a message, including who send it, when, the content of the message, etc. If there are no messages in your channel, then an error is thrown.
   * @example
   * alice.chat.read(channel).then(messages => console.log(messages))
   */


  async read(channel, options) {
    await this._guardInitialized();
    const optionsWithDefaults = { ...options,
      channel,
      peek: options && options.peek ? options.peek : false,
      unreadOnly: options && options.unreadOnly !== undefined ? options.unreadOnly : false
    };
    const res = await this._runApiCommand({
      apiName: 'chat',
      method: 'read',
      options: optionsWithDefaults
    });

    if (!res) {
      throw new Error('Keybase chat read returned nothing.');
    } // Removes a single object with property `msg`
    // TODO: include pagination?


    const cleanedRes = res.messages.map(message => message.msg);
    return cleanedRes;
  }
  /**
   * Send a message to a certain channel.
   * @memberof Chat
   * @param channel - The chat channel to send the message in.
   * @param message - The chat message to send.
   * @param options - An object of options that can be passed to the method.
   * @example
   * const channel = {name: 'kbot,' + bot.myInfo().username, public: false, topic_type: 'chat'}
   * const message = {body: 'Hello kbot!'}
   * bot.chat.send(channel, message).then(() => console.log('message sent!'))
   */


  async send(channel, message, options) {
    await this._guardInitialized();
    const args = { ...options,
      channel,
      message
    };
    const res = await this._runApiCommand({
      apiName: 'chat',
      method: 'send',
      options: args
    });

    if (!res) {
      throw new Error('Keybase chat send returned nothing');
    }

    return {id: res.id}
  }
  /**
   * Send a file to a channel.
   * @memberof Chat
   * @param channel - The chat channel to send the message in.
   * @param filename - The absolute path of the file to send.
   * @param options - An object of options that can be passed to the method.
   * @example
   * bot.chat.attach(channel, '/Users/nathan/my_picture.png').then(() => console.log('Sent a picture!'))
   */


  async attach(channel, filename, options) {
    await this._guardInitialized();
    const args = { ...options,
      channel,
      filename
    };
    const res = await this._runApiCommand({
      apiName: 'chat',
      method: 'attach',
      options: args
    });

    if (!res) {
      throw new Error('Keybase chat attach returned nothing');
    }

    return {id: res.id}
  }
  /**
   * Download a file send via Keybase chat.
   * @memberof Chat
   * @param channel - The chat channel that the desired attacment to download is in.
   * @param messageId - The message id of the attached file.
   * @param output - The absolute path of where the file should be downloaded to.
   * @param options - An object of options that can be passed to the method
   * @example
   * bot.chat.download(channel, 325, '/Users/nathan/Downloads/file.png')
   */


  async download(channel, messageId, output, options) {
    await this._guardInitialized();
    const args = { ...options,
      channel,
      messageId,
      output
    };
    const res = await this._runApiCommand({
      apiName: 'chat',
      method: 'download',
      options: args
    });

    if (!res) {
      throw new Error('Keybase chat download returned nothing');
    }
  }
  /**
   * Reacts to a given message in a channel. Messages have messageId's associated with
   * them, which you can learn in `bot.chat.read`.
   * @memberof Chat
   * @param channel - The chat channel to send the message in.
   * @param messageId - The id of the message to react to.
   * @param reaction - The reaction emoji, in colon form.
   * @param options - An object of options that can be passed to the method.
   * @example
   * bot.chat.react(channel, 314, ':+1:').then(() => console.log('Thumbs up!'))
   */


  async react(channel, messageId, reaction, options) {
    await this._guardInitialized();
    const args = { ...options,
      channel,
      messageId,
      message: {
        body: reaction
      }
    };
    const res = await this._runApiCommand({
      apiName: 'chat',
      method: 'reaction',
      options: args
    });

    if (!res) {
      throw new Error('Keybase chat react returned nothing.');
    }

    return {id: res.id}
  }
  /**
   * Deletes a message in a channel. Messages have messageId's associated with
   * them, which you can learn in `bot.chat.read`. Known bug: the GUI has a cache,
   * and deleting from the CLI may not become apparent immediately.
   * @memberof Chat
   * @param channel - The chat channel to send the message in.
   * @param messageId - The id of the message to delete.
   * @param options - An object of options that can be passed to the method.
   * @example
   * bot.chat.delete(channel, 314).then(() => console.log('message deleted!'))
   */


  async delete(channel, messageId, options) {
    await this._guardInitialized();
    const args = { ...options,
      channel,
      messageId
    };
    const res = await this._runApiCommand({
      apiName: 'chat',
      method: 'delete',
      options: args
    });

    if (!res) {
      throw new Error('Keybase chat delete returned nothing.');
    }
  }
  /**
   * Listens for new chat messages on a specified channel. The `onMessage` function is called for every message your bot receives. This is pretty similar to `watchAllChannelsForNewMessages`, except it specifically checks one channel. Note that it receives messages your own bot posts, but from other devices. You can filter out your own messages by looking at a message's sender object.
   * @memberof Chat
   * @param channel - The chat channel to watch.
   * @param onMessage - A callback that is triggered on every message your bot receives.
   * @param onError - A callback that is triggered on any error that occurs while the method is executing.
   * @example
   * // Reply to all messages between you and `kbot` with 'thanks!'
   * const channel = {name: 'kbot,' + bot.myInfo().username, public: false, topic_type: 'chat'}
   * const onMessage = message => {
   *   const channel = message.channel
   *   bot.chat.send({
   *    channel: channel,
   *      message: {
   *        body: 'thanks!!!',
   *      },
   *   })
   * }
   * bot.chat.watchChannelForNewMessages(channel, onMessage)
   */


  async watchChannelForNewMessages(channel, onMessage, onError) {
    await this._guardInitialized();

    this._chatListen(onMessage, onError, channel);
  }
  /**
   * This function will put your bot into full-read mode, where it reads
   * everything it can and every new message it finds it will pass to you, so
   * you can do what you want with it. For example, if you want to write a
   * Keybase bot that talks shit at anyone who dares approach it, this is the
   * function to use. Note that it receives messages your own bot posts, but from other devices.
   * You can filter out your own messages by looking at a message's sender object.
   * @memberof Chat
   * @param onMessage - A callback that is triggered on every message your bot receives.
   * @param onError - A callback that is triggered on any error that occurs while the method is executing.
   * @example
   * // Reply to incoming traffic on all channels with 'thanks!'
   * const onMessage = message => {
   *   const channel = message.channel
   *   bot.chat.send({
   *    channel: channel,
   *      message: {
   *        body: 'thanks!!!',
   *      },
   *   })
   * }
   * bot.chat.watchAllChannelsForNewMessages(onMessage)
   *
   */


  async watchAllChannelsForNewMessages(onMessage, onError) {
    await this._guardInitialized();

    this._chatListen(onMessage, onError);
  }
  /**
   * Spawns the chat listen process and handles the calling of onMessage, onError, and filtering for a specific channel.
   * @memberof Chat
   * @ignore
   * @param onMessage - A callback that is triggered on every message your bot receives.
   * @param onError - A callback that is triggered on any error that occurs while the method is executing.
   * @param channel - The chat channel to watch.
   * @example
   * this._chatListen(onMessage, onError)
   */


  _chatListen(onMessage, onError, channel) {
    const args = ['chat', 'api-listen'];

    if (this.homeDir) {
      args.unshift('--home', this.homeDir);
    }

    const child = child_process.spawn(this._pathToKeybaseBinary(), args);
    this.spawnedProcesses.push(child);
    const lineReaderStdout = readline.createInterface({
      input: child.stdout
    });

    const onLine = line => {
      try {
        const messageObject = formatAPIObjectOutput(JSON.parse(line));

        if (messageObject.hasOwnProperty('error')) {
          throw new Error(messageObject.error);
        } else if ( // fire onMessage if it was from a different sender or at least a different device
        // from this sender. Bots can filter out their own messages from other devices.
        (!channel || channel.name === messageObject.msg.channel.name) && this.username && this.devicename && (messageObject.msg.sender.username !== this.username.toLowerCase() || messageObject.msg.sender.deviceName !== this.devicename)) {
          onMessage(messageObject.msg);
        }
      } catch (error) {
        if (onError) {
          onError(error);
        }
      }
    };

    lineReaderStdout.on('line', onLine);
  }

}

/** The wallet module of your Keybase bot. For more info about the API this module uses, you may want to check out `keybase wallet api`. */
class Wallet extends ClientBase {
  /**
   * Provides a list of all accounts owned by the current Keybase user.
   * @memberof Wallet
   * @returns - An array of accounts. If there are no accounts, the array is empty.
   * @example
   * bot.wallet.balances().then(accounts => console.log(accounts))
   */
  async balances() {
    await this._guardInitialized();
    const res = await this._runApiCommand({
      apiName: 'wallet',
      method: 'balances'
    });

    if (!res) {
      throw new Error('Keybase wallet balanaces returned nothing.');
    }

    return res || [];
  }
  /**
   * Provides a list of all transactions in a single account.
   * @memberof Wallet
   * @param accountId - The id of an account owned by a Keybase user.
   * @returns - An array of transactions related to the account.
   * @example
   * bot.wallet.history('GDUKZH6Q3U5WQD4PDGZXYLJE3P76BDRDWPSALN4OUFEESI2QL5UZHCK').then(transactions => console.log(transactions))
   */


  async history(accountId) {
    await this._guardInitialized();
    const options = {
      accountId
    };
    const res = await this._runApiCommand({
      apiName: 'wallet',
      method: 'history',
      options: options
    });

    if (!res) {
      throw new Error('Keybase wallet history returned nothing.');
    } // Removes a single object with property `payment`


    const cleanedRes = res.map(payment => payment.payment);
    return cleanedRes;
  }
  /**
   * Get details about a particular transaction
   * @memberof Wallet
   * @param transactionId - The id of the transaction you would like details about.
   * @returns - An object of details about the transaction specified.
   * @example
   * bot.wallet.details('e5334601b9dc2a24e031ffeec2fce37bb6a8b4b51fc711d16dec04d3e64976c4').then(details => console.log(details))
   */


  async details(transactionId) {
    await this._guardInitialized();
    const options = {
      txid: transactionId
    };
    const res = await this._runApiCommand({
      apiName: 'wallet',
      method: 'details',
      options: options
    });

    if (!res) {
      throw new Error('Keybase wallet details returned nothing.');
    }

    return res;
  }
  /**
   * Lookup the primary Stellar account ID of a Keybase user.
   * @memberof Wallet
   * @param name - The name of the user you want to lookup. This can be either a Keybase username or a username of another account that is supported by Keybase if it is followed by an '@<service>'.
   * @returns - An object containing the account ID and Keybase username of the found user.
   * @example
   * const lookup1 = bot.wallet.lookup('patrick')
   * // 'patrick' on Keybase is 'patrickxb' on twitter
   * const lookup2 = bot.wallet.lookup('patrcikxb@twitter')
   * // Using Lodash's `isEqual` since objects with same values aren't equal in JavaScript
   * _.isEqual(lookup1, lookup2) // => true
   */


  async lookup(name) {
    await this._guardInitialized();
    const options = {
      name
    };
    const res = await this._runApiCommand({
      apiName: 'wallet',
      method: 'lookup',
      options
    });

    if (!res) {
      throw new Error('Keybase wallet lookup returned nothing.');
    }

    return res;
  }
  /**
   * Send lumens (XLM) via Keybase with your bot!
   * @memberof Wallet
   * @param recipient - Who you're sending your money to. This can be a Keybase user, stellar address, or a username of another account that is supported by Keybase if it is followed by an '@<service>'.
   * @param amount - The amount of XLM to send.
   * @param [currency] - Adds a currency value to the amount specified. For example, adding 'USD' would send
   * @param [message] - The message for your payment
   * @returns - The trasaction object of the transaction.
   * @example
   * bot.wallet.send('nathunsmitty', '3.50') // Send 3.50 XLM to Keybase user `nathunsmitty`
   * bot.wallet.send('nathunsmitty@github', '3.50') // Send 3.50 XLM to GitHub user `nathunsmitty`
   * bot.wallet.send('nathunsmitty', '3.50', 'USD') // Send $3.50 worth of lumens to Keybase user `nathunsmitty`
   * bot.wallet.send('nathunsmitty', '3.50', 'USD', 'Shut up and take my money!') // Send $3.50 worth of lumens to Keybase user `nathunsmitty` with a memo
   */


  async send(recipient, amount, currency, message) {
    await this._guardInitialized();
    const options = {
      recipient,
      amount,
      currency,
      message
    };
    const res = await this._runApiCommand({
      apiName: 'wallet',
      method: 'send',
      options
    });

    if (!res) {
      throw new Error('Keybase wallet send returned nothing.');
    }

    return res;
  }
  /**
   * Send lumens (XLM) via Keybase to more than one user at once. As opposed to the normal bot.wallet.send
   * command, this can get multiple transactions into the same 5-second Stellar ledger.
   * @memberof Wallet
   * @param batchId - a unique Id for this batch, which you provide. Example, `airdrop2025`. A user can only receive once per batchId, enforced by Keybase, so if you run a program twice with the same batchId and send to the same users, subsequent sends will error.
   * @param payments - an array of objects containing recipients and XLM of the form {"recipient": "someusername", "amount": "1.234", "message", "hi there"}
   * @returns - an object
   * @example
   * bot.wallet.batch("airdrop2040",[{"recipient":"a1","amount": "1.414", "message": "hi a1, yes 1"},{"recipient": "a2", "amount": "3.14159", "message": "hi a2, yes 2"},}])
   */


  async batch(batchId, payments) {
    await this._guardInitialized();
    const options = {
      batchId,
      payments
    };
    const res = await this._runApiCommand({
      apiName: 'wallet',
      method: 'batch',
      options
    });

    if (!res) {
      throw new Error('Keybase wallet batch returned nothing.');
    }

    return res;
  }
  /**
   * If you send XLM to a Keybase user who has not established a wallet, you can cancel the payment before the recipient claims it and the XLM will be returned to your account.
   * @memberof Wallet
   * @param transactionId - The id of the transaction to cancel.
   * @example
   * bot.wallet.cancel('e5334601b9dc2a24e031ffeec2fce37bb6a8b4b51fc711d16dec04d3e64976c4').then(() => console.log('Transaction successfully canceled!'))
   */


  async cancel(transactionId) {
    await this._guardInitialized();
    const options = {
      txid: transactionId
    };
    const res = await this._runApiCommand({
      apiName: 'wallet',
      method: 'cancel',
      options
    });

    if (!res) {
      throw new Error('Keybase wallet cancel returned nothing.');
    }
  }

}

/** A Keybase bot. */
class Bot {
  // where KB binary copied, and homeDir (if not existing svc)

  /**
   * Create a bot. Note you can't do much too exciting with your bot after you instantiate it; you have to initialize it first.
   * @memberof Bot
   * @example
   * const bot = new Bot()
   */
  constructor() {
    this._workingDir = randomTempDir();
    this._service = new Service(this._workingDir);
    this.chat = new Chat(this._workingDir);
    this.wallet = new Wallet(this._workingDir);
  }
  /**
   * Initialize your bot by starting an instance of the Keybase service and logging in using oneshot mode.
   * @memberof Bot
   * @param username - The username of your bot's Keybase account.
   * @param paperkey - The paperkey of your bot's Keybase account.
   * @param options - The initialization options for your bot.
   * @example
   * bot.init('username', 'paperkey')
   */


  async init(username, paperkey, options) {
    await this._prepWorkingDir();
    await this._service.init(username, paperkey, options);
    await this._initSubBots(options);
  }
  /**
   * Initialize your bot by using an existing running service with a logged in user.
   * @memberof Bot
   * @param homeDir - The home directory of this currently running service. Leave blank to use the default homeDir for your system.
   * @param options - The initialization options for your bot.
   * @example
   * bot.initFromRunningService()
   */


  async initFromRunningService(homeDir, options) {
    await this._prepWorkingDir();
    await this._service.initFromRunningService(homeDir, options);
    await this._initSubBots(options);
  }
  /**
   * Get info about your bot!
   * @memberof Bot
   * @returns – Useful information like the username, device, and home directory of your bot. If your bot isn't initialized, you'll get `null`.
   * @example
   * const info = bot.myInfo()
   */


  myInfo() {
    return this._service.myInfo();
  }
  /**
   * Deinitializes the bot by logging out, stopping the keybase service, and removing any leftover login files made by the bot. This should be run before your bot ends.
   * @memberof Bot
   * @example
   * bot.deinit()
   */


  async deinit() {
    // Stop the clients first, so that they aren't trying to
    // talk to a deinit'ed service
    await this.chat._deinit();
    await this._service.deinit();
    await rmdirRecursive(this._workingDir);
  }

  async _prepWorkingDir() {
    const keybaseBinaryLocation = await whichKeybase();
    const destination = path.join(this._workingDir, 'keybase');
    await util.promisify(mkdirp)(this._workingDir);
    await util.promisify(fs.copyFile)(keybaseBinaryLocation, destination);
  }

  async _initSubBots(options) {
    const info = this.myInfo();

    if (info) {
      await this.chat._init(info.homeDir, options);
      await this.wallet._init(info.homeDir, options);
    } else {
      throw new Error('Issue initializing bot.');
    }
  }

}

module.exports = Bot;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/lodash.camelcase/index.js":
/*!************************************************!*\
  !*** ./node_modules/lodash.camelcase/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsAstral = '[' + rsAstralRange + ']',
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
  rsUpper + '+' + rsOptUpperContr,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 'ss'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);

    var strSymbols = hasUnicode(string)
      ? stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the camel cased string.
 * @example
 *
 * _.camelCase('Foo Bar');
 * // => 'fooBar'
 *
 * _.camelCase('--foo-bar--');
 * // => 'fooBar'
 *
 * _.camelCase('__FOO_BAR__');
 * // => 'fooBar'
 */
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});

/**
 * Converts the first character of `string` to upper case and the remaining
 * to lower case.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to capitalize.
 * @returns {string} Returns the capitalized string.
 * @example
 *
 * _.capitalize('FRED');
 * // => 'Fred'
 */
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = createCaseFirst('toUpperCase');

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = camelCase;


/***/ }),

/***/ "./node_modules/lodash.kebabcase/index.js":
/*!************************************************!*\
  !*** ./node_modules/lodash.kebabcase/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
  rsUpper + '+' + rsOptUpperContr,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 'ss'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

/**
 * Converts `string` to
 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__FOO_BAR__');
 * // => 'foo-bar'
 */
var kebabCase = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = kebabCase;


/***/ }),

/***/ "./node_modules/lodash.snakecase/index.js":
/*!************************************************!*\
  !*** ./node_modules/lodash.snakecase/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
    rsComboSymbolsRange = '\\u20d0-\\u20f0',
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo, 'g');

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
  rsUpper + '+' + rsOptUpperContr,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 'ss'
};

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

/**
 * Converts `string` to
 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the snake cased string.
 * @example
 *
 * _.snakeCase('Foo Bar');
 * // => 'foo_bar'
 *
 * _.snakeCase('fooBar');
 * // => 'foo_bar'
 *
 * _.snakeCase('--FOO-BAR--');
 * // => 'foo_bar'
 */
var snakeCase = createCompounder(function(result, word, index) {
  return result + (index ? '_' : '') + word.toLowerCase();
});

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

module.exports = snakeCase;


/***/ }),

/***/ "./node_modules/mime-db/db.json":
/*!**************************************!*\
  !*** ./node_modules/mime-db/db.json ***!
  \**************************************/
/*! exports provided: application/1d-interleaved-parityfec, application/3gpdash-qoe-report+xml, application/3gpp-ims+xml, application/a2l, application/activemessage, application/activity+json, application/alto-costmap+json, application/alto-costmapfilter+json, application/alto-directory+json, application/alto-endpointcost+json, application/alto-endpointcostparams+json, application/alto-endpointprop+json, application/alto-endpointpropparams+json, application/alto-error+json, application/alto-networkmap+json, application/alto-networkmapfilter+json, application/aml, application/andrew-inset, application/applefile, application/applixware, application/atf, application/atfx, application/atom+xml, application/atomcat+xml, application/atomdeleted+xml, application/atomicmail, application/atomsvc+xml, application/atxml, application/auth-policy+xml, application/bacnet-xdd+zip, application/batch-smtp, application/bdoc, application/beep+xml, application/calendar+json, application/calendar+xml, application/call-completion, application/cals-1840, application/cbor, application/cccex, application/ccmp+xml, application/ccxml+xml, application/cdfx+xml, application/cdmi-capability, application/cdmi-container, application/cdmi-domain, application/cdmi-object, application/cdmi-queue, application/cdni, application/cea, application/cea-2018+xml, application/cellml+xml, application/cfw, application/clue_info+xml, application/cms, application/cnrp+xml, application/coap-group+json, application/coap-payload, application/commonground, application/conference-info+xml, application/cose, application/cose-key, application/cose-key-set, application/cpl+xml, application/csrattrs, application/csta+xml, application/cstadata+xml, application/csvm+json, application/cu-seeme, application/cwt, application/cybercash, application/dart, application/dash+xml, application/dashdelta, application/davmount+xml, application/dca-rft, application/dcd, application/dec-dx, application/dialog-info+xml, application/dicom, application/dicom+json, application/dicom+xml, application/dii, application/dit, application/dns, application/dns+json, application/dns-message, application/docbook+xml, application/dskpp+xml, application/dssc+der, application/dssc+xml, application/dvcs, application/ecmascript, application/edi-consent, application/edi-x12, application/edifact, application/efi, application/emergencycalldata.comment+xml, application/emergencycalldata.control+xml, application/emergencycalldata.deviceinfo+xml, application/emergencycalldata.ecall.msd, application/emergencycalldata.providerinfo+xml, application/emergencycalldata.serviceinfo+xml, application/emergencycalldata.subscriberinfo+xml, application/emergencycalldata.veds+xml, application/emma+xml, application/emotionml+xml, application/encaprtp, application/epp+xml, application/epub+zip, application/eshop, application/exi, application/fastinfoset, application/fastsoap, application/fdt+xml, application/fhir+json, application/fhir+xml, application/fido.trusted-apps+json, application/fits, application/font-sfnt, application/font-tdpfr, application/font-woff, application/framework-attributes+xml, application/geo+json, application/geo+json-seq, application/geopackage+sqlite3, application/geoxacml+xml, application/gltf-buffer, application/gml+xml, application/gpx+xml, application/gxf, application/gzip, application/h224, application/held+xml, application/hjson, application/http, application/hyperstudio, application/ibe-key-request+xml, application/ibe-pkg-reply+xml, application/ibe-pp-data, application/iges, application/im-iscomposing+xml, application/index, application/index.cmd, application/index.obj, application/index.response, application/index.vnd, application/inkml+xml, application/iotp, application/ipfix, application/ipp, application/isup, application/its+xml, application/java-archive, application/java-serialized-object, application/java-vm, application/javascript, application/jf2feed+json, application/jose, application/jose+json, application/jrd+json, application/json, application/json-patch+json, application/json-seq, application/json5, application/jsonml+json, application/jwk+json, application/jwk-set+json, application/jwt, application/kpml-request+xml, application/kpml-response+xml, application/ld+json, application/lgr+xml, application/link-format, application/load-control+xml, application/lost+xml, application/lostsync+xml, application/lxf, application/mac-binhex40, application/mac-compactpro, application/macwriteii, application/mads+xml, application/manifest+json, application/marc, application/marcxml+xml, application/mathematica, application/mathml+xml, application/mathml-content+xml, application/mathml-presentation+xml, application/mbms-associated-procedure-description+xml, application/mbms-deregister+xml, application/mbms-envelope+xml, application/mbms-msk+xml, application/mbms-msk-response+xml, application/mbms-protection-description+xml, application/mbms-reception-report+xml, application/mbms-register+xml, application/mbms-register-response+xml, application/mbms-schedule+xml, application/mbms-user-service-description+xml, application/mbox, application/media-policy-dataset+xml, application/media_control+xml, application/mediaservercontrol+xml, application/merge-patch+json, application/metalink+xml, application/metalink4+xml, application/mets+xml, application/mf4, application/mikey, application/mmt-usd+xml, application/mods+xml, application/moss-keys, application/moss-signature, application/mosskey-data, application/mosskey-request, application/mp21, application/mp4, application/mpeg4-generic, application/mpeg4-iod, application/mpeg4-iod-xmt, application/mrb-consumer+xml, application/mrb-publish+xml, application/msc-ivr+xml, application/msc-mixer+xml, application/msword, application/mud+json, application/mxf, application/n-quads, application/n-triples, application/nasdata, application/news-checkgroups, application/news-groupinfo, application/news-transmission, application/nlsml+xml, application/node, application/nss, application/ocsp-request, application/ocsp-response, application/octet-stream, application/oda, application/odx, application/oebps-package+xml, application/ogg, application/omdoc+xml, application/onenote, application/oxps, application/p2p-overlay+xml, application/parityfec, application/passport, application/patch-ops-error+xml, application/pdf, application/pdx, application/pgp-encrypted, application/pgp-keys, application/pgp-signature, application/pics-rules, application/pidf+xml, application/pidf-diff+xml, application/pkcs10, application/pkcs12, application/pkcs7-mime, application/pkcs7-signature, application/pkcs8, application/pkcs8-encrypted, application/pkix-attr-cert, application/pkix-cert, application/pkix-crl, application/pkix-pkipath, application/pkixcmp, application/pls+xml, application/poc-settings+xml, application/postscript, application/ppsp-tracker+json, application/problem+json, application/problem+xml, application/provenance+xml, application/prs.alvestrand.titrax-sheet, application/prs.cww, application/prs.hpub+zip, application/prs.nprend, application/prs.plucker, application/prs.rdf-xml-crypt, application/prs.xsf+xml, application/pskc+xml, application/qsig, application/raml+yaml, application/raptorfec, application/rdap+json, application/rdf+xml, application/reginfo+xml, application/relax-ng-compact-syntax, application/remote-printing, application/reputon+json, application/resource-lists+xml, application/resource-lists-diff+xml, application/rfc+xml, application/riscos, application/rlmi+xml, application/rls-services+xml, application/route-apd+xml, application/route-s-tsid+xml, application/route-usd+xml, application/rpki-ghostbusters, application/rpki-manifest, application/rpki-publication, application/rpki-roa, application/rpki-updown, application/rsd+xml, application/rss+xml, application/rtf, application/rtploopback, application/rtx, application/samlassertion+xml, application/samlmetadata+xml, application/sbml+xml, application/scaip+xml, application/scim+json, application/scvp-cv-request, application/scvp-cv-response, application/scvp-vp-request, application/scvp-vp-response, application/sdp, application/secevent+jwt, application/senml+cbor, application/senml+json, application/senml+xml, application/senml-exi, application/sensml+cbor, application/sensml+json, application/sensml+xml, application/sensml-exi, application/sep+xml, application/sep-exi, application/session-info, application/set-payment, application/set-payment-initiation, application/set-registration, application/set-registration-initiation, application/sgml, application/sgml-open-catalog, application/shf+xml, application/sieve, application/simple-filter+xml, application/simple-message-summary, application/simplesymbolcontainer, application/slate, application/smil, application/smil+xml, application/smpte336m, application/soap+fastinfoset, application/soap+xml, application/sparql-query, application/sparql-results+xml, application/spirits-event+xml, application/sql, application/srgs, application/srgs+xml, application/sru+xml, application/ssdl+xml, application/ssml+xml, application/stix+json, application/tamp-apex-update, application/tamp-apex-update-confirm, application/tamp-community-update, application/tamp-community-update-confirm, application/tamp-error, application/tamp-sequence-adjust, application/tamp-sequence-adjust-confirm, application/tamp-status-query, application/tamp-status-response, application/tamp-update, application/tamp-update-confirm, application/tar, application/taxii+json, application/tei+xml, application/thraud+xml, application/timestamp-query, application/timestamp-reply, application/timestamped-data, application/tlsrpt+gzip, application/tlsrpt+json, application/tnauthlist, application/trickle-ice-sdpfrag, application/trig, application/ttml+xml, application/tve-trigger, application/ulpfec, application/urc-grpsheet+xml, application/urc-ressheet+xml, application/urc-targetdesc+xml, application/urc-uisocketdesc+xml, application/vcard+json, application/vcard+xml, application/vemmi, application/vividence.scriptfile, application/vnd.1000minds.decision-model+xml, application/vnd.3gpp-prose+xml, application/vnd.3gpp-prose-pc3ch+xml, application/vnd.3gpp-v2x-local-service-information, application/vnd.3gpp.access-transfer-events+xml, application/vnd.3gpp.bsf+xml, application/vnd.3gpp.gmop+xml, application/vnd.3gpp.mc-signalling-ear, application/vnd.3gpp.mcdata-payload, application/vnd.3gpp.mcdata-signalling, application/vnd.3gpp.mcptt-affiliation-command+xml, application/vnd.3gpp.mcptt-floor-request+xml, application/vnd.3gpp.mcptt-info+xml, application/vnd.3gpp.mcptt-location-info+xml, application/vnd.3gpp.mcptt-mbms-usage-info+xml, application/vnd.3gpp.mcptt-signed+xml, application/vnd.3gpp.mid-call+xml, application/vnd.3gpp.pic-bw-large, application/vnd.3gpp.pic-bw-small, application/vnd.3gpp.pic-bw-var, application/vnd.3gpp.sms, application/vnd.3gpp.sms+xml, application/vnd.3gpp.srvcc-ext+xml, application/vnd.3gpp.srvcc-info+xml, application/vnd.3gpp.state-and-event-info+xml, application/vnd.3gpp.ussd+xml, application/vnd.3gpp2.bcmcsinfo+xml, application/vnd.3gpp2.sms, application/vnd.3gpp2.tcap, application/vnd.3lightssoftware.imagescal, application/vnd.3m.post-it-notes, application/vnd.accpac.simply.aso, application/vnd.accpac.simply.imp, application/vnd.acucobol, application/vnd.acucorp, application/vnd.adobe.air-application-installer-package+zip, application/vnd.adobe.flash.movie, application/vnd.adobe.formscentral.fcdt, application/vnd.adobe.fxp, application/vnd.adobe.partial-upload, application/vnd.adobe.xdp+xml, application/vnd.adobe.xfdf, application/vnd.aether.imp, application/vnd.afpc.afplinedata, application/vnd.afpc.modca, application/vnd.ah-barcode, application/vnd.ahead.space, application/vnd.airzip.filesecure.azf, application/vnd.airzip.filesecure.azs, application/vnd.amadeus+json, application/vnd.amazon.ebook, application/vnd.amazon.mobi8-ebook, application/vnd.americandynamics.acc, application/vnd.amiga.ami, application/vnd.amundsen.maze+xml, application/vnd.android.package-archive, application/vnd.anki, application/vnd.anser-web-certificate-issue-initiation, application/vnd.anser-web-funds-transfer-initiation, application/vnd.antix.game-component, application/vnd.apache.thrift.binary, application/vnd.apache.thrift.compact, application/vnd.apache.thrift.json, application/vnd.api+json, application/vnd.apothekende.reservation+json, application/vnd.apple.installer+xml, application/vnd.apple.keynote, application/vnd.apple.mpegurl, application/vnd.apple.numbers, application/vnd.apple.pages, application/vnd.apple.pkpass, application/vnd.arastra.swi, application/vnd.aristanetworks.swi, application/vnd.artisan+json, application/vnd.artsquare, application/vnd.astraea-software.iota, application/vnd.audiograph, application/vnd.autopackage, application/vnd.avalon+json, application/vnd.avistar+xml, application/vnd.balsamiq.bmml+xml, application/vnd.balsamiq.bmpr, application/vnd.banana-accounting, application/vnd.bbf.usp.msg, application/vnd.bbf.usp.msg+json, application/vnd.bekitzur-stech+json, application/vnd.bint.med-content, application/vnd.biopax.rdf+xml, application/vnd.blink-idb-value-wrapper, application/vnd.blueice.multipass, application/vnd.bluetooth.ep.oob, application/vnd.bluetooth.le.oob, application/vnd.bmi, application/vnd.businessobjects, application/vnd.byu.uapi+json, application/vnd.cab-jscript, application/vnd.canon-cpdl, application/vnd.canon-lips, application/vnd.capasystems-pg+json, application/vnd.cendio.thinlinc.clientconf, application/vnd.century-systems.tcp_stream, application/vnd.chemdraw+xml, application/vnd.chess-pgn, application/vnd.chipnuts.karaoke-mmd, application/vnd.cinderella, application/vnd.cirpack.isdn-ext, application/vnd.citationstyles.style+xml, application/vnd.claymore, application/vnd.cloanto.rp9, application/vnd.clonk.c4group, application/vnd.cluetrust.cartomobile-config, application/vnd.cluetrust.cartomobile-config-pkg, application/vnd.coffeescript, application/vnd.collabio.xodocuments.document, application/vnd.collabio.xodocuments.document-template, application/vnd.collabio.xodocuments.presentation, application/vnd.collabio.xodocuments.presentation-template, application/vnd.collabio.xodocuments.spreadsheet, application/vnd.collabio.xodocuments.spreadsheet-template, application/vnd.collection+json, application/vnd.collection.doc+json, application/vnd.collection.next+json, application/vnd.comicbook+zip, application/vnd.comicbook-rar, application/vnd.commerce-battelle, application/vnd.commonspace, application/vnd.contact.cmsg, application/vnd.coreos.ignition+json, application/vnd.cosmocaller, application/vnd.crick.clicker, application/vnd.crick.clicker.keyboard, application/vnd.crick.clicker.palette, application/vnd.crick.clicker.template, application/vnd.crick.clicker.wordbank, application/vnd.criticaltools.wbs+xml, application/vnd.ctc-posml, application/vnd.ctct.ws+xml, application/vnd.cups-pdf, application/vnd.cups-postscript, application/vnd.cups-ppd, application/vnd.cups-raster, application/vnd.cups-raw, application/vnd.curl, application/vnd.curl.car, application/vnd.curl.pcurl, application/vnd.cyan.dean.root+xml, application/vnd.cybank, application/vnd.d2l.coursepackage1p0+zip, application/vnd.dart, application/vnd.data-vision.rdz, application/vnd.datapackage+json, application/vnd.dataresource+json, application/vnd.debian.binary-package, application/vnd.dece.data, application/vnd.dece.ttml+xml, application/vnd.dece.unspecified, application/vnd.dece.zip, application/vnd.denovo.fcselayout-link, application/vnd.desmume.movie, application/vnd.dir-bi.plate-dl-nosuffix, application/vnd.dm.delegation+xml, application/vnd.dna, application/vnd.document+json, application/vnd.dolby.mlp, application/vnd.dolby.mobile.1, application/vnd.dolby.mobile.2, application/vnd.doremir.scorecloud-binary-document, application/vnd.dpgraph, application/vnd.dreamfactory, application/vnd.drive+json, application/vnd.ds-keypoint, application/vnd.dtg.local, application/vnd.dtg.local.flash, application/vnd.dtg.local.html, application/vnd.dvb.ait, application/vnd.dvb.dvbj, application/vnd.dvb.esgcontainer, application/vnd.dvb.ipdcdftnotifaccess, application/vnd.dvb.ipdcesgaccess, application/vnd.dvb.ipdcesgaccess2, application/vnd.dvb.ipdcesgpdd, application/vnd.dvb.ipdcroaming, application/vnd.dvb.iptv.alfec-base, application/vnd.dvb.iptv.alfec-enhancement, application/vnd.dvb.notif-aggregate-root+xml, application/vnd.dvb.notif-container+xml, application/vnd.dvb.notif-generic+xml, application/vnd.dvb.notif-ia-msglist+xml, application/vnd.dvb.notif-ia-registration-request+xml, application/vnd.dvb.notif-ia-registration-response+xml, application/vnd.dvb.notif-init+xml, application/vnd.dvb.pfr, application/vnd.dvb.service, application/vnd.dxr, application/vnd.dynageo, application/vnd.dzr, application/vnd.easykaraoke.cdgdownload, application/vnd.ecdis-update, application/vnd.ecip.rlp, application/vnd.ecowin.chart, application/vnd.ecowin.filerequest, application/vnd.ecowin.fileupdate, application/vnd.ecowin.series, application/vnd.ecowin.seriesrequest, application/vnd.ecowin.seriesupdate, application/vnd.efi.img, application/vnd.efi.iso, application/vnd.emclient.accessrequest+xml, application/vnd.enliven, application/vnd.enphase.envoy, application/vnd.eprints.data+xml, application/vnd.epson.esf, application/vnd.epson.msf, application/vnd.epson.quickanime, application/vnd.epson.salt, application/vnd.epson.ssf, application/vnd.ericsson.quickcall, application/vnd.espass-espass+zip, application/vnd.eszigno3+xml, application/vnd.etsi.aoc+xml, application/vnd.etsi.asic-e+zip, application/vnd.etsi.asic-s+zip, application/vnd.etsi.cug+xml, application/vnd.etsi.iptvcommand+xml, application/vnd.etsi.iptvdiscovery+xml, application/vnd.etsi.iptvprofile+xml, application/vnd.etsi.iptvsad-bc+xml, application/vnd.etsi.iptvsad-cod+xml, application/vnd.etsi.iptvsad-npvr+xml, application/vnd.etsi.iptvservice+xml, application/vnd.etsi.iptvsync+xml, application/vnd.etsi.iptvueprofile+xml, application/vnd.etsi.mcid+xml, application/vnd.etsi.mheg5, application/vnd.etsi.overload-control-policy-dataset+xml, application/vnd.etsi.pstn+xml, application/vnd.etsi.sci+xml, application/vnd.etsi.simservs+xml, application/vnd.etsi.timestamp-token, application/vnd.etsi.tsl+xml, application/vnd.etsi.tsl.der, application/vnd.eudora.data, application/vnd.evolv.ecig.profile, application/vnd.evolv.ecig.settings, application/vnd.evolv.ecig.theme, application/vnd.exstream-empower+zip, application/vnd.ezpix-album, application/vnd.ezpix-package, application/vnd.f-secure.mobile, application/vnd.fastcopy-disk-image, application/vnd.fdf, application/vnd.fdsn.mseed, application/vnd.fdsn.seed, application/vnd.ffsns, application/vnd.filmit.zfc, application/vnd.fints, application/vnd.firemonkeys.cloudcell, application/vnd.flographit, application/vnd.fluxtime.clip, application/vnd.font-fontforge-sfd, application/vnd.framemaker, application/vnd.frogans.fnc, application/vnd.frogans.ltf, application/vnd.fsc.weblaunch, application/vnd.fujitsu.oasys, application/vnd.fujitsu.oasys2, application/vnd.fujitsu.oasys3, application/vnd.fujitsu.oasysgp, application/vnd.fujitsu.oasysprs, application/vnd.fujixerox.art-ex, application/vnd.fujixerox.art4, application/vnd.fujixerox.ddd, application/vnd.fujixerox.docuworks, application/vnd.fujixerox.docuworks.binder, application/vnd.fujixerox.docuworks.container, application/vnd.fujixerox.hbpl, application/vnd.fut-misnet, application/vnd.futoin+cbor, application/vnd.futoin+json, application/vnd.fuzzysheet, application/vnd.genomatix.tuxedo, application/vnd.geo+json, application/vnd.geocube+xml, application/vnd.geogebra.file, application/vnd.geogebra.tool, application/vnd.geometry-explorer, application/vnd.geonext, application/vnd.geoplan, application/vnd.geospace, application/vnd.gerber, application/vnd.globalplatform.card-content-mgt, application/vnd.globalplatform.card-content-mgt-response, application/vnd.gmx, application/vnd.google-apps.document, application/vnd.google-apps.presentation, application/vnd.google-apps.spreadsheet, application/vnd.google-earth.kml+xml, application/vnd.google-earth.kmz, application/vnd.gov.sk.e-form+xml, application/vnd.gov.sk.e-form+zip, application/vnd.gov.sk.xmldatacontainer+xml, application/vnd.grafeq, application/vnd.gridmp, application/vnd.groove-account, application/vnd.groove-help, application/vnd.groove-identity-message, application/vnd.groove-injector, application/vnd.groove-tool-message, application/vnd.groove-tool-template, application/vnd.groove-vcard, application/vnd.hal+json, application/vnd.hal+xml, application/vnd.handheld-entertainment+xml, application/vnd.hbci, application/vnd.hc+json, application/vnd.hcl-bireports, application/vnd.hdt, application/vnd.heroku+json, application/vnd.hhe.lesson-player, application/vnd.hp-hpgl, application/vnd.hp-hpid, application/vnd.hp-hps, application/vnd.hp-jlyt, application/vnd.hp-pcl, application/vnd.hp-pclxl, application/vnd.httphone, application/vnd.hydrostatix.sof-data, application/vnd.hyper+json, application/vnd.hyper-item+json, application/vnd.hyperdrive+json, application/vnd.hzn-3d-crossword, application/vnd.ibm.afplinedata, application/vnd.ibm.electronic-media, application/vnd.ibm.minipay, application/vnd.ibm.modcap, application/vnd.ibm.rights-management, application/vnd.ibm.secure-container, application/vnd.iccprofile, application/vnd.ieee.1905, application/vnd.igloader, application/vnd.imagemeter.folder+zip, application/vnd.imagemeter.image+zip, application/vnd.immervision-ivp, application/vnd.immervision-ivu, application/vnd.ims.imsccv1p1, application/vnd.ims.imsccv1p2, application/vnd.ims.imsccv1p3, application/vnd.ims.lis.v2.result+json, application/vnd.ims.lti.v2.toolconsumerprofile+json, application/vnd.ims.lti.v2.toolproxy+json, application/vnd.ims.lti.v2.toolproxy.id+json, application/vnd.ims.lti.v2.toolsettings+json, application/vnd.ims.lti.v2.toolsettings.simple+json, application/vnd.informedcontrol.rms+xml, application/vnd.informix-visionary, application/vnd.infotech.project, application/vnd.infotech.project+xml, application/vnd.innopath.wamp.notification, application/vnd.insors.igm, application/vnd.intercon.formnet, application/vnd.intergeo, application/vnd.intertrust.digibox, application/vnd.intertrust.nncp, application/vnd.intu.qbo, application/vnd.intu.qfx, application/vnd.iptc.g2.catalogitem+xml, application/vnd.iptc.g2.conceptitem+xml, application/vnd.iptc.g2.knowledgeitem+xml, application/vnd.iptc.g2.newsitem+xml, application/vnd.iptc.g2.newsmessage+xml, application/vnd.iptc.g2.packageitem+xml, application/vnd.iptc.g2.planningitem+xml, application/vnd.ipunplugged.rcprofile, application/vnd.irepository.package+xml, application/vnd.is-xpr, application/vnd.isac.fcs, application/vnd.jam, application/vnd.japannet-directory-service, application/vnd.japannet-jpnstore-wakeup, application/vnd.japannet-payment-wakeup, application/vnd.japannet-registration, application/vnd.japannet-registration-wakeup, application/vnd.japannet-setstore-wakeup, application/vnd.japannet-verification, application/vnd.japannet-verification-wakeup, application/vnd.jcp.javame.midlet-rms, application/vnd.jisp, application/vnd.joost.joda-archive, application/vnd.jsk.isdn-ngn, application/vnd.kahootz, application/vnd.kde.karbon, application/vnd.kde.kchart, application/vnd.kde.kformula, application/vnd.kde.kivio, application/vnd.kde.kontour, application/vnd.kde.kpresenter, application/vnd.kde.kspread, application/vnd.kde.kword, application/vnd.kenameaapp, application/vnd.kidspiration, application/vnd.kinar, application/vnd.koan, application/vnd.kodak-descriptor, application/vnd.las.las+json, application/vnd.las.las+xml, application/vnd.leap+json, application/vnd.liberty-request+xml, application/vnd.llamagraphics.life-balance.desktop, application/vnd.llamagraphics.life-balance.exchange+xml, application/vnd.lotus-1-2-3, application/vnd.lotus-approach, application/vnd.lotus-freelance, application/vnd.lotus-notes, application/vnd.lotus-organizer, application/vnd.lotus-screencam, application/vnd.lotus-wordpro, application/vnd.macports.portpkg, application/vnd.mapbox-vector-tile, application/vnd.marlin.drm.actiontoken+xml, application/vnd.marlin.drm.conftoken+xml, application/vnd.marlin.drm.license+xml, application/vnd.marlin.drm.mdcf, application/vnd.mason+json, application/vnd.maxmind.maxmind-db, application/vnd.mcd, application/vnd.medcalcdata, application/vnd.mediastation.cdkey, application/vnd.meridian-slingshot, application/vnd.mfer, application/vnd.mfmp, application/vnd.micro+json, application/vnd.micrografx.flo, application/vnd.micrografx.igx, application/vnd.microsoft.portable-executable, application/vnd.microsoft.windows.thumbnail-cache, application/vnd.miele+json, application/vnd.mif, application/vnd.minisoft-hp3000-save, application/vnd.mitsubishi.misty-guard.trustweb, application/vnd.mobius.daf, application/vnd.mobius.dis, application/vnd.mobius.mbk, application/vnd.mobius.mqy, application/vnd.mobius.msl, application/vnd.mobius.plc, application/vnd.mobius.txf, application/vnd.mophun.application, application/vnd.mophun.certificate, application/vnd.motorola.flexsuite, application/vnd.motorola.flexsuite.adsi, application/vnd.motorola.flexsuite.fis, application/vnd.motorola.flexsuite.gotap, application/vnd.motorola.flexsuite.kmr, application/vnd.motorola.flexsuite.ttc, application/vnd.motorola.flexsuite.wem, application/vnd.motorola.iprm, application/vnd.mozilla.xul+xml, application/vnd.ms-3mfdocument, application/vnd.ms-artgalry, application/vnd.ms-asf, application/vnd.ms-cab-compressed, application/vnd.ms-color.iccprofile, application/vnd.ms-excel, application/vnd.ms-excel.addin.macroenabled.12, application/vnd.ms-excel.sheet.binary.macroenabled.12, application/vnd.ms-excel.sheet.macroenabled.12, application/vnd.ms-excel.template.macroenabled.12, application/vnd.ms-fontobject, application/vnd.ms-htmlhelp, application/vnd.ms-ims, application/vnd.ms-lrm, application/vnd.ms-office.activex+xml, application/vnd.ms-officetheme, application/vnd.ms-opentype, application/vnd.ms-outlook, application/vnd.ms-package.obfuscated-opentype, application/vnd.ms-pki.seccat, application/vnd.ms-pki.stl, application/vnd.ms-playready.initiator+xml, application/vnd.ms-powerpoint, application/vnd.ms-powerpoint.addin.macroenabled.12, application/vnd.ms-powerpoint.presentation.macroenabled.12, application/vnd.ms-powerpoint.slide.macroenabled.12, application/vnd.ms-powerpoint.slideshow.macroenabled.12, application/vnd.ms-powerpoint.template.macroenabled.12, application/vnd.ms-printdevicecapabilities+xml, application/vnd.ms-printing.printticket+xml, application/vnd.ms-printschematicket+xml, application/vnd.ms-project, application/vnd.ms-tnef, application/vnd.ms-windows.devicepairing, application/vnd.ms-windows.nwprinting.oob, application/vnd.ms-windows.printerpairing, application/vnd.ms-windows.wsd.oob, application/vnd.ms-wmdrm.lic-chlg-req, application/vnd.ms-wmdrm.lic-resp, application/vnd.ms-wmdrm.meter-chlg-req, application/vnd.ms-wmdrm.meter-resp, application/vnd.ms-word.document.macroenabled.12, application/vnd.ms-word.template.macroenabled.12, application/vnd.ms-works, application/vnd.ms-wpl, application/vnd.ms-xpsdocument, application/vnd.msa-disk-image, application/vnd.mseq, application/vnd.msign, application/vnd.multiad.creator, application/vnd.multiad.creator.cif, application/vnd.music-niff, application/vnd.musician, application/vnd.muvee.style, application/vnd.mynfc, application/vnd.ncd.control, application/vnd.ncd.reference, application/vnd.nearst.inv+json, application/vnd.nervana, application/vnd.netfpx, application/vnd.neurolanguage.nlu, application/vnd.nimn, application/vnd.nintendo.nitro.rom, application/vnd.nintendo.snes.rom, application/vnd.nitf, application/vnd.noblenet-directory, application/vnd.noblenet-sealer, application/vnd.noblenet-web, application/vnd.nokia.catalogs, application/vnd.nokia.conml+wbxml, application/vnd.nokia.conml+xml, application/vnd.nokia.iptv.config+xml, application/vnd.nokia.isds-radio-presets, application/vnd.nokia.landmark+wbxml, application/vnd.nokia.landmark+xml, application/vnd.nokia.landmarkcollection+xml, application/vnd.nokia.n-gage.ac+xml, application/vnd.nokia.n-gage.data, application/vnd.nokia.n-gage.symbian.install, application/vnd.nokia.ncd, application/vnd.nokia.pcd+wbxml, application/vnd.nokia.pcd+xml, application/vnd.nokia.radio-preset, application/vnd.nokia.radio-presets, application/vnd.novadigm.edm, application/vnd.novadigm.edx, application/vnd.novadigm.ext, application/vnd.ntt-local.content-share, application/vnd.ntt-local.file-transfer, application/vnd.ntt-local.ogw_remote-access, application/vnd.ntt-local.sip-ta_remote, application/vnd.ntt-local.sip-ta_tcp_stream, application/vnd.oasis.opendocument.chart, application/vnd.oasis.opendocument.chart-template, application/vnd.oasis.opendocument.database, application/vnd.oasis.opendocument.formula, application/vnd.oasis.opendocument.formula-template, application/vnd.oasis.opendocument.graphics, application/vnd.oasis.opendocument.graphics-template, application/vnd.oasis.opendocument.image, application/vnd.oasis.opendocument.image-template, application/vnd.oasis.opendocument.presentation, application/vnd.oasis.opendocument.presentation-template, application/vnd.oasis.opendocument.spreadsheet, application/vnd.oasis.opendocument.spreadsheet-template, application/vnd.oasis.opendocument.text, application/vnd.oasis.opendocument.text-master, application/vnd.oasis.opendocument.text-template, application/vnd.oasis.opendocument.text-web, application/vnd.obn, application/vnd.ocf+cbor, application/vnd.oftn.l10n+json, application/vnd.oipf.contentaccessdownload+xml, application/vnd.oipf.contentaccessstreaming+xml, application/vnd.oipf.cspg-hexbinary, application/vnd.oipf.dae.svg+xml, application/vnd.oipf.dae.xhtml+xml, application/vnd.oipf.mippvcontrolmessage+xml, application/vnd.oipf.pae.gem, application/vnd.oipf.spdiscovery+xml, application/vnd.oipf.spdlist+xml, application/vnd.oipf.ueprofile+xml, application/vnd.oipf.userprofile+xml, application/vnd.olpc-sugar, application/vnd.oma-scws-config, application/vnd.oma-scws-http-request, application/vnd.oma-scws-http-response, application/vnd.oma.bcast.associated-procedure-parameter+xml, application/vnd.oma.bcast.drm-trigger+xml, application/vnd.oma.bcast.imd+xml, application/vnd.oma.bcast.ltkm, application/vnd.oma.bcast.notification+xml, application/vnd.oma.bcast.provisioningtrigger, application/vnd.oma.bcast.sgboot, application/vnd.oma.bcast.sgdd+xml, application/vnd.oma.bcast.sgdu, application/vnd.oma.bcast.simple-symbol-container, application/vnd.oma.bcast.smartcard-trigger+xml, application/vnd.oma.bcast.sprov+xml, application/vnd.oma.bcast.stkm, application/vnd.oma.cab-address-book+xml, application/vnd.oma.cab-feature-handler+xml, application/vnd.oma.cab-pcc+xml, application/vnd.oma.cab-subs-invite+xml, application/vnd.oma.cab-user-prefs+xml, application/vnd.oma.dcd, application/vnd.oma.dcdc, application/vnd.oma.dd2+xml, application/vnd.oma.drm.risd+xml, application/vnd.oma.group-usage-list+xml, application/vnd.oma.lwm2m+json, application/vnd.oma.lwm2m+tlv, application/vnd.oma.pal+xml, application/vnd.oma.poc.detailed-progress-report+xml, application/vnd.oma.poc.final-report+xml, application/vnd.oma.poc.groups+xml, application/vnd.oma.poc.invocation-descriptor+xml, application/vnd.oma.poc.optimized-progress-report+xml, application/vnd.oma.push, application/vnd.oma.scidm.messages+xml, application/vnd.oma.xcap-directory+xml, application/vnd.omads-email+xml, application/vnd.omads-file+xml, application/vnd.omads-folder+xml, application/vnd.omaloc-supl-init, application/vnd.onepager, application/vnd.onepagertamp, application/vnd.onepagertamx, application/vnd.onepagertat, application/vnd.onepagertatp, application/vnd.onepagertatx, application/vnd.openblox.game+xml, application/vnd.openblox.game-binary, application/vnd.openeye.oeb, application/vnd.openofficeorg.extension, application/vnd.openstreetmap.data+xml, application/vnd.openxmlformats-officedocument.custom-properties+xml, application/vnd.openxmlformats-officedocument.customxmlproperties+xml, application/vnd.openxmlformats-officedocument.drawing+xml, application/vnd.openxmlformats-officedocument.drawingml.chart+xml, application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml, application/vnd.openxmlformats-officedocument.extended-properties+xml, application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml, application/vnd.openxmlformats-officedocument.presentationml.comments+xml, application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml, application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml, application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml, application/vnd.openxmlformats-officedocument.presentationml.presprops+xml, application/vnd.openxmlformats-officedocument.presentationml.slide, application/vnd.openxmlformats-officedocument.presentationml.slide+xml, application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml, application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml, application/vnd.openxmlformats-officedocument.presentationml.slideshow, application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml, application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml, application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml, application/vnd.openxmlformats-officedocument.presentationml.tags+xml, application/vnd.openxmlformats-officedocument.presentationml.template, application/vnd.openxmlformats-officedocument.presentationml.template.main+xml, application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.template, application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml, application/vnd.openxmlformats-officedocument.theme+xml, application/vnd.openxmlformats-officedocument.themeoverride+xml, application/vnd.openxmlformats-officedocument.vmldrawing, application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.template, application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml, application/vnd.openxmlformats-package.core-properties+xml, application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml, application/vnd.openxmlformats-package.relationships+xml, application/vnd.oracle.resource+json, application/vnd.orange.indata, application/vnd.osa.netdeploy, application/vnd.osgeo.mapguide.package, application/vnd.osgi.bundle, application/vnd.osgi.dp, application/vnd.osgi.subsystem, application/vnd.otps.ct-kip+xml, application/vnd.oxli.countgraph, application/vnd.pagerduty+json, application/vnd.palm, application/vnd.panoply, application/vnd.paos.xml, application/vnd.patentdive, application/vnd.pawaafile, application/vnd.pcos, application/vnd.pg.format, application/vnd.pg.osasli, application/vnd.piaccess.application-licence, application/vnd.picsel, application/vnd.pmi.widget, application/vnd.poc.group-advertisement+xml, application/vnd.pocketlearn, application/vnd.powerbuilder6, application/vnd.powerbuilder6-s, application/vnd.powerbuilder7, application/vnd.powerbuilder7-s, application/vnd.powerbuilder75, application/vnd.powerbuilder75-s, application/vnd.preminet, application/vnd.previewsystems.box, application/vnd.proteus.magazine, application/vnd.psfs, application/vnd.publishare-delta-tree, application/vnd.pvi.ptid1, application/vnd.pwg-multiplexed, application/vnd.pwg-xhtml-print+xml, application/vnd.qualcomm.brew-app-res, application/vnd.quarantainenet, application/vnd.quark.quarkxpress, application/vnd.quobject-quoxdocument, application/vnd.radisys.moml+xml, application/vnd.radisys.msml+xml, application/vnd.radisys.msml-audit+xml, application/vnd.radisys.msml-audit-conf+xml, application/vnd.radisys.msml-audit-conn+xml, application/vnd.radisys.msml-audit-dialog+xml, application/vnd.radisys.msml-audit-stream+xml, application/vnd.radisys.msml-conf+xml, application/vnd.radisys.msml-dialog+xml, application/vnd.radisys.msml-dialog-base+xml, application/vnd.radisys.msml-dialog-fax-detect+xml, application/vnd.radisys.msml-dialog-fax-sendrecv+xml, application/vnd.radisys.msml-dialog-group+xml, application/vnd.radisys.msml-dialog-speech+xml, application/vnd.radisys.msml-dialog-transform+xml, application/vnd.rainstor.data, application/vnd.rapid, application/vnd.rar, application/vnd.realvnc.bed, application/vnd.recordare.musicxml, application/vnd.recordare.musicxml+xml, application/vnd.renlearn.rlprint, application/vnd.restful+json, application/vnd.rig.cryptonote, application/vnd.rim.cod, application/vnd.rn-realmedia, application/vnd.rn-realmedia-vbr, application/vnd.route66.link66+xml, application/vnd.rs-274x, application/vnd.ruckus.download, application/vnd.s3sms, application/vnd.sailingtracker.track, application/vnd.sbm.cid, application/vnd.sbm.mid2, application/vnd.scribus, application/vnd.sealed.3df, application/vnd.sealed.csf, application/vnd.sealed.doc, application/vnd.sealed.eml, application/vnd.sealed.mht, application/vnd.sealed.net, application/vnd.sealed.ppt, application/vnd.sealed.tiff, application/vnd.sealed.xls, application/vnd.sealedmedia.softseal.html, application/vnd.sealedmedia.softseal.pdf, application/vnd.seemail, application/vnd.sema, application/vnd.semd, application/vnd.semf, application/vnd.shana.informed.formdata, application/vnd.shana.informed.formtemplate, application/vnd.shana.informed.interchange, application/vnd.shana.informed.package, application/vnd.shootproof+json, application/vnd.sigrok.session, application/vnd.simtech-mindmapper, application/vnd.siren+json, application/vnd.smaf, application/vnd.smart.notebook, application/vnd.smart.teacher, application/vnd.software602.filler.form+xml, application/vnd.software602.filler.form-xml-zip, application/vnd.solent.sdkm+xml, application/vnd.spotfire.dxp, application/vnd.spotfire.sfs, application/vnd.sqlite3, application/vnd.sss-cod, application/vnd.sss-dtf, application/vnd.sss-ntf, application/vnd.stardivision.calc, application/vnd.stardivision.draw, application/vnd.stardivision.impress, application/vnd.stardivision.math, application/vnd.stardivision.writer, application/vnd.stardivision.writer-global, application/vnd.stepmania.package, application/vnd.stepmania.stepchart, application/vnd.street-stream, application/vnd.sun.wadl+xml, application/vnd.sun.xml.calc, application/vnd.sun.xml.calc.template, application/vnd.sun.xml.draw, application/vnd.sun.xml.draw.template, application/vnd.sun.xml.impress, application/vnd.sun.xml.impress.template, application/vnd.sun.xml.math, application/vnd.sun.xml.writer, application/vnd.sun.xml.writer.global, application/vnd.sun.xml.writer.template, application/vnd.sus-calendar, application/vnd.svd, application/vnd.swiftview-ics, application/vnd.symbian.install, application/vnd.syncml+xml, application/vnd.syncml.dm+wbxml, application/vnd.syncml.dm+xml, application/vnd.syncml.dm.notification, application/vnd.syncml.dmddf+wbxml, application/vnd.syncml.dmddf+xml, application/vnd.syncml.dmtnds+wbxml, application/vnd.syncml.dmtnds+xml, application/vnd.syncml.ds.notification, application/vnd.tableschema+json, application/vnd.tao.intent-module-archive, application/vnd.tcpdump.pcap, application/vnd.think-cell.ppttc+json, application/vnd.tmd.mediaflex.api+xml, application/vnd.tml, application/vnd.tmobile-livetv, application/vnd.tri.onesource, application/vnd.trid.tpt, application/vnd.triscape.mxs, application/vnd.trueapp, application/vnd.truedoc, application/vnd.ubisoft.webplayer, application/vnd.ufdl, application/vnd.uiq.theme, application/vnd.umajin, application/vnd.unity, application/vnd.uoml+xml, application/vnd.uplanet.alert, application/vnd.uplanet.alert-wbxml, application/vnd.uplanet.bearer-choice, application/vnd.uplanet.bearer-choice-wbxml, application/vnd.uplanet.cacheop, application/vnd.uplanet.cacheop-wbxml, application/vnd.uplanet.channel, application/vnd.uplanet.channel-wbxml, application/vnd.uplanet.list, application/vnd.uplanet.list-wbxml, application/vnd.uplanet.listcmd, application/vnd.uplanet.listcmd-wbxml, application/vnd.uplanet.signal, application/vnd.uri-map, application/vnd.valve.source.material, application/vnd.vcx, application/vnd.vd-study, application/vnd.vectorworks, application/vnd.vel+json, application/vnd.verimatrix.vcas, application/vnd.vidsoft.vidconference, application/vnd.visio, application/vnd.visionary, application/vnd.vividence.scriptfile, application/vnd.vsf, application/vnd.wap.sic, application/vnd.wap.slc, application/vnd.wap.wbxml, application/vnd.wap.wmlc, application/vnd.wap.wmlscriptc, application/vnd.webturbo, application/vnd.wfa.p2p, application/vnd.wfa.wsc, application/vnd.windows.devicepairing, application/vnd.wmc, application/vnd.wmf.bootstrap, application/vnd.wolfram.mathematica, application/vnd.wolfram.mathematica.package, application/vnd.wolfram.player, application/vnd.wordperfect, application/vnd.wqd, application/vnd.wrq-hp3000-labelled, application/vnd.wt.stf, application/vnd.wv.csp+wbxml, application/vnd.wv.csp+xml, application/vnd.wv.ssp+xml, application/vnd.xacml+json, application/vnd.xara, application/vnd.xfdl, application/vnd.xfdl.webform, application/vnd.xmi+xml, application/vnd.xmpie.cpkg, application/vnd.xmpie.dpkg, application/vnd.xmpie.plan, application/vnd.xmpie.ppkg, application/vnd.xmpie.xlim, application/vnd.yamaha.hv-dic, application/vnd.yamaha.hv-script, application/vnd.yamaha.hv-voice, application/vnd.yamaha.openscoreformat, application/vnd.yamaha.openscoreformat.osfpvg+xml, application/vnd.yamaha.remote-setup, application/vnd.yamaha.smaf-audio, application/vnd.yamaha.smaf-phrase, application/vnd.yamaha.through-ngn, application/vnd.yamaha.tunnel-udpencap, application/vnd.yaoweme, application/vnd.yellowriver-custom-menu, application/vnd.youtube.yt, application/vnd.zul, application/vnd.zzazz.deck+xml, application/voicexml+xml, application/voucher-cms+json, application/vq-rtcpxr, application/wasm, application/watcherinfo+xml, application/webpush-options+json, application/whoispp-query, application/whoispp-response, application/widget, application/winhlp, application/wita, application/wordperfect5.1, application/wsdl+xml, application/wspolicy+xml, application/x-7z-compressed, application/x-abiword, application/x-ace-compressed, application/x-amf, application/x-apple-diskimage, application/x-arj, application/x-authorware-bin, application/x-authorware-map, application/x-authorware-seg, application/x-bcpio, application/x-bdoc, application/x-bittorrent, application/x-blorb, application/x-bzip, application/x-bzip2, application/x-cbr, application/x-cdlink, application/x-cfs-compressed, application/x-chat, application/x-chess-pgn, application/x-chrome-extension, application/x-cocoa, application/x-compress, application/x-conference, application/x-cpio, application/x-csh, application/x-deb, application/x-debian-package, application/x-dgc-compressed, application/x-director, application/x-doom, application/x-dtbncx+xml, application/x-dtbook+xml, application/x-dtbresource+xml, application/x-dvi, application/x-envoy, application/x-eva, application/x-font-bdf, application/x-font-dos, application/x-font-framemaker, application/x-font-ghostscript, application/x-font-libgrx, application/x-font-linux-psf, application/x-font-pcf, application/x-font-snf, application/x-font-speedo, application/x-font-sunos-news, application/x-font-type1, application/x-font-vfont, application/x-freearc, application/x-futuresplash, application/x-gca-compressed, application/x-glulx, application/x-gnumeric, application/x-gramps-xml, application/x-gtar, application/x-gzip, application/x-hdf, application/x-httpd-php, application/x-install-instructions, application/x-iso9660-image, application/x-java-archive-diff, application/x-java-jnlp-file, application/x-javascript, application/x-latex, application/x-lua-bytecode, application/x-lzh-compressed, application/x-makeself, application/x-mie, application/x-mobipocket-ebook, application/x-mpegurl, application/x-ms-application, application/x-ms-shortcut, application/x-ms-wmd, application/x-ms-wmz, application/x-ms-xbap, application/x-msaccess, application/x-msbinder, application/x-mscardfile, application/x-msclip, application/x-msdos-program, application/x-msdownload, application/x-msmediaview, application/x-msmetafile, application/x-msmoney, application/x-mspublisher, application/x-msschedule, application/x-msterminal, application/x-mswrite, application/x-netcdf, application/x-ns-proxy-autoconfig, application/x-nzb, application/x-perl, application/x-pilot, application/x-pkcs12, application/x-pkcs7-certificates, application/x-pkcs7-certreqresp, application/x-rar-compressed, application/x-redhat-package-manager, application/x-research-info-systems, application/x-sea, application/x-sh, application/x-shar, application/x-shockwave-flash, application/x-silverlight-app, application/x-sql, application/x-stuffit, application/x-stuffitx, application/x-subrip, application/x-sv4cpio, application/x-sv4crc, application/x-t3vm-image, application/x-tads, application/x-tar, application/x-tcl, application/x-tex, application/x-tex-tfm, application/x-texinfo, application/x-tgif, application/x-ustar, application/x-virtualbox-hdd, application/x-virtualbox-ova, application/x-virtualbox-ovf, application/x-virtualbox-vbox, application/x-virtualbox-vbox-extpack, application/x-virtualbox-vdi, application/x-virtualbox-vhd, application/x-virtualbox-vmdk, application/x-wais-source, application/x-web-app-manifest+json, application/x-www-form-urlencoded, application/x-x509-ca-cert, application/x-xfig, application/x-xliff+xml, application/x-xpinstall, application/x-xz, application/x-zmachine, application/x400-bp, application/xacml+xml, application/xaml+xml, application/xcap-att+xml, application/xcap-caps+xml, application/xcap-diff+xml, application/xcap-el+xml, application/xcap-error+xml, application/xcap-ns+xml, application/xcon-conference-info+xml, application/xcon-conference-info-diff+xml, application/xenc+xml, application/xhtml+xml, application/xhtml-voice+xml, application/xliff+xml, application/xml, application/xml-dtd, application/xml-external-parsed-entity, application/xml-patch+xml, application/xmpp+xml, application/xop+xml, application/xproc+xml, application/xslt+xml, application/xspf+xml, application/xv+xml, application/yang, application/yang-data+json, application/yang-data+xml, application/yang-patch+json, application/yang-patch+xml, application/yin+xml, application/zip, application/zlib, application/zstd, audio/1d-interleaved-parityfec, audio/32kadpcm, audio/3gpp, audio/3gpp2, audio/aac, audio/ac3, audio/adpcm, audio/amr, audio/amr-wb, audio/amr-wb+, audio/aptx, audio/asc, audio/atrac-advanced-lossless, audio/atrac-x, audio/atrac3, audio/basic, audio/bv16, audio/bv32, audio/clearmode, audio/cn, audio/dat12, audio/dls, audio/dsr-es201108, audio/dsr-es202050, audio/dsr-es202211, audio/dsr-es202212, audio/dv, audio/dvi4, audio/eac3, audio/encaprtp, audio/evrc, audio/evrc-qcp, audio/evrc0, audio/evrc1, audio/evrcb, audio/evrcb0, audio/evrcb1, audio/evrcnw, audio/evrcnw0, audio/evrcnw1, audio/evrcwb, audio/evrcwb0, audio/evrcwb1, audio/evs, audio/fwdred, audio/g711-0, audio/g719, audio/g722, audio/g7221, audio/g723, audio/g726-16, audio/g726-24, audio/g726-32, audio/g726-40, audio/g728, audio/g729, audio/g7291, audio/g729d, audio/g729e, audio/gsm, audio/gsm-efr, audio/gsm-hr-08, audio/ilbc, audio/ip-mr_v2.5, audio/isac, audio/l16, audio/l20, audio/l24, audio/l8, audio/lpc, audio/melp, audio/melp1200, audio/melp2400, audio/melp600, audio/midi, audio/mobile-xmf, audio/mp3, audio/mp4, audio/mp4a-latm, audio/mpa, audio/mpa-robust, audio/mpeg, audio/mpeg4-generic, audio/musepack, audio/ogg, audio/opus, audio/parityfec, audio/pcma, audio/pcma-wb, audio/pcmu, audio/pcmu-wb, audio/prs.sid, audio/qcelp, audio/raptorfec, audio/red, audio/rtp-enc-aescm128, audio/rtp-midi, audio/rtploopback, audio/rtx, audio/s3m, audio/silk, audio/smv, audio/smv-qcp, audio/smv0, audio/sp-midi, audio/speex, audio/t140c, audio/t38, audio/telephone-event, audio/tone, audio/uemclip, audio/ulpfec, audio/usac, audio/vdvi, audio/vmr-wb, audio/vnd.3gpp.iufp, audio/vnd.4sb, audio/vnd.audiokoz, audio/vnd.celp, audio/vnd.cisco.nse, audio/vnd.cmles.radio-events, audio/vnd.cns.anp1, audio/vnd.cns.inf1, audio/vnd.dece.audio, audio/vnd.digital-winds, audio/vnd.dlna.adts, audio/vnd.dolby.heaac.1, audio/vnd.dolby.heaac.2, audio/vnd.dolby.mlp, audio/vnd.dolby.mps, audio/vnd.dolby.pl2, audio/vnd.dolby.pl2x, audio/vnd.dolby.pl2z, audio/vnd.dolby.pulse.1, audio/vnd.dra, audio/vnd.dts, audio/vnd.dts.hd, audio/vnd.dvb.file, audio/vnd.everad.plj, audio/vnd.hns.audio, audio/vnd.lucent.voice, audio/vnd.ms-playready.media.pya, audio/vnd.nokia.mobile-xmf, audio/vnd.nortel.vbk, audio/vnd.nuera.ecelp4800, audio/vnd.nuera.ecelp7470, audio/vnd.nuera.ecelp9600, audio/vnd.octel.sbc, audio/vnd.presonus.multitrack, audio/vnd.qcelp, audio/vnd.rhetorex.32kadpcm, audio/vnd.rip, audio/vnd.rn-realaudio, audio/vnd.sealedmedia.softseal.mpeg, audio/vnd.vmx.cvsd, audio/vnd.wave, audio/vorbis, audio/vorbis-config, audio/wav, audio/wave, audio/webm, audio/x-aac, audio/x-aiff, audio/x-caf, audio/x-flac, audio/x-m4a, audio/x-matroska, audio/x-mpegurl, audio/x-ms-wax, audio/x-ms-wma, audio/x-pn-realaudio, audio/x-pn-realaudio-plugin, audio/x-realaudio, audio/x-tta, audio/x-wav, audio/xm, chemical/x-cdx, chemical/x-cif, chemical/x-cmdf, chemical/x-cml, chemical/x-csml, chemical/x-pdb, chemical/x-xyz, font/collection, font/otf, font/sfnt, font/ttf, font/woff, font/woff2, image/aces, image/apng, image/avci, image/avcs, image/bmp, image/cgm, image/dicom-rle, image/emf, image/fits, image/g3fax, image/gif, image/heic, image/heic-sequence, image/heif, image/heif-sequence, image/ief, image/jls, image/jp2, image/jpeg, image/jpm, image/jpx, image/ktx, image/naplps, image/pjpeg, image/png, image/prs.btif, image/prs.pti, image/pwg-raster, image/sgi, image/svg+xml, image/t38, image/tiff, image/tiff-fx, image/vnd.adobe.photoshop, image/vnd.airzip.accelerator.azv, image/vnd.cns.inf2, image/vnd.dece.graphic, image/vnd.djvu, image/vnd.dvb.subtitle, image/vnd.dwg, image/vnd.dxf, image/vnd.fastbidsheet, image/vnd.fpx, image/vnd.fst, image/vnd.fujixerox.edmics-mmr, image/vnd.fujixerox.edmics-rlc, image/vnd.globalgraphics.pgb, image/vnd.microsoft.icon, image/vnd.mix, image/vnd.mozilla.apng, image/vnd.ms-modi, image/vnd.ms-photo, image/vnd.net-fpx, image/vnd.radiance, image/vnd.sealed.png, image/vnd.sealedmedia.softseal.gif, image/vnd.sealedmedia.softseal.jpg, image/vnd.svf, image/vnd.tencent.tap, image/vnd.valve.source.texture, image/vnd.wap.wbmp, image/vnd.xiff, image/vnd.zbrush.pcx, image/webp, image/wmf, image/x-3ds, image/x-cmu-raster, image/x-cmx, image/x-freehand, image/x-icon, image/x-jng, image/x-mrsid-image, image/x-ms-bmp, image/x-pcx, image/x-pict, image/x-portable-anymap, image/x-portable-bitmap, image/x-portable-graymap, image/x-portable-pixmap, image/x-rgb, image/x-tga, image/x-xbitmap, image/x-xcf, image/x-xpixmap, image/x-xwindowdump, message/cpim, message/delivery-status, message/disposition-notification, message/external-body, message/feedback-report, message/global, message/global-delivery-status, message/global-disposition-notification, message/global-headers, message/http, message/imdn+xml, message/news, message/partial, message/rfc822, message/s-http, message/sip, message/sipfrag, message/tracking-status, message/vnd.si.simp, message/vnd.wfa.wsc, model/3mf, model/gltf+json, model/gltf-binary, model/iges, model/mesh, model/stl, model/vnd.collada+xml, model/vnd.dwf, model/vnd.flatland.3dml, model/vnd.gdl, model/vnd.gs-gdl, model/vnd.gs.gdl, model/vnd.gtw, model/vnd.moml+xml, model/vnd.mts, model/vnd.opengex, model/vnd.parasolid.transmit.binary, model/vnd.parasolid.transmit.text, model/vnd.rosette.annotated-data-model, model/vnd.usdz+zip, model/vnd.valve.source.compiled-map, model/vnd.vtu, model/vrml, model/x3d+binary, model/x3d+fastinfoset, model/x3d+vrml, model/x3d+xml, model/x3d-vrml, multipart/alternative, multipart/appledouble, multipart/byteranges, multipart/digest, multipart/encrypted, multipart/form-data, multipart/header-set, multipart/mixed, multipart/multilingual, multipart/parallel, multipart/related, multipart/report, multipart/signed, multipart/vnd.bint.med-plus, multipart/voice-message, multipart/x-mixed-replace, text/1d-interleaved-parityfec, text/cache-manifest, text/calendar, text/calender, text/cmd, text/coffeescript, text/css, text/csv, text/csv-schema, text/directory, text/dns, text/ecmascript, text/encaprtp, text/enriched, text/fwdred, text/grammar-ref-list, text/html, text/jade, text/javascript, text/jcr-cnd, text/jsx, text/less, text/markdown, text/mathml, text/mizar, text/n3, text/parameters, text/parityfec, text/plain, text/provenance-notation, text/prs.fallenstein.rst, text/prs.lines.tag, text/prs.prop.logic, text/raptorfec, text/red, text/rfc822-headers, text/richtext, text/rtf, text/rtp-enc-aescm128, text/rtploopback, text/rtx, text/sgml, text/shex, text/slim, text/strings, text/stylus, text/t140, text/tab-separated-values, text/troff, text/turtle, text/ulpfec, text/uri-list, text/vcard, text/vnd.a, text/vnd.abc, text/vnd.ascii-art, text/vnd.curl, text/vnd.curl.dcurl, text/vnd.curl.mcurl, text/vnd.curl.scurl, text/vnd.debian.copyright, text/vnd.dmclientscript, text/vnd.dvb.subtitle, text/vnd.esmertec.theme-descriptor, text/vnd.fly, text/vnd.fmi.flexstor, text/vnd.gml, text/vnd.graphviz, text/vnd.hgl, text/vnd.in3d.3dml, text/vnd.in3d.spot, text/vnd.iptc.newsml, text/vnd.iptc.nitf, text/vnd.latex-z, text/vnd.motorola.reflex, text/vnd.ms-mediapackage, text/vnd.net2phone.commcenter.command, text/vnd.radisys.msml-basic-layout, text/vnd.si.uricatalogue, text/vnd.sun.j2me.app-descriptor, text/vnd.trolltech.linguist, text/vnd.wap.si, text/vnd.wap.sl, text/vnd.wap.wml, text/vnd.wap.wmlscript, text/vtt, text/x-asm, text/x-c, text/x-component, text/x-fortran, text/x-gwt-rpc, text/x-handlebars-template, text/x-java-source, text/x-jquery-tmpl, text/x-lua, text/x-markdown, text/x-nfo, text/x-opml, text/x-org, text/x-pascal, text/x-processing, text/x-sass, text/x-scss, text/x-setext, text/x-sfv, text/x-suse-ymp, text/x-uuencode, text/x-vcalendar, text/x-vcard, text/xml, text/xml-external-parsed-entity, text/yaml, video/1d-interleaved-parityfec, video/3gpp, video/3gpp-tt, video/3gpp2, video/bmpeg, video/bt656, video/celb, video/dv, video/encaprtp, video/h261, video/h263, video/h263-1998, video/h263-2000, video/h264, video/h264-rcdo, video/h264-svc, video/h265, video/iso.segment, video/jpeg, video/jpeg2000, video/jpm, video/mj2, video/mp1s, video/mp2p, video/mp2t, video/mp4, video/mp4v-es, video/mpeg, video/mpeg4-generic, video/mpv, video/nv, video/ogg, video/parityfec, video/pointer, video/quicktime, video/raptorfec, video/raw, video/rtp-enc-aescm128, video/rtploopback, video/rtx, video/smpte291, video/smpte292m, video/ulpfec, video/vc1, video/vc2, video/vnd.cctv, video/vnd.dece.hd, video/vnd.dece.mobile, video/vnd.dece.mp4, video/vnd.dece.pd, video/vnd.dece.sd, video/vnd.dece.video, video/vnd.directv.mpeg, video/vnd.directv.mpeg-tts, video/vnd.dlna.mpeg-tts, video/vnd.dvb.file, video/vnd.fvt, video/vnd.hns.video, video/vnd.iptvforum.1dparityfec-1010, video/vnd.iptvforum.1dparityfec-2005, video/vnd.iptvforum.2dparityfec-1010, video/vnd.iptvforum.2dparityfec-2005, video/vnd.iptvforum.ttsavc, video/vnd.iptvforum.ttsmpeg2, video/vnd.motorola.video, video/vnd.motorola.videop, video/vnd.mpegurl, video/vnd.ms-playready.media.pyv, video/vnd.nokia.interleaved-multimedia, video/vnd.nokia.mp4vr, video/vnd.nokia.videovoip, video/vnd.objectvideo, video/vnd.radgamettools.bink, video/vnd.radgamettools.smacker, video/vnd.sealed.mpeg1, video/vnd.sealed.mpeg4, video/vnd.sealed.swf, video/vnd.sealedmedia.softseal.mov, video/vnd.uvvu.mp4, video/vnd.vivo, video/vp8, video/webm, video/x-f4v, video/x-fli, video/x-flv, video/x-m4v, video/x-matroska, video/x-mng, video/x-ms-asf, video/x-ms-vob, video/x-ms-wm, video/x-ms-wmv, video/x-ms-wmx, video/x-ms-wvx, video/x-msvideo, video/x-sgi-movie, video/x-smv, x-conference/x-cooltalk, x-shader/x-fragment, x-shader/x-vertex, default */
/***/ (function(module) {

module.exports = {"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/cbor":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["ecma","es"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true},"application/fhir+json":{"source":"iana","compressible":true},"application/fhir+xml":{"source":"iana","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mmt-usd+xml":{"source":"iana","compressible":true},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","compressible":true},"application/msc-mixer+xml":{"source":"iana","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana"},"application/n-triples":{"source":"iana"},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana"},"application/news-groupinfo":{"source":"iana"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana"},"application/nss":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p2p-overlay+xml":{"source":"iana","compressible":true},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana"},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","compressible":true},"application/pidf-diff+xml":{"source":"iana","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true},"application/route-s-tsid+xml":{"source":"iana","compressible":true},"application/route-usd+xml":{"source":"iana","compressible":true},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana"},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana"},"application/ttml+xml":{"source":"iana","compressible":true},"application/tve-trigger":{"source":"iana"},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true},"application/urc-targetdesc+xml":{"source":"iana","compressible":true},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["keynote"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana"},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana"},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","compressible":true},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"apache","extensions":["der","crt","pem"]},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true},"application/xcap-caps+xml":{"source":"iana","compressible":true},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana"},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana"},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana"},"image/avcs":{"source":"iana"},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/stl":{"source":"iana"},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana"},"model/vnd.parasolid.transmit.binary":{"source":"iana"},"model/vnd.parasolid.transmit.text":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.usdz+zip":{"source":"iana","compressible":false},"model/vnd.valve.source.compiled-map":{"source":"iana"},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana"},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana"},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana","compressible":false},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shex":{"extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana"},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vp8":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}};

/***/ }),

/***/ "./node_modules/mime-db/index.js":
/*!***************************************!*\
  !*** ./node_modules/mime-db/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(/*! ./db.json */ "./node_modules/mime-db/db.json")


/***/ }),

/***/ "./node_modules/mime-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/mime-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(/*! mime-db */ "./node_modules/mime-db/index.js")
var extname = __webpack_require__(/*! path */ "path").extname

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ "./node_modules/mkdirp/index.js":
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! path */ "path");
var fs = __webpack_require__(/*! fs */ "fs");
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;
    
    var cb = f || function () {};
    p = path.resolve(p);
    
    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }
    
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    
    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};


/***/ }),

/***/ "./node_modules/oauth-sign/index.js":
/*!******************************************!*\
  !*** ./node_modules/oauth-sign/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var crypto = __webpack_require__(/*! crypto */ "crypto")

function sha (key, body, algorithm) {
  return crypto.createHmac(algorithm, key).update(body).digest('base64')
}

function rsa (key, body) {
  return crypto.createSign('RSA-SHA1').update(body).sign(key, 'base64')
}

function rfc3986 (str) {
  return encodeURIComponent(str)
    .replace(/!/g,'%21')
    .replace(/\*/g,'%2A')
    .replace(/\(/g,'%28')
    .replace(/\)/g,'%29')
    .replace(/'/g,'%27')
}

// Maps object to bi-dimensional array
// Converts { foo: 'A', bar: [ 'b', 'B' ]} to
// [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]
function map (obj) {
  var key, val, arr = []
  for (key in obj) {
    val = obj[key]
    if (Array.isArray(val))
      for (var i = 0; i < val.length; i++)
        arr.push([key, val[i]])
    else if (typeof val === 'object')
      for (var prop in val)
        arr.push([key + '[' + prop + ']', val[prop]])
    else
      arr.push([key, val])
  }
  return arr
}

// Compare function for sort
function compare (a, b) {
  return a > b ? 1 : a < b ? -1 : 0
}

function generateBase (httpMethod, base_uri, params) {
  // adapted from https://dev.twitter.com/docs/auth/oauth and 
  // https://dev.twitter.com/docs/auth/creating-signature

  // Parameter normalization
  // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
  var normalized = map(params)
  // 1.  First, the name and value of each parameter are encoded
  .map(function (p) {
    return [ rfc3986(p[0]), rfc3986(p[1] || '') ]
  })
  // 2.  The parameters are sorted by name, using ascending byte value
  //     ordering.  If two or more parameters share the same name, they
  //     are sorted by their value.
  .sort(function (a, b) {
    return compare(a[0], b[0]) || compare(a[1], b[1])
  })
  // 3.  The name of each parameter is concatenated to its corresponding
  //     value using an "=" character (ASCII code 61) as a separator, even
  //     if the value is empty.
  .map(function (p) { return p.join('=') })
   // 4.  The sorted name/value pairs are concatenated together into a
   //     single string by using an "&" character (ASCII code 38) as
   //     separator.
  .join('&')

  var base = [
    rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),
    rfc3986(base_uri),
    rfc3986(normalized)
  ].join('&')

  return base
}

function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
  var base = generateBase(httpMethod, base_uri, params)
  var key = [
    consumer_secret || '',
    token_secret || ''
  ].map(rfc3986).join('&')

  return sha(key, base, 'sha1')
}

function hmacsign256 (httpMethod, base_uri, params, consumer_secret, token_secret) {
  var base = generateBase(httpMethod, base_uri, params)
  var key = [
    consumer_secret || '',
    token_secret || ''
  ].map(rfc3986).join('&')

  return sha(key, base, 'sha256')
}

function rsasign (httpMethod, base_uri, params, private_key, token_secret) {
  var base = generateBase(httpMethod, base_uri, params)
  var key = private_key || ''

  return rsa(key, base)
}

function plaintext (consumer_secret, token_secret) {
  var key = [
    consumer_secret || '',
    token_secret || ''
  ].map(rfc3986).join('&')

  return key
}

function sign (signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
  var method
  var skipArgs = 1

  switch (signMethod) {
    case 'RSA-SHA1':
      method = rsasign
      break
    case 'HMAC-SHA1':
      method = hmacsign
      break
    case 'HMAC-SHA256':
      method = hmacsign256
      break
    case 'PLAINTEXT':
      method = plaintext
      skipArgs = 4
      break
    default:
     throw new Error('Signature method not supported: ' + signMethod)
  }

  return method.apply(null, [].slice.call(arguments, skipArgs))
}

exports.hmacsign = hmacsign
exports.hmacsign256 = hmacsign256
exports.rsasign = rsasign
exports.plaintext = plaintext
exports.sign = sign
exports.rfc3986 = rfc3986
exports.generateBase = generateBase

/***/ }),

/***/ "./node_modules/oauth/index.js":
/*!*************************************!*\
  !*** ./node_modules/oauth/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.OAuth = __webpack_require__(/*! ./lib/oauth */ "./node_modules/oauth/lib/oauth.js").OAuth;
exports.OAuthEcho = __webpack_require__(/*! ./lib/oauth */ "./node_modules/oauth/lib/oauth.js").OAuthEcho;
exports.OAuth2 = __webpack_require__(/*! ./lib/oauth2 */ "./node_modules/oauth/lib/oauth2.js").OAuth2;

/***/ }),

/***/ "./node_modules/oauth/lib/_utils.js":
/*!******************************************!*\
  !*** ./node_modules/oauth/lib/_utils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Returns true if this is a host that closes *before* it ends?!?!
module.exports.isAnEarlyCloseHost= function( hostName ) {
  return hostName && hostName.match(".*google(apis)?.com$")
}

/***/ }),

/***/ "./node_modules/oauth/lib/oauth.js":
/*!*****************************************!*\
  !*** ./node_modules/oauth/lib/oauth.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var crypto= __webpack_require__(/*! crypto */ "crypto"),
    sha1= __webpack_require__(/*! ./sha1 */ "./node_modules/oauth/lib/sha1.js"),
    http= __webpack_require__(/*! http */ "http"),
    https= __webpack_require__(/*! https */ "https"),
    URL= __webpack_require__(/*! url */ "url"),
    querystring= __webpack_require__(/*! querystring */ "querystring"),
    OAuthUtils= __webpack_require__(/*! ./_utils */ "./node_modules/oauth/lib/_utils.js");

exports.OAuth= function(requestUrl, accessUrl, consumerKey, consumerSecret, version, authorize_callback, signatureMethod, nonceSize, customHeaders) {
  this._isEcho = false;

  this._requestUrl= requestUrl;
  this._accessUrl= accessUrl;
  this._consumerKey= consumerKey;
  this._consumerSecret= this._encodeData( consumerSecret );
  if (signatureMethod == "RSA-SHA1") {
    this._privateKey = consumerSecret;
  }
  this._version= version;
  if( authorize_callback === undefined ) {
    this._authorize_callback= "oob";
  }
  else {
    this._authorize_callback= authorize_callback;
  }

  if( signatureMethod != "PLAINTEXT" && signatureMethod != "HMAC-SHA1" && signatureMethod != "RSA-SHA1")
    throw new Error("Un-supported signature method: " + signatureMethod )
  this._signatureMethod= signatureMethod;
  this._nonceSize= nonceSize || 32;
  this._headers= customHeaders || {"Accept" : "*/*",
                                   "Connection" : "close",
                                   "User-Agent" : "Node authentication"}
  this._clientOptions= this._defaultClientOptions= {"requestTokenHttpMethod": "POST",
                                                    "accessTokenHttpMethod": "POST",
                                                    "followRedirects": true};
  this._oauthParameterSeperator = ",";
};

exports.OAuthEcho= function(realm, verify_credentials, consumerKey, consumerSecret, version, signatureMethod, nonceSize, customHeaders) {
  this._isEcho = true;

  this._realm= realm;
  this._verifyCredentials = verify_credentials;
  this._consumerKey= consumerKey;
  this._consumerSecret= this._encodeData( consumerSecret );
  if (signatureMethod == "RSA-SHA1") {
    this._privateKey = consumerSecret;
  }
  this._version= version;

  if( signatureMethod != "PLAINTEXT" && signatureMethod != "HMAC-SHA1" && signatureMethod != "RSA-SHA1")
    throw new Error("Un-supported signature method: " + signatureMethod );
  this._signatureMethod= signatureMethod;
  this._nonceSize= nonceSize || 32;
  this._headers= customHeaders || {"Accept" : "*/*",
                                   "Connection" : "close",
                                   "User-Agent" : "Node authentication"};
  this._oauthParameterSeperator = ",";
}

exports.OAuthEcho.prototype = exports.OAuth.prototype;

exports.OAuth.prototype._getTimestamp= function() {
  return Math.floor( (new Date()).getTime() / 1000 );
}

exports.OAuth.prototype._encodeData= function(toEncode){
 if( toEncode == null || toEncode == "" ) return ""
 else {
    var result= encodeURIComponent(toEncode);
    // Fix the mismatch between OAuth's  RFC3986's and Javascript's beliefs in what is right and wrong ;)
    return result.replace(/\!/g, "%21")
                 .replace(/\'/g, "%27")
                 .replace(/\(/g, "%28")
                 .replace(/\)/g, "%29")
                 .replace(/\*/g, "%2A");
 }
}

exports.OAuth.prototype._decodeData= function(toDecode) {
  if( toDecode != null ) {
    toDecode = toDecode.replace(/\+/g, " ");
  }
  return decodeURIComponent( toDecode);
}

exports.OAuth.prototype._getSignature= function(method, url, parameters, tokenSecret) {
  var signatureBase= this._createSignatureBase(method, url, parameters);
  return this._createSignature( signatureBase, tokenSecret );
}

exports.OAuth.prototype._normalizeUrl= function(url) {
  var parsedUrl= URL.parse(url, true)
   var port ="";
   if( parsedUrl.port ) {
     if( (parsedUrl.protocol == "http:" && parsedUrl.port != "80" ) ||
         (parsedUrl.protocol == "https:" && parsedUrl.port != "443") ) {
           port= ":" + parsedUrl.port;
         }
   }

  if( !parsedUrl.pathname  || parsedUrl.pathname == "" ) parsedUrl.pathname ="/";

  return parsedUrl.protocol + "//" + parsedUrl.hostname + port + parsedUrl.pathname;
}

// Is the parameter considered an OAuth parameter
exports.OAuth.prototype._isParameterNameAnOAuthParameter= function(parameter) {
  var m = parameter.match('^oauth_');
  if( m && ( m[0] === "oauth_" ) ) {
    return true;
  }
  else {
    return false;
  }
};

// build the OAuth request authorization header
exports.OAuth.prototype._buildAuthorizationHeaders= function(orderedParameters) {
  var authHeader="OAuth ";
  if( this._isEcho ) {
    authHeader += 'realm="' + this._realm + '",';
  }

  for( var i= 0 ; i < orderedParameters.length; i++) {
     // Whilst the all the parameters should be included within the signature, only the oauth_ arguments
     // should appear within the authorization header.
     if( this._isParameterNameAnOAuthParameter(orderedParameters[i][0]) ) {
      authHeader+= "" + this._encodeData(orderedParameters[i][0])+"=\""+ this._encodeData(orderedParameters[i][1])+"\""+ this._oauthParameterSeperator;
     }
  }

  authHeader= authHeader.substring(0, authHeader.length-this._oauthParameterSeperator.length);
  return authHeader;
}

// Takes an object literal that represents the arguments, and returns an array
// of argument/value pairs.
exports.OAuth.prototype._makeArrayOfArgumentsHash= function(argumentsHash) {
  var argument_pairs= [];
  for(var key in argumentsHash ) {
    if (argumentsHash.hasOwnProperty(key)) {
       var value= argumentsHash[key];
       if( Array.isArray(value) ) {
         for(var i=0;i<value.length;i++) {
           argument_pairs[argument_pairs.length]= [key, value[i]];
         }
       }
       else {
         argument_pairs[argument_pairs.length]= [key, value];
       }
    }
  }
  return argument_pairs;
}

// Sorts the encoded key value pairs by encoded name, then encoded value
exports.OAuth.prototype._sortRequestParams= function(argument_pairs) {
  // Sort by name, then value.
  argument_pairs.sort(function(a,b) {
      if ( a[0]== b[0] )  {
        return a[1] < b[1] ? -1 : 1;
      }
      else return a[0] < b[0] ? -1 : 1;
  });

  return argument_pairs;
}

exports.OAuth.prototype._normaliseRequestParams= function(args) {
  var argument_pairs= this._makeArrayOfArgumentsHash(args);
  // First encode them #3.4.1.3.2 .1
  for(var i=0;i<argument_pairs.length;i++) {
    argument_pairs[i][0]= this._encodeData( argument_pairs[i][0] );
    argument_pairs[i][1]= this._encodeData( argument_pairs[i][1] );
  }

  // Then sort them #3.4.1.3.2 .2
  argument_pairs= this._sortRequestParams( argument_pairs );

  // Then concatenate together #3.4.1.3.2 .3 & .4
  var args= "";
  for(var i=0;i<argument_pairs.length;i++) {
      args+= argument_pairs[i][0];
      args+= "="
      args+= argument_pairs[i][1];
      if( i < argument_pairs.length-1 ) args+= "&";
  }
  return args;
}

exports.OAuth.prototype._createSignatureBase= function(method, url, parameters) {
  url= this._encodeData( this._normalizeUrl(url) );
  parameters= this._encodeData( parameters );
  return method.toUpperCase() + "&" + url + "&" + parameters;
}

exports.OAuth.prototype._createSignature= function(signatureBase, tokenSecret) {
   if( tokenSecret === undefined ) var tokenSecret= "";
   else tokenSecret= this._encodeData( tokenSecret );
   // consumerSecret is already encoded
   var key= this._consumerSecret + "&" + tokenSecret;

   var hash= ""
   if( this._signatureMethod == "PLAINTEXT" ) {
     hash= key;
   }
   else if (this._signatureMethod == "RSA-SHA1") {
     key = this._privateKey || "";
     hash= crypto.createSign("RSA-SHA1").update(signatureBase).sign(key, 'base64');
   }
   else {
       if( crypto.Hmac ) {
         hash = crypto.createHmac("sha1", key).update(signatureBase).digest("base64");
       }
       else {
         hash= sha1.HMACSHA1(key, signatureBase);
       }
   }
   return hash;
}
exports.OAuth.prototype.NONCE_CHARS= ['a','b','c','d','e','f','g','h','i','j','k','l','m','n',
              'o','p','q','r','s','t','u','v','w','x','y','z','A','B',
              'C','D','E','F','G','H','I','J','K','L','M','N','O','P',
              'Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3',
              '4','5','6','7','8','9'];

exports.OAuth.prototype._getNonce= function(nonceSize) {
   var result = [];
   var chars= this.NONCE_CHARS;
   var char_pos;
   var nonce_chars_length= chars.length;

   for (var i = 0; i < nonceSize; i++) {
       char_pos= Math.floor(Math.random() * nonce_chars_length);
       result[i]=  chars[char_pos];
   }
   return result.join('');
}

exports.OAuth.prototype._createClient= function( port, hostname, method, path, headers, sslEnabled ) {
  var options = {
    host: hostname,
    port: port,
    path: path,
    method: method,
    headers: headers
  };
  var httpModel;
  if( sslEnabled ) {
    httpModel= https;
  } else {
    httpModel= http;
  }
  return httpModel.request(options);
}

exports.OAuth.prototype._prepareParameters= function( oauth_token, oauth_token_secret, method, url, extra_params ) {
  var oauthParameters= {
      "oauth_timestamp":        this._getTimestamp(),
      "oauth_nonce":            this._getNonce(this._nonceSize),
      "oauth_version":          this._version,
      "oauth_signature_method": this._signatureMethod,
      "oauth_consumer_key":     this._consumerKey
  };

  if( oauth_token ) {
    oauthParameters["oauth_token"]= oauth_token;
  }

  var sig;
  if( this._isEcho ) {
    sig = this._getSignature( "GET",  this._verifyCredentials,  this._normaliseRequestParams(oauthParameters), oauth_token_secret);
  }
  else {
    if( extra_params ) {
      for( var key in extra_params ) {
        if (extra_params.hasOwnProperty(key)) oauthParameters[key]= extra_params[key];
      }
    }
    var parsedUrl= URL.parse( url, false );

    if( parsedUrl.query ) {
      var key2;
      var extraParameters= querystring.parse(parsedUrl.query);
      for(var key in extraParameters ) {
        var value= extraParameters[key];
          if( typeof value == "object" ){
            // TODO: This probably should be recursive
            for(key2 in value){
              oauthParameters[key + "[" + key2 + "]"] = value[key2];
            }
          } else {
            oauthParameters[key]= value;
          }
        }
    }

    sig = this._getSignature( method,  url,  this._normaliseRequestParams(oauthParameters), oauth_token_secret);
  }

  var orderedParameters= this._sortRequestParams( this._makeArrayOfArgumentsHash(oauthParameters) );
  orderedParameters[orderedParameters.length]= ["oauth_signature", sig];
  return orderedParameters;
}

exports.OAuth.prototype._performSecureRequest= function( oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type,  callback ) {
  var orderedParameters= this._prepareParameters(oauth_token, oauth_token_secret, method, url, extra_params);

  if( !post_content_type ) {
    post_content_type= "application/x-www-form-urlencoded";
  }
  var parsedUrl= URL.parse( url, false );
  if( parsedUrl.protocol == "http:" && !parsedUrl.port ) parsedUrl.port= 80;
  if( parsedUrl.protocol == "https:" && !parsedUrl.port ) parsedUrl.port= 443;

  var headers= {};
  var authorization = this._buildAuthorizationHeaders(orderedParameters);
  if ( this._isEcho ) {
    headers["X-Verify-Credentials-Authorization"]= authorization;
  }
  else {
    headers["Authorization"]= authorization;
  }

  headers["Host"] = parsedUrl.host

  for( var key in this._headers ) {
    if (this._headers.hasOwnProperty(key)) {
      headers[key]= this._headers[key];
    }
  }

  // Filter out any passed extra_params that are really to do with OAuth
  for(var key in extra_params) {
    if( this._isParameterNameAnOAuthParameter( key ) ) {
      delete extra_params[key];
    }
  }

  if( (method == "POST" || method == "PUT")  && ( post_body == null && extra_params != null) ) {
    // Fix the mismatch between the output of querystring.stringify() and this._encodeData()
    post_body= querystring.stringify(extra_params)
                       .replace(/\!/g, "%21")
                       .replace(/\'/g, "%27")
                       .replace(/\(/g, "%28")
                       .replace(/\)/g, "%29")
                       .replace(/\*/g, "%2A");
  }

  if( post_body ) {
      if ( Buffer.isBuffer(post_body) ) {
          headers["Content-length"]= post_body.length;
      } else {
          headers["Content-length"]= Buffer.byteLength(post_body);
      }
  } else {
      headers["Content-length"]= 0;
  }

  headers["Content-Type"]= post_content_type;

  var path;
  if( !parsedUrl.pathname  || parsedUrl.pathname == "" ) parsedUrl.pathname ="/";
  if( parsedUrl.query ) path= parsedUrl.pathname + "?"+ parsedUrl.query ;
  else path= parsedUrl.pathname;

  var request;
  if( parsedUrl.protocol == "https:" ) {
    request= this._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers, true);
  }
  else {
    request= this._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers);
  }

  var clientOptions = this._clientOptions;
  if( callback ) {
    var data="";
    var self= this;

    // Some hosts *cough* google appear to close the connection early / send no content-length header
    // allow this behaviour.
    var allowEarlyClose= OAuthUtils.isAnEarlyCloseHost( parsedUrl.hostname );
    var callbackCalled= false;
    var passBackControl = function( response ) {
      if(!callbackCalled) {
        callbackCalled= true;
        if ( response.statusCode >= 200 && response.statusCode <= 299 ) {
          callback(null, data, response);
        } else {
          // Follow 301 or 302 redirects with Location HTTP header
          if((response.statusCode == 301 || response.statusCode == 302) && clientOptions.followRedirects && response.headers && response.headers.location) {
            self._performSecureRequest( oauth_token, oauth_token_secret, method, response.headers.location, extra_params, post_body, post_content_type,  callback);
          }
          else {
            callback({ statusCode: response.statusCode, data: data }, data, response);
          }
        }
      }
    }

    request.on('response', function (response) {
      response.setEncoding('utf8');
      response.on('data', function (chunk) {
        data+=chunk;
      });
      response.on('end', function () {
        passBackControl( response );
      });
      response.on('close', function () {
        if( allowEarlyClose ) {
          passBackControl( response );
        }
      });
    });

    request.on("error", function(err) {
      if(!callbackCalled) {
        callbackCalled= true;
        callback( err )
      }
    });

    if( (method == "POST" || method =="PUT") && post_body != null && post_body != "" ) {
      request.write(post_body);
    }
    request.end();
  }
  else {
    if( (method == "POST" || method =="PUT") && post_body != null && post_body != "" ) {
      request.write(post_body);
    }
    return request;
  }

  return;
}

exports.OAuth.prototype.setClientOptions= function(options) {
  var key,
      mergedOptions= {},
      hasOwnProperty= Object.prototype.hasOwnProperty;

  for( key in this._defaultClientOptions ) {
    if( !hasOwnProperty.call(options, key) ) {
      mergedOptions[key]= this._defaultClientOptions[key];
    } else {
      mergedOptions[key]= options[key];
    }
  }

  this._clientOptions= mergedOptions;
};

exports.OAuth.prototype.getOAuthAccessToken= function(oauth_token, oauth_token_secret, oauth_verifier,  callback) {
  var extraParams= {};
  if( typeof oauth_verifier == "function" ) {
    callback= oauth_verifier;
  } else {
    extraParams.oauth_verifier= oauth_verifier;
  }

   this._performSecureRequest( oauth_token, oauth_token_secret, this._clientOptions.accessTokenHttpMethod, this._accessUrl, extraParams, null, null, function(error, data, response) {
         if( error ) callback(error);
         else {
           var results= querystring.parse( data );
           var oauth_access_token= results["oauth_token"];
           delete results["oauth_token"];
           var oauth_access_token_secret= results["oauth_token_secret"];
           delete results["oauth_token_secret"];
           callback(null, oauth_access_token, oauth_access_token_secret, results );
         }
   })
}

// Deprecated
exports.OAuth.prototype.getProtectedResource= function(url, method, oauth_token, oauth_token_secret, callback) {
  this._performSecureRequest( oauth_token, oauth_token_secret, method, url, null, "", null, callback );
}

exports.OAuth.prototype.delete= function(url, oauth_token, oauth_token_secret, callback) {
  return this._performSecureRequest( oauth_token, oauth_token_secret, "DELETE", url, null, "", null, callback );
}

exports.OAuth.prototype.get= function(url, oauth_token, oauth_token_secret, callback) {
  return this._performSecureRequest( oauth_token, oauth_token_secret, "GET", url, null, "", null, callback );
}

exports.OAuth.prototype._putOrPost= function(method, url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
  var extra_params= null;
  if( typeof post_content_type == "function" ) {
    callback= post_content_type;
    post_content_type= null;
  }
  if ( typeof post_body != "string" && !Buffer.isBuffer(post_body) ) {
    post_content_type= "application/x-www-form-urlencoded"
    extra_params= post_body;
    post_body= null;
  }
  return this._performSecureRequest( oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type, callback );
}


exports.OAuth.prototype.put= function(url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
  return this._putOrPost("PUT", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);
}

exports.OAuth.prototype.post= function(url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
  return this._putOrPost("POST", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);
}

/**
 * Gets a request token from the OAuth provider and passes that information back
 * to the calling code.
 *
 * The callback should expect a function of the following form:
 *
 * function(err, token, token_secret, parsedQueryString) {}
 *
 * This method has optional parameters so can be called in the following 2 ways:
 *
 * 1) Primary use case: Does a basic request with no extra parameters
 *  getOAuthRequestToken( callbackFunction )
 *
 * 2) As above but allows for provision of extra parameters to be sent as part of the query to the server.
 *  getOAuthRequestToken( extraParams, callbackFunction )
 *
 * N.B. This method will HTTP POST verbs by default, if you wish to override this behaviour you will
 * need to provide a requestTokenHttpMethod option when creating the client.
 *
 **/
exports.OAuth.prototype.getOAuthRequestToken= function( extraParams, callback ) {
   if( typeof extraParams == "function" ){
     callback = extraParams;
     extraParams = {};
   }
  // Callbacks are 1.0A related
  if( this._authorize_callback ) {
    extraParams["oauth_callback"]= this._authorize_callback;
  }
  this._performSecureRequest( null, null, this._clientOptions.requestTokenHttpMethod, this._requestUrl, extraParams, null, null, function(error, data, response) {
    if( error ) callback(error);
    else {
      var results= querystring.parse(data);

      var oauth_token= results["oauth_token"];
      var oauth_token_secret= results["oauth_token_secret"];
      delete results["oauth_token"];
      delete results["oauth_token_secret"];
      callback(null, oauth_token, oauth_token_secret,  results );
    }
  });
}

exports.OAuth.prototype.signUrl= function(url, oauth_token, oauth_token_secret, method) {

  if( method === undefined ) {
    var method= "GET";
  }

  var orderedParameters= this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});
  var parsedUrl= URL.parse( url, false );

  var query="";
  for( var i= 0 ; i < orderedParameters.length; i++) {
    query+= orderedParameters[i][0]+"="+ this._encodeData(orderedParameters[i][1]) + "&";
  }
  query= query.substring(0, query.length-1);

  return parsedUrl.protocol + "//"+ parsedUrl.host + parsedUrl.pathname + "?" + query;
};

exports.OAuth.prototype.authHeader= function(url, oauth_token, oauth_token_secret, method) {
  if( method === undefined ) {
    var method= "GET";
  }

  var orderedParameters= this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});
  return this._buildAuthorizationHeaders(orderedParameters);
};


/***/ }),

/***/ "./node_modules/oauth/lib/oauth2.js":
/*!******************************************!*\
  !*** ./node_modules/oauth/lib/oauth2.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var querystring= __webpack_require__(/*! querystring */ "querystring"),
    crypto= __webpack_require__(/*! crypto */ "crypto"),
    https= __webpack_require__(/*! https */ "https"),
    http= __webpack_require__(/*! http */ "http"),
    URL= __webpack_require__(/*! url */ "url"),
    OAuthUtils= __webpack_require__(/*! ./_utils */ "./node_modules/oauth/lib/_utils.js");

exports.OAuth2= function(clientId, clientSecret, baseSite, authorizePath, accessTokenPath, customHeaders) {
  this._clientId= clientId;
  this._clientSecret= clientSecret;
  this._baseSite= baseSite;
  this._authorizeUrl= authorizePath || "/oauth/authorize";
  this._accessTokenUrl= accessTokenPath || "/oauth/access_token";
  this._accessTokenName= "access_token";
  this._authMethod= "Bearer";
  this._customHeaders = customHeaders || {};
  this._useAuthorizationHeaderForGET= false;

  //our agent
  this._agent = undefined;
};

// Allows you to set an agent to use instead of the default HTTP or
// HTTPS agents. Useful when dealing with your own certificates.
exports.OAuth2.prototype.setAgent = function(agent) {
  this._agent = agent;
};

// This 'hack' method is required for sites that don't use
// 'access_token' as the name of the access token (for requests).
// ( http://tools.ietf.org/html/draft-ietf-oauth-v2-16#section-7 )
// it isn't clear what the correct value should be atm, so allowing
// for specific (temporary?) override for now.
exports.OAuth2.prototype.setAccessTokenName= function ( name ) {
  this._accessTokenName= name;
}

// Sets the authorization method for Authorization header.
// e.g. Authorization: Bearer <token>  # "Bearer" is the authorization method.
exports.OAuth2.prototype.setAuthMethod = function ( authMethod ) {
  this._authMethod = authMethod;
};


// If you use the OAuth2 exposed 'get' method (and don't construct your own _request call )
// this will specify whether to use an 'Authorize' header instead of passing the access_token as a query parameter
exports.OAuth2.prototype.useAuthorizationHeaderforGET = function(useIt) {
  this._useAuthorizationHeaderForGET= useIt;
}

exports.OAuth2.prototype._getAccessTokenUrl= function() {
  return this._baseSite + this._accessTokenUrl; /* + "?" + querystring.stringify(params); */
}

// Build the authorization header. In particular, build the part after the colon.
// e.g. Authorization: Bearer <token>  # Build "Bearer <token>"
exports.OAuth2.prototype.buildAuthHeader= function(token) {
  return this._authMethod + ' ' + token;
};

exports.OAuth2.prototype._chooseHttpLibrary= function( parsedUrl ) {
  var http_library= https;
  // As this is OAUth2, we *assume* https unless told explicitly otherwise.
  if( parsedUrl.protocol != "https:" ) {
    http_library= http;
  }
  return http_library;
};

exports.OAuth2.prototype._request= function(method, url, headers, post_body, access_token, callback) {

  var parsedUrl= URL.parse( url, true );
  if( parsedUrl.protocol == "https:" && !parsedUrl.port ) {
    parsedUrl.port= 443;
  }

  var http_library= this._chooseHttpLibrary( parsedUrl );


  var realHeaders= {};
  for( var key in this._customHeaders ) {
    realHeaders[key]= this._customHeaders[key];
  }
  if( headers ) {
    for(var key in headers) {
      realHeaders[key] = headers[key];
    }
  }
  realHeaders['Host']= parsedUrl.host;

  if (!realHeaders['User-Agent']) {
    realHeaders['User-Agent'] = 'Node-oauth';
  }

  if( post_body ) {
      if ( Buffer.isBuffer(post_body) ) {
          realHeaders["Content-Length"]= post_body.length;
      } else {
          realHeaders["Content-Length"]= Buffer.byteLength(post_body);
      }
  } else {
      realHeaders["Content-length"]= 0;
  }

  if( access_token && !('Authorization' in realHeaders)) {
    if( ! parsedUrl.query ) parsedUrl.query= {};
    parsedUrl.query[this._accessTokenName]= access_token;
  }

  var queryStr= querystring.stringify(parsedUrl.query);
  if( queryStr ) queryStr=  "?" + queryStr;
  var options = {
    host:parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.pathname + queryStr,
    method: method,
    headers: realHeaders
  };

  this._executeRequest( http_library, options, post_body, callback );
}

exports.OAuth2.prototype._executeRequest= function( http_library, options, post_body, callback ) {
  // Some hosts *cough* google appear to close the connection early / send no content-length header
  // allow this behaviour.
  var allowEarlyClose= OAuthUtils.isAnEarlyCloseHost(options.host);
  var callbackCalled= false;
  function passBackControl( response, result ) {
    if(!callbackCalled) {
      callbackCalled=true;
      if( !(response.statusCode >= 200 && response.statusCode <= 299) && (response.statusCode != 301) && (response.statusCode != 302) ) {
        callback({ statusCode: response.statusCode, data: result });
      } else {
        callback(null, result, response);
      }
    }
  }

  var result= "";

  //set the agent on the request options
  if (this._agent) {
    options.agent = this._agent;
  }

  var request = http_library.request(options);
  request.on('response', function (response) {
    response.on("data", function (chunk) {
      result+= chunk
    });
    response.on("close", function (err) {
      if( allowEarlyClose ) {
        passBackControl( response, result );
      }
    });
    response.addListener("end", function () {
      passBackControl( response, result );
    });
  });
  request.on('error', function(e) {
    callbackCalled= true;
    callback(e);
  });

  if( (options.method == 'POST' || options.method == 'PUT') && post_body ) {
     request.write(post_body);
  }
  request.end();
}

exports.OAuth2.prototype.getAuthorizeUrl= function( params ) {
  var params= params || {};
  params['client_id'] = this._clientId;
  return this._baseSite + this._authorizeUrl + "?" + querystring.stringify(params);
}

exports.OAuth2.prototype.getOAuthAccessToken= function(code, params, callback) {
  var params= params || {};
  params['client_id'] = this._clientId;
  params['client_secret'] = this._clientSecret;
  var codeParam = (params.grant_type === 'refresh_token') ? 'refresh_token' : 'code';
  params[codeParam]= code;

  var post_data= querystring.stringify( params );
  var post_headers= {
       'Content-Type': 'application/x-www-form-urlencoded'
   };


  this._request("POST", this._getAccessTokenUrl(), post_headers, post_data, null, function(error, data, response) {
    if( error )  callback(error);
    else {
      var results;
      try {
        // As of http://tools.ietf.org/html/draft-ietf-oauth-v2-07
        // responses should be in JSON
        results= JSON.parse( data );
      }
      catch(e) {
        // .... However both Facebook + Github currently use rev05 of the spec
        // and neither seem to specify a content-type correctly in their response headers :(
        // clients of these services will suffer a *minor* performance cost of the exception
        // being thrown
        results= querystring.parse( data );
      }
      var access_token= results["access_token"];
      var refresh_token= results["refresh_token"];
      delete results["refresh_token"];
      callback(null, access_token, refresh_token, results); // callback results =-=
    }
  });
}

// Deprecated
exports.OAuth2.prototype.getProtectedResource= function(url, access_token, callback) {
  this._request("GET", url, {}, "", access_token, callback );
}

exports.OAuth2.prototype.get= function(url, access_token, callback) {
  if( this._useAuthorizationHeaderForGET ) {
    var headers= {'Authorization': this.buildAuthHeader(access_token) }
    access_token= null;
  }
  else {
    headers= {};
  }
  this._request("GET", url, headers, "", access_token, callback );
}


/***/ }),

/***/ "./node_modules/oauth/lib/sha1.js":
/*!****************************************!*\
  !*** ./node_modules/oauth/lib/sha1.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS 180-1
 * Version 2.2 Copyright Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 1;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "="; /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s)    { return rstr2hex(rstr_sha1(str2rstr_utf8(s))); }
function b64_sha1(s)    { return rstr2b64(rstr_sha1(str2rstr_utf8(s))); }
function any_sha1(s, e) { return rstr2any(rstr_sha1(str2rstr_utf8(s)), e); }
function hex_hmac_sha1(k, d)
  { return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_sha1(k, d)
  { return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_sha1(k, d, e)
  { return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc").toLowerCase() == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA1 of a raw string
 */
function rstr_sha1(s)
{
  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
}

/*
 * Calculate the HMAC-SHA1 of a key and some data (raw strings)
 */
function rstr_hmac_sha1(key, data)
{
  var bkey = rstr2binb(key);
  if(bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var remainders = Array();
  var i, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. We stop when the dividend is zero.
   * All remainders are stored for later use.
   */
  while(dividend.length > 0)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[remainders.length] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  /* Append leading zero equivalents */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)))
  for(i = output.length; i < full_length; i++)
    output = encoding[0] + output;

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of big-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binb(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
  return output;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (24 - i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function binb_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = bit_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = bit_rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

exports.HMACSHA1= function(key, data) {
  return b64_hmac_sha1(key, data);
}

/***/ }),

/***/ "./node_modules/performance-now/lib/performance-now.js":
/*!*************************************************************!*\
  !*** ./node_modules/performance-now/lib/performance-now.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

//# sourceMappingURL=performance-now.js.map


/***/ }),

/***/ "./node_modules/psl/data/rules.json":
/*!******************************************!*\
  !*** ./node_modules/psl/data/rules.json ***!
  \******************************************/
/*! exports provided: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036, 1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1120, 1121, 1122, 1123, 1124, 1125, 1126, 1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 1135, 1136, 1137, 1138, 1139, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152, 1153, 1154, 1155, 1156, 1157, 1158, 1159, 1160, 1161, 1162, 1163, 1164, 1165, 1166, 1167, 1168, 1169, 1170, 1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1180, 1181, 1182, 1183, 1184, 1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194, 1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316, 1317, 1318, 1319, 1320, 1321, 1322, 1323, 1324, 1325, 1326, 1327, 1328, 1329, 1330, 1331, 1332, 1333, 1334, 1335, 1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1355, 1356, 1357, 1358, 1359, 1360, 1361, 1362, 1363, 1364, 1365, 1366, 1367, 1368, 1369, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1398, 1399, 1400, 1401, 1402, 1403, 1404, 1405, 1406, 1407, 1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1416, 1417, 1418, 1419, 1420, 1421, 1422, 1423, 1424, 1425, 1426, 1427, 1428, 1429, 1430, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1445, 1446, 1447, 1448, 1449, 1450, 1451, 1452, 1453, 1454, 1455, 1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465, 1466, 1467, 1468, 1469, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487, 1488, 1489, 1490, 1491, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499, 1500, 1501, 1502, 1503, 1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1526, 1527, 1528, 1529, 1530, 1531, 1532, 1533, 1534, 1535, 1536, 1537, 1538, 1539, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1550, 1551, 1552, 1553, 1554, 1555, 1556, 1557, 1558, 1559, 1560, 1561, 1562, 1563, 1564, 1565, 1566, 1567, 1568, 1569, 1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1580, 1581, 1582, 1583, 1584, 1585, 1586, 1587, 1588, 1589, 1590, 1591, 1592, 1593, 1594, 1595, 1596, 1597, 1598, 1599, 1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607, 1608, 1609, 1610, 1611, 1612, 1613, 1614, 1615, 1616, 1617, 1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627, 1628, 1629, 1630, 1631, 1632, 1633, 1634, 1635, 1636, 1637, 1638, 1639, 1640, 1641, 1642, 1643, 1644, 1645, 1646, 1647, 1648, 1649, 1650, 1651, 1652, 1653, 1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663, 1664, 1665, 1666, 1667, 1668, 1669, 1670, 1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1680, 1681, 1682, 1683, 1684, 1685, 1686, 1687, 1688, 1689, 1690, 1691, 1692, 1693, 1694, 1695, 1696, 1697, 1698, 1699, 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711, 1712, 1713, 1714, 1715, 1716, 1717, 1718, 1719, 1720, 1721, 1722, 1723, 1724, 1725, 1726, 1727, 1728, 1729, 1730, 1731, 1732, 1733, 1734, 1735, 1736, 1737, 1738, 1739, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759, 1760, 1761, 1762, 1763, 1764, 1765, 1766, 1767, 1768, 1769, 1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1780, 1781, 1782, 1783, 1784, 1785, 1786, 1787, 1788, 1789, 1790, 1791, 1792, 1793, 1794, 1795, 1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1805, 1806, 1807, 1808, 1809, 1810, 1811, 1812, 1813, 1814, 1815, 1816, 1817, 1818, 1819, 1820, 1821, 1822, 1823, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1835, 1836, 1837, 1838, 1839, 1840, 1841, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849, 1850, 1851, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100, 2101, 2102, 2103, 2104, 2105, 2106, 2107, 2108, 2109, 2110, 2111, 2112, 2113, 2114, 2115, 2116, 2117, 2118, 2119, 2120, 2121, 2122, 2123, 2124, 2125, 2126, 2127, 2128, 2129, 2130, 2131, 2132, 2133, 2134, 2135, 2136, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2144, 2145, 2146, 2147, 2148, 2149, 2150, 2151, 2152, 2153, 2154, 2155, 2156, 2157, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2165, 2166, 2167, 2168, 2169, 2170, 2171, 2172, 2173, 2174, 2175, 2176, 2177, 2178, 2179, 2180, 2181, 2182, 2183, 2184, 2185, 2186, 2187, 2188, 2189, 2190, 2191, 2192, 2193, 2194, 2195, 2196, 2197, 2198, 2199, 2200, 2201, 2202, 2203, 2204, 2205, 2206, 2207, 2208, 2209, 2210, 2211, 2212, 2213, 2214, 2215, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2229, 2230, 2231, 2232, 2233, 2234, 2235, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2246, 2247, 2248, 2249, 2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262, 2263, 2264, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2272, 2273, 2274, 2275, 2276, 2277, 2278, 2279, 2280, 2281, 2282, 2283, 2284, 2285, 2286, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2296, 2297, 2298, 2299, 2300, 2301, 2302, 2303, 2304, 2305, 2306, 2307, 2308, 2309, 2310, 2311, 2312, 2313, 2314, 2315, 2316, 2317, 2318, 2319, 2320, 2321, 2322, 2323, 2324, 2325, 2326, 2327, 2328, 2329, 2330, 2331, 2332, 2333, 2334, 2335, 2336, 2337, 2338, 2339, 2340, 2341, 2342, 2343, 2344, 2345, 2346, 2347, 2348, 2349, 2350, 2351, 2352, 2353, 2354, 2355, 2356, 2357, 2358, 2359, 2360, 2361, 2362, 2363, 2364, 2365, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2384, 2385, 2386, 2387, 2388, 2389, 2390, 2391, 2392, 2393, 2394, 2395, 2396, 2397, 2398, 2399, 2400, 2401, 2402, 2403, 2404, 2405, 2406, 2407, 2408, 2409, 2410, 2411, 2412, 2413, 2414, 2415, 2416, 2417, 2418, 2419, 2420, 2421, 2422, 2423, 2424, 2425, 2426, 2427, 2428, 2429, 2430, 2431, 2432, 2433, 2434, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2443, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2456, 2457, 2458, 2459, 2460, 2461, 2462, 2463, 2464, 2465, 2466, 2467, 2468, 2469, 2470, 2471, 2472, 2473, 2474, 2475, 2476, 2477, 2478, 2479, 2480, 2481, 2482, 2483, 2484, 2485, 2486, 2487, 2488, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2497, 2498, 2499, 2500, 2501, 2502, 2503, 2504, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2517, 2518, 2519, 2520, 2521, 2522, 2523, 2524, 2525, 2526, 2527, 2528, 2529, 2530, 2531, 2532, 2533, 2534, 2535, 2536, 2537, 2538, 2539, 2540, 2541, 2542, 2543, 2544, 2545, 2546, 2547, 2548, 2549, 2550, 2551, 2552, 2553, 2554, 2555, 2556, 2557, 2558, 2559, 2560, 2561, 2562, 2563, 2564, 2565, 2566, 2567, 2568, 2569, 2570, 2571, 2572, 2573, 2574, 2575, 2576, 2577, 2578, 2579, 2580, 2581, 2582, 2583, 2584, 2585, 2586, 2587, 2588, 2589, 2590, 2591, 2592, 2593, 2594, 2595, 2596, 2597, 2598, 2599, 2600, 2601, 2602, 2603, 2604, 2605, 2606, 2607, 2608, 2609, 2610, 2611, 2612, 2613, 2614, 2615, 2616, 2617, 2618, 2619, 2620, 2621, 2622, 2623, 2624, 2625, 2626, 2627, 2628, 2629, 2630, 2631, 2632, 2633, 2634, 2635, 2636, 2637, 2638, 2639, 2640, 2641, 2642, 2643, 2644, 2645, 2646, 2647, 2648, 2649, 2650, 2651, 2652, 2653, 2654, 2655, 2656, 2657, 2658, 2659, 2660, 2661, 2662, 2663, 2664, 2665, 2666, 2667, 2668, 2669, 2670, 2671, 2672, 2673, 2674, 2675, 2676, 2677, 2678, 2679, 2680, 2681, 2682, 2683, 2684, 2685, 2686, 2687, 2688, 2689, 2690, 2691, 2692, 2693, 2694, 2695, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2703, 2704, 2705, 2706, 2707, 2708, 2709, 2710, 2711, 2712, 2713, 2714, 2715, 2716, 2717, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2728, 2729, 2730, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2741, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2752, 2753, 2754, 2755, 2756, 2757, 2758, 2759, 2760, 2761, 2762, 2763, 2764, 2765, 2766, 2767, 2768, 2769, 2770, 2771, 2772, 2773, 2774, 2775, 2776, 2777, 2778, 2779, 2780, 2781, 2782, 2783, 2784, 2785, 2786, 2787, 2788, 2789, 2790, 2791, 2792, 2793, 2794, 2795, 2796, 2797, 2798, 2799, 2800, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817, 2818, 2819, 2820, 2821, 2822, 2823, 2824, 2825, 2826, 2827, 2828, 2829, 2830, 2831, 2832, 2833, 2834, 2835, 2836, 2837, 2838, 2839, 2840, 2841, 2842, 2843, 2844, 2845, 2846, 2847, 2848, 2849, 2850, 2851, 2852, 2853, 2854, 2855, 2856, 2857, 2858, 2859, 2860, 2861, 2862, 2863, 2864, 2865, 2866, 2867, 2868, 2869, 2870, 2871, 2872, 2873, 2874, 2875, 2876, 2877, 2878, 2879, 2880, 2881, 2882, 2883, 2884, 2885, 2886, 2887, 2888, 2889, 2890, 2891, 2892, 2893, 2894, 2895, 2896, 2897, 2898, 2899, 2900, 2901, 2902, 2903, 2904, 2905, 2906, 2907, 2908, 2909, 2910, 2911, 2912, 2913, 2914, 2915, 2916, 2917, 2918, 2919, 2920, 2921, 2922, 2923, 2924, 2925, 2926, 2927, 2928, 2929, 2930, 2931, 2932, 2933, 2934, 2935, 2936, 2937, 2938, 2939, 2940, 2941, 2942, 2943, 2944, 2945, 2946, 2947, 2948, 2949, 2950, 2951, 2952, 2953, 2954, 2955, 2956, 2957, 2958, 2959, 2960, 2961, 2962, 2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3006, 3007, 3008, 3009, 3010, 3011, 3012, 3013, 3014, 3015, 3016, 3017, 3018, 3019, 3020, 3021, 3022, 3023, 3024, 3025, 3026, 3027, 3028, 3029, 3030, 3031, 3032, 3033, 3034, 3035, 3036, 3037, 3038, 3039, 3040, 3041, 3042, 3043, 3044, 3045, 3046, 3047, 3048, 3049, 3050, 3051, 3052, 3053, 3054, 3055, 3056, 3057, 3058, 3059, 3060, 3061, 3062, 3063, 3064, 3065, 3066, 3067, 3068, 3069, 3070, 3071, 3072, 3073, 3074, 3075, 3076, 3077, 3078, 3079, 3080, 3081, 3082, 3083, 3084, 3085, 3086, 3087, 3088, 3089, 3090, 3091, 3092, 3093, 3094, 3095, 3096, 3097, 3098, 3099, 3100, 3101, 3102, 3103, 3104, 3105, 3106, 3107, 3108, 3109, 3110, 3111, 3112, 3113, 3114, 3115, 3116, 3117, 3118, 3119, 3120, 3121, 3122, 3123, 3124, 3125, 3126, 3127, 3128, 3129, 3130, 3131, 3132, 3133, 3134, 3135, 3136, 3137, 3138, 3139, 3140, 3141, 3142, 3143, 3144, 3145, 3146, 3147, 3148, 3149, 3150, 3151, 3152, 3153, 3154, 3155, 3156, 3157, 3158, 3159, 3160, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3168, 3169, 3170, 3171, 3172, 3173, 3174, 3175, 3176, 3177, 3178, 3179, 3180, 3181, 3182, 3183, 3184, 3185, 3186, 3187, 3188, 3189, 3190, 3191, 3192, 3193, 3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3202, 3203, 3204, 3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214, 3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 3225, 3226, 3227, 3228, 3229, 3230, 3231, 3232, 3233, 3234, 3235, 3236, 3237, 3238, 3239, 3240, 3241, 3242, 3243, 3244, 3245, 3246, 3247, 3248, 3249, 3250, 3251, 3252, 3253, 3254, 3255, 3256, 3257, 3258, 3259, 3260, 3261, 3262, 3263, 3264, 3265, 3266, 3267, 3268, 3269, 3270, 3271, 3272, 3273, 3274, 3275, 3276, 3277, 3278, 3279, 3280, 3281, 3282, 3283, 3284, 3285, 3286, 3287, 3288, 3289, 3290, 3291, 3292, 3293, 3294, 3295, 3296, 3297, 3298, 3299, 3300, 3301, 3302, 3303, 3304, 3305, 3306, 3307, 3308, 3309, 3310, 3311, 3312, 3313, 3314, 3315, 3316, 3317, 3318, 3319, 3320, 3321, 3322, 3323, 3324, 3325, 3326, 3327, 3328, 3329, 3330, 3331, 3332, 3333, 3334, 3335, 3336, 3337, 3338, 3339, 3340, 3341, 3342, 3343, 3344, 3345, 3346, 3347, 3348, 3349, 3350, 3351, 3352, 3353, 3354, 3355, 3356, 3357, 3358, 3359, 3360, 3361, 3362, 3363, 3364, 3365, 3366, 3367, 3368, 3369, 3370, 3371, 3372, 3373, 3374, 3375, 3376, 3377, 3378, 3379, 3380, 3381, 3382, 3383, 3384, 3385, 3386, 3387, 3388, 3389, 3390, 3391, 3392, 3393, 3394, 3395, 3396, 3397, 3398, 3399, 3400, 3401, 3402, 3403, 3404, 3405, 3406, 3407, 3408, 3409, 3410, 3411, 3412, 3413, 3414, 3415, 3416, 3417, 3418, 3419, 3420, 3421, 3422, 3423, 3424, 3425, 3426, 3427, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3435, 3436, 3437, 3438, 3439, 3440, 3441, 3442, 3443, 3444, 3445, 3446, 3447, 3448, 3449, 3450, 3451, 3452, 3453, 3454, 3455, 3456, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467, 3468, 3469, 3470, 3471, 3472, 3473, 3474, 3475, 3476, 3477, 3478, 3479, 3480, 3481, 3482, 3483, 3484, 3485, 3486, 3487, 3488, 3489, 3490, 3491, 3492, 3493, 3494, 3495, 3496, 3497, 3498, 3499, 3500, 3501, 3502, 3503, 3504, 3505, 3506, 3507, 3508, 3509, 3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3518, 3519, 3520, 3521, 3522, 3523, 3524, 3525, 3526, 3527, 3528, 3529, 3530, 3531, 3532, 3533, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544, 3545, 3546, 3547, 3548, 3549, 3550, 3551, 3552, 3553, 3554, 3555, 3556, 3557, 3558, 3559, 3560, 3561, 3562, 3563, 3564, 3565, 3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575, 3576, 3577, 3578, 3579, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 3643, 3644, 3645, 3646, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 3676, 3677, 3678, 3679, 3680, 3681, 3682, 3683, 3684, 3685, 3686, 3687, 3688, 3689, 3690, 3691, 3692, 3693, 3694, 3695, 3696, 3697, 3698, 3699, 3700, 3701, 3702, 3703, 3704, 3705, 3706, 3707, 3708, 3709, 3710, 3711, 3712, 3713, 3714, 3715, 3716, 3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3725, 3726, 3727, 3728, 3729, 3730, 3731, 3732, 3733, 3734, 3735, 3736, 3737, 3738, 3739, 3740, 3741, 3742, 3743, 3744, 3745, 3746, 3747, 3748, 3749, 3750, 3751, 3752, 3753, 3754, 3755, 3756, 3757, 3758, 3759, 3760, 3761, 3762, 3763, 3764, 3765, 3766, 3767, 3768, 3769, 3770, 3771, 3772, 3773, 3774, 3775, 3776, 3777, 3778, 3779, 3780, 3781, 3782, 3783, 3784, 3785, 3786, 3787, 3788, 3789, 3790, 3791, 3792, 3793, 3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803, 3804, 3805, 3806, 3807, 3808, 3809, 3810, 3811, 3812, 3813, 3814, 3815, 3816, 3817, 3818, 3819, 3820, 3821, 3822, 3823, 3824, 3825, 3826, 3827, 3828, 3829, 3830, 3831, 3832, 3833, 3834, 3835, 3836, 3837, 3838, 3839, 3840, 3841, 3842, 3843, 3844, 3845, 3846, 3847, 3848, 3849, 3850, 3851, 3852, 3853, 3854, 3855, 3856, 3857, 3858, 3859, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868, 3869, 3870, 3871, 3872, 3873, 3874, 3875, 3876, 3877, 3878, 3879, 3880, 3881, 3882, 3883, 3884, 3885, 3886, 3887, 3888, 3889, 3890, 3891, 3892, 3893, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3902, 3903, 3904, 3905, 3906, 3907, 3908, 3909, 3910, 3911, 3912, 3913, 3914, 3915, 3916, 3917, 3918, 3919, 3920, 3921, 3922, 3923, 3924, 3925, 3926, 3927, 3928, 3929, 3930, 3931, 3932, 3933, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942, 3943, 3944, 3945, 3946, 3947, 3948, 3949, 3950, 3951, 3952, 3953, 3954, 3955, 3956, 3957, 3958, 3959, 3960, 3961, 3962, 3963, 3964, 3965, 3966, 3967, 3968, 3969, 3970, 3971, 3972, 3973, 3974, 3975, 3976, 3977, 3978, 3979, 3980, 3981, 3982, 3983, 3984, 3985, 3986, 3987, 3988, 3989, 3990, 3991, 3992, 3993, 3994, 3995, 3996, 3997, 3998, 3999, 4000, 4001, 4002, 4003, 4004, 4005, 4006, 4007, 4008, 4009, 4010, 4011, 4012, 4013, 4014, 4015, 4016, 4017, 4018, 4019, 4020, 4021, 4022, 4023, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4032, 4033, 4034, 4035, 4036, 4037, 4038, 4039, 4040, 4041, 4042, 4043, 4044, 4045, 4046, 4047, 4048, 4049, 4050, 4051, 4052, 4053, 4054, 4055, 4056, 4057, 4058, 4059, 4060, 4061, 4062, 4063, 4064, 4065, 4066, 4067, 4068, 4069, 4070, 4071, 4072, 4073, 4074, 4075, 4076, 4077, 4078, 4079, 4080, 4081, 4082, 4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4092, 4093, 4094, 4095, 4096, 4097, 4098, 4099, 4100, 4101, 4102, 4103, 4104, 4105, 4106, 4107, 4108, 4109, 4110, 4111, 4112, 4113, 4114, 4115, 4116, 4117, 4118, 4119, 4120, 4121, 4122, 4123, 4124, 4125, 4126, 4127, 4128, 4129, 4130, 4131, 4132, 4133, 4134, 4135, 4136, 4137, 4138, 4139, 4140, 4141, 4142, 4143, 4144, 4145, 4146, 4147, 4148, 4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4159, 4160, 4161, 4162, 4163, 4164, 4165, 4166, 4167, 4168, 4169, 4170, 4171, 4172, 4173, 4174, 4175, 4176, 4177, 4178, 4179, 4180, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189, 4190, 4191, 4192, 4193, 4194, 4195, 4196, 4197, 4198, 4199, 4200, 4201, 4202, 4203, 4204, 4205, 4206, 4207, 4208, 4209, 4210, 4211, 4212, 4213, 4214, 4215, 4216, 4217, 4218, 4219, 4220, 4221, 4222, 4223, 4224, 4225, 4226, 4227, 4228, 4229, 4230, 4231, 4232, 4233, 4234, 4235, 4236, 4237, 4238, 4239, 4240, 4241, 4242, 4243, 4244, 4245, 4246, 4247, 4248, 4249, 4250, 4251, 4252, 4253, 4254, 4255, 4256, 4257, 4258, 4259, 4260, 4261, 4262, 4263, 4264, 4265, 4266, 4267, 4268, 4269, 4270, 4271, 4272, 4273, 4274, 4275, 4276, 4277, 4278, 4279, 4280, 4281, 4282, 4283, 4284, 4285, 4286, 4287, 4288, 4289, 4290, 4291, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299, 4300, 4301, 4302, 4303, 4304, 4305, 4306, 4307, 4308, 4309, 4310, 4311, 4312, 4313, 4314, 4315, 4316, 4317, 4318, 4319, 4320, 4321, 4322, 4323, 4324, 4325, 4326, 4327, 4328, 4329, 4330, 4331, 4332, 4333, 4334, 4335, 4336, 4337, 4338, 4339, 4340, 4341, 4342, 4343, 4344, 4345, 4346, 4347, 4348, 4349, 4350, 4351, 4352, 4353, 4354, 4355, 4356, 4357, 4358, 4359, 4360, 4361, 4362, 4363, 4364, 4365, 4366, 4367, 4368, 4369, 4370, 4371, 4372, 4373, 4374, 4375, 4376, 4377, 4378, 4379, 4380, 4381, 4382, 4383, 4384, 4385, 4386, 4387, 4388, 4389, 4390, 4391, 4392, 4393, 4394, 4395, 4396, 4397, 4398, 4399, 4400, 4401, 4402, 4403, 4404, 4405, 4406, 4407, 4408, 4409, 4410, 4411, 4412, 4413, 4414, 4415, 4416, 4417, 4418, 4419, 4420, 4421, 4422, 4423, 4424, 4425, 4426, 4427, 4428, 4429, 4430, 4431, 4432, 4433, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441, 4442, 4443, 4444, 4445, 4446, 4447, 4448, 4449, 4450, 4451, 4452, 4453, 4454, 4455, 4456, 4457, 4458, 4459, 4460, 4461, 4462, 4463, 4464, 4465, 4466, 4467, 4468, 4469, 4470, 4471, 4472, 4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4481, 4482, 4483, 4484, 4485, 4486, 4487, 4488, 4489, 4490, 4491, 4492, 4493, 4494, 4495, 4496, 4497, 4498, 4499, 4500, 4501, 4502, 4503, 4504, 4505, 4506, 4507, 4508, 4509, 4510, 4511, 4512, 4513, 4514, 4515, 4516, 4517, 4518, 4519, 4520, 4521, 4522, 4523, 4524, 4525, 4526, 4527, 4528, 4529, 4530, 4531, 4532, 4533, 4534, 4535, 4536, 4537, 4538, 4539, 4540, 4541, 4542, 4543, 4544, 4545, 4546, 4547, 4548, 4549, 4550, 4551, 4552, 4553, 4554, 4555, 4556, 4557, 4558, 4559, 4560, 4561, 4562, 4563, 4564, 4565, 4566, 4567, 4568, 4569, 4570, 4571, 4572, 4573, 4574, 4575, 4576, 4577, 4578, 4579, 4580, 4581, 4582, 4583, 4584, 4585, 4586, 4587, 4588, 4589, 4590, 4591, 4592, 4593, 4594, 4595, 4596, 4597, 4598, 4599, 4600, 4601, 4602, 4603, 4604, 4605, 4606, 4607, 4608, 4609, 4610, 4611, 4612, 4613, 4614, 4615, 4616, 4617, 4618, 4619, 4620, 4621, 4622, 4623, 4624, 4625, 4626, 4627, 4628, 4629, 4630, 4631, 4632, 4633, 4634, 4635, 4636, 4637, 4638, 4639, 4640, 4641, 4642, 4643, 4644, 4645, 4646, 4647, 4648, 4649, 4650, 4651, 4652, 4653, 4654, 4655, 4656, 4657, 4658, 4659, 4660, 4661, 4662, 4663, 4664, 4665, 4666, 4667, 4668, 4669, 4670, 4671, 4672, 4673, 4674, 4675, 4676, 4677, 4678, 4679, 4680, 4681, 4682, 4683, 4684, 4685, 4686, 4687, 4688, 4689, 4690, 4691, 4692, 4693, 4694, 4695, 4696, 4697, 4698, 4699, 4700, 4701, 4702, 4703, 4704, 4705, 4706, 4707, 4708, 4709, 4710, 4711, 4712, 4713, 4714, 4715, 4716, 4717, 4718, 4719, 4720, 4721, 4722, 4723, 4724, 4725, 4726, 4727, 4728, 4729, 4730, 4731, 4732, 4733, 4734, 4735, 4736, 4737, 4738, 4739, 4740, 4741, 4742, 4743, 4744, 4745, 4746, 4747, 4748, 4749, 4750, 4751, 4752, 4753, 4754, 4755, 4756, 4757, 4758, 4759, 4760, 4761, 4762, 4763, 4764, 4765, 4766, 4767, 4768, 4769, 4770, 4771, 4772, 4773, 4774, 4775, 4776, 4777, 4778, 4779, 4780, 4781, 4782, 4783, 4784, 4785, 4786, 4787, 4788, 4789, 4790, 4791, 4792, 4793, 4794, 4795, 4796, 4797, 4798, 4799, 4800, 4801, 4802, 4803, 4804, 4805, 4806, 4807, 4808, 4809, 4810, 4811, 4812, 4813, 4814, 4815, 4816, 4817, 4818, 4819, 4820, 4821, 4822, 4823, 4824, 4825, 4826, 4827, 4828, 4829, 4830, 4831, 4832, 4833, 4834, 4835, 4836, 4837, 4838, 4839, 4840, 4841, 4842, 4843, 4844, 4845, 4846, 4847, 4848, 4849, 4850, 4851, 4852, 4853, 4854, 4855, 4856, 4857, 4858, 4859, 4860, 4861, 4862, 4863, 4864, 4865, 4866, 4867, 4868, 4869, 4870, 4871, 4872, 4873, 4874, 4875, 4876, 4877, 4878, 4879, 4880, 4881, 4882, 4883, 4884, 4885, 4886, 4887, 4888, 4889, 4890, 4891, 4892, 4893, 4894, 4895, 4896, 4897, 4898, 4899, 4900, 4901, 4902, 4903, 4904, 4905, 4906, 4907, 4908, 4909, 4910, 4911, 4912, 4913, 4914, 4915, 4916, 4917, 4918, 4919, 4920, 4921, 4922, 4923, 4924, 4925, 4926, 4927, 4928, 4929, 4930, 4931, 4932, 4933, 4934, 4935, 4936, 4937, 4938, 4939, 4940, 4941, 4942, 4943, 4944, 4945, 4946, 4947, 4948, 4949, 4950, 4951, 4952, 4953, 4954, 4955, 4956, 4957, 4958, 4959, 4960, 4961, 4962, 4963, 4964, 4965, 4966, 4967, 4968, 4969, 4970, 4971, 4972, 4973, 4974, 4975, 4976, 4977, 4978, 4979, 4980, 4981, 4982, 4983, 4984, 4985, 4986, 4987, 4988, 4989, 4990, 4991, 4992, 4993, 4994, 4995, 4996, 4997, 4998, 4999, 5000, 5001, 5002, 5003, 5004, 5005, 5006, 5007, 5008, 5009, 5010, 5011, 5012, 5013, 5014, 5015, 5016, 5017, 5018, 5019, 5020, 5021, 5022, 5023, 5024, 5025, 5026, 5027, 5028, 5029, 5030, 5031, 5032, 5033, 5034, 5035, 5036, 5037, 5038, 5039, 5040, 5041, 5042, 5043, 5044, 5045, 5046, 5047, 5048, 5049, 5050, 5051, 5052, 5053, 5054, 5055, 5056, 5057, 5058, 5059, 5060, 5061, 5062, 5063, 5064, 5065, 5066, 5067, 5068, 5069, 5070, 5071, 5072, 5073, 5074, 5075, 5076, 5077, 5078, 5079, 5080, 5081, 5082, 5083, 5084, 5085, 5086, 5087, 5088, 5089, 5090, 5091, 5092, 5093, 5094, 5095, 5096, 5097, 5098, 5099, 5100, 5101, 5102, 5103, 5104, 5105, 5106, 5107, 5108, 5109, 5110, 5111, 5112, 5113, 5114, 5115, 5116, 5117, 5118, 5119, 5120, 5121, 5122, 5123, 5124, 5125, 5126, 5127, 5128, 5129, 5130, 5131, 5132, 5133, 5134, 5135, 5136, 5137, 5138, 5139, 5140, 5141, 5142, 5143, 5144, 5145, 5146, 5147, 5148, 5149, 5150, 5151, 5152, 5153, 5154, 5155, 5156, 5157, 5158, 5159, 5160, 5161, 5162, 5163, 5164, 5165, 5166, 5167, 5168, 5169, 5170, 5171, 5172, 5173, 5174, 5175, 5176, 5177, 5178, 5179, 5180, 5181, 5182, 5183, 5184, 5185, 5186, 5187, 5188, 5189, 5190, 5191, 5192, 5193, 5194, 5195, 5196, 5197, 5198, 5199, 5200, 5201, 5202, 5203, 5204, 5205, 5206, 5207, 5208, 5209, 5210, 5211, 5212, 5213, 5214, 5215, 5216, 5217, 5218, 5219, 5220, 5221, 5222, 5223, 5224, 5225, 5226, 5227, 5228, 5229, 5230, 5231, 5232, 5233, 5234, 5235, 5236, 5237, 5238, 5239, 5240, 5241, 5242, 5243, 5244, 5245, 5246, 5247, 5248, 5249, 5250, 5251, 5252, 5253, 5254, 5255, 5256, 5257, 5258, 5259, 5260, 5261, 5262, 5263, 5264, 5265, 5266, 5267, 5268, 5269, 5270, 5271, 5272, 5273, 5274, 5275, 5276, 5277, 5278, 5279, 5280, 5281, 5282, 5283, 5284, 5285, 5286, 5287, 5288, 5289, 5290, 5291, 5292, 5293, 5294, 5295, 5296, 5297, 5298, 5299, 5300, 5301, 5302, 5303, 5304, 5305, 5306, 5307, 5308, 5309, 5310, 5311, 5312, 5313, 5314, 5315, 5316, 5317, 5318, 5319, 5320, 5321, 5322, 5323, 5324, 5325, 5326, 5327, 5328, 5329, 5330, 5331, 5332, 5333, 5334, 5335, 5336, 5337, 5338, 5339, 5340, 5341, 5342, 5343, 5344, 5345, 5346, 5347, 5348, 5349, 5350, 5351, 5352, 5353, 5354, 5355, 5356, 5357, 5358, 5359, 5360, 5361, 5362, 5363, 5364, 5365, 5366, 5367, 5368, 5369, 5370, 5371, 5372, 5373, 5374, 5375, 5376, 5377, 5378, 5379, 5380, 5381, 5382, 5383, 5384, 5385, 5386, 5387, 5388, 5389, 5390, 5391, 5392, 5393, 5394, 5395, 5396, 5397, 5398, 5399, 5400, 5401, 5402, 5403, 5404, 5405, 5406, 5407, 5408, 5409, 5410, 5411, 5412, 5413, 5414, 5415, 5416, 5417, 5418, 5419, 5420, 5421, 5422, 5423, 5424, 5425, 5426, 5427, 5428, 5429, 5430, 5431, 5432, 5433, 5434, 5435, 5436, 5437, 5438, 5439, 5440, 5441, 5442, 5443, 5444, 5445, 5446, 5447, 5448, 5449, 5450, 5451, 5452, 5453, 5454, 5455, 5456, 5457, 5458, 5459, 5460, 5461, 5462, 5463, 5464, 5465, 5466, 5467, 5468, 5469, 5470, 5471, 5472, 5473, 5474, 5475, 5476, 5477, 5478, 5479, 5480, 5481, 5482, 5483, 5484, 5485, 5486, 5487, 5488, 5489, 5490, 5491, 5492, 5493, 5494, 5495, 5496, 5497, 5498, 5499, 5500, 5501, 5502, 5503, 5504, 5505, 5506, 5507, 5508, 5509, 5510, 5511, 5512, 5513, 5514, 5515, 5516, 5517, 5518, 5519, 5520, 5521, 5522, 5523, 5524, 5525, 5526, 5527, 5528, 5529, 5530, 5531, 5532, 5533, 5534, 5535, 5536, 5537, 5538, 5539, 5540, 5541, 5542, 5543, 5544, 5545, 5546, 5547, 5548, 5549, 5550, 5551, 5552, 5553, 5554, 5555, 5556, 5557, 5558, 5559, 5560, 5561, 5562, 5563, 5564, 5565, 5566, 5567, 5568, 5569, 5570, 5571, 5572, 5573, 5574, 5575, 5576, 5577, 5578, 5579, 5580, 5581, 5582, 5583, 5584, 5585, 5586, 5587, 5588, 5589, 5590, 5591, 5592, 5593, 5594, 5595, 5596, 5597, 5598, 5599, 5600, 5601, 5602, 5603, 5604, 5605, 5606, 5607, 5608, 5609, 5610, 5611, 5612, 5613, 5614, 5615, 5616, 5617, 5618, 5619, 5620, 5621, 5622, 5623, 5624, 5625, 5626, 5627, 5628, 5629, 5630, 5631, 5632, 5633, 5634, 5635, 5636, 5637, 5638, 5639, 5640, 5641, 5642, 5643, 5644, 5645, 5646, 5647, 5648, 5649, 5650, 5651, 5652, 5653, 5654, 5655, 5656, 5657, 5658, 5659, 5660, 5661, 5662, 5663, 5664, 5665, 5666, 5667, 5668, 5669, 5670, 5671, 5672, 5673, 5674, 5675, 5676, 5677, 5678, 5679, 5680, 5681, 5682, 5683, 5684, 5685, 5686, 5687, 5688, 5689, 5690, 5691, 5692, 5693, 5694, 5695, 5696, 5697, 5698, 5699, 5700, 5701, 5702, 5703, 5704, 5705, 5706, 5707, 5708, 5709, 5710, 5711, 5712, 5713, 5714, 5715, 5716, 5717, 5718, 5719, 5720, 5721, 5722, 5723, 5724, 5725, 5726, 5727, 5728, 5729, 5730, 5731, 5732, 5733, 5734, 5735, 5736, 5737, 5738, 5739, 5740, 5741, 5742, 5743, 5744, 5745, 5746, 5747, 5748, 5749, 5750, 5751, 5752, 5753, 5754, 5755, 5756, 5757, 5758, 5759, 5760, 5761, 5762, 5763, 5764, 5765, 5766, 5767, 5768, 5769, 5770, 5771, 5772, 5773, 5774, 5775, 5776, 5777, 5778, 5779, 5780, 5781, 5782, 5783, 5784, 5785, 5786, 5787, 5788, 5789, 5790, 5791, 5792, 5793, 5794, 5795, 5796, 5797, 5798, 5799, 5800, 5801, 5802, 5803, 5804, 5805, 5806, 5807, 5808, 5809, 5810, 5811, 5812, 5813, 5814, 5815, 5816, 5817, 5818, 5819, 5820, 5821, 5822, 5823, 5824, 5825, 5826, 5827, 5828, 5829, 5830, 5831, 5832, 5833, 5834, 5835, 5836, 5837, 5838, 5839, 5840, 5841, 5842, 5843, 5844, 5845, 5846, 5847, 5848, 5849, 5850, 5851, 5852, 5853, 5854, 5855, 5856, 5857, 5858, 5859, 5860, 5861, 5862, 5863, 5864, 5865, 5866, 5867, 5868, 5869, 5870, 5871, 5872, 5873, 5874, 5875, 5876, 5877, 5878, 5879, 5880, 5881, 5882, 5883, 5884, 5885, 5886, 5887, 5888, 5889, 5890, 5891, 5892, 5893, 5894, 5895, 5896, 5897, 5898, 5899, 5900, 5901, 5902, 5903, 5904, 5905, 5906, 5907, 5908, 5909, 5910, 5911, 5912, 5913, 5914, 5915, 5916, 5917, 5918, 5919, 5920, 5921, 5922, 5923, 5924, 5925, 5926, 5927, 5928, 5929, 5930, 5931, 5932, 5933, 5934, 5935, 5936, 5937, 5938, 5939, 5940, 5941, 5942, 5943, 5944, 5945, 5946, 5947, 5948, 5949, 5950, 5951, 5952, 5953, 5954, 5955, 5956, 5957, 5958, 5959, 5960, 5961, 5962, 5963, 5964, 5965, 5966, 5967, 5968, 5969, 5970, 5971, 5972, 5973, 5974, 5975, 5976, 5977, 5978, 5979, 5980, 5981, 5982, 5983, 5984, 5985, 5986, 5987, 5988, 5989, 5990, 5991, 5992, 5993, 5994, 5995, 5996, 5997, 5998, 5999, 6000, 6001, 6002, 6003, 6004, 6005, 6006, 6007, 6008, 6009, 6010, 6011, 6012, 6013, 6014, 6015, 6016, 6017, 6018, 6019, 6020, 6021, 6022, 6023, 6024, 6025, 6026, 6027, 6028, 6029, 6030, 6031, 6032, 6033, 6034, 6035, 6036, 6037, 6038, 6039, 6040, 6041, 6042, 6043, 6044, 6045, 6046, 6047, 6048, 6049, 6050, 6051, 6052, 6053, 6054, 6055, 6056, 6057, 6058, 6059, 6060, 6061, 6062, 6063, 6064, 6065, 6066, 6067, 6068, 6069, 6070, 6071, 6072, 6073, 6074, 6075, 6076, 6077, 6078, 6079, 6080, 6081, 6082, 6083, 6084, 6085, 6086, 6087, 6088, 6089, 6090, 6091, 6092, 6093, 6094, 6095, 6096, 6097, 6098, 6099, 6100, 6101, 6102, 6103, 6104, 6105, 6106, 6107, 6108, 6109, 6110, 6111, 6112, 6113, 6114, 6115, 6116, 6117, 6118, 6119, 6120, 6121, 6122, 6123, 6124, 6125, 6126, 6127, 6128, 6129, 6130, 6131, 6132, 6133, 6134, 6135, 6136, 6137, 6138, 6139, 6140, 6141, 6142, 6143, 6144, 6145, 6146, 6147, 6148, 6149, 6150, 6151, 6152, 6153, 6154, 6155, 6156, 6157, 6158, 6159, 6160, 6161, 6162, 6163, 6164, 6165, 6166, 6167, 6168, 6169, 6170, 6171, 6172, 6173, 6174, 6175, 6176, 6177, 6178, 6179, 6180, 6181, 6182, 6183, 6184, 6185, 6186, 6187, 6188, 6189, 6190, 6191, 6192, 6193, 6194, 6195, 6196, 6197, 6198, 6199, 6200, 6201, 6202, 6203, 6204, 6205, 6206, 6207, 6208, 6209, 6210, 6211, 6212, 6213, 6214, 6215, 6216, 6217, 6218, 6219, 6220, 6221, 6222, 6223, 6224, 6225, 6226, 6227, 6228, 6229, 6230, 6231, 6232, 6233, 6234, 6235, 6236, 6237, 6238, 6239, 6240, 6241, 6242, 6243, 6244, 6245, 6246, 6247, 6248, 6249, 6250, 6251, 6252, 6253, 6254, 6255, 6256, 6257, 6258, 6259, 6260, 6261, 6262, 6263, 6264, 6265, 6266, 6267, 6268, 6269, 6270, 6271, 6272, 6273, 6274, 6275, 6276, 6277, 6278, 6279, 6280, 6281, 6282, 6283, 6284, 6285, 6286, 6287, 6288, 6289, 6290, 6291, 6292, 6293, 6294, 6295, 6296, 6297, 6298, 6299, 6300, 6301, 6302, 6303, 6304, 6305, 6306, 6307, 6308, 6309, 6310, 6311, 6312, 6313, 6314, 6315, 6316, 6317, 6318, 6319, 6320, 6321, 6322, 6323, 6324, 6325, 6326, 6327, 6328, 6329, 6330, 6331, 6332, 6333, 6334, 6335, 6336, 6337, 6338, 6339, 6340, 6341, 6342, 6343, 6344, 6345, 6346, 6347, 6348, 6349, 6350, 6351, 6352, 6353, 6354, 6355, 6356, 6357, 6358, 6359, 6360, 6361, 6362, 6363, 6364, 6365, 6366, 6367, 6368, 6369, 6370, 6371, 6372, 6373, 6374, 6375, 6376, 6377, 6378, 6379, 6380, 6381, 6382, 6383, 6384, 6385, 6386, 6387, 6388, 6389, 6390, 6391, 6392, 6393, 6394, 6395, 6396, 6397, 6398, 6399, 6400, 6401, 6402, 6403, 6404, 6405, 6406, 6407, 6408, 6409, 6410, 6411, 6412, 6413, 6414, 6415, 6416, 6417, 6418, 6419, 6420, 6421, 6422, 6423, 6424, 6425, 6426, 6427, 6428, 6429, 6430, 6431, 6432, 6433, 6434, 6435, 6436, 6437, 6438, 6439, 6440, 6441, 6442, 6443, 6444, 6445, 6446, 6447, 6448, 6449, 6450, 6451, 6452, 6453, 6454, 6455, 6456, 6457, 6458, 6459, 6460, 6461, 6462, 6463, 6464, 6465, 6466, 6467, 6468, 6469, 6470, 6471, 6472, 6473, 6474, 6475, 6476, 6477, 6478, 6479, 6480, 6481, 6482, 6483, 6484, 6485, 6486, 6487, 6488, 6489, 6490, 6491, 6492, 6493, 6494, 6495, 6496, 6497, 6498, 6499, 6500, 6501, 6502, 6503, 6504, 6505, 6506, 6507, 6508, 6509, 6510, 6511, 6512, 6513, 6514, 6515, 6516, 6517, 6518, 6519, 6520, 6521, 6522, 6523, 6524, 6525, 6526, 6527, 6528, 6529, 6530, 6531, 6532, 6533, 6534, 6535, 6536, 6537, 6538, 6539, 6540, 6541, 6542, 6543, 6544, 6545, 6546, 6547, 6548, 6549, 6550, 6551, 6552, 6553, 6554, 6555, 6556, 6557, 6558, 6559, 6560, 6561, 6562, 6563, 6564, 6565, 6566, 6567, 6568, 6569, 6570, 6571, 6572, 6573, 6574, 6575, 6576, 6577, 6578, 6579, 6580, 6581, 6582, 6583, 6584, 6585, 6586, 6587, 6588, 6589, 6590, 6591, 6592, 6593, 6594, 6595, 6596, 6597, 6598, 6599, 6600, 6601, 6602, 6603, 6604, 6605, 6606, 6607, 6608, 6609, 6610, 6611, 6612, 6613, 6614, 6615, 6616, 6617, 6618, 6619, 6620, 6621, 6622, 6623, 6624, 6625, 6626, 6627, 6628, 6629, 6630, 6631, 6632, 6633, 6634, 6635, 6636, 6637, 6638, 6639, 6640, 6641, 6642, 6643, 6644, 6645, 6646, 6647, 6648, 6649, 6650, 6651, 6652, 6653, 6654, 6655, 6656, 6657, 6658, 6659, 6660, 6661, 6662, 6663, 6664, 6665, 6666, 6667, 6668, 6669, 6670, 6671, 6672, 6673, 6674, 6675, 6676, 6677, 6678, 6679, 6680, 6681, 6682, 6683, 6684, 6685, 6686, 6687, 6688, 6689, 6690, 6691, 6692, 6693, 6694, 6695, 6696, 6697, 6698, 6699, 6700, 6701, 6702, 6703, 6704, 6705, 6706, 6707, 6708, 6709, 6710, 6711, 6712, 6713, 6714, 6715, 6716, 6717, 6718, 6719, 6720, 6721, 6722, 6723, 6724, 6725, 6726, 6727, 6728, 6729, 6730, 6731, 6732, 6733, 6734, 6735, 6736, 6737, 6738, 6739, 6740, 6741, 6742, 6743, 6744, 6745, 6746, 6747, 6748, 6749, 6750, 6751, 6752, 6753, 6754, 6755, 6756, 6757, 6758, 6759, 6760, 6761, 6762, 6763, 6764, 6765, 6766, 6767, 6768, 6769, 6770, 6771, 6772, 6773, 6774, 6775, 6776, 6777, 6778, 6779, 6780, 6781, 6782, 6783, 6784, 6785, 6786, 6787, 6788, 6789, 6790, 6791, 6792, 6793, 6794, 6795, 6796, 6797, 6798, 6799, 6800, 6801, 6802, 6803, 6804, 6805, 6806, 6807, 6808, 6809, 6810, 6811, 6812, 6813, 6814, 6815, 6816, 6817, 6818, 6819, 6820, 6821, 6822, 6823, 6824, 6825, 6826, 6827, 6828, 6829, 6830, 6831, 6832, 6833, 6834, 6835, 6836, 6837, 6838, 6839, 6840, 6841, 6842, 6843, 6844, 6845, 6846, 6847, 6848, 6849, 6850, 6851, 6852, 6853, 6854, 6855, 6856, 6857, 6858, 6859, 6860, 6861, 6862, 6863, 6864, 6865, 6866, 6867, 6868, 6869, 6870, 6871, 6872, 6873, 6874, 6875, 6876, 6877, 6878, 6879, 6880, 6881, 6882, 6883, 6884, 6885, 6886, 6887, 6888, 6889, 6890, 6891, 6892, 6893, 6894, 6895, 6896, 6897, 6898, 6899, 6900, 6901, 6902, 6903, 6904, 6905, 6906, 6907, 6908, 6909, 6910, 6911, 6912, 6913, 6914, 6915, 6916, 6917, 6918, 6919, 6920, 6921, 6922, 6923, 6924, 6925, 6926, 6927, 6928, 6929, 6930, 6931, 6932, 6933, 6934, 6935, 6936, 6937, 6938, 6939, 6940, 6941, 6942, 6943, 6944, 6945, 6946, 6947, 6948, 6949, 6950, 6951, 6952, 6953, 6954, 6955, 6956, 6957, 6958, 6959, 6960, 6961, 6962, 6963, 6964, 6965, 6966, 6967, 6968, 6969, 6970, 6971, 6972, 6973, 6974, 6975, 6976, 6977, 6978, 6979, 6980, 6981, 6982, 6983, 6984, 6985, 6986, 6987, 6988, 6989, 6990, 6991, 6992, 6993, 6994, 6995, 6996, 6997, 6998, 6999, 7000, 7001, 7002, 7003, 7004, 7005, 7006, 7007, 7008, 7009, 7010, 7011, 7012, 7013, 7014, 7015, 7016, 7017, 7018, 7019, 7020, 7021, 7022, 7023, 7024, 7025, 7026, 7027, 7028, 7029, 7030, 7031, 7032, 7033, 7034, 7035, 7036, 7037, 7038, 7039, 7040, 7041, 7042, 7043, 7044, 7045, 7046, 7047, 7048, 7049, 7050, 7051, 7052, 7053, 7054, 7055, 7056, 7057, 7058, 7059, 7060, 7061, 7062, 7063, 7064, 7065, 7066, 7067, 7068, 7069, 7070, 7071, 7072, 7073, 7074, 7075, 7076, 7077, 7078, 7079, 7080, 7081, 7082, 7083, 7084, 7085, 7086, 7087, 7088, 7089, 7090, 7091, 7092, 7093, 7094, 7095, 7096, 7097, 7098, 7099, 7100, 7101, 7102, 7103, 7104, 7105, 7106, 7107, 7108, 7109, 7110, 7111, 7112, 7113, 7114, 7115, 7116, 7117, 7118, 7119, 7120, 7121, 7122, 7123, 7124, 7125, 7126, 7127, 7128, 7129, 7130, 7131, 7132, 7133, 7134, 7135, 7136, 7137, 7138, 7139, 7140, 7141, 7142, 7143, 7144, 7145, 7146, 7147, 7148, 7149, 7150, 7151, 7152, 7153, 7154, 7155, 7156, 7157, 7158, 7159, 7160, 7161, 7162, 7163, 7164, 7165, 7166, 7167, 7168, 7169, 7170, 7171, 7172, 7173, 7174, 7175, 7176, 7177, 7178, 7179, 7180, 7181, 7182, 7183, 7184, 7185, 7186, 7187, 7188, 7189, 7190, 7191, 7192, 7193, 7194, 7195, 7196, 7197, 7198, 7199, 7200, 7201, 7202, 7203, 7204, 7205, 7206, 7207, 7208, 7209, 7210, 7211, 7212, 7213, 7214, 7215, 7216, 7217, 7218, 7219, 7220, 7221, 7222, 7223, 7224, 7225, 7226, 7227, 7228, 7229, 7230, 7231, 7232, 7233, 7234, 7235, 7236, 7237, 7238, 7239, 7240, 7241, 7242, 7243, 7244, 7245, 7246, 7247, 7248, 7249, 7250, 7251, 7252, 7253, 7254, 7255, 7256, 7257, 7258, 7259, 7260, 7261, 7262, 7263, 7264, 7265, 7266, 7267, 7268, 7269, 7270, 7271, 7272, 7273, 7274, 7275, 7276, 7277, 7278, 7279, 7280, 7281, 7282, 7283, 7284, 7285, 7286, 7287, 7288, 7289, 7290, 7291, 7292, 7293, 7294, 7295, 7296, 7297, 7298, 7299, 7300, 7301, 7302, 7303, 7304, 7305, 7306, 7307, 7308, 7309, 7310, 7311, 7312, 7313, 7314, 7315, 7316, 7317, 7318, 7319, 7320, 7321, 7322, 7323, 7324, 7325, 7326, 7327, 7328, 7329, 7330, 7331, 7332, 7333, 7334, 7335, 7336, 7337, 7338, 7339, 7340, 7341, 7342, 7343, 7344, 7345, 7346, 7347, 7348, 7349, 7350, 7351, 7352, 7353, 7354, 7355, 7356, 7357, 7358, 7359, 7360, 7361, 7362, 7363, 7364, 7365, 7366, 7367, 7368, 7369, 7370, 7371, 7372, 7373, 7374, 7375, 7376, 7377, 7378, 7379, 7380, 7381, 7382, 7383, 7384, 7385, 7386, 7387, 7388, 7389, 7390, 7391, 7392, 7393, 7394, 7395, 7396, 7397, 7398, 7399, 7400, 7401, 7402, 7403, 7404, 7405, 7406, 7407, 7408, 7409, 7410, 7411, 7412, 7413, 7414, 7415, 7416, 7417, 7418, 7419, 7420, 7421, 7422, 7423, 7424, 7425, 7426, 7427, 7428, 7429, 7430, 7431, 7432, 7433, 7434, 7435, 7436, 7437, 7438, 7439, 7440, 7441, 7442, 7443, 7444, 7445, 7446, 7447, 7448, 7449, 7450, 7451, 7452, 7453, 7454, 7455, 7456, 7457, 7458, 7459, 7460, 7461, 7462, 7463, 7464, 7465, 7466, 7467, 7468, 7469, 7470, 7471, 7472, 7473, 7474, 7475, 7476, 7477, 7478, 7479, 7480, 7481, 7482, 7483, 7484, 7485, 7486, 7487, 7488, 7489, 7490, 7491, 7492, 7493, 7494, 7495, 7496, 7497, 7498, 7499, 7500, 7501, 7502, 7503, 7504, 7505, 7506, 7507, 7508, 7509, 7510, 7511, 7512, 7513, 7514, 7515, 7516, 7517, 7518, 7519, 7520, 7521, 7522, 7523, 7524, 7525, 7526, 7527, 7528, 7529, 7530, 7531, 7532, 7533, 7534, 7535, 7536, 7537, 7538, 7539, 7540, 7541, 7542, 7543, 7544, 7545, 7546, 7547, 7548, 7549, 7550, 7551, 7552, 7553, 7554, 7555, 7556, 7557, 7558, 7559, 7560, 7561, 7562, 7563, 7564, 7565, 7566, 7567, 7568, 7569, 7570, 7571, 7572, 7573, 7574, 7575, 7576, 7577, 7578, 7579, 7580, 7581, 7582, 7583, 7584, 7585, 7586, 7587, 7588, 7589, 7590, 7591, 7592, 7593, 7594, 7595, 7596, 7597, 7598, 7599, 7600, 7601, 7602, 7603, 7604, 7605, 7606, 7607, 7608, 7609, 7610, 7611, 7612, 7613, 7614, 7615, 7616, 7617, 7618, 7619, 7620, 7621, 7622, 7623, 7624, 7625, 7626, 7627, 7628, 7629, 7630, 7631, 7632, 7633, 7634, 7635, 7636, 7637, 7638, 7639, 7640, 7641, 7642, 7643, 7644, 7645, 7646, 7647, 7648, 7649, 7650, 7651, 7652, 7653, 7654, 7655, 7656, 7657, 7658, 7659, 7660, 7661, 7662, 7663, 7664, 7665, 7666, 7667, 7668, 7669, 7670, 7671, 7672, 7673, 7674, 7675, 7676, 7677, 7678, 7679, 7680, 7681, 7682, 7683, 7684, 7685, 7686, 7687, 7688, 7689, 7690, 7691, 7692, 7693, 7694, 7695, 7696, 7697, 7698, 7699, 7700, 7701, 7702, 7703, 7704, 7705, 7706, 7707, 7708, 7709, 7710, 7711, 7712, 7713, 7714, 7715, 7716, 7717, 7718, 7719, 7720, 7721, 7722, 7723, 7724, 7725, 7726, 7727, 7728, 7729, 7730, 7731, 7732, 7733, 7734, 7735, 7736, 7737, 7738, 7739, 7740, 7741, 7742, 7743, 7744, 7745, 7746, 7747, 7748, 7749, 7750, 7751, 7752, 7753, 7754, 7755, 7756, 7757, 7758, 7759, 7760, 7761, 7762, 7763, 7764, 7765, 7766, 7767, 7768, 7769, 7770, 7771, 7772, 7773, 7774, 7775, 7776, 7777, 7778, 7779, 7780, 7781, 7782, 7783, 7784, 7785, 7786, 7787, 7788, 7789, 7790, 7791, 7792, 7793, 7794, 7795, 7796, 7797, 7798, 7799, 7800, 7801, 7802, 7803, 7804, 7805, 7806, 7807, 7808, 7809, 7810, 7811, 7812, 7813, 7814, 7815, 7816, 7817, 7818, 7819, 7820, 7821, 7822, 7823, 7824, 7825, 7826, 7827, 7828, 7829, 7830, 7831, 7832, 7833, 7834, 7835, 7836, 7837, 7838, 7839, 7840, 7841, 7842, 7843, 7844, 7845, 7846, 7847, 7848, 7849, 7850, 7851, 7852, 7853, 7854, 7855, 7856, 7857, 7858, 7859, 7860, 7861, 7862, 7863, 7864, 7865, 7866, 7867, 7868, 7869, 7870, 7871, 7872, 7873, 7874, 7875, 7876, 7877, 7878, 7879, 7880, 7881, 7882, 7883, 7884, 7885, 7886, 7887, 7888, 7889, 7890, 7891, 7892, 7893, 7894, 7895, 7896, 7897, 7898, 7899, 7900, 7901, 7902, 7903, 7904, 7905, 7906, 7907, 7908, 7909, 7910, 7911, 7912, 7913, 7914, 7915, 7916, 7917, 7918, 7919, 7920, 7921, 7922, 7923, 7924, 7925, 7926, 7927, 7928, 7929, 7930, 7931, 7932, 7933, 7934, 7935, 7936, 7937, 7938, 7939, 7940, 7941, 7942, 7943, 7944, 7945, 7946, 7947, 7948, 7949, 7950, 7951, 7952, 7953, 7954, 7955, 7956, 7957, 7958, 7959, 7960, 7961, 7962, 7963, 7964, 7965, 7966, 7967, 7968, 7969, 7970, 7971, 7972, 7973, 7974, 7975, 7976, 7977, 7978, 7979, 7980, 7981, 7982, 7983, 7984, 7985, 7986, 7987, 7988, 7989, 7990, 7991, 7992, 7993, 7994, 7995, 7996, 7997, 7998, 7999, 8000, 8001, 8002, 8003, 8004, 8005, 8006, 8007, 8008, 8009, 8010, 8011, 8012, 8013, 8014, 8015, 8016, 8017, 8018, 8019, 8020, 8021, 8022, 8023, 8024, 8025, 8026, 8027, 8028, 8029, 8030, 8031, 8032, 8033, 8034, 8035, 8036, 8037, 8038, 8039, 8040, 8041, 8042, 8043, 8044, 8045, 8046, 8047, 8048, 8049, 8050, 8051, 8052, 8053, 8054, 8055, 8056, 8057, 8058, 8059, 8060, 8061, 8062, 8063, 8064, 8065, 8066, 8067, 8068, 8069, 8070, 8071, 8072, 8073, 8074, 8075, 8076, 8077, 8078, 8079, 8080, 8081, 8082, 8083, 8084, 8085, 8086, 8087, 8088, 8089, 8090, 8091, 8092, 8093, 8094, 8095, 8096, 8097, 8098, 8099, 8100, 8101, 8102, 8103, 8104, 8105, 8106, 8107, 8108, 8109, 8110, 8111, 8112, 8113, 8114, 8115, 8116, 8117, 8118, 8119, 8120, 8121, 8122, 8123, 8124, 8125, 8126, 8127, 8128, 8129, 8130, 8131, 8132, 8133, 8134, 8135, 8136, 8137, 8138, 8139, 8140, 8141, 8142, 8143, 8144, 8145, 8146, 8147, 8148, 8149, 8150, 8151, 8152, 8153, 8154, 8155, 8156, 8157, 8158, 8159, 8160, 8161, 8162, 8163, 8164, 8165, 8166, 8167, 8168, 8169, 8170, 8171, 8172, 8173, 8174, 8175, 8176, 8177, 8178, 8179, 8180, 8181, 8182, 8183, 8184, 8185, 8186, 8187, 8188, 8189, 8190, 8191, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8203, 8204, 8205, 8206, 8207, 8208, 8209, 8210, 8211, 8212, 8213, 8214, 8215, 8216, 8217, 8218, 8219, 8220, 8221, 8222, 8223, 8224, 8225, 8226, 8227, 8228, 8229, 8230, 8231, 8232, 8233, 8234, 8235, 8236, 8237, 8238, 8239, 8240, 8241, 8242, 8243, 8244, 8245, 8246, 8247, 8248, 8249, 8250, 8251, 8252, 8253, 8254, 8255, 8256, 8257, 8258, 8259, 8260, 8261, 8262, 8263, 8264, 8265, 8266, 8267, 8268, 8269, 8270, 8271, 8272, 8273, 8274, 8275, 8276, 8277, 8278, 8279, 8280, 8281, 8282, 8283, 8284, 8285, 8286, 8287, 8288, 8289, 8290, 8291, 8292, 8293, 8294, 8295, 8296, 8297, 8298, 8299, 8300, 8301, 8302, 8303, 8304, 8305, 8306, 8307, 8308, 8309, 8310, 8311, 8312, 8313, 8314, 8315, 8316, 8317, 8318, 8319, 8320, 8321, 8322, 8323, 8324, 8325, 8326, 8327, 8328, 8329, 8330, 8331, 8332, 8333, 8334, 8335, 8336, 8337, 8338, 8339, 8340, 8341, 8342, 8343, 8344, 8345, 8346, 8347, 8348, 8349, 8350, 8351, 8352, 8353, 8354, 8355, 8356, 8357, 8358, 8359, 8360, 8361, 8362, 8363, 8364, 8365, 8366, 8367, 8368, 8369, 8370, 8371, 8372, 8373, 8374, 8375, 8376, 8377, 8378, 8379, 8380, 8381, 8382, 8383, 8384, 8385, 8386, 8387, 8388, 8389, 8390, 8391, 8392, 8393, 8394, 8395, 8396, 8397, 8398, 8399, 8400, 8401, 8402, 8403, 8404, 8405, 8406, 8407, 8408, 8409, 8410, 8411, 8412, 8413, 8414, 8415, 8416, 8417, 8418, 8419, 8420, 8421, 8422, 8423, 8424, 8425, 8426, 8427, 8428, 8429, 8430, 8431, 8432, 8433, 8434, 8435, 8436, 8437, 8438, 8439, 8440, 8441, 8442, 8443, 8444, 8445, 8446, 8447, 8448, 8449, 8450, 8451, 8452, 8453, 8454, 8455, 8456, 8457, 8458, 8459, 8460, 8461, 8462, 8463, 8464, 8465, 8466, 8467, 8468, 8469, 8470, 8471, 8472, 8473, 8474, 8475, 8476, 8477, 8478, 8479, 8480, 8481, 8482, 8483, 8484, 8485, 8486, 8487, 8488, 8489, 8490, 8491, 8492, 8493, 8494, 8495, 8496, 8497, 8498, 8499, 8500, 8501, 8502, 8503, 8504, 8505, 8506, 8507, 8508, 8509, 8510, 8511, 8512, 8513, 8514, 8515, 8516, 8517, 8518, 8519, 8520, 8521, 8522, 8523, 8524, 8525, 8526, 8527, 8528, 8529, 8530, 8531, 8532, 8533, 8534, 8535, 8536, 8537, 8538, 8539, 8540, 8541, 8542, 8543, 8544, 8545, 8546, 8547, 8548, 8549, 8550, 8551, 8552, 8553, 8554, 8555, 8556, 8557, 8558, 8559, 8560, 8561, 8562, 8563, 8564, 8565, 8566, 8567, 8568, 8569, 8570, 8571, 8572, 8573, 8574, 8575, 8576, 8577, 8578, 8579, 8580, 8581, 8582, 8583, 8584, 8585, 8586, 8587, 8588, 8589, 8590, 8591, 8592, 8593, 8594, 8595, 8596, 8597, 8598, 8599, 8600, 8601, 8602, 8603, 8604, 8605, 8606, 8607, 8608, 8609, 8610, 8611, 8612, 8613, 8614, 8615, 8616, default */
/***/ (function(module) {

module.exports = ["ac","com.ac","edu.ac","gov.ac","net.ac","mil.ac","org.ac","ad","nom.ad","ae","co.ae","net.ae","org.ae","sch.ae","ac.ae","gov.ae","mil.ae","aero","accident-investigation.aero","accident-prevention.aero","aerobatic.aero","aeroclub.aero","aerodrome.aero","agents.aero","aircraft.aero","airline.aero","airport.aero","air-surveillance.aero","airtraffic.aero","air-traffic-control.aero","ambulance.aero","amusement.aero","association.aero","author.aero","ballooning.aero","broker.aero","caa.aero","cargo.aero","catering.aero","certification.aero","championship.aero","charter.aero","civilaviation.aero","club.aero","conference.aero","consultant.aero","consulting.aero","control.aero","council.aero","crew.aero","design.aero","dgca.aero","educator.aero","emergency.aero","engine.aero","engineer.aero","entertainment.aero","equipment.aero","exchange.aero","express.aero","federation.aero","flight.aero","freight.aero","fuel.aero","gliding.aero","government.aero","groundhandling.aero","group.aero","hanggliding.aero","homebuilt.aero","insurance.aero","journal.aero","journalist.aero","leasing.aero","logistics.aero","magazine.aero","maintenance.aero","media.aero","microlight.aero","modelling.aero","navigation.aero","parachuting.aero","paragliding.aero","passenger-association.aero","pilot.aero","press.aero","production.aero","recreation.aero","repbody.aero","res.aero","research.aero","rotorcraft.aero","safety.aero","scientist.aero","services.aero","show.aero","skydiving.aero","software.aero","student.aero","trader.aero","trading.aero","trainer.aero","union.aero","workinggroup.aero","works.aero","af","gov.af","com.af","org.af","net.af","edu.af","ag","com.ag","org.ag","net.ag","co.ag","nom.ag","ai","off.ai","com.ai","net.ai","org.ai","al","com.al","edu.al","gov.al","mil.al","net.al","org.al","am","ao","ed.ao","gv.ao","og.ao","co.ao","pb.ao","it.ao","aq","ar","com.ar","edu.ar","gob.ar","gov.ar","int.ar","mil.ar","musica.ar","net.ar","org.ar","tur.ar","arpa","e164.arpa","in-addr.arpa","ip6.arpa","iris.arpa","uri.arpa","urn.arpa","as","gov.as","asia","at","ac.at","co.at","gv.at","or.at","au","com.au","net.au","org.au","edu.au","gov.au","asn.au","id.au","info.au","conf.au","oz.au","act.au","nsw.au","nt.au","qld.au","sa.au","tas.au","vic.au","wa.au","act.edu.au","nsw.edu.au","nt.edu.au","qld.edu.au","sa.edu.au","tas.edu.au","vic.edu.au","wa.edu.au","qld.gov.au","sa.gov.au","tas.gov.au","vic.gov.au","wa.gov.au","aw","com.aw","ax","az","com.az","net.az","int.az","gov.az","org.az","edu.az","info.az","pp.az","mil.az","name.az","pro.az","biz.az","ba","com.ba","edu.ba","gov.ba","mil.ba","net.ba","org.ba","bb","biz.bb","co.bb","com.bb","edu.bb","gov.bb","info.bb","net.bb","org.bb","store.bb","tv.bb","*.bd","be","ac.be","bf","gov.bf","bg","a.bg","b.bg","c.bg","d.bg","e.bg","f.bg","g.bg","h.bg","i.bg","j.bg","k.bg","l.bg","m.bg","n.bg","o.bg","p.bg","q.bg","r.bg","s.bg","t.bg","u.bg","v.bg","w.bg","x.bg","y.bg","z.bg","0.bg","1.bg","2.bg","3.bg","4.bg","5.bg","6.bg","7.bg","8.bg","9.bg","bh","com.bh","edu.bh","net.bh","org.bh","gov.bh","bi","co.bi","com.bi","edu.bi","or.bi","org.bi","biz","bj","asso.bj","barreau.bj","gouv.bj","bm","com.bm","edu.bm","gov.bm","net.bm","org.bm","bn","com.bn","edu.bn","gov.bn","net.bn","org.bn","bo","com.bo","edu.bo","gob.bo","int.bo","org.bo","net.bo","mil.bo","tv.bo","web.bo","academia.bo","agro.bo","arte.bo","blog.bo","bolivia.bo","ciencia.bo","cooperativa.bo","democracia.bo","deporte.bo","ecologia.bo","economia.bo","empresa.bo","indigena.bo","industria.bo","info.bo","medicina.bo","movimiento.bo","musica.bo","natural.bo","nombre.bo","noticias.bo","patria.bo","politica.bo","profesional.bo","plurinacional.bo","pueblo.bo","revista.bo","salud.bo","tecnologia.bo","tksat.bo","transporte.bo","wiki.bo","br","9guacu.br","abc.br","adm.br","adv.br","agr.br","aju.br","am.br","anani.br","aparecida.br","arq.br","art.br","ato.br","b.br","barueri.br","belem.br","bhz.br","bio.br","blog.br","bmd.br","boavista.br","bsb.br","campinagrande.br","campinas.br","caxias.br","cim.br","cng.br","cnt.br","com.br","contagem.br","coop.br","cri.br","cuiaba.br","curitiba.br","def.br","ecn.br","eco.br","edu.br","emp.br","eng.br","esp.br","etc.br","eti.br","far.br","feira.br","flog.br","floripa.br","fm.br","fnd.br","fortal.br","fot.br","foz.br","fst.br","g12.br","ggf.br","goiania.br","gov.br","ac.gov.br","al.gov.br","am.gov.br","ap.gov.br","ba.gov.br","ce.gov.br","df.gov.br","es.gov.br","go.gov.br","ma.gov.br","mg.gov.br","ms.gov.br","mt.gov.br","pa.gov.br","pb.gov.br","pe.gov.br","pi.gov.br","pr.gov.br","rj.gov.br","rn.gov.br","ro.gov.br","rr.gov.br","rs.gov.br","sc.gov.br","se.gov.br","sp.gov.br","to.gov.br","gru.br","imb.br","ind.br","inf.br","jab.br","jampa.br","jdf.br","joinville.br","jor.br","jus.br","leg.br","lel.br","londrina.br","macapa.br","maceio.br","manaus.br","maringa.br","mat.br","med.br","mil.br","morena.br","mp.br","mus.br","natal.br","net.br","niteroi.br","*.nom.br","not.br","ntr.br","odo.br","ong.br","org.br","osasco.br","palmas.br","poa.br","ppg.br","pro.br","psc.br","psi.br","pvh.br","qsl.br","radio.br","rec.br","recife.br","ribeirao.br","rio.br","riobranco.br","riopreto.br","salvador.br","sampa.br","santamaria.br","santoandre.br","saobernardo.br","saogonca.br","sjc.br","slg.br","slz.br","sorocaba.br","srv.br","taxi.br","teo.br","the.br","tmp.br","trd.br","tur.br","tv.br","udi.br","vet.br","vix.br","vlog.br","wiki.br","zlg.br","bs","com.bs","net.bs","org.bs","edu.bs","gov.bs","bt","com.bt","edu.bt","gov.bt","net.bt","org.bt","bv","bw","co.bw","org.bw","by","gov.by","mil.by","com.by","of.by","bz","com.bz","net.bz","org.bz","edu.bz","gov.bz","ca","ab.ca","bc.ca","mb.ca","nb.ca","nf.ca","nl.ca","ns.ca","nt.ca","nu.ca","on.ca","pe.ca","qc.ca","sk.ca","yk.ca","gc.ca","cat","cc","cd","gov.cd","cf","cg","ch","ci","org.ci","or.ci","com.ci","co.ci","edu.ci","ed.ci","ac.ci","net.ci","go.ci","asso.ci","aéroport.ci","int.ci","presse.ci","md.ci","gouv.ci","*.ck","!www.ck","cl","gov.cl","gob.cl","co.cl","mil.cl","cm","co.cm","com.cm","gov.cm","net.cm","cn","ac.cn","com.cn","edu.cn","gov.cn","net.cn","org.cn","mil.cn","公司.cn","网络.cn","網絡.cn","ah.cn","bj.cn","cq.cn","fj.cn","gd.cn","gs.cn","gz.cn","gx.cn","ha.cn","hb.cn","he.cn","hi.cn","hl.cn","hn.cn","jl.cn","js.cn","jx.cn","ln.cn","nm.cn","nx.cn","qh.cn","sc.cn","sd.cn","sh.cn","sn.cn","sx.cn","tj.cn","xj.cn","xz.cn","yn.cn","zj.cn","hk.cn","mo.cn","tw.cn","co","arts.co","com.co","edu.co","firm.co","gov.co","info.co","int.co","mil.co","net.co","nom.co","org.co","rec.co","web.co","com","coop","cr","ac.cr","co.cr","ed.cr","fi.cr","go.cr","or.cr","sa.cr","cu","com.cu","edu.cu","org.cu","net.cu","gov.cu","inf.cu","cv","cw","com.cw","edu.cw","net.cw","org.cw","cx","gov.cx","cy","ac.cy","biz.cy","com.cy","ekloges.cy","gov.cy","ltd.cy","name.cy","net.cy","org.cy","parliament.cy","press.cy","pro.cy","tm.cy","cz","de","dj","dk","dm","com.dm","net.dm","org.dm","edu.dm","gov.dm","do","art.do","com.do","edu.do","gob.do","gov.do","mil.do","net.do","org.do","sld.do","web.do","dz","com.dz","org.dz","net.dz","gov.dz","edu.dz","asso.dz","pol.dz","art.dz","ec","com.ec","info.ec","net.ec","fin.ec","k12.ec","med.ec","pro.ec","org.ec","edu.ec","gov.ec","gob.ec","mil.ec","edu","ee","edu.ee","gov.ee","riik.ee","lib.ee","med.ee","com.ee","pri.ee","aip.ee","org.ee","fie.ee","eg","com.eg","edu.eg","eun.eg","gov.eg","mil.eg","name.eg","net.eg","org.eg","sci.eg","*.er","es","com.es","nom.es","org.es","gob.es","edu.es","et","com.et","gov.et","org.et","edu.et","biz.et","name.et","info.et","net.et","eu","fi","aland.fi","*.fj","*.fk","fm","fo","fr","com.fr","asso.fr","nom.fr","prd.fr","presse.fr","tm.fr","aeroport.fr","assedic.fr","avocat.fr","avoues.fr","cci.fr","chambagri.fr","chirurgiens-dentistes.fr","experts-comptables.fr","geometre-expert.fr","gouv.fr","greta.fr","huissier-justice.fr","medecin.fr","notaires.fr","pharmacien.fr","port.fr","veterinaire.fr","ga","gb","gd","ge","com.ge","edu.ge","gov.ge","org.ge","mil.ge","net.ge","pvt.ge","gf","gg","co.gg","net.gg","org.gg","gh","com.gh","edu.gh","gov.gh","org.gh","mil.gh","gi","com.gi","ltd.gi","gov.gi","mod.gi","edu.gi","org.gi","gl","co.gl","com.gl","edu.gl","net.gl","org.gl","gm","gn","ac.gn","com.gn","edu.gn","gov.gn","org.gn","net.gn","gov","gp","com.gp","net.gp","mobi.gp","edu.gp","org.gp","asso.gp","gq","gr","com.gr","edu.gr","net.gr","org.gr","gov.gr","gs","gt","com.gt","edu.gt","gob.gt","ind.gt","mil.gt","net.gt","org.gt","gu","com.gu","edu.gu","gov.gu","guam.gu","info.gu","net.gu","org.gu","web.gu","gw","gy","co.gy","com.gy","edu.gy","gov.gy","net.gy","org.gy","hk","com.hk","edu.hk","gov.hk","idv.hk","net.hk","org.hk","公司.hk","教育.hk","敎育.hk","政府.hk","個人.hk","个人.hk","箇人.hk","網络.hk","网络.hk","组織.hk","網絡.hk","网絡.hk","组织.hk","組織.hk","組织.hk","hm","hn","com.hn","edu.hn","org.hn","net.hn","mil.hn","gob.hn","hr","iz.hr","from.hr","name.hr","com.hr","ht","com.ht","shop.ht","firm.ht","info.ht","adult.ht","net.ht","pro.ht","org.ht","med.ht","art.ht","coop.ht","pol.ht","asso.ht","edu.ht","rel.ht","gouv.ht","perso.ht","hu","co.hu","info.hu","org.hu","priv.hu","sport.hu","tm.hu","2000.hu","agrar.hu","bolt.hu","casino.hu","city.hu","erotica.hu","erotika.hu","film.hu","forum.hu","games.hu","hotel.hu","ingatlan.hu","jogasz.hu","konyvelo.hu","lakas.hu","media.hu","news.hu","reklam.hu","sex.hu","shop.hu","suli.hu","szex.hu","tozsde.hu","utazas.hu","video.hu","id","ac.id","biz.id","co.id","desa.id","go.id","mil.id","my.id","net.id","or.id","ponpes.id","sch.id","web.id","ie","gov.ie","il","ac.il","co.il","gov.il","idf.il","k12.il","muni.il","net.il","org.il","im","ac.im","co.im","com.im","ltd.co.im","net.im","org.im","plc.co.im","tt.im","tv.im","in","co.in","firm.in","net.in","org.in","gen.in","ind.in","nic.in","ac.in","edu.in","res.in","gov.in","mil.in","info","int","eu.int","io","com.io","iq","gov.iq","edu.iq","mil.iq","com.iq","org.iq","net.iq","ir","ac.ir","co.ir","gov.ir","id.ir","net.ir","org.ir","sch.ir","ایران.ir","ايران.ir","is","net.is","com.is","edu.is","gov.is","org.is","int.is","it","gov.it","edu.it","abr.it","abruzzo.it","aosta-valley.it","aostavalley.it","bas.it","basilicata.it","cal.it","calabria.it","cam.it","campania.it","emilia-romagna.it","emiliaromagna.it","emr.it","friuli-v-giulia.it","friuli-ve-giulia.it","friuli-vegiulia.it","friuli-venezia-giulia.it","friuli-veneziagiulia.it","friuli-vgiulia.it","friuliv-giulia.it","friulive-giulia.it","friulivegiulia.it","friulivenezia-giulia.it","friuliveneziagiulia.it","friulivgiulia.it","fvg.it","laz.it","lazio.it","lig.it","liguria.it","lom.it","lombardia.it","lombardy.it","lucania.it","mar.it","marche.it","mol.it","molise.it","piedmont.it","piemonte.it","pmn.it","pug.it","puglia.it","sar.it","sardegna.it","sardinia.it","sic.it","sicilia.it","sicily.it","taa.it","tos.it","toscana.it","trentin-sud-tirol.it","trentin-süd-tirol.it","trentin-sudtirol.it","trentin-südtirol.it","trentin-sued-tirol.it","trentin-suedtirol.it","trentino-a-adige.it","trentino-aadige.it","trentino-alto-adige.it","trentino-altoadige.it","trentino-s-tirol.it","trentino-stirol.it","trentino-sud-tirol.it","trentino-süd-tirol.it","trentino-sudtirol.it","trentino-südtirol.it","trentino-sued-tirol.it","trentino-suedtirol.it","trentino.it","trentinoa-adige.it","trentinoaadige.it","trentinoalto-adige.it","trentinoaltoadige.it","trentinos-tirol.it","trentinostirol.it","trentinosud-tirol.it","trentinosüd-tirol.it","trentinosudtirol.it","trentinosüdtirol.it","trentinosued-tirol.it","trentinosuedtirol.it","trentinsud-tirol.it","trentinsüd-tirol.it","trentinsudtirol.it","trentinsüdtirol.it","trentinsued-tirol.it","trentinsuedtirol.it","tuscany.it","umb.it","umbria.it","val-d-aosta.it","val-daosta.it","vald-aosta.it","valdaosta.it","valle-aosta.it","valle-d-aosta.it","valle-daosta.it","valleaosta.it","valled-aosta.it","valledaosta.it","vallee-aoste.it","vallée-aoste.it","vallee-d-aoste.it","vallée-d-aoste.it","valleeaoste.it","valléeaoste.it","valleedaoste.it","valléedaoste.it","vao.it","vda.it","ven.it","veneto.it","ag.it","agrigento.it","al.it","alessandria.it","alto-adige.it","altoadige.it","an.it","ancona.it","andria-barletta-trani.it","andria-trani-barletta.it","andriabarlettatrani.it","andriatranibarletta.it","ao.it","aosta.it","aoste.it","ap.it","aq.it","aquila.it","ar.it","arezzo.it","ascoli-piceno.it","ascolipiceno.it","asti.it","at.it","av.it","avellino.it","ba.it","balsan-sudtirol.it","balsan-südtirol.it","balsan-suedtirol.it","balsan.it","bari.it","barletta-trani-andria.it","barlettatraniandria.it","belluno.it","benevento.it","bergamo.it","bg.it","bi.it","biella.it","bl.it","bn.it","bo.it","bologna.it","bolzano-altoadige.it","bolzano.it","bozen-sudtirol.it","bozen-südtirol.it","bozen-suedtirol.it","bozen.it","br.it","brescia.it","brindisi.it","bs.it","bt.it","bulsan-sudtirol.it","bulsan-südtirol.it","bulsan-suedtirol.it","bulsan.it","bz.it","ca.it","cagliari.it","caltanissetta.it","campidano-medio.it","campidanomedio.it","campobasso.it","carbonia-iglesias.it","carboniaiglesias.it","carrara-massa.it","carraramassa.it","caserta.it","catania.it","catanzaro.it","cb.it","ce.it","cesena-forli.it","cesena-forlì.it","cesenaforli.it","cesenaforlì.it","ch.it","chieti.it","ci.it","cl.it","cn.it","co.it","como.it","cosenza.it","cr.it","cremona.it","crotone.it","cs.it","ct.it","cuneo.it","cz.it","dell-ogliastra.it","dellogliastra.it","en.it","enna.it","fc.it","fe.it","fermo.it","ferrara.it","fg.it","fi.it","firenze.it","florence.it","fm.it","foggia.it","forli-cesena.it","forlì-cesena.it","forlicesena.it","forlìcesena.it","fr.it","frosinone.it","ge.it","genoa.it","genova.it","go.it","gorizia.it","gr.it","grosseto.it","iglesias-carbonia.it","iglesiascarbonia.it","im.it","imperia.it","is.it","isernia.it","kr.it","la-spezia.it","laquila.it","laspezia.it","latina.it","lc.it","le.it","lecce.it","lecco.it","li.it","livorno.it","lo.it","lodi.it","lt.it","lu.it","lucca.it","macerata.it","mantova.it","massa-carrara.it","massacarrara.it","matera.it","mb.it","mc.it","me.it","medio-campidano.it","mediocampidano.it","messina.it","mi.it","milan.it","milano.it","mn.it","mo.it","modena.it","monza-brianza.it","monza-e-della-brianza.it","monza.it","monzabrianza.it","monzaebrianza.it","monzaedellabrianza.it","ms.it","mt.it","na.it","naples.it","napoli.it","no.it","novara.it","nu.it","nuoro.it","og.it","ogliastra.it","olbia-tempio.it","olbiatempio.it","or.it","oristano.it","ot.it","pa.it","padova.it","padua.it","palermo.it","parma.it","pavia.it","pc.it","pd.it","pe.it","perugia.it","pesaro-urbino.it","pesarourbino.it","pescara.it","pg.it","pi.it","piacenza.it","pisa.it","pistoia.it","pn.it","po.it","pordenone.it","potenza.it","pr.it","prato.it","pt.it","pu.it","pv.it","pz.it","ra.it","ragusa.it","ravenna.it","rc.it","re.it","reggio-calabria.it","reggio-emilia.it","reggiocalabria.it","reggioemilia.it","rg.it","ri.it","rieti.it","rimini.it","rm.it","rn.it","ro.it","roma.it","rome.it","rovigo.it","sa.it","salerno.it","sassari.it","savona.it","si.it","siena.it","siracusa.it","so.it","sondrio.it","sp.it","sr.it","ss.it","suedtirol.it","südtirol.it","sv.it","ta.it","taranto.it","te.it","tempio-olbia.it","tempioolbia.it","teramo.it","terni.it","tn.it","to.it","torino.it","tp.it","tr.it","trani-andria-barletta.it","trani-barletta-andria.it","traniandriabarletta.it","tranibarlettaandria.it","trapani.it","trento.it","treviso.it","trieste.it","ts.it","turin.it","tv.it","ud.it","udine.it","urbino-pesaro.it","urbinopesaro.it","va.it","varese.it","vb.it","vc.it","ve.it","venezia.it","venice.it","verbania.it","vercelli.it","verona.it","vi.it","vibo-valentia.it","vibovalentia.it","vicenza.it","viterbo.it","vr.it","vs.it","vt.it","vv.it","je","co.je","net.je","org.je","*.jm","jo","com.jo","org.jo","net.jo","edu.jo","sch.jo","gov.jo","mil.jo","name.jo","jobs","jp","ac.jp","ad.jp","co.jp","ed.jp","go.jp","gr.jp","lg.jp","ne.jp","or.jp","aichi.jp","akita.jp","aomori.jp","chiba.jp","ehime.jp","fukui.jp","fukuoka.jp","fukushima.jp","gifu.jp","gunma.jp","hiroshima.jp","hokkaido.jp","hyogo.jp","ibaraki.jp","ishikawa.jp","iwate.jp","kagawa.jp","kagoshima.jp","kanagawa.jp","kochi.jp","kumamoto.jp","kyoto.jp","mie.jp","miyagi.jp","miyazaki.jp","nagano.jp","nagasaki.jp","nara.jp","niigata.jp","oita.jp","okayama.jp","okinawa.jp","osaka.jp","saga.jp","saitama.jp","shiga.jp","shimane.jp","shizuoka.jp","tochigi.jp","tokushima.jp","tokyo.jp","tottori.jp","toyama.jp","wakayama.jp","yamagata.jp","yamaguchi.jp","yamanashi.jp","栃木.jp","愛知.jp","愛媛.jp","兵庫.jp","熊本.jp","茨城.jp","北海道.jp","千葉.jp","和歌山.jp","長崎.jp","長野.jp","新潟.jp","青森.jp","静岡.jp","東京.jp","石川.jp","埼玉.jp","三重.jp","京都.jp","佐賀.jp","大分.jp","大阪.jp","奈良.jp","宮城.jp","宮崎.jp","富山.jp","山口.jp","山形.jp","山梨.jp","岩手.jp","岐阜.jp","岡山.jp","島根.jp","広島.jp","徳島.jp","沖縄.jp","滋賀.jp","神奈川.jp","福井.jp","福岡.jp","福島.jp","秋田.jp","群馬.jp","香川.jp","高知.jp","鳥取.jp","鹿児島.jp","*.kawasaki.jp","*.kitakyushu.jp","*.kobe.jp","*.nagoya.jp","*.sapporo.jp","*.sendai.jp","*.yokohama.jp","!city.kawasaki.jp","!city.kitakyushu.jp","!city.kobe.jp","!city.nagoya.jp","!city.sapporo.jp","!city.sendai.jp","!city.yokohama.jp","aisai.aichi.jp","ama.aichi.jp","anjo.aichi.jp","asuke.aichi.jp","chiryu.aichi.jp","chita.aichi.jp","fuso.aichi.jp","gamagori.aichi.jp","handa.aichi.jp","hazu.aichi.jp","hekinan.aichi.jp","higashiura.aichi.jp","ichinomiya.aichi.jp","inazawa.aichi.jp","inuyama.aichi.jp","isshiki.aichi.jp","iwakura.aichi.jp","kanie.aichi.jp","kariya.aichi.jp","kasugai.aichi.jp","kira.aichi.jp","kiyosu.aichi.jp","komaki.aichi.jp","konan.aichi.jp","kota.aichi.jp","mihama.aichi.jp","miyoshi.aichi.jp","nishio.aichi.jp","nisshin.aichi.jp","obu.aichi.jp","oguchi.aichi.jp","oharu.aichi.jp","okazaki.aichi.jp","owariasahi.aichi.jp","seto.aichi.jp","shikatsu.aichi.jp","shinshiro.aichi.jp","shitara.aichi.jp","tahara.aichi.jp","takahama.aichi.jp","tobishima.aichi.jp","toei.aichi.jp","togo.aichi.jp","tokai.aichi.jp","tokoname.aichi.jp","toyoake.aichi.jp","toyohashi.aichi.jp","toyokawa.aichi.jp","toyone.aichi.jp","toyota.aichi.jp","tsushima.aichi.jp","yatomi.aichi.jp","akita.akita.jp","daisen.akita.jp","fujisato.akita.jp","gojome.akita.jp","hachirogata.akita.jp","happou.akita.jp","higashinaruse.akita.jp","honjo.akita.jp","honjyo.akita.jp","ikawa.akita.jp","kamikoani.akita.jp","kamioka.akita.jp","katagami.akita.jp","kazuno.akita.jp","kitaakita.akita.jp","kosaka.akita.jp","kyowa.akita.jp","misato.akita.jp","mitane.akita.jp","moriyoshi.akita.jp","nikaho.akita.jp","noshiro.akita.jp","odate.akita.jp","oga.akita.jp","ogata.akita.jp","semboku.akita.jp","yokote.akita.jp","yurihonjo.akita.jp","aomori.aomori.jp","gonohe.aomori.jp","hachinohe.aomori.jp","hashikami.aomori.jp","hiranai.aomori.jp","hirosaki.aomori.jp","itayanagi.aomori.jp","kuroishi.aomori.jp","misawa.aomori.jp","mutsu.aomori.jp","nakadomari.aomori.jp","noheji.aomori.jp","oirase.aomori.jp","owani.aomori.jp","rokunohe.aomori.jp","sannohe.aomori.jp","shichinohe.aomori.jp","shingo.aomori.jp","takko.aomori.jp","towada.aomori.jp","tsugaru.aomori.jp","tsuruta.aomori.jp","abiko.chiba.jp","asahi.chiba.jp","chonan.chiba.jp","chosei.chiba.jp","choshi.chiba.jp","chuo.chiba.jp","funabashi.chiba.jp","futtsu.chiba.jp","hanamigawa.chiba.jp","ichihara.chiba.jp","ichikawa.chiba.jp","ichinomiya.chiba.jp","inzai.chiba.jp","isumi.chiba.jp","kamagaya.chiba.jp","kamogawa.chiba.jp","kashiwa.chiba.jp","katori.chiba.jp","katsuura.chiba.jp","kimitsu.chiba.jp","kisarazu.chiba.jp","kozaki.chiba.jp","kujukuri.chiba.jp","kyonan.chiba.jp","matsudo.chiba.jp","midori.chiba.jp","mihama.chiba.jp","minamiboso.chiba.jp","mobara.chiba.jp","mutsuzawa.chiba.jp","nagara.chiba.jp","nagareyama.chiba.jp","narashino.chiba.jp","narita.chiba.jp","noda.chiba.jp","oamishirasato.chiba.jp","omigawa.chiba.jp","onjuku.chiba.jp","otaki.chiba.jp","sakae.chiba.jp","sakura.chiba.jp","shimofusa.chiba.jp","shirako.chiba.jp","shiroi.chiba.jp","shisui.chiba.jp","sodegaura.chiba.jp","sosa.chiba.jp","tako.chiba.jp","tateyama.chiba.jp","togane.chiba.jp","tohnosho.chiba.jp","tomisato.chiba.jp","urayasu.chiba.jp","yachimata.chiba.jp","yachiyo.chiba.jp","yokaichiba.chiba.jp","yokoshibahikari.chiba.jp","yotsukaido.chiba.jp","ainan.ehime.jp","honai.ehime.jp","ikata.ehime.jp","imabari.ehime.jp","iyo.ehime.jp","kamijima.ehime.jp","kihoku.ehime.jp","kumakogen.ehime.jp","masaki.ehime.jp","matsuno.ehime.jp","matsuyama.ehime.jp","namikata.ehime.jp","niihama.ehime.jp","ozu.ehime.jp","saijo.ehime.jp","seiyo.ehime.jp","shikokuchuo.ehime.jp","tobe.ehime.jp","toon.ehime.jp","uchiko.ehime.jp","uwajima.ehime.jp","yawatahama.ehime.jp","echizen.fukui.jp","eiheiji.fukui.jp","fukui.fukui.jp","ikeda.fukui.jp","katsuyama.fukui.jp","mihama.fukui.jp","minamiechizen.fukui.jp","obama.fukui.jp","ohi.fukui.jp","ono.fukui.jp","sabae.fukui.jp","sakai.fukui.jp","takahama.fukui.jp","tsuruga.fukui.jp","wakasa.fukui.jp","ashiya.fukuoka.jp","buzen.fukuoka.jp","chikugo.fukuoka.jp","chikuho.fukuoka.jp","chikujo.fukuoka.jp","chikushino.fukuoka.jp","chikuzen.fukuoka.jp","chuo.fukuoka.jp","dazaifu.fukuoka.jp","fukuchi.fukuoka.jp","hakata.fukuoka.jp","higashi.fukuoka.jp","hirokawa.fukuoka.jp","hisayama.fukuoka.jp","iizuka.fukuoka.jp","inatsuki.fukuoka.jp","kaho.fukuoka.jp","kasuga.fukuoka.jp","kasuya.fukuoka.jp","kawara.fukuoka.jp","keisen.fukuoka.jp","koga.fukuoka.jp","kurate.fukuoka.jp","kurogi.fukuoka.jp","kurume.fukuoka.jp","minami.fukuoka.jp","miyako.fukuoka.jp","miyama.fukuoka.jp","miyawaka.fukuoka.jp","mizumaki.fukuoka.jp","munakata.fukuoka.jp","nakagawa.fukuoka.jp","nakama.fukuoka.jp","nishi.fukuoka.jp","nogata.fukuoka.jp","ogori.fukuoka.jp","okagaki.fukuoka.jp","okawa.fukuoka.jp","oki.fukuoka.jp","omuta.fukuoka.jp","onga.fukuoka.jp","onojo.fukuoka.jp","oto.fukuoka.jp","saigawa.fukuoka.jp","sasaguri.fukuoka.jp","shingu.fukuoka.jp","shinyoshitomi.fukuoka.jp","shonai.fukuoka.jp","soeda.fukuoka.jp","sue.fukuoka.jp","tachiarai.fukuoka.jp","tagawa.fukuoka.jp","takata.fukuoka.jp","toho.fukuoka.jp","toyotsu.fukuoka.jp","tsuiki.fukuoka.jp","ukiha.fukuoka.jp","umi.fukuoka.jp","usui.fukuoka.jp","yamada.fukuoka.jp","yame.fukuoka.jp","yanagawa.fukuoka.jp","yukuhashi.fukuoka.jp","aizubange.fukushima.jp","aizumisato.fukushima.jp","aizuwakamatsu.fukushima.jp","asakawa.fukushima.jp","bandai.fukushima.jp","date.fukushima.jp","fukushima.fukushima.jp","furudono.fukushima.jp","futaba.fukushima.jp","hanawa.fukushima.jp","higashi.fukushima.jp","hirata.fukushima.jp","hirono.fukushima.jp","iitate.fukushima.jp","inawashiro.fukushima.jp","ishikawa.fukushima.jp","iwaki.fukushima.jp","izumizaki.fukushima.jp","kagamiishi.fukushima.jp","kaneyama.fukushima.jp","kawamata.fukushima.jp","kitakata.fukushima.jp","kitashiobara.fukushima.jp","koori.fukushima.jp","koriyama.fukushima.jp","kunimi.fukushima.jp","miharu.fukushima.jp","mishima.fukushima.jp","namie.fukushima.jp","nango.fukushima.jp","nishiaizu.fukushima.jp","nishigo.fukushima.jp","okuma.fukushima.jp","omotego.fukushima.jp","ono.fukushima.jp","otama.fukushima.jp","samegawa.fukushima.jp","shimogo.fukushima.jp","shirakawa.fukushima.jp","showa.fukushima.jp","soma.fukushima.jp","sukagawa.fukushima.jp","taishin.fukushima.jp","tamakawa.fukushima.jp","tanagura.fukushima.jp","tenei.fukushima.jp","yabuki.fukushima.jp","yamato.fukushima.jp","yamatsuri.fukushima.jp","yanaizu.fukushima.jp","yugawa.fukushima.jp","anpachi.gifu.jp","ena.gifu.jp","gifu.gifu.jp","ginan.gifu.jp","godo.gifu.jp","gujo.gifu.jp","hashima.gifu.jp","hichiso.gifu.jp","hida.gifu.jp","higashishirakawa.gifu.jp","ibigawa.gifu.jp","ikeda.gifu.jp","kakamigahara.gifu.jp","kani.gifu.jp","kasahara.gifu.jp","kasamatsu.gifu.jp","kawaue.gifu.jp","kitagata.gifu.jp","mino.gifu.jp","minokamo.gifu.jp","mitake.gifu.jp","mizunami.gifu.jp","motosu.gifu.jp","nakatsugawa.gifu.jp","ogaki.gifu.jp","sakahogi.gifu.jp","seki.gifu.jp","sekigahara.gifu.jp","shirakawa.gifu.jp","tajimi.gifu.jp","takayama.gifu.jp","tarui.gifu.jp","toki.gifu.jp","tomika.gifu.jp","wanouchi.gifu.jp","yamagata.gifu.jp","yaotsu.gifu.jp","yoro.gifu.jp","annaka.gunma.jp","chiyoda.gunma.jp","fujioka.gunma.jp","higashiagatsuma.gunma.jp","isesaki.gunma.jp","itakura.gunma.jp","kanna.gunma.jp","kanra.gunma.jp","katashina.gunma.jp","kawaba.gunma.jp","kiryu.gunma.jp","kusatsu.gunma.jp","maebashi.gunma.jp","meiwa.gunma.jp","midori.gunma.jp","minakami.gunma.jp","naganohara.gunma.jp","nakanojo.gunma.jp","nanmoku.gunma.jp","numata.gunma.jp","oizumi.gunma.jp","ora.gunma.jp","ota.gunma.jp","shibukawa.gunma.jp","shimonita.gunma.jp","shinto.gunma.jp","showa.gunma.jp","takasaki.gunma.jp","takayama.gunma.jp","tamamura.gunma.jp","tatebayashi.gunma.jp","tomioka.gunma.jp","tsukiyono.gunma.jp","tsumagoi.gunma.jp","ueno.gunma.jp","yoshioka.gunma.jp","asaminami.hiroshima.jp","daiwa.hiroshima.jp","etajima.hiroshima.jp","fuchu.hiroshima.jp","fukuyama.hiroshima.jp","hatsukaichi.hiroshima.jp","higashihiroshima.hiroshima.jp","hongo.hiroshima.jp","jinsekikogen.hiroshima.jp","kaita.hiroshima.jp","kui.hiroshima.jp","kumano.hiroshima.jp","kure.hiroshima.jp","mihara.hiroshima.jp","miyoshi.hiroshima.jp","naka.hiroshima.jp","onomichi.hiroshima.jp","osakikamijima.hiroshima.jp","otake.hiroshima.jp","saka.hiroshima.jp","sera.hiroshima.jp","seranishi.hiroshima.jp","shinichi.hiroshima.jp","shobara.hiroshima.jp","takehara.hiroshima.jp","abashiri.hokkaido.jp","abira.hokkaido.jp","aibetsu.hokkaido.jp","akabira.hokkaido.jp","akkeshi.hokkaido.jp","asahikawa.hokkaido.jp","ashibetsu.hokkaido.jp","ashoro.hokkaido.jp","assabu.hokkaido.jp","atsuma.hokkaido.jp","bibai.hokkaido.jp","biei.hokkaido.jp","bifuka.hokkaido.jp","bihoro.hokkaido.jp","biratori.hokkaido.jp","chippubetsu.hokkaido.jp","chitose.hokkaido.jp","date.hokkaido.jp","ebetsu.hokkaido.jp","embetsu.hokkaido.jp","eniwa.hokkaido.jp","erimo.hokkaido.jp","esan.hokkaido.jp","esashi.hokkaido.jp","fukagawa.hokkaido.jp","fukushima.hokkaido.jp","furano.hokkaido.jp","furubira.hokkaido.jp","haboro.hokkaido.jp","hakodate.hokkaido.jp","hamatonbetsu.hokkaido.jp","hidaka.hokkaido.jp","higashikagura.hokkaido.jp","higashikawa.hokkaido.jp","hiroo.hokkaido.jp","hokuryu.hokkaido.jp","hokuto.hokkaido.jp","honbetsu.hokkaido.jp","horokanai.hokkaido.jp","horonobe.hokkaido.jp","ikeda.hokkaido.jp","imakane.hokkaido.jp","ishikari.hokkaido.jp","iwamizawa.hokkaido.jp","iwanai.hokkaido.jp","kamifurano.hokkaido.jp","kamikawa.hokkaido.jp","kamishihoro.hokkaido.jp","kamisunagawa.hokkaido.jp","kamoenai.hokkaido.jp","kayabe.hokkaido.jp","kembuchi.hokkaido.jp","kikonai.hokkaido.jp","kimobetsu.hokkaido.jp","kitahiroshima.hokkaido.jp","kitami.hokkaido.jp","kiyosato.hokkaido.jp","koshimizu.hokkaido.jp","kunneppu.hokkaido.jp","kuriyama.hokkaido.jp","kuromatsunai.hokkaido.jp","kushiro.hokkaido.jp","kutchan.hokkaido.jp","kyowa.hokkaido.jp","mashike.hokkaido.jp","matsumae.hokkaido.jp","mikasa.hokkaido.jp","minamifurano.hokkaido.jp","mombetsu.hokkaido.jp","moseushi.hokkaido.jp","mukawa.hokkaido.jp","muroran.hokkaido.jp","naie.hokkaido.jp","nakagawa.hokkaido.jp","nakasatsunai.hokkaido.jp","nakatombetsu.hokkaido.jp","nanae.hokkaido.jp","nanporo.hokkaido.jp","nayoro.hokkaido.jp","nemuro.hokkaido.jp","niikappu.hokkaido.jp","niki.hokkaido.jp","nishiokoppe.hokkaido.jp","noboribetsu.hokkaido.jp","numata.hokkaido.jp","obihiro.hokkaido.jp","obira.hokkaido.jp","oketo.hokkaido.jp","okoppe.hokkaido.jp","otaru.hokkaido.jp","otobe.hokkaido.jp","otofuke.hokkaido.jp","otoineppu.hokkaido.jp","oumu.hokkaido.jp","ozora.hokkaido.jp","pippu.hokkaido.jp","rankoshi.hokkaido.jp","rebun.hokkaido.jp","rikubetsu.hokkaido.jp","rishiri.hokkaido.jp","rishirifuji.hokkaido.jp","saroma.hokkaido.jp","sarufutsu.hokkaido.jp","shakotan.hokkaido.jp","shari.hokkaido.jp","shibecha.hokkaido.jp","shibetsu.hokkaido.jp","shikabe.hokkaido.jp","shikaoi.hokkaido.jp","shimamaki.hokkaido.jp","shimizu.hokkaido.jp","shimokawa.hokkaido.jp","shinshinotsu.hokkaido.jp","shintoku.hokkaido.jp","shiranuka.hokkaido.jp","shiraoi.hokkaido.jp","shiriuchi.hokkaido.jp","sobetsu.hokkaido.jp","sunagawa.hokkaido.jp","taiki.hokkaido.jp","takasu.hokkaido.jp","takikawa.hokkaido.jp","takinoue.hokkaido.jp","teshikaga.hokkaido.jp","tobetsu.hokkaido.jp","tohma.hokkaido.jp","tomakomai.hokkaido.jp","tomari.hokkaido.jp","toya.hokkaido.jp","toyako.hokkaido.jp","toyotomi.hokkaido.jp","toyoura.hokkaido.jp","tsubetsu.hokkaido.jp","tsukigata.hokkaido.jp","urakawa.hokkaido.jp","urausu.hokkaido.jp","uryu.hokkaido.jp","utashinai.hokkaido.jp","wakkanai.hokkaido.jp","wassamu.hokkaido.jp","yakumo.hokkaido.jp","yoichi.hokkaido.jp","aioi.hyogo.jp","akashi.hyogo.jp","ako.hyogo.jp","amagasaki.hyogo.jp","aogaki.hyogo.jp","asago.hyogo.jp","ashiya.hyogo.jp","awaji.hyogo.jp","fukusaki.hyogo.jp","goshiki.hyogo.jp","harima.hyogo.jp","himeji.hyogo.jp","ichikawa.hyogo.jp","inagawa.hyogo.jp","itami.hyogo.jp","kakogawa.hyogo.jp","kamigori.hyogo.jp","kamikawa.hyogo.jp","kasai.hyogo.jp","kasuga.hyogo.jp","kawanishi.hyogo.jp","miki.hyogo.jp","minamiawaji.hyogo.jp","nishinomiya.hyogo.jp","nishiwaki.hyogo.jp","ono.hyogo.jp","sanda.hyogo.jp","sannan.hyogo.jp","sasayama.hyogo.jp","sayo.hyogo.jp","shingu.hyogo.jp","shinonsen.hyogo.jp","shiso.hyogo.jp","sumoto.hyogo.jp","taishi.hyogo.jp","taka.hyogo.jp","takarazuka.hyogo.jp","takasago.hyogo.jp","takino.hyogo.jp","tamba.hyogo.jp","tatsuno.hyogo.jp","toyooka.hyogo.jp","yabu.hyogo.jp","yashiro.hyogo.jp","yoka.hyogo.jp","yokawa.hyogo.jp","ami.ibaraki.jp","asahi.ibaraki.jp","bando.ibaraki.jp","chikusei.ibaraki.jp","daigo.ibaraki.jp","fujishiro.ibaraki.jp","hitachi.ibaraki.jp","hitachinaka.ibaraki.jp","hitachiomiya.ibaraki.jp","hitachiota.ibaraki.jp","ibaraki.ibaraki.jp","ina.ibaraki.jp","inashiki.ibaraki.jp","itako.ibaraki.jp","iwama.ibaraki.jp","joso.ibaraki.jp","kamisu.ibaraki.jp","kasama.ibaraki.jp","kashima.ibaraki.jp","kasumigaura.ibaraki.jp","koga.ibaraki.jp","miho.ibaraki.jp","mito.ibaraki.jp","moriya.ibaraki.jp","naka.ibaraki.jp","namegata.ibaraki.jp","oarai.ibaraki.jp","ogawa.ibaraki.jp","omitama.ibaraki.jp","ryugasaki.ibaraki.jp","sakai.ibaraki.jp","sakuragawa.ibaraki.jp","shimodate.ibaraki.jp","shimotsuma.ibaraki.jp","shirosato.ibaraki.jp","sowa.ibaraki.jp","suifu.ibaraki.jp","takahagi.ibaraki.jp","tamatsukuri.ibaraki.jp","tokai.ibaraki.jp","tomobe.ibaraki.jp","tone.ibaraki.jp","toride.ibaraki.jp","tsuchiura.ibaraki.jp","tsukuba.ibaraki.jp","uchihara.ibaraki.jp","ushiku.ibaraki.jp","yachiyo.ibaraki.jp","yamagata.ibaraki.jp","yawara.ibaraki.jp","yuki.ibaraki.jp","anamizu.ishikawa.jp","hakui.ishikawa.jp","hakusan.ishikawa.jp","kaga.ishikawa.jp","kahoku.ishikawa.jp","kanazawa.ishikawa.jp","kawakita.ishikawa.jp","komatsu.ishikawa.jp","nakanoto.ishikawa.jp","nanao.ishikawa.jp","nomi.ishikawa.jp","nonoichi.ishikawa.jp","noto.ishikawa.jp","shika.ishikawa.jp","suzu.ishikawa.jp","tsubata.ishikawa.jp","tsurugi.ishikawa.jp","uchinada.ishikawa.jp","wajima.ishikawa.jp","fudai.iwate.jp","fujisawa.iwate.jp","hanamaki.iwate.jp","hiraizumi.iwate.jp","hirono.iwate.jp","ichinohe.iwate.jp","ichinoseki.iwate.jp","iwaizumi.iwate.jp","iwate.iwate.jp","joboji.iwate.jp","kamaishi.iwate.jp","kanegasaki.iwate.jp","karumai.iwate.jp","kawai.iwate.jp","kitakami.iwate.jp","kuji.iwate.jp","kunohe.iwate.jp","kuzumaki.iwate.jp","miyako.iwate.jp","mizusawa.iwate.jp","morioka.iwate.jp","ninohe.iwate.jp","noda.iwate.jp","ofunato.iwate.jp","oshu.iwate.jp","otsuchi.iwate.jp","rikuzentakata.iwate.jp","shiwa.iwate.jp","shizukuishi.iwate.jp","sumita.iwate.jp","tanohata.iwate.jp","tono.iwate.jp","yahaba.iwate.jp","yamada.iwate.jp","ayagawa.kagawa.jp","higashikagawa.kagawa.jp","kanonji.kagawa.jp","kotohira.kagawa.jp","manno.kagawa.jp","marugame.kagawa.jp","mitoyo.kagawa.jp","naoshima.kagawa.jp","sanuki.kagawa.jp","tadotsu.kagawa.jp","takamatsu.kagawa.jp","tonosho.kagawa.jp","uchinomi.kagawa.jp","utazu.kagawa.jp","zentsuji.kagawa.jp","akune.kagoshima.jp","amami.kagoshima.jp","hioki.kagoshima.jp","isa.kagoshima.jp","isen.kagoshima.jp","izumi.kagoshima.jp","kagoshima.kagoshima.jp","kanoya.kagoshima.jp","kawanabe.kagoshima.jp","kinko.kagoshima.jp","kouyama.kagoshima.jp","makurazaki.kagoshima.jp","matsumoto.kagoshima.jp","minamitane.kagoshima.jp","nakatane.kagoshima.jp","nishinoomote.kagoshima.jp","satsumasendai.kagoshima.jp","soo.kagoshima.jp","tarumizu.kagoshima.jp","yusui.kagoshima.jp","aikawa.kanagawa.jp","atsugi.kanagawa.jp","ayase.kanagawa.jp","chigasaki.kanagawa.jp","ebina.kanagawa.jp","fujisawa.kanagawa.jp","hadano.kanagawa.jp","hakone.kanagawa.jp","hiratsuka.kanagawa.jp","isehara.kanagawa.jp","kaisei.kanagawa.jp","kamakura.kanagawa.jp","kiyokawa.kanagawa.jp","matsuda.kanagawa.jp","minamiashigara.kanagawa.jp","miura.kanagawa.jp","nakai.kanagawa.jp","ninomiya.kanagawa.jp","odawara.kanagawa.jp","oi.kanagawa.jp","oiso.kanagawa.jp","sagamihara.kanagawa.jp","samukawa.kanagawa.jp","tsukui.kanagawa.jp","yamakita.kanagawa.jp","yamato.kanagawa.jp","yokosuka.kanagawa.jp","yugawara.kanagawa.jp","zama.kanagawa.jp","zushi.kanagawa.jp","aki.kochi.jp","geisei.kochi.jp","hidaka.kochi.jp","higashitsuno.kochi.jp","ino.kochi.jp","kagami.kochi.jp","kami.kochi.jp","kitagawa.kochi.jp","kochi.kochi.jp","mihara.kochi.jp","motoyama.kochi.jp","muroto.kochi.jp","nahari.kochi.jp","nakamura.kochi.jp","nankoku.kochi.jp","nishitosa.kochi.jp","niyodogawa.kochi.jp","ochi.kochi.jp","okawa.kochi.jp","otoyo.kochi.jp","otsuki.kochi.jp","sakawa.kochi.jp","sukumo.kochi.jp","susaki.kochi.jp","tosa.kochi.jp","tosashimizu.kochi.jp","toyo.kochi.jp","tsuno.kochi.jp","umaji.kochi.jp","yasuda.kochi.jp","yusuhara.kochi.jp","amakusa.kumamoto.jp","arao.kumamoto.jp","aso.kumamoto.jp","choyo.kumamoto.jp","gyokuto.kumamoto.jp","kamiamakusa.kumamoto.jp","kikuchi.kumamoto.jp","kumamoto.kumamoto.jp","mashiki.kumamoto.jp","mifune.kumamoto.jp","minamata.kumamoto.jp","minamioguni.kumamoto.jp","nagasu.kumamoto.jp","nishihara.kumamoto.jp","oguni.kumamoto.jp","ozu.kumamoto.jp","sumoto.kumamoto.jp","takamori.kumamoto.jp","uki.kumamoto.jp","uto.kumamoto.jp","yamaga.kumamoto.jp","yamato.kumamoto.jp","yatsushiro.kumamoto.jp","ayabe.kyoto.jp","fukuchiyama.kyoto.jp","higashiyama.kyoto.jp","ide.kyoto.jp","ine.kyoto.jp","joyo.kyoto.jp","kameoka.kyoto.jp","kamo.kyoto.jp","kita.kyoto.jp","kizu.kyoto.jp","kumiyama.kyoto.jp","kyotamba.kyoto.jp","kyotanabe.kyoto.jp","kyotango.kyoto.jp","maizuru.kyoto.jp","minami.kyoto.jp","minamiyamashiro.kyoto.jp","miyazu.kyoto.jp","muko.kyoto.jp","nagaokakyo.kyoto.jp","nakagyo.kyoto.jp","nantan.kyoto.jp","oyamazaki.kyoto.jp","sakyo.kyoto.jp","seika.kyoto.jp","tanabe.kyoto.jp","uji.kyoto.jp","ujitawara.kyoto.jp","wazuka.kyoto.jp","yamashina.kyoto.jp","yawata.kyoto.jp","asahi.mie.jp","inabe.mie.jp","ise.mie.jp","kameyama.mie.jp","kawagoe.mie.jp","kiho.mie.jp","kisosaki.mie.jp","kiwa.mie.jp","komono.mie.jp","kumano.mie.jp","kuwana.mie.jp","matsusaka.mie.jp","meiwa.mie.jp","mihama.mie.jp","minamiise.mie.jp","misugi.mie.jp","miyama.mie.jp","nabari.mie.jp","shima.mie.jp","suzuka.mie.jp","tado.mie.jp","taiki.mie.jp","taki.mie.jp","tamaki.mie.jp","toba.mie.jp","tsu.mie.jp","udono.mie.jp","ureshino.mie.jp","watarai.mie.jp","yokkaichi.mie.jp","furukawa.miyagi.jp","higashimatsushima.miyagi.jp","ishinomaki.miyagi.jp","iwanuma.miyagi.jp","kakuda.miyagi.jp","kami.miyagi.jp","kawasaki.miyagi.jp","marumori.miyagi.jp","matsushima.miyagi.jp","minamisanriku.miyagi.jp","misato.miyagi.jp","murata.miyagi.jp","natori.miyagi.jp","ogawara.miyagi.jp","ohira.miyagi.jp","onagawa.miyagi.jp","osaki.miyagi.jp","rifu.miyagi.jp","semine.miyagi.jp","shibata.miyagi.jp","shichikashuku.miyagi.jp","shikama.miyagi.jp","shiogama.miyagi.jp","shiroishi.miyagi.jp","tagajo.miyagi.jp","taiwa.miyagi.jp","tome.miyagi.jp","tomiya.miyagi.jp","wakuya.miyagi.jp","watari.miyagi.jp","yamamoto.miyagi.jp","zao.miyagi.jp","aya.miyazaki.jp","ebino.miyazaki.jp","gokase.miyazaki.jp","hyuga.miyazaki.jp","kadogawa.miyazaki.jp","kawaminami.miyazaki.jp","kijo.miyazaki.jp","kitagawa.miyazaki.jp","kitakata.miyazaki.jp","kitaura.miyazaki.jp","kobayashi.miyazaki.jp","kunitomi.miyazaki.jp","kushima.miyazaki.jp","mimata.miyazaki.jp","miyakonojo.miyazaki.jp","miyazaki.miyazaki.jp","morotsuka.miyazaki.jp","nichinan.miyazaki.jp","nishimera.miyazaki.jp","nobeoka.miyazaki.jp","saito.miyazaki.jp","shiiba.miyazaki.jp","shintomi.miyazaki.jp","takaharu.miyazaki.jp","takanabe.miyazaki.jp","takazaki.miyazaki.jp","tsuno.miyazaki.jp","achi.nagano.jp","agematsu.nagano.jp","anan.nagano.jp","aoki.nagano.jp","asahi.nagano.jp","azumino.nagano.jp","chikuhoku.nagano.jp","chikuma.nagano.jp","chino.nagano.jp","fujimi.nagano.jp","hakuba.nagano.jp","hara.nagano.jp","hiraya.nagano.jp","iida.nagano.jp","iijima.nagano.jp","iiyama.nagano.jp","iizuna.nagano.jp","ikeda.nagano.jp","ikusaka.nagano.jp","ina.nagano.jp","karuizawa.nagano.jp","kawakami.nagano.jp","kiso.nagano.jp","kisofukushima.nagano.jp","kitaaiki.nagano.jp","komagane.nagano.jp","komoro.nagano.jp","matsukawa.nagano.jp","matsumoto.nagano.jp","miasa.nagano.jp","minamiaiki.nagano.jp","minamimaki.nagano.jp","minamiminowa.nagano.jp","minowa.nagano.jp","miyada.nagano.jp","miyota.nagano.jp","mochizuki.nagano.jp","nagano.nagano.jp","nagawa.nagano.jp","nagiso.nagano.jp","nakagawa.nagano.jp","nakano.nagano.jp","nozawaonsen.nagano.jp","obuse.nagano.jp","ogawa.nagano.jp","okaya.nagano.jp","omachi.nagano.jp","omi.nagano.jp","ookuwa.nagano.jp","ooshika.nagano.jp","otaki.nagano.jp","otari.nagano.jp","sakae.nagano.jp","sakaki.nagano.jp","saku.nagano.jp","sakuho.nagano.jp","shimosuwa.nagano.jp","shinanomachi.nagano.jp","shiojiri.nagano.jp","suwa.nagano.jp","suzaka.nagano.jp","takagi.nagano.jp","takamori.nagano.jp","takayama.nagano.jp","tateshina.nagano.jp","tatsuno.nagano.jp","togakushi.nagano.jp","togura.nagano.jp","tomi.nagano.jp","ueda.nagano.jp","wada.nagano.jp","yamagata.nagano.jp","yamanouchi.nagano.jp","yasaka.nagano.jp","yasuoka.nagano.jp","chijiwa.nagasaki.jp","futsu.nagasaki.jp","goto.nagasaki.jp","hasami.nagasaki.jp","hirado.nagasaki.jp","iki.nagasaki.jp","isahaya.nagasaki.jp","kawatana.nagasaki.jp","kuchinotsu.nagasaki.jp","matsuura.nagasaki.jp","nagasaki.nagasaki.jp","obama.nagasaki.jp","omura.nagasaki.jp","oseto.nagasaki.jp","saikai.nagasaki.jp","sasebo.nagasaki.jp","seihi.nagasaki.jp","shimabara.nagasaki.jp","shinkamigoto.nagasaki.jp","togitsu.nagasaki.jp","tsushima.nagasaki.jp","unzen.nagasaki.jp","ando.nara.jp","gose.nara.jp","heguri.nara.jp","higashiyoshino.nara.jp","ikaruga.nara.jp","ikoma.nara.jp","kamikitayama.nara.jp","kanmaki.nara.jp","kashiba.nara.jp","kashihara.nara.jp","katsuragi.nara.jp","kawai.nara.jp","kawakami.nara.jp","kawanishi.nara.jp","koryo.nara.jp","kurotaki.nara.jp","mitsue.nara.jp","miyake.nara.jp","nara.nara.jp","nosegawa.nara.jp","oji.nara.jp","ouda.nara.jp","oyodo.nara.jp","sakurai.nara.jp","sango.nara.jp","shimoichi.nara.jp","shimokitayama.nara.jp","shinjo.nara.jp","soni.nara.jp","takatori.nara.jp","tawaramoto.nara.jp","tenkawa.nara.jp","tenri.nara.jp","uda.nara.jp","yamatokoriyama.nara.jp","yamatotakada.nara.jp","yamazoe.nara.jp","yoshino.nara.jp","aga.niigata.jp","agano.niigata.jp","gosen.niigata.jp","itoigawa.niigata.jp","izumozaki.niigata.jp","joetsu.niigata.jp","kamo.niigata.jp","kariwa.niigata.jp","kashiwazaki.niigata.jp","minamiuonuma.niigata.jp","mitsuke.niigata.jp","muika.niigata.jp","murakami.niigata.jp","myoko.niigata.jp","nagaoka.niigata.jp","niigata.niigata.jp","ojiya.niigata.jp","omi.niigata.jp","sado.niigata.jp","sanjo.niigata.jp","seiro.niigata.jp","seirou.niigata.jp","sekikawa.niigata.jp","shibata.niigata.jp","tagami.niigata.jp","tainai.niigata.jp","tochio.niigata.jp","tokamachi.niigata.jp","tsubame.niigata.jp","tsunan.niigata.jp","uonuma.niigata.jp","yahiko.niigata.jp","yoita.niigata.jp","yuzawa.niigata.jp","beppu.oita.jp","bungoono.oita.jp","bungotakada.oita.jp","hasama.oita.jp","hiji.oita.jp","himeshima.oita.jp","hita.oita.jp","kamitsue.oita.jp","kokonoe.oita.jp","kuju.oita.jp","kunisaki.oita.jp","kusu.oita.jp","oita.oita.jp","saiki.oita.jp","taketa.oita.jp","tsukumi.oita.jp","usa.oita.jp","usuki.oita.jp","yufu.oita.jp","akaiwa.okayama.jp","asakuchi.okayama.jp","bizen.okayama.jp","hayashima.okayama.jp","ibara.okayama.jp","kagamino.okayama.jp","kasaoka.okayama.jp","kibichuo.okayama.jp","kumenan.okayama.jp","kurashiki.okayama.jp","maniwa.okayama.jp","misaki.okayama.jp","nagi.okayama.jp","niimi.okayama.jp","nishiawakura.okayama.jp","okayama.okayama.jp","satosho.okayama.jp","setouchi.okayama.jp","shinjo.okayama.jp","shoo.okayama.jp","soja.okayama.jp","takahashi.okayama.jp","tamano.okayama.jp","tsuyama.okayama.jp","wake.okayama.jp","yakage.okayama.jp","aguni.okinawa.jp","ginowan.okinawa.jp","ginoza.okinawa.jp","gushikami.okinawa.jp","haebaru.okinawa.jp","higashi.okinawa.jp","hirara.okinawa.jp","iheya.okinawa.jp","ishigaki.okinawa.jp","ishikawa.okinawa.jp","itoman.okinawa.jp","izena.okinawa.jp","kadena.okinawa.jp","kin.okinawa.jp","kitadaito.okinawa.jp","kitanakagusuku.okinawa.jp","kumejima.okinawa.jp","kunigami.okinawa.jp","minamidaito.okinawa.jp","motobu.okinawa.jp","nago.okinawa.jp","naha.okinawa.jp","nakagusuku.okinawa.jp","nakijin.okinawa.jp","nanjo.okinawa.jp","nishihara.okinawa.jp","ogimi.okinawa.jp","okinawa.okinawa.jp","onna.okinawa.jp","shimoji.okinawa.jp","taketomi.okinawa.jp","tarama.okinawa.jp","tokashiki.okinawa.jp","tomigusuku.okinawa.jp","tonaki.okinawa.jp","urasoe.okinawa.jp","uruma.okinawa.jp","yaese.okinawa.jp","yomitan.okinawa.jp","yonabaru.okinawa.jp","yonaguni.okinawa.jp","zamami.okinawa.jp","abeno.osaka.jp","chihayaakasaka.osaka.jp","chuo.osaka.jp","daito.osaka.jp","fujiidera.osaka.jp","habikino.osaka.jp","hannan.osaka.jp","higashiosaka.osaka.jp","higashisumiyoshi.osaka.jp","higashiyodogawa.osaka.jp","hirakata.osaka.jp","ibaraki.osaka.jp","ikeda.osaka.jp","izumi.osaka.jp","izumiotsu.osaka.jp","izumisano.osaka.jp","kadoma.osaka.jp","kaizuka.osaka.jp","kanan.osaka.jp","kashiwara.osaka.jp","katano.osaka.jp","kawachinagano.osaka.jp","kishiwada.osaka.jp","kita.osaka.jp","kumatori.osaka.jp","matsubara.osaka.jp","minato.osaka.jp","minoh.osaka.jp","misaki.osaka.jp","moriguchi.osaka.jp","neyagawa.osaka.jp","nishi.osaka.jp","nose.osaka.jp","osakasayama.osaka.jp","sakai.osaka.jp","sayama.osaka.jp","sennan.osaka.jp","settsu.osaka.jp","shijonawate.osaka.jp","shimamoto.osaka.jp","suita.osaka.jp","tadaoka.osaka.jp","taishi.osaka.jp","tajiri.osaka.jp","takaishi.osaka.jp","takatsuki.osaka.jp","tondabayashi.osaka.jp","toyonaka.osaka.jp","toyono.osaka.jp","yao.osaka.jp","ariake.saga.jp","arita.saga.jp","fukudomi.saga.jp","genkai.saga.jp","hamatama.saga.jp","hizen.saga.jp","imari.saga.jp","kamimine.saga.jp","kanzaki.saga.jp","karatsu.saga.jp","kashima.saga.jp","kitagata.saga.jp","kitahata.saga.jp","kiyama.saga.jp","kouhoku.saga.jp","kyuragi.saga.jp","nishiarita.saga.jp","ogi.saga.jp","omachi.saga.jp","ouchi.saga.jp","saga.saga.jp","shiroishi.saga.jp","taku.saga.jp","tara.saga.jp","tosu.saga.jp","yoshinogari.saga.jp","arakawa.saitama.jp","asaka.saitama.jp","chichibu.saitama.jp","fujimi.saitama.jp","fujimino.saitama.jp","fukaya.saitama.jp","hanno.saitama.jp","hanyu.saitama.jp","hasuda.saitama.jp","hatogaya.saitama.jp","hatoyama.saitama.jp","hidaka.saitama.jp","higashichichibu.saitama.jp","higashimatsuyama.saitama.jp","honjo.saitama.jp","ina.saitama.jp","iruma.saitama.jp","iwatsuki.saitama.jp","kamiizumi.saitama.jp","kamikawa.saitama.jp","kamisato.saitama.jp","kasukabe.saitama.jp","kawagoe.saitama.jp","kawaguchi.saitama.jp","kawajima.saitama.jp","kazo.saitama.jp","kitamoto.saitama.jp","koshigaya.saitama.jp","kounosu.saitama.jp","kuki.saitama.jp","kumagaya.saitama.jp","matsubushi.saitama.jp","minano.saitama.jp","misato.saitama.jp","miyashiro.saitama.jp","miyoshi.saitama.jp","moroyama.saitama.jp","nagatoro.saitama.jp","namegawa.saitama.jp","niiza.saitama.jp","ogano.saitama.jp","ogawa.saitama.jp","ogose.saitama.jp","okegawa.saitama.jp","omiya.saitama.jp","otaki.saitama.jp","ranzan.saitama.jp","ryokami.saitama.jp","saitama.saitama.jp","sakado.saitama.jp","satte.saitama.jp","sayama.saitama.jp","shiki.saitama.jp","shiraoka.saitama.jp","soka.saitama.jp","sugito.saitama.jp","toda.saitama.jp","tokigawa.saitama.jp","tokorozawa.saitama.jp","tsurugashima.saitama.jp","urawa.saitama.jp","warabi.saitama.jp","yashio.saitama.jp","yokoze.saitama.jp","yono.saitama.jp","yorii.saitama.jp","yoshida.saitama.jp","yoshikawa.saitama.jp","yoshimi.saitama.jp","aisho.shiga.jp","gamo.shiga.jp","higashiomi.shiga.jp","hikone.shiga.jp","koka.shiga.jp","konan.shiga.jp","kosei.shiga.jp","koto.shiga.jp","kusatsu.shiga.jp","maibara.shiga.jp","moriyama.shiga.jp","nagahama.shiga.jp","nishiazai.shiga.jp","notogawa.shiga.jp","omihachiman.shiga.jp","otsu.shiga.jp","ritto.shiga.jp","ryuoh.shiga.jp","takashima.shiga.jp","takatsuki.shiga.jp","torahime.shiga.jp","toyosato.shiga.jp","yasu.shiga.jp","akagi.shimane.jp","ama.shimane.jp","gotsu.shimane.jp","hamada.shimane.jp","higashiizumo.shimane.jp","hikawa.shimane.jp","hikimi.shimane.jp","izumo.shimane.jp","kakinoki.shimane.jp","masuda.shimane.jp","matsue.shimane.jp","misato.shimane.jp","nishinoshima.shimane.jp","ohda.shimane.jp","okinoshima.shimane.jp","okuizumo.shimane.jp","shimane.shimane.jp","tamayu.shimane.jp","tsuwano.shimane.jp","unnan.shimane.jp","yakumo.shimane.jp","yasugi.shimane.jp","yatsuka.shimane.jp","arai.shizuoka.jp","atami.shizuoka.jp","fuji.shizuoka.jp","fujieda.shizuoka.jp","fujikawa.shizuoka.jp","fujinomiya.shizuoka.jp","fukuroi.shizuoka.jp","gotemba.shizuoka.jp","haibara.shizuoka.jp","hamamatsu.shizuoka.jp","higashiizu.shizuoka.jp","ito.shizuoka.jp","iwata.shizuoka.jp","izu.shizuoka.jp","izunokuni.shizuoka.jp","kakegawa.shizuoka.jp","kannami.shizuoka.jp","kawanehon.shizuoka.jp","kawazu.shizuoka.jp","kikugawa.shizuoka.jp","kosai.shizuoka.jp","makinohara.shizuoka.jp","matsuzaki.shizuoka.jp","minamiizu.shizuoka.jp","mishima.shizuoka.jp","morimachi.shizuoka.jp","nishiizu.shizuoka.jp","numazu.shizuoka.jp","omaezaki.shizuoka.jp","shimada.shizuoka.jp","shimizu.shizuoka.jp","shimoda.shizuoka.jp","shizuoka.shizuoka.jp","susono.shizuoka.jp","yaizu.shizuoka.jp","yoshida.shizuoka.jp","ashikaga.tochigi.jp","bato.tochigi.jp","haga.tochigi.jp","ichikai.tochigi.jp","iwafune.tochigi.jp","kaminokawa.tochigi.jp","kanuma.tochigi.jp","karasuyama.tochigi.jp","kuroiso.tochigi.jp","mashiko.tochigi.jp","mibu.tochigi.jp","moka.tochigi.jp","motegi.tochigi.jp","nasu.tochigi.jp","nasushiobara.tochigi.jp","nikko.tochigi.jp","nishikata.tochigi.jp","nogi.tochigi.jp","ohira.tochigi.jp","ohtawara.tochigi.jp","oyama.tochigi.jp","sakura.tochigi.jp","sano.tochigi.jp","shimotsuke.tochigi.jp","shioya.tochigi.jp","takanezawa.tochigi.jp","tochigi.tochigi.jp","tsuga.tochigi.jp","ujiie.tochigi.jp","utsunomiya.tochigi.jp","yaita.tochigi.jp","aizumi.tokushima.jp","anan.tokushima.jp","ichiba.tokushima.jp","itano.tokushima.jp","kainan.tokushima.jp","komatsushima.tokushima.jp","matsushige.tokushima.jp","mima.tokushima.jp","minami.tokushima.jp","miyoshi.tokushima.jp","mugi.tokushima.jp","nakagawa.tokushima.jp","naruto.tokushima.jp","sanagochi.tokushima.jp","shishikui.tokushima.jp","tokushima.tokushima.jp","wajiki.tokushima.jp","adachi.tokyo.jp","akiruno.tokyo.jp","akishima.tokyo.jp","aogashima.tokyo.jp","arakawa.tokyo.jp","bunkyo.tokyo.jp","chiyoda.tokyo.jp","chofu.tokyo.jp","chuo.tokyo.jp","edogawa.tokyo.jp","fuchu.tokyo.jp","fussa.tokyo.jp","hachijo.tokyo.jp","hachioji.tokyo.jp","hamura.tokyo.jp","higashikurume.tokyo.jp","higashimurayama.tokyo.jp","higashiyamato.tokyo.jp","hino.tokyo.jp","hinode.tokyo.jp","hinohara.tokyo.jp","inagi.tokyo.jp","itabashi.tokyo.jp","katsushika.tokyo.jp","kita.tokyo.jp","kiyose.tokyo.jp","kodaira.tokyo.jp","koganei.tokyo.jp","kokubunji.tokyo.jp","komae.tokyo.jp","koto.tokyo.jp","kouzushima.tokyo.jp","kunitachi.tokyo.jp","machida.tokyo.jp","meguro.tokyo.jp","minato.tokyo.jp","mitaka.tokyo.jp","mizuho.tokyo.jp","musashimurayama.tokyo.jp","musashino.tokyo.jp","nakano.tokyo.jp","nerima.tokyo.jp","ogasawara.tokyo.jp","okutama.tokyo.jp","ome.tokyo.jp","oshima.tokyo.jp","ota.tokyo.jp","setagaya.tokyo.jp","shibuya.tokyo.jp","shinagawa.tokyo.jp","shinjuku.tokyo.jp","suginami.tokyo.jp","sumida.tokyo.jp","tachikawa.tokyo.jp","taito.tokyo.jp","tama.tokyo.jp","toshima.tokyo.jp","chizu.tottori.jp","hino.tottori.jp","kawahara.tottori.jp","koge.tottori.jp","kotoura.tottori.jp","misasa.tottori.jp","nanbu.tottori.jp","nichinan.tottori.jp","sakaiminato.tottori.jp","tottori.tottori.jp","wakasa.tottori.jp","yazu.tottori.jp","yonago.tottori.jp","asahi.toyama.jp","fuchu.toyama.jp","fukumitsu.toyama.jp","funahashi.toyama.jp","himi.toyama.jp","imizu.toyama.jp","inami.toyama.jp","johana.toyama.jp","kamiichi.toyama.jp","kurobe.toyama.jp","nakaniikawa.toyama.jp","namerikawa.toyama.jp","nanto.toyama.jp","nyuzen.toyama.jp","oyabe.toyama.jp","taira.toyama.jp","takaoka.toyama.jp","tateyama.toyama.jp","toga.toyama.jp","tonami.toyama.jp","toyama.toyama.jp","unazuki.toyama.jp","uozu.toyama.jp","yamada.toyama.jp","arida.wakayama.jp","aridagawa.wakayama.jp","gobo.wakayama.jp","hashimoto.wakayama.jp","hidaka.wakayama.jp","hirogawa.wakayama.jp","inami.wakayama.jp","iwade.wakayama.jp","kainan.wakayama.jp","kamitonda.wakayama.jp","katsuragi.wakayama.jp","kimino.wakayama.jp","kinokawa.wakayama.jp","kitayama.wakayama.jp","koya.wakayama.jp","koza.wakayama.jp","kozagawa.wakayama.jp","kudoyama.wakayama.jp","kushimoto.wakayama.jp","mihama.wakayama.jp","misato.wakayama.jp","nachikatsuura.wakayama.jp","shingu.wakayama.jp","shirahama.wakayama.jp","taiji.wakayama.jp","tanabe.wakayama.jp","wakayama.wakayama.jp","yuasa.wakayama.jp","yura.wakayama.jp","asahi.yamagata.jp","funagata.yamagata.jp","higashine.yamagata.jp","iide.yamagata.jp","kahoku.yamagata.jp","kaminoyama.yamagata.jp","kaneyama.yamagata.jp","kawanishi.yamagata.jp","mamurogawa.yamagata.jp","mikawa.yamagata.jp","murayama.yamagata.jp","nagai.yamagata.jp","nakayama.yamagata.jp","nanyo.yamagata.jp","nishikawa.yamagata.jp","obanazawa.yamagata.jp","oe.yamagata.jp","oguni.yamagata.jp","ohkura.yamagata.jp","oishida.yamagata.jp","sagae.yamagata.jp","sakata.yamagata.jp","sakegawa.yamagata.jp","shinjo.yamagata.jp","shirataka.yamagata.jp","shonai.yamagata.jp","takahata.yamagata.jp","tendo.yamagata.jp","tozawa.yamagata.jp","tsuruoka.yamagata.jp","yamagata.yamagata.jp","yamanobe.yamagata.jp","yonezawa.yamagata.jp","yuza.yamagata.jp","abu.yamaguchi.jp","hagi.yamaguchi.jp","hikari.yamaguchi.jp","hofu.yamaguchi.jp","iwakuni.yamaguchi.jp","kudamatsu.yamaguchi.jp","mitou.yamaguchi.jp","nagato.yamaguchi.jp","oshima.yamaguchi.jp","shimonoseki.yamaguchi.jp","shunan.yamaguchi.jp","tabuse.yamaguchi.jp","tokuyama.yamaguchi.jp","toyota.yamaguchi.jp","ube.yamaguchi.jp","yuu.yamaguchi.jp","chuo.yamanashi.jp","doshi.yamanashi.jp","fuefuki.yamanashi.jp","fujikawa.yamanashi.jp","fujikawaguchiko.yamanashi.jp","fujiyoshida.yamanashi.jp","hayakawa.yamanashi.jp","hokuto.yamanashi.jp","ichikawamisato.yamanashi.jp","kai.yamanashi.jp","kofu.yamanashi.jp","koshu.yamanashi.jp","kosuge.yamanashi.jp","minami-alps.yamanashi.jp","minobu.yamanashi.jp","nakamichi.yamanashi.jp","nanbu.yamanashi.jp","narusawa.yamanashi.jp","nirasaki.yamanashi.jp","nishikatsura.yamanashi.jp","oshino.yamanashi.jp","otsuki.yamanashi.jp","showa.yamanashi.jp","tabayama.yamanashi.jp","tsuru.yamanashi.jp","uenohara.yamanashi.jp","yamanakako.yamanashi.jp","yamanashi.yamanashi.jp","ke","ac.ke","co.ke","go.ke","info.ke","me.ke","mobi.ke","ne.ke","or.ke","sc.ke","kg","org.kg","net.kg","com.kg","edu.kg","gov.kg","mil.kg","*.kh","ki","edu.ki","biz.ki","net.ki","org.ki","gov.ki","info.ki","com.ki","km","org.km","nom.km","gov.km","prd.km","tm.km","edu.km","mil.km","ass.km","com.km","coop.km","asso.km","presse.km","medecin.km","notaires.km","pharmaciens.km","veterinaire.km","gouv.km","kn","net.kn","org.kn","edu.kn","gov.kn","kp","com.kp","edu.kp","gov.kp","org.kp","rep.kp","tra.kp","kr","ac.kr","co.kr","es.kr","go.kr","hs.kr","kg.kr","mil.kr","ms.kr","ne.kr","or.kr","pe.kr","re.kr","sc.kr","busan.kr","chungbuk.kr","chungnam.kr","daegu.kr","daejeon.kr","gangwon.kr","gwangju.kr","gyeongbuk.kr","gyeonggi.kr","gyeongnam.kr","incheon.kr","jeju.kr","jeonbuk.kr","jeonnam.kr","seoul.kr","ulsan.kr","kw","com.kw","edu.kw","emb.kw","gov.kw","ind.kw","net.kw","org.kw","ky","edu.ky","gov.ky","com.ky","org.ky","net.ky","kz","org.kz","edu.kz","net.kz","gov.kz","mil.kz","com.kz","la","int.la","net.la","info.la","edu.la","gov.la","per.la","com.la","org.la","lb","com.lb","edu.lb","gov.lb","net.lb","org.lb","lc","com.lc","net.lc","co.lc","org.lc","edu.lc","gov.lc","li","lk","gov.lk","sch.lk","net.lk","int.lk","com.lk","org.lk","edu.lk","ngo.lk","soc.lk","web.lk","ltd.lk","assn.lk","grp.lk","hotel.lk","ac.lk","lr","com.lr","edu.lr","gov.lr","org.lr","net.lr","ls","co.ls","org.ls","lt","gov.lt","lu","lv","com.lv","edu.lv","gov.lv","org.lv","mil.lv","id.lv","net.lv","asn.lv","conf.lv","ly","com.ly","net.ly","gov.ly","plc.ly","edu.ly","sch.ly","med.ly","org.ly","id.ly","ma","co.ma","net.ma","gov.ma","org.ma","ac.ma","press.ma","mc","tm.mc","asso.mc","md","me","co.me","net.me","org.me","edu.me","ac.me","gov.me","its.me","priv.me","mg","org.mg","nom.mg","gov.mg","prd.mg","tm.mg","edu.mg","mil.mg","com.mg","co.mg","mh","mil","mk","com.mk","org.mk","net.mk","edu.mk","gov.mk","inf.mk","name.mk","ml","com.ml","edu.ml","gouv.ml","gov.ml","net.ml","org.ml","presse.ml","*.mm","mn","gov.mn","edu.mn","org.mn","mo","com.mo","net.mo","org.mo","edu.mo","gov.mo","mobi","mp","mq","mr","gov.mr","ms","com.ms","edu.ms","gov.ms","net.ms","org.ms","mt","com.mt","edu.mt","net.mt","org.mt","mu","com.mu","net.mu","org.mu","gov.mu","ac.mu","co.mu","or.mu","museum","academy.museum","agriculture.museum","air.museum","airguard.museum","alabama.museum","alaska.museum","amber.museum","ambulance.museum","american.museum","americana.museum","americanantiques.museum","americanart.museum","amsterdam.museum","and.museum","annefrank.museum","anthro.museum","anthropology.museum","antiques.museum","aquarium.museum","arboretum.museum","archaeological.museum","archaeology.museum","architecture.museum","art.museum","artanddesign.museum","artcenter.museum","artdeco.museum","arteducation.museum","artgallery.museum","arts.museum","artsandcrafts.museum","asmatart.museum","assassination.museum","assisi.museum","association.museum","astronomy.museum","atlanta.museum","austin.museum","australia.museum","automotive.museum","aviation.museum","axis.museum","badajoz.museum","baghdad.museum","bahn.museum","bale.museum","baltimore.museum","barcelona.museum","baseball.museum","basel.museum","baths.museum","bauern.museum","beauxarts.museum","beeldengeluid.museum","bellevue.museum","bergbau.museum","berkeley.museum","berlin.museum","bern.museum","bible.museum","bilbao.museum","bill.museum","birdart.museum","birthplace.museum","bonn.museum","boston.museum","botanical.museum","botanicalgarden.museum","botanicgarden.museum","botany.museum","brandywinevalley.museum","brasil.museum","bristol.museum","british.museum","britishcolumbia.museum","broadcast.museum","brunel.museum","brussel.museum","brussels.museum","bruxelles.museum","building.museum","burghof.museum","bus.museum","bushey.museum","cadaques.museum","california.museum","cambridge.museum","can.museum","canada.museum","capebreton.museum","carrier.museum","cartoonart.museum","casadelamoneda.museum","castle.museum","castres.museum","celtic.museum","center.museum","chattanooga.museum","cheltenham.museum","chesapeakebay.museum","chicago.museum","children.museum","childrens.museum","childrensgarden.museum","chiropractic.museum","chocolate.museum","christiansburg.museum","cincinnati.museum","cinema.museum","circus.museum","civilisation.museum","civilization.museum","civilwar.museum","clinton.museum","clock.museum","coal.museum","coastaldefence.museum","cody.museum","coldwar.museum","collection.museum","colonialwilliamsburg.museum","coloradoplateau.museum","columbia.museum","columbus.museum","communication.museum","communications.museum","community.museum","computer.museum","computerhistory.museum","comunicações.museum","contemporary.museum","contemporaryart.museum","convent.museum","copenhagen.museum","corporation.museum","correios-e-telecomunicações.museum","corvette.museum","costume.museum","countryestate.museum","county.museum","crafts.museum","cranbrook.museum","creation.museum","cultural.museum","culturalcenter.museum","culture.museum","cyber.museum","cymru.museum","dali.museum","dallas.museum","database.museum","ddr.museum","decorativearts.museum","delaware.museum","delmenhorst.museum","denmark.museum","depot.museum","design.museum","detroit.museum","dinosaur.museum","discovery.museum","dolls.museum","donostia.museum","durham.museum","eastafrica.museum","eastcoast.museum","education.museum","educational.museum","egyptian.museum","eisenbahn.museum","elburg.museum","elvendrell.museum","embroidery.museum","encyclopedic.museum","england.museum","entomology.museum","environment.museum","environmentalconservation.museum","epilepsy.museum","essex.museum","estate.museum","ethnology.museum","exeter.museum","exhibition.museum","family.museum","farm.museum","farmequipment.museum","farmers.museum","farmstead.museum","field.museum","figueres.museum","filatelia.museum","film.museum","fineart.museum","finearts.museum","finland.museum","flanders.museum","florida.museum","force.museum","fortmissoula.museum","fortworth.museum","foundation.museum","francaise.museum","frankfurt.museum","franziskaner.museum","freemasonry.museum","freiburg.museum","fribourg.museum","frog.museum","fundacio.museum","furniture.museum","gallery.museum","garden.museum","gateway.museum","geelvinck.museum","gemological.museum","geology.museum","georgia.museum","giessen.museum","glas.museum","glass.museum","gorge.museum","grandrapids.museum","graz.museum","guernsey.museum","halloffame.museum","hamburg.museum","handson.museum","harvestcelebration.museum","hawaii.museum","health.museum","heimatunduhren.museum","hellas.museum","helsinki.museum","hembygdsforbund.museum","heritage.museum","histoire.museum","historical.museum","historicalsociety.museum","historichouses.museum","historisch.museum","historisches.museum","history.museum","historyofscience.museum","horology.museum","house.museum","humanities.museum","illustration.museum","imageandsound.museum","indian.museum","indiana.museum","indianapolis.museum","indianmarket.museum","intelligence.museum","interactive.museum","iraq.museum","iron.museum","isleofman.museum","jamison.museum","jefferson.museum","jerusalem.museum","jewelry.museum","jewish.museum","jewishart.museum","jfk.museum","journalism.museum","judaica.museum","judygarland.museum","juedisches.museum","juif.museum","karate.museum","karikatur.museum","kids.museum","koebenhavn.museum","koeln.museum","kunst.museum","kunstsammlung.museum","kunstunddesign.museum","labor.museum","labour.museum","lajolla.museum","lancashire.museum","landes.museum","lans.museum","läns.museum","larsson.museum","lewismiller.museum","lincoln.museum","linz.museum","living.museum","livinghistory.museum","localhistory.museum","london.museum","losangeles.museum","louvre.museum","loyalist.museum","lucerne.museum","luxembourg.museum","luzern.museum","mad.museum","madrid.museum","mallorca.museum","manchester.museum","mansion.museum","mansions.museum","manx.museum","marburg.museum","maritime.museum","maritimo.museum","maryland.museum","marylhurst.museum","media.museum","medical.museum","medizinhistorisches.museum","meeres.museum","memorial.museum","mesaverde.museum","michigan.museum","midatlantic.museum","military.museum","mill.museum","miners.museum","mining.museum","minnesota.museum","missile.museum","missoula.museum","modern.museum","moma.museum","money.museum","monmouth.museum","monticello.museum","montreal.museum","moscow.museum","motorcycle.museum","muenchen.museum","muenster.museum","mulhouse.museum","muncie.museum","museet.museum","museumcenter.museum","museumvereniging.museum","music.museum","national.museum","nationalfirearms.museum","nationalheritage.museum","nativeamerican.museum","naturalhistory.museum","naturalhistorymuseum.museum","naturalsciences.museum","nature.museum","naturhistorisches.museum","natuurwetenschappen.museum","naumburg.museum","naval.museum","nebraska.museum","neues.museum","newhampshire.museum","newjersey.museum","newmexico.museum","newport.museum","newspaper.museum","newyork.museum","niepce.museum","norfolk.museum","north.museum","nrw.museum","nuernberg.museum","nuremberg.museum","nyc.museum","nyny.museum","oceanographic.museum","oceanographique.museum","omaha.museum","online.museum","ontario.museum","openair.museum","oregon.museum","oregontrail.museum","otago.museum","oxford.museum","pacific.museum","paderborn.museum","palace.museum","paleo.museum","palmsprings.museum","panama.museum","paris.museum","pasadena.museum","pharmacy.museum","philadelphia.museum","philadelphiaarea.museum","philately.museum","phoenix.museum","photography.museum","pilots.museum","pittsburgh.museum","planetarium.museum","plantation.museum","plants.museum","plaza.museum","portal.museum","portland.museum","portlligat.museum","posts-and-telecommunications.museum","preservation.museum","presidio.museum","press.museum","project.museum","public.museum","pubol.museum","quebec.museum","railroad.museum","railway.museum","research.museum","resistance.museum","riodejaneiro.museum","rochester.museum","rockart.museum","roma.museum","russia.museum","saintlouis.museum","salem.museum","salvadordali.museum","salzburg.museum","sandiego.museum","sanfrancisco.museum","santabarbara.museum","santacruz.museum","santafe.museum","saskatchewan.museum","satx.museum","savannahga.museum","schlesisches.museum","schoenbrunn.museum","schokoladen.museum","school.museum","schweiz.museum","science.museum","scienceandhistory.museum","scienceandindustry.museum","sciencecenter.museum","sciencecenters.museum","science-fiction.museum","sciencehistory.museum","sciences.museum","sciencesnaturelles.museum","scotland.museum","seaport.museum","settlement.museum","settlers.museum","shell.museum","sherbrooke.museum","sibenik.museum","silk.museum","ski.museum","skole.museum","society.museum","sologne.museum","soundandvision.museum","southcarolina.museum","southwest.museum","space.museum","spy.museum","square.museum","stadt.museum","stalbans.museum","starnberg.museum","state.museum","stateofdelaware.museum","station.museum","steam.museum","steiermark.museum","stjohn.museum","stockholm.museum","stpetersburg.museum","stuttgart.museum","suisse.museum","surgeonshall.museum","surrey.museum","svizzera.museum","sweden.museum","sydney.museum","tank.museum","tcm.museum","technology.museum","telekommunikation.museum","television.museum","texas.museum","textile.museum","theater.museum","time.museum","timekeeping.museum","topology.museum","torino.museum","touch.museum","town.museum","transport.museum","tree.museum","trolley.museum","trust.museum","trustee.museum","uhren.museum","ulm.museum","undersea.museum","university.museum","usa.museum","usantiques.museum","usarts.museum","uscountryestate.museum","usculture.museum","usdecorativearts.museum","usgarden.museum","ushistory.museum","ushuaia.museum","uslivinghistory.museum","utah.museum","uvic.museum","valley.museum","vantaa.museum","versailles.museum","viking.museum","village.museum","virginia.museum","virtual.museum","virtuel.museum","vlaanderen.museum","volkenkunde.museum","wales.museum","wallonie.museum","war.museum","washingtondc.museum","watchandclock.museum","watch-and-clock.museum","western.museum","westfalen.museum","whaling.museum","wildlife.museum","williamsburg.museum","windmill.museum","workshop.museum","york.museum","yorkshire.museum","yosemite.museum","youth.museum","zoological.museum","zoology.museum","ירושלים.museum","иком.museum","mv","aero.mv","biz.mv","com.mv","coop.mv","edu.mv","gov.mv","info.mv","int.mv","mil.mv","museum.mv","name.mv","net.mv","org.mv","pro.mv","mw","ac.mw","biz.mw","co.mw","com.mw","coop.mw","edu.mw","gov.mw","int.mw","museum.mw","net.mw","org.mw","mx","com.mx","org.mx","gob.mx","edu.mx","net.mx","my","com.my","net.my","org.my","gov.my","edu.my","mil.my","name.my","mz","ac.mz","adv.mz","co.mz","edu.mz","gov.mz","mil.mz","net.mz","org.mz","na","info.na","pro.na","name.na","school.na","or.na","dr.na","us.na","mx.na","ca.na","in.na","cc.na","tv.na","ws.na","mobi.na","co.na","com.na","org.na","name","nc","asso.nc","nom.nc","ne","net","nf","com.nf","net.nf","per.nf","rec.nf","web.nf","arts.nf","firm.nf","info.nf","other.nf","store.nf","ng","com.ng","edu.ng","gov.ng","i.ng","mil.ng","mobi.ng","name.ng","net.ng","org.ng","sch.ng","ni","ac.ni","biz.ni","co.ni","com.ni","edu.ni","gob.ni","in.ni","info.ni","int.ni","mil.ni","net.ni","nom.ni","org.ni","web.ni","nl","bv.nl","no","fhs.no","vgs.no","fylkesbibl.no","folkebibl.no","museum.no","idrett.no","priv.no","mil.no","stat.no","dep.no","kommune.no","herad.no","aa.no","ah.no","bu.no","fm.no","hl.no","hm.no","jan-mayen.no","mr.no","nl.no","nt.no","of.no","ol.no","oslo.no","rl.no","sf.no","st.no","svalbard.no","tm.no","tr.no","va.no","vf.no","gs.aa.no","gs.ah.no","gs.bu.no","gs.fm.no","gs.hl.no","gs.hm.no","gs.jan-mayen.no","gs.mr.no","gs.nl.no","gs.nt.no","gs.of.no","gs.ol.no","gs.oslo.no","gs.rl.no","gs.sf.no","gs.st.no","gs.svalbard.no","gs.tm.no","gs.tr.no","gs.va.no","gs.vf.no","akrehamn.no","åkrehamn.no","algard.no","ålgård.no","arna.no","brumunddal.no","bryne.no","bronnoysund.no","brønnøysund.no","drobak.no","drøbak.no","egersund.no","fetsund.no","floro.no","florø.no","fredrikstad.no","hokksund.no","honefoss.no","hønefoss.no","jessheim.no","jorpeland.no","jørpeland.no","kirkenes.no","kopervik.no","krokstadelva.no","langevag.no","langevåg.no","leirvik.no","mjondalen.no","mjøndalen.no","mo-i-rana.no","mosjoen.no","mosjøen.no","nesoddtangen.no","orkanger.no","osoyro.no","osøyro.no","raholt.no","råholt.no","sandnessjoen.no","sandnessjøen.no","skedsmokorset.no","slattum.no","spjelkavik.no","stathelle.no","stavern.no","stjordalshalsen.no","stjørdalshalsen.no","tananger.no","tranby.no","vossevangen.no","afjord.no","åfjord.no","agdenes.no","al.no","ål.no","alesund.no","ålesund.no","alstahaug.no","alta.no","áltá.no","alaheadju.no","álaheadju.no","alvdal.no","amli.no","åmli.no","amot.no","åmot.no","andebu.no","andoy.no","andøy.no","andasuolo.no","ardal.no","årdal.no","aremark.no","arendal.no","ås.no","aseral.no","åseral.no","asker.no","askim.no","askvoll.no","askoy.no","askøy.no","asnes.no","åsnes.no","audnedaln.no","aukra.no","aure.no","aurland.no","aurskog-holand.no","aurskog-høland.no","austevoll.no","austrheim.no","averoy.no","averøy.no","balestrand.no","ballangen.no","balat.no","bálát.no","balsfjord.no","bahccavuotna.no","báhccavuotna.no","bamble.no","bardu.no","beardu.no","beiarn.no","bajddar.no","bájddar.no","baidar.no","báidár.no","berg.no","bergen.no","berlevag.no","berlevåg.no","bearalvahki.no","bearalváhki.no","bindal.no","birkenes.no","bjarkoy.no","bjarkøy.no","bjerkreim.no","bjugn.no","bodo.no","bodø.no","badaddja.no","bådåddjå.no","budejju.no","bokn.no","bremanger.no","bronnoy.no","brønnøy.no","bygland.no","bykle.no","barum.no","bærum.no","bo.telemark.no","bø.telemark.no","bo.nordland.no","bø.nordland.no","bievat.no","bievát.no","bomlo.no","bømlo.no","batsfjord.no","båtsfjord.no","bahcavuotna.no","báhcavuotna.no","dovre.no","drammen.no","drangedal.no","dyroy.no","dyrøy.no","donna.no","dønna.no","eid.no","eidfjord.no","eidsberg.no","eidskog.no","eidsvoll.no","eigersund.no","elverum.no","enebakk.no","engerdal.no","etne.no","etnedal.no","evenes.no","evenassi.no","evenášši.no","evje-og-hornnes.no","farsund.no","fauske.no","fuossko.no","fuoisku.no","fedje.no","fet.no","finnoy.no","finnøy.no","fitjar.no","fjaler.no","fjell.no","flakstad.no","flatanger.no","flekkefjord.no","flesberg.no","flora.no","fla.no","flå.no","folldal.no","forsand.no","fosnes.no","frei.no","frogn.no","froland.no","frosta.no","frana.no","fræna.no","froya.no","frøya.no","fusa.no","fyresdal.no","forde.no","førde.no","gamvik.no","gangaviika.no","gáŋgaviika.no","gaular.no","gausdal.no","gildeskal.no","gildeskål.no","giske.no","gjemnes.no","gjerdrum.no","gjerstad.no","gjesdal.no","gjovik.no","gjøvik.no","gloppen.no","gol.no","gran.no","grane.no","granvin.no","gratangen.no","grimstad.no","grong.no","kraanghke.no","kråanghke.no","grue.no","gulen.no","hadsel.no","halden.no","halsa.no","hamar.no","hamaroy.no","habmer.no","hábmer.no","hapmir.no","hápmir.no","hammerfest.no","hammarfeasta.no","hámmárfeasta.no","haram.no","hareid.no","harstad.no","hasvik.no","aknoluokta.no","ákŋoluokta.no","hattfjelldal.no","aarborte.no","haugesund.no","hemne.no","hemnes.no","hemsedal.no","heroy.more-og-romsdal.no","herøy.møre-og-romsdal.no","heroy.nordland.no","herøy.nordland.no","hitra.no","hjartdal.no","hjelmeland.no","hobol.no","hobøl.no","hof.no","hol.no","hole.no","holmestrand.no","holtalen.no","holtålen.no","hornindal.no","horten.no","hurdal.no","hurum.no","hvaler.no","hyllestad.no","hagebostad.no","hægebostad.no","hoyanger.no","høyanger.no","hoylandet.no","høylandet.no","ha.no","hå.no","ibestad.no","inderoy.no","inderøy.no","iveland.no","jevnaker.no","jondal.no","jolster.no","jølster.no","karasjok.no","karasjohka.no","kárášjohka.no","karlsoy.no","galsa.no","gálsá.no","karmoy.no","karmøy.no","kautokeino.no","guovdageaidnu.no","klepp.no","klabu.no","klæbu.no","kongsberg.no","kongsvinger.no","kragero.no","kragerø.no","kristiansand.no","kristiansund.no","krodsherad.no","krødsherad.no","kvalsund.no","rahkkeravju.no","ráhkkerávju.no","kvam.no","kvinesdal.no","kvinnherad.no","kviteseid.no","kvitsoy.no","kvitsøy.no","kvafjord.no","kvæfjord.no","giehtavuoatna.no","kvanangen.no","kvænangen.no","navuotna.no","návuotna.no","kafjord.no","kåfjord.no","gaivuotna.no","gáivuotna.no","larvik.no","lavangen.no","lavagis.no","loabat.no","loabát.no","lebesby.no","davvesiida.no","leikanger.no","leirfjord.no","leka.no","leksvik.no","lenvik.no","leangaviika.no","leaŋgaviika.no","lesja.no","levanger.no","lier.no","lierne.no","lillehammer.no","lillesand.no","lindesnes.no","lindas.no","lindås.no","lom.no","loppa.no","lahppi.no","láhppi.no","lund.no","lunner.no","luroy.no","lurøy.no","luster.no","lyngdal.no","lyngen.no","ivgu.no","lardal.no","lerdal.no","lærdal.no","lodingen.no","lødingen.no","lorenskog.no","lørenskog.no","loten.no","løten.no","malvik.no","masoy.no","måsøy.no","muosat.no","muosát.no","mandal.no","marker.no","marnardal.no","masfjorden.no","meland.no","meldal.no","melhus.no","meloy.no","meløy.no","meraker.no","meråker.no","moareke.no","moåreke.no","midsund.no","midtre-gauldal.no","modalen.no","modum.no","molde.no","moskenes.no","moss.no","mosvik.no","malselv.no","målselv.no","malatvuopmi.no","málatvuopmi.no","namdalseid.no","aejrie.no","namsos.no","namsskogan.no","naamesjevuemie.no","nååmesjevuemie.no","laakesvuemie.no","nannestad.no","narvik.no","narviika.no","naustdal.no","nedre-eiker.no","nes.akershus.no","nes.buskerud.no","nesna.no","nesodden.no","nesseby.no","unjarga.no","unjárga.no","nesset.no","nissedal.no","nittedal.no","nord-aurdal.no","nord-fron.no","nord-odal.no","norddal.no","nordkapp.no","davvenjarga.no","davvenjárga.no","nordre-land.no","nordreisa.no","raisa.no","ráisa.no","nore-og-uvdal.no","notodden.no","naroy.no","nærøy.no","notteroy.no","nøtterøy.no","odda.no","oksnes.no","øksnes.no","oppdal.no","oppegard.no","oppegård.no","orkdal.no","orland.no","ørland.no","orskog.no","ørskog.no","orsta.no","ørsta.no","os.hedmark.no","os.hordaland.no","osen.no","osteroy.no","osterøy.no","ostre-toten.no","østre-toten.no","overhalla.no","ovre-eiker.no","øvre-eiker.no","oyer.no","øyer.no","oygarden.no","øygarden.no","oystre-slidre.no","øystre-slidre.no","porsanger.no","porsangu.no","porsáŋgu.no","porsgrunn.no","radoy.no","radøy.no","rakkestad.no","rana.no","ruovat.no","randaberg.no","rauma.no","rendalen.no","rennebu.no","rennesoy.no","rennesøy.no","rindal.no","ringebu.no","ringerike.no","ringsaker.no","rissa.no","risor.no","risør.no","roan.no","rollag.no","rygge.no","ralingen.no","rælingen.no","rodoy.no","rødøy.no","romskog.no","rømskog.no","roros.no","røros.no","rost.no","røst.no","royken.no","røyken.no","royrvik.no","røyrvik.no","rade.no","råde.no","salangen.no","siellak.no","saltdal.no","salat.no","sálát.no","sálat.no","samnanger.no","sande.more-og-romsdal.no","sande.møre-og-romsdal.no","sande.vestfold.no","sandefjord.no","sandnes.no","sandoy.no","sandøy.no","sarpsborg.no","sauda.no","sauherad.no","sel.no","selbu.no","selje.no","seljord.no","sigdal.no","siljan.no","sirdal.no","skaun.no","skedsmo.no","ski.no","skien.no","skiptvet.no","skjervoy.no","skjervøy.no","skierva.no","skiervá.no","skjak.no","skjåk.no","skodje.no","skanland.no","skånland.no","skanit.no","skánit.no","smola.no","smøla.no","snillfjord.no","snasa.no","snåsa.no","snoasa.no","snaase.no","snåase.no","sogndal.no","sokndal.no","sola.no","solund.no","songdalen.no","sortland.no","spydeberg.no","stange.no","stavanger.no","steigen.no","steinkjer.no","stjordal.no","stjørdal.no","stokke.no","stor-elvdal.no","stord.no","stordal.no","storfjord.no","omasvuotna.no","strand.no","stranda.no","stryn.no","sula.no","suldal.no","sund.no","sunndal.no","surnadal.no","sveio.no","svelvik.no","sykkylven.no","sogne.no","søgne.no","somna.no","sømna.no","sondre-land.no","søndre-land.no","sor-aurdal.no","sør-aurdal.no","sor-fron.no","sør-fron.no","sor-odal.no","sør-odal.no","sor-varanger.no","sør-varanger.no","matta-varjjat.no","mátta-várjjat.no","sorfold.no","sørfold.no","sorreisa.no","sørreisa.no","sorum.no","sørum.no","tana.no","deatnu.no","time.no","tingvoll.no","tinn.no","tjeldsund.no","dielddanuorri.no","tjome.no","tjøme.no","tokke.no","tolga.no","torsken.no","tranoy.no","tranøy.no","tromso.no","tromsø.no","tromsa.no","romsa.no","trondheim.no","troandin.no","trysil.no","trana.no","træna.no","trogstad.no","trøgstad.no","tvedestrand.no","tydal.no","tynset.no","tysfjord.no","divtasvuodna.no","divttasvuotna.no","tysnes.no","tysvar.no","tysvær.no","tonsberg.no","tønsberg.no","ullensaker.no","ullensvang.no","ulvik.no","utsira.no","vadso.no","vadsø.no","cahcesuolo.no","čáhcesuolo.no","vaksdal.no","valle.no","vang.no","vanylven.no","vardo.no","vardø.no","varggat.no","várggát.no","vefsn.no","vaapste.no","vega.no","vegarshei.no","vegårshei.no","vennesla.no","verdal.no","verran.no","vestby.no","vestnes.no","vestre-slidre.no","vestre-toten.no","vestvagoy.no","vestvågøy.no","vevelstad.no","vik.no","vikna.no","vindafjord.no","volda.no","voss.no","varoy.no","værøy.no","vagan.no","vågan.no","voagat.no","vagsoy.no","vågsøy.no","vaga.no","vågå.no","valer.ostfold.no","våler.østfold.no","valer.hedmark.no","våler.hedmark.no","*.np","nr","biz.nr","info.nr","gov.nr","edu.nr","org.nr","net.nr","com.nr","nu","nz","ac.nz","co.nz","cri.nz","geek.nz","gen.nz","govt.nz","health.nz","iwi.nz","kiwi.nz","maori.nz","mil.nz","māori.nz","net.nz","org.nz","parliament.nz","school.nz","om","co.om","com.om","edu.om","gov.om","med.om","museum.om","net.om","org.om","pro.om","onion","org","pa","ac.pa","gob.pa","com.pa","org.pa","sld.pa","edu.pa","net.pa","ing.pa","abo.pa","med.pa","nom.pa","pe","edu.pe","gob.pe","nom.pe","mil.pe","org.pe","com.pe","net.pe","pf","com.pf","org.pf","edu.pf","*.pg","ph","com.ph","net.ph","org.ph","gov.ph","edu.ph","ngo.ph","mil.ph","i.ph","pk","com.pk","net.pk","edu.pk","org.pk","fam.pk","biz.pk","web.pk","gov.pk","gob.pk","gok.pk","gon.pk","gop.pk","gos.pk","info.pk","pl","com.pl","net.pl","org.pl","aid.pl","agro.pl","atm.pl","auto.pl","biz.pl","edu.pl","gmina.pl","gsm.pl","info.pl","mail.pl","miasta.pl","media.pl","mil.pl","nieruchomosci.pl","nom.pl","pc.pl","powiat.pl","priv.pl","realestate.pl","rel.pl","sex.pl","shop.pl","sklep.pl","sos.pl","szkola.pl","targi.pl","tm.pl","tourism.pl","travel.pl","turystyka.pl","gov.pl","ap.gov.pl","ic.gov.pl","is.gov.pl","us.gov.pl","kmpsp.gov.pl","kppsp.gov.pl","kwpsp.gov.pl","psp.gov.pl","wskr.gov.pl","kwp.gov.pl","mw.gov.pl","ug.gov.pl","um.gov.pl","umig.gov.pl","ugim.gov.pl","upow.gov.pl","uw.gov.pl","starostwo.gov.pl","pa.gov.pl","po.gov.pl","psse.gov.pl","pup.gov.pl","rzgw.gov.pl","sa.gov.pl","so.gov.pl","sr.gov.pl","wsa.gov.pl","sko.gov.pl","uzs.gov.pl","wiih.gov.pl","winb.gov.pl","pinb.gov.pl","wios.gov.pl","witd.gov.pl","wzmiuw.gov.pl","piw.gov.pl","wiw.gov.pl","griw.gov.pl","wif.gov.pl","oum.gov.pl","sdn.gov.pl","zp.gov.pl","uppo.gov.pl","mup.gov.pl","wuoz.gov.pl","konsulat.gov.pl","oirm.gov.pl","augustow.pl","babia-gora.pl","bedzin.pl","beskidy.pl","bialowieza.pl","bialystok.pl","bielawa.pl","bieszczady.pl","boleslawiec.pl","bydgoszcz.pl","bytom.pl","cieszyn.pl","czeladz.pl","czest.pl","dlugoleka.pl","elblag.pl","elk.pl","glogow.pl","gniezno.pl","gorlice.pl","grajewo.pl","ilawa.pl","jaworzno.pl","jelenia-gora.pl","jgora.pl","kalisz.pl","kazimierz-dolny.pl","karpacz.pl","kartuzy.pl","kaszuby.pl","katowice.pl","kepno.pl","ketrzyn.pl","klodzko.pl","kobierzyce.pl","kolobrzeg.pl","konin.pl","konskowola.pl","kutno.pl","lapy.pl","lebork.pl","legnica.pl","lezajsk.pl","limanowa.pl","lomza.pl","lowicz.pl","lubin.pl","lukow.pl","malbork.pl","malopolska.pl","mazowsze.pl","mazury.pl","mielec.pl","mielno.pl","mragowo.pl","naklo.pl","nowaruda.pl","nysa.pl","olawa.pl","olecko.pl","olkusz.pl","olsztyn.pl","opoczno.pl","opole.pl","ostroda.pl","ostroleka.pl","ostrowiec.pl","ostrowwlkp.pl","pila.pl","pisz.pl","podhale.pl","podlasie.pl","polkowice.pl","pomorze.pl","pomorskie.pl","prochowice.pl","pruszkow.pl","przeworsk.pl","pulawy.pl","radom.pl","rawa-maz.pl","rybnik.pl","rzeszow.pl","sanok.pl","sejny.pl","slask.pl","slupsk.pl","sosnowiec.pl","stalowa-wola.pl","skoczow.pl","starachowice.pl","stargard.pl","suwalki.pl","swidnica.pl","swiebodzin.pl","swinoujscie.pl","szczecin.pl","szczytno.pl","tarnobrzeg.pl","tgory.pl","turek.pl","tychy.pl","ustka.pl","walbrzych.pl","warmia.pl","warszawa.pl","waw.pl","wegrow.pl","wielun.pl","wlocl.pl","wloclawek.pl","wodzislaw.pl","wolomin.pl","wroclaw.pl","zachpomor.pl","zagan.pl","zarow.pl","zgora.pl","zgorzelec.pl","pm","pn","gov.pn","co.pn","org.pn","edu.pn","net.pn","post","pr","com.pr","net.pr","org.pr","gov.pr","edu.pr","isla.pr","pro.pr","biz.pr","info.pr","name.pr","est.pr","prof.pr","ac.pr","pro","aaa.pro","aca.pro","acct.pro","avocat.pro","bar.pro","cpa.pro","eng.pro","jur.pro","law.pro","med.pro","recht.pro","ps","edu.ps","gov.ps","sec.ps","plo.ps","com.ps","org.ps","net.ps","pt","net.pt","gov.pt","org.pt","edu.pt","int.pt","publ.pt","com.pt","nome.pt","pw","co.pw","ne.pw","or.pw","ed.pw","go.pw","belau.pw","py","com.py","coop.py","edu.py","gov.py","mil.py","net.py","org.py","qa","com.qa","edu.qa","gov.qa","mil.qa","name.qa","net.qa","org.qa","sch.qa","re","asso.re","com.re","nom.re","ro","arts.ro","com.ro","firm.ro","info.ro","nom.ro","nt.ro","org.ro","rec.ro","store.ro","tm.ro","www.ro","rs","ac.rs","co.rs","edu.rs","gov.rs","in.rs","org.rs","ru","ac.ru","edu.ru","gov.ru","int.ru","mil.ru","test.ru","rw","gov.rw","net.rw","edu.rw","ac.rw","com.rw","co.rw","int.rw","mil.rw","gouv.rw","sa","com.sa","net.sa","org.sa","gov.sa","med.sa","pub.sa","edu.sa","sch.sa","sb","com.sb","edu.sb","gov.sb","net.sb","org.sb","sc","com.sc","gov.sc","net.sc","org.sc","edu.sc","sd","com.sd","net.sd","org.sd","edu.sd","med.sd","tv.sd","gov.sd","info.sd","se","a.se","ac.se","b.se","bd.se","brand.se","c.se","d.se","e.se","f.se","fh.se","fhsk.se","fhv.se","g.se","h.se","i.se","k.se","komforb.se","kommunalforbund.se","komvux.se","l.se","lanbib.se","m.se","n.se","naturbruksgymn.se","o.se","org.se","p.se","parti.se","pp.se","press.se","r.se","s.se","t.se","tm.se","u.se","w.se","x.se","y.se","z.se","sg","com.sg","net.sg","org.sg","gov.sg","edu.sg","per.sg","sh","com.sh","net.sh","gov.sh","org.sh","mil.sh","si","sj","sk","sl","com.sl","net.sl","edu.sl","gov.sl","org.sl","sm","sn","art.sn","com.sn","edu.sn","gouv.sn","org.sn","perso.sn","univ.sn","so","com.so","net.so","org.so","sr","st","co.st","com.st","consulado.st","edu.st","embaixada.st","gov.st","mil.st","net.st","org.st","principe.st","saotome.st","store.st","su","sv","com.sv","edu.sv","gob.sv","org.sv","red.sv","sx","gov.sx","sy","edu.sy","gov.sy","net.sy","mil.sy","com.sy","org.sy","sz","co.sz","ac.sz","org.sz","tc","td","tel","tf","tg","th","ac.th","co.th","go.th","in.th","mi.th","net.th","or.th","tj","ac.tj","biz.tj","co.tj","com.tj","edu.tj","go.tj","gov.tj","int.tj","mil.tj","name.tj","net.tj","nic.tj","org.tj","test.tj","web.tj","tk","tl","gov.tl","tm","com.tm","co.tm","org.tm","net.tm","nom.tm","gov.tm","mil.tm","edu.tm","tn","com.tn","ens.tn","fin.tn","gov.tn","ind.tn","intl.tn","nat.tn","net.tn","org.tn","info.tn","perso.tn","tourism.tn","edunet.tn","rnrt.tn","rns.tn","rnu.tn","mincom.tn","agrinet.tn","defense.tn","turen.tn","to","com.to","gov.to","net.to","org.to","edu.to","mil.to","tr","com.tr","info.tr","biz.tr","net.tr","org.tr","web.tr","gen.tr","tv.tr","av.tr","dr.tr","bbs.tr","name.tr","tel.tr","gov.tr","bel.tr","pol.tr","mil.tr","k12.tr","edu.tr","kep.tr","nc.tr","gov.nc.tr","tt","co.tt","com.tt","org.tt","net.tt","biz.tt","info.tt","pro.tt","int.tt","coop.tt","jobs.tt","mobi.tt","travel.tt","museum.tt","aero.tt","name.tt","gov.tt","edu.tt","tv","tw","edu.tw","gov.tw","mil.tw","com.tw","net.tw","org.tw","idv.tw","game.tw","ebiz.tw","club.tw","網路.tw","組織.tw","商業.tw","tz","ac.tz","co.tz","go.tz","hotel.tz","info.tz","me.tz","mil.tz","mobi.tz","ne.tz","or.tz","sc.tz","tv.tz","ua","com.ua","edu.ua","gov.ua","in.ua","net.ua","org.ua","cherkassy.ua","cherkasy.ua","chernigov.ua","chernihiv.ua","chernivtsi.ua","chernovtsy.ua","ck.ua","cn.ua","cr.ua","crimea.ua","cv.ua","dn.ua","dnepropetrovsk.ua","dnipropetrovsk.ua","dominic.ua","donetsk.ua","dp.ua","if.ua","ivano-frankivsk.ua","kh.ua","kharkiv.ua","kharkov.ua","kherson.ua","khmelnitskiy.ua","khmelnytskyi.ua","kiev.ua","kirovograd.ua","km.ua","kr.ua","krym.ua","ks.ua","kv.ua","kyiv.ua","lg.ua","lt.ua","lugansk.ua","lutsk.ua","lv.ua","lviv.ua","mk.ua","mykolaiv.ua","nikolaev.ua","od.ua","odesa.ua","odessa.ua","pl.ua","poltava.ua","rivne.ua","rovno.ua","rv.ua","sb.ua","sebastopol.ua","sevastopol.ua","sm.ua","sumy.ua","te.ua","ternopil.ua","uz.ua","uzhgorod.ua","vinnica.ua","vinnytsia.ua","vn.ua","volyn.ua","yalta.ua","zaporizhzhe.ua","zaporizhzhia.ua","zhitomir.ua","zhytomyr.ua","zp.ua","zt.ua","ug","co.ug","or.ug","ac.ug","sc.ug","go.ug","ne.ug","com.ug","org.ug","uk","ac.uk","co.uk","gov.uk","ltd.uk","me.uk","net.uk","nhs.uk","org.uk","plc.uk","police.uk","*.sch.uk","us","dni.us","fed.us","isa.us","kids.us","nsn.us","ak.us","al.us","ar.us","as.us","az.us","ca.us","co.us","ct.us","dc.us","de.us","fl.us","ga.us","gu.us","hi.us","ia.us","id.us","il.us","in.us","ks.us","ky.us","la.us","ma.us","md.us","me.us","mi.us","mn.us","mo.us","ms.us","mt.us","nc.us","nd.us","ne.us","nh.us","nj.us","nm.us","nv.us","ny.us","oh.us","ok.us","or.us","pa.us","pr.us","ri.us","sc.us","sd.us","tn.us","tx.us","ut.us","vi.us","vt.us","va.us","wa.us","wi.us","wv.us","wy.us","k12.ak.us","k12.al.us","k12.ar.us","k12.as.us","k12.az.us","k12.ca.us","k12.co.us","k12.ct.us","k12.dc.us","k12.de.us","k12.fl.us","k12.ga.us","k12.gu.us","k12.ia.us","k12.id.us","k12.il.us","k12.in.us","k12.ks.us","k12.ky.us","k12.la.us","k12.ma.us","k12.md.us","k12.me.us","k12.mi.us","k12.mn.us","k12.mo.us","k12.ms.us","k12.mt.us","k12.nc.us","k12.ne.us","k12.nh.us","k12.nj.us","k12.nm.us","k12.nv.us","k12.ny.us","k12.oh.us","k12.ok.us","k12.or.us","k12.pa.us","k12.pr.us","k12.ri.us","k12.sc.us","k12.tn.us","k12.tx.us","k12.ut.us","k12.vi.us","k12.vt.us","k12.va.us","k12.wa.us","k12.wi.us","k12.wy.us","cc.ak.us","cc.al.us","cc.ar.us","cc.as.us","cc.az.us","cc.ca.us","cc.co.us","cc.ct.us","cc.dc.us","cc.de.us","cc.fl.us","cc.ga.us","cc.gu.us","cc.hi.us","cc.ia.us","cc.id.us","cc.il.us","cc.in.us","cc.ks.us","cc.ky.us","cc.la.us","cc.ma.us","cc.md.us","cc.me.us","cc.mi.us","cc.mn.us","cc.mo.us","cc.ms.us","cc.mt.us","cc.nc.us","cc.nd.us","cc.ne.us","cc.nh.us","cc.nj.us","cc.nm.us","cc.nv.us","cc.ny.us","cc.oh.us","cc.ok.us","cc.or.us","cc.pa.us","cc.pr.us","cc.ri.us","cc.sc.us","cc.sd.us","cc.tn.us","cc.tx.us","cc.ut.us","cc.vi.us","cc.vt.us","cc.va.us","cc.wa.us","cc.wi.us","cc.wv.us","cc.wy.us","lib.ak.us","lib.al.us","lib.ar.us","lib.as.us","lib.az.us","lib.ca.us","lib.co.us","lib.ct.us","lib.dc.us","lib.fl.us","lib.ga.us","lib.gu.us","lib.hi.us","lib.ia.us","lib.id.us","lib.il.us","lib.in.us","lib.ks.us","lib.ky.us","lib.la.us","lib.ma.us","lib.md.us","lib.me.us","lib.mi.us","lib.mn.us","lib.mo.us","lib.ms.us","lib.mt.us","lib.nc.us","lib.nd.us","lib.ne.us","lib.nh.us","lib.nj.us","lib.nm.us","lib.nv.us","lib.ny.us","lib.oh.us","lib.ok.us","lib.or.us","lib.pa.us","lib.pr.us","lib.ri.us","lib.sc.us","lib.sd.us","lib.tn.us","lib.tx.us","lib.ut.us","lib.vi.us","lib.vt.us","lib.va.us","lib.wa.us","lib.wi.us","lib.wy.us","pvt.k12.ma.us","chtr.k12.ma.us","paroch.k12.ma.us","ann-arbor.mi.us","cog.mi.us","dst.mi.us","eaton.mi.us","gen.mi.us","mus.mi.us","tec.mi.us","washtenaw.mi.us","uy","com.uy","edu.uy","gub.uy","mil.uy","net.uy","org.uy","uz","co.uz","com.uz","net.uz","org.uz","va","vc","com.vc","net.vc","org.vc","gov.vc","mil.vc","edu.vc","ve","arts.ve","co.ve","com.ve","e12.ve","edu.ve","firm.ve","gob.ve","gov.ve","info.ve","int.ve","mil.ve","net.ve","org.ve","rec.ve","store.ve","tec.ve","web.ve","vg","vi","co.vi","com.vi","k12.vi","net.vi","org.vi","vn","com.vn","net.vn","org.vn","edu.vn","gov.vn","int.vn","ac.vn","biz.vn","info.vn","name.vn","pro.vn","health.vn","vu","com.vu","edu.vu","net.vu","org.vu","wf","ws","com.ws","net.ws","org.ws","gov.ws","edu.ws","yt","امارات","հայ","বাংলা","бг","бел","中国","中國","الجزائر","مصر","ею","გე","ελ","香港","公司.香港","教育.香港","政府.香港","個人.香港","網絡.香港","組織.香港","ಭಾರತ","ଭାରତ","ভাৰত","भारतम्","भारोत","ڀارت","ഭാരതം","भारत","بارت","بھارت","భారత్","ભારત","ਭਾਰਤ","ভারত","இந்தியா","ایران","ايران","عراق","الاردن","한국","қаз","ලංකා","இலங்கை","المغرب","мкд","мон","澳門","澳门","مليسيا","عمان","پاکستان","پاكستان","فلسطين","срб","пр.срб","орг.срб","обр.срб","од.срб","упр.срб","ак.срб","рф","قطر","السعودية","السعودیة","السعودیۃ","السعوديه","سودان","新加坡","சிங்கப்பூர்","سورية","سوريا","ไทย","ศึกษา.ไทย","ธุรกิจ.ไทย","รัฐบาล.ไทย","ทหาร.ไทย","เน็ต.ไทย","องค์กร.ไทย","تونس","台灣","台湾","臺灣","укр","اليمن","xxx","*.ye","ac.za","agric.za","alt.za","co.za","edu.za","gov.za","grondar.za","law.za","mil.za","net.za","ngo.za","nis.za","nom.za","org.za","school.za","tm.za","web.za","zm","ac.zm","biz.zm","co.zm","com.zm","edu.zm","gov.zm","info.zm","mil.zm","net.zm","org.zm","sch.zm","zw","ac.zw","co.zw","gov.zw","mil.zw","org.zw","aaa","aarp","abarth","abb","abbott","abbvie","abc","able","abogado","abudhabi","academy","accenture","accountant","accountants","aco","active","actor","adac","ads","adult","aeg","aetna","afamilycompany","afl","africa","agakhan","agency","aig","aigo","airbus","airforce","airtel","akdn","alfaromeo","alibaba","alipay","allfinanz","allstate","ally","alsace","alstom","americanexpress","americanfamily","amex","amfam","amica","amsterdam","analytics","android","anquan","anz","aol","apartments","app","apple","aquarelle","arab","aramco","archi","army","art","arte","asda","associates","athleta","attorney","auction","audi","audible","audio","auspost","author","auto","autos","avianca","aws","axa","azure","baby","baidu","banamex","bananarepublic","band","bank","bar","barcelona","barclaycard","barclays","barefoot","bargains","baseball","basketball","bauhaus","bayern","bbc","bbt","bbva","bcg","bcn","beats","beauty","beer","bentley","berlin","best","bestbuy","bet","bharti","bible","bid","bike","bing","bingo","bio","black","blackfriday","blanco","blockbuster","blog","bloomberg","blue","bms","bmw","bnl","bnpparibas","boats","boehringer","bofa","bom","bond","boo","book","booking","bosch","bostik","boston","bot","boutique","box","bradesco","bridgestone","broadway","broker","brother","brussels","budapest","bugatti","build","builders","business","buy","buzz","bzh","cab","cafe","cal","call","calvinklein","cam","camera","camp","cancerresearch","canon","capetown","capital","capitalone","car","caravan","cards","care","career","careers","cars","cartier","casa","case","caseih","cash","casino","catering","catholic","cba","cbn","cbre","cbs","ceb","center","ceo","cern","cfa","cfd","chanel","channel","charity","chase","chat","cheap","chintai","christmas","chrome","chrysler","church","cipriani","circle","cisco","citadel","citi","citic","city","cityeats","claims","cleaning","click","clinic","clinique","clothing","cloud","club","clubmed","coach","codes","coffee","college","cologne","comcast","commbank","community","company","compare","computer","comsec","condos","construction","consulting","contact","contractors","cooking","cookingchannel","cool","corsica","country","coupon","coupons","courses","credit","creditcard","creditunion","cricket","crown","crs","cruise","cruises","csc","cuisinella","cymru","cyou","dabur","dad","dance","data","date","dating","datsun","day","dclk","dds","deal","dealer","deals","degree","delivery","dell","deloitte","delta","democrat","dental","dentist","desi","design","dev","dhl","diamonds","diet","digital","direct","directory","discount","discover","dish","diy","dnp","docs","doctor","dodge","dog","doha","domains","dot","download","drive","dtv","dubai","duck","dunlop","duns","dupont","durban","dvag","dvr","earth","eat","eco","edeka","education","email","emerck","energy","engineer","engineering","enterprises","epost","epson","equipment","ericsson","erni","esq","estate","esurance","etisalat","eurovision","eus","events","everbank","exchange","expert","exposed","express","extraspace","fage","fail","fairwinds","faith","family","fan","fans","farm","farmers","fashion","fast","fedex","feedback","ferrari","ferrero","fiat","fidelity","fido","film","final","finance","financial","fire","firestone","firmdale","fish","fishing","fit","fitness","flickr","flights","flir","florist","flowers","fly","foo","food","foodnetwork","football","ford","forex","forsale","forum","foundation","fox","free","fresenius","frl","frogans","frontdoor","frontier","ftr","fujitsu","fujixerox","fun","fund","furniture","futbol","fyi","gal","gallery","gallo","gallup","game","games","gap","garden","gbiz","gdn","gea","gent","genting","george","ggee","gift","gifts","gives","giving","glade","glass","gle","global","globo","gmail","gmbh","gmo","gmx","godaddy","gold","goldpoint","golf","goo","goodyear","goog","google","gop","got","grainger","graphics","gratis","green","gripe","grocery","group","guardian","gucci","guge","guide","guitars","guru","hair","hamburg","hangout","haus","hbo","hdfc","hdfcbank","health","healthcare","help","helsinki","here","hermes","hgtv","hiphop","hisamitsu","hitachi","hiv","hkt","hockey","holdings","holiday","homedepot","homegoods","homes","homesense","honda","honeywell","horse","hospital","host","hosting","hot","hoteles","hotels","hotmail","house","how","hsbc","hughes","hyatt","hyundai","ibm","icbc","ice","icu","ieee","ifm","ikano","imamat","imdb","immo","immobilien","inc","industries","infiniti","ing","ink","institute","insurance","insure","intel","international","intuit","investments","ipiranga","irish","iselect","ismaili","ist","istanbul","itau","itv","iveco","jaguar","java","jcb","jcp","jeep","jetzt","jewelry","jio","jll","jmp","jnj","joburg","jot","joy","jpmorgan","jprs","juegos","juniper","kaufen","kddi","kerryhotels","kerrylogistics","kerryproperties","kfh","kia","kim","kinder","kindle","kitchen","kiwi","koeln","komatsu","kosher","kpmg","kpn","krd","kred","kuokgroup","kyoto","lacaixa","ladbrokes","lamborghini","lamer","lancaster","lancia","lancome","land","landrover","lanxess","lasalle","lat","latino","latrobe","law","lawyer","lds","lease","leclerc","lefrak","legal","lego","lexus","lgbt","liaison","lidl","life","lifeinsurance","lifestyle","lighting","like","lilly","limited","limo","lincoln","linde","link","lipsy","live","living","lixil","llc","loan","loans","locker","locus","loft","lol","london","lotte","lotto","love","lpl","lplfinancial","ltd","ltda","lundbeck","lupin","luxe","luxury","macys","madrid","maif","maison","makeup","man","management","mango","map","market","marketing","markets","marriott","marshalls","maserati","mattel","mba","mckinsey","med","media","meet","melbourne","meme","memorial","men","menu","merckmsd","metlife","miami","microsoft","mini","mint","mit","mitsubishi","mlb","mls","mma","mobile","mobily","moda","moe","moi","mom","monash","money","monster","mopar","mormon","mortgage","moscow","moto","motorcycles","mov","movie","movistar","msd","mtn","mtr","mutual","nab","nadex","nagoya","nationwide","natura","navy","nba","nec","netbank","netflix","network","neustar","new","newholland","news","next","nextdirect","nexus","nfl","ngo","nhk","nico","nike","nikon","ninja","nissan","nissay","nokia","northwesternmutual","norton","now","nowruz","nowtv","nra","nrw","ntt","nyc","obi","observer","off","office","okinawa","olayan","olayangroup","oldnavy","ollo","omega","one","ong","onl","online","onyourside","ooo","open","oracle","orange","organic","origins","osaka","otsuka","ott","ovh","page","panasonic","paris","pars","partners","parts","party","passagens","pay","pccw","pet","pfizer","pharmacy","phd","philips","phone","photo","photography","photos","physio","piaget","pics","pictet","pictures","pid","pin","ping","pink","pioneer","pizza","place","play","playstation","plumbing","plus","pnc","pohl","poker","politie","porn","pramerica","praxi","press","prime","prod","productions","prof","progressive","promo","properties","property","protection","pru","prudential","pub","pwc","qpon","quebec","quest","qvc","racing","radio","raid","read","realestate","realtor","realty","recipes","red","redstone","redumbrella","rehab","reise","reisen","reit","reliance","ren","rent","rentals","repair","report","republican","rest","restaurant","review","reviews","rexroth","rich","richardli","ricoh","rightathome","ril","rio","rip","rmit","rocher","rocks","rodeo","rogers","room","rsvp","rugby","ruhr","run","rwe","ryukyu","saarland","safe","safety","sakura","sale","salon","samsclub","samsung","sandvik","sandvikcoromant","sanofi","sap","sarl","sas","save","saxo","sbi","sbs","sca","scb","schaeffler","schmidt","scholarships","school","schule","schwarz","science","scjohnson","scor","scot","search","seat","secure","security","seek","select","sener","services","ses","seven","sew","sex","sexy","sfr","shangrila","sharp","shaw","shell","shia","shiksha","shoes","shop","shopping","shouji","show","showtime","shriram","silk","sina","singles","site","ski","skin","sky","skype","sling","smart","smile","sncf","soccer","social","softbank","software","sohu","solar","solutions","song","sony","soy","space","spiegel","sport","spot","spreadbetting","srl","srt","stada","staples","star","starhub","statebank","statefarm","statoil","stc","stcgroup","stockholm","storage","store","stream","studio","study","style","sucks","supplies","supply","support","surf","surgery","suzuki","swatch","swiftcover","swiss","sydney","symantec","systems","tab","taipei","talk","taobao","target","tatamotors","tatar","tattoo","tax","taxi","tci","tdk","team","tech","technology","telefonica","temasek","tennis","teva","thd","theater","theatre","tiaa","tickets","tienda","tiffany","tips","tires","tirol","tjmaxx","tjx","tkmaxx","tmall","today","tokyo","tools","top","toray","toshiba","total","tours","town","toyota","toys","trade","trading","training","travel","travelchannel","travelers","travelersinsurance","trust","trv","tube","tui","tunes","tushu","tvs","ubank","ubs","uconnect","unicom","university","uno","uol","ups","vacations","vana","vanguard","vegas","ventures","verisign","versicherung","vet","viajes","video","vig","viking","villas","vin","vip","virgin","visa","vision","vistaprint","viva","vivo","vlaanderen","vodka","volkswagen","volvo","vote","voting","voto","voyage","vuelos","wales","walmart","walter","wang","wanggou","warman","watch","watches","weather","weatherchannel","webcam","weber","website","wed","wedding","weibo","weir","whoswho","wien","wiki","williamhill","win","windows","wine","winners","wme","wolterskluwer","woodside","work","works","world","wow","wtc","wtf","xbox","xerox","xfinity","xihuan","xin","कॉम","セール","佛山","慈善","集团","在线","大众汽车","点看","คอม","八卦","موقع","公益","公司","香格里拉","网站","移动","我爱你","москва","католик","онлайн","сайт","联通","קום","时尚","微博","淡马锡","ファッション","орг","नेट","ストア","삼성","商标","商店","商城","дети","ポイント","新闻","工行","家電","كوم","中文网","中信","娱乐","谷歌","電訊盈科","购物","クラウド","通販","网店","संगठन","餐厅","网络","ком","诺基亚","食品","飞利浦","手表","手机","ارامكو","العليان","اتصالات","بازار","موبايلي","ابوظبي","كاثوليك","همراه","닷컴","政府","شبكة","بيتك","عرب","机构","组织机构","健康","招聘","рус","珠宝","大拿","みんな","グーグル","世界","書籍","网址","닷넷","コム","天主教","游戏","vermögensberater","vermögensberatung","企业","信息","嘉里大酒店","嘉里","广东","政务","xyz","yachts","yahoo","yamaxun","yandex","yodobashi","yoga","yokohama","you","youtube","yun","zappos","zara","zero","zip","zippo","zone","zuerich","cc.ua","inf.ua","ltd.ua","beep.pl","*.compute.estate","*.alces.network","alwaysdata.net","cloudfront.net","*.compute.amazonaws.com","*.compute-1.amazonaws.com","*.compute.amazonaws.com.cn","us-east-1.amazonaws.com","cn-north-1.eb.amazonaws.com.cn","cn-northwest-1.eb.amazonaws.com.cn","elasticbeanstalk.com","ap-northeast-1.elasticbeanstalk.com","ap-northeast-2.elasticbeanstalk.com","ap-northeast-3.elasticbeanstalk.com","ap-south-1.elasticbeanstalk.com","ap-southeast-1.elasticbeanstalk.com","ap-southeast-2.elasticbeanstalk.com","ca-central-1.elasticbeanstalk.com","eu-central-1.elasticbeanstalk.com","eu-west-1.elasticbeanstalk.com","eu-west-2.elasticbeanstalk.com","eu-west-3.elasticbeanstalk.com","sa-east-1.elasticbeanstalk.com","us-east-1.elasticbeanstalk.com","us-east-2.elasticbeanstalk.com","us-gov-west-1.elasticbeanstalk.com","us-west-1.elasticbeanstalk.com","us-west-2.elasticbeanstalk.com","*.elb.amazonaws.com","*.elb.amazonaws.com.cn","s3.amazonaws.com","s3-ap-northeast-1.amazonaws.com","s3-ap-northeast-2.amazonaws.com","s3-ap-south-1.amazonaws.com","s3-ap-southeast-1.amazonaws.com","s3-ap-southeast-2.amazonaws.com","s3-ca-central-1.amazonaws.com","s3-eu-central-1.amazonaws.com","s3-eu-west-1.amazonaws.com","s3-eu-west-2.amazonaws.com","s3-eu-west-3.amazonaws.com","s3-external-1.amazonaws.com","s3-fips-us-gov-west-1.amazonaws.com","s3-sa-east-1.amazonaws.com","s3-us-gov-west-1.amazonaws.com","s3-us-east-2.amazonaws.com","s3-us-west-1.amazonaws.com","s3-us-west-2.amazonaws.com","s3.ap-northeast-2.amazonaws.com","s3.ap-south-1.amazonaws.com","s3.cn-north-1.amazonaws.com.cn","s3.ca-central-1.amazonaws.com","s3.eu-central-1.amazonaws.com","s3.eu-west-2.amazonaws.com","s3.eu-west-3.amazonaws.com","s3.us-east-2.amazonaws.com","s3.dualstack.ap-northeast-1.amazonaws.com","s3.dualstack.ap-northeast-2.amazonaws.com","s3.dualstack.ap-south-1.amazonaws.com","s3.dualstack.ap-southeast-1.amazonaws.com","s3.dualstack.ap-southeast-2.amazonaws.com","s3.dualstack.ca-central-1.amazonaws.com","s3.dualstack.eu-central-1.amazonaws.com","s3.dualstack.eu-west-1.amazonaws.com","s3.dualstack.eu-west-2.amazonaws.com","s3.dualstack.eu-west-3.amazonaws.com","s3.dualstack.sa-east-1.amazonaws.com","s3.dualstack.us-east-1.amazonaws.com","s3.dualstack.us-east-2.amazonaws.com","s3-website-us-east-1.amazonaws.com","s3-website-us-west-1.amazonaws.com","s3-website-us-west-2.amazonaws.com","s3-website-ap-northeast-1.amazonaws.com","s3-website-ap-southeast-1.amazonaws.com","s3-website-ap-southeast-2.amazonaws.com","s3-website-eu-west-1.amazonaws.com","s3-website-sa-east-1.amazonaws.com","s3-website.ap-northeast-2.amazonaws.com","s3-website.ap-south-1.amazonaws.com","s3-website.ca-central-1.amazonaws.com","s3-website.eu-central-1.amazonaws.com","s3-website.eu-west-2.amazonaws.com","s3-website.eu-west-3.amazonaws.com","s3-website.us-east-2.amazonaws.com","t3l3p0rt.net","tele.amune.org","apigee.io","on-aptible.com","user.party.eus","pimienta.org","poivron.org","potager.org","sweetpepper.org","myasustor.com","myfritz.net","*.awdev.ca","*.advisor.ws","backplaneapp.io","betainabox.com","bnr.la","blackbaudcdn.net","boomla.net","boxfuse.io","square7.ch","bplaced.com","bplaced.de","square7.de","bplaced.net","square7.net","browsersafetymark.io","mycd.eu","ae.org","ar.com","br.com","cn.com","com.de","com.se","de.com","eu.com","gb.com","gb.net","hu.com","hu.net","jp.net","jpn.com","kr.com","mex.com","no.com","qc.com","ru.com","sa.com","se.net","uk.com","uk.net","us.com","uy.com","za.bz","za.com","africa.com","gr.com","in.net","us.org","co.com","c.la","certmgr.org","xenapponazure.com","virtueeldomein.nl","cleverapps.io","c66.me","cloud66.ws","jdevcloud.com","wpdevcloud.com","cloudaccess.host","freesite.host","cloudaccess.net","cloudcontrolled.com","cloudcontrolapp.com","co.ca","*.otap.co","co.cz","c.cdn77.org","cdn77-ssl.net","r.cdn77.net","rsc.cdn77.org","ssl.origin.cdn77-secure.org","cloudns.asia","cloudns.biz","cloudns.club","cloudns.cc","cloudns.eu","cloudns.in","cloudns.info","cloudns.org","cloudns.pro","cloudns.pw","cloudns.us","cloudeity.net","cnpy.gdn","co.nl","co.no","webhosting.be","hosting-cluster.nl","dyn.cosidns.de","dynamisches-dns.de","dnsupdater.de","internet-dns.de","l-o-g-i-n.de","dynamic-dns.info","feste-ip.net","knx-server.net","static-access.net","realm.cz","*.cryptonomic.net","cupcake.is","cyon.link","cyon.site","daplie.me","localhost.daplie.me","dattolocal.com","dattorelay.com","dattoweb.com","mydatto.com","dattolocal.net","mydatto.net","biz.dk","co.dk","firm.dk","reg.dk","store.dk","debian.net","dedyn.io","dnshome.de","drayddns.com","dreamhosters.com","mydrobo.com","drud.io","drud.us","duckdns.org","dy.fi","tunk.org","dyndns-at-home.com","dyndns-at-work.com","dyndns-blog.com","dyndns-free.com","dyndns-home.com","dyndns-ip.com","dyndns-mail.com","dyndns-office.com","dyndns-pics.com","dyndns-remote.com","dyndns-server.com","dyndns-web.com","dyndns-wiki.com","dyndns-work.com","dyndns.biz","dyndns.info","dyndns.org","dyndns.tv","at-band-camp.net","ath.cx","barrel-of-knowledge.info","barrell-of-knowledge.info","better-than.tv","blogdns.com","blogdns.net","blogdns.org","blogsite.org","boldlygoingnowhere.org","broke-it.net","buyshouses.net","cechire.com","dnsalias.com","dnsalias.net","dnsalias.org","dnsdojo.com","dnsdojo.net","dnsdojo.org","does-it.net","doesntexist.com","doesntexist.org","dontexist.com","dontexist.net","dontexist.org","doomdns.com","doomdns.org","dvrdns.org","dyn-o-saur.com","dynalias.com","dynalias.net","dynalias.org","dynathome.net","dyndns.ws","endofinternet.net","endofinternet.org","endoftheinternet.org","est-a-la-maison.com","est-a-la-masion.com","est-le-patron.com","est-mon-blogueur.com","for-better.biz","for-more.biz","for-our.info","for-some.biz","for-the.biz","forgot.her.name","forgot.his.name","from-ak.com","from-al.com","from-ar.com","from-az.net","from-ca.com","from-co.net","from-ct.com","from-dc.com","from-de.com","from-fl.com","from-ga.com","from-hi.com","from-ia.com","from-id.com","from-il.com","from-in.com","from-ks.com","from-ky.com","from-la.net","from-ma.com","from-md.com","from-me.org","from-mi.com","from-mn.com","from-mo.com","from-ms.com","from-mt.com","from-nc.com","from-nd.com","from-ne.com","from-nh.com","from-nj.com","from-nm.com","from-nv.com","from-ny.net","from-oh.com","from-ok.com","from-or.com","from-pa.com","from-pr.com","from-ri.com","from-sc.com","from-sd.com","from-tn.com","from-tx.com","from-ut.com","from-va.com","from-vt.com","from-wa.com","from-wi.com","from-wv.com","from-wy.com","ftpaccess.cc","fuettertdasnetz.de","game-host.org","game-server.cc","getmyip.com","gets-it.net","go.dyndns.org","gotdns.com","gotdns.org","groks-the.info","groks-this.info","ham-radio-op.net","here-for-more.info","hobby-site.com","hobby-site.org","home.dyndns.org","homedns.org","homeftp.net","homeftp.org","homeip.net","homelinux.com","homelinux.net","homelinux.org","homeunix.com","homeunix.net","homeunix.org","iamallama.com","in-the-band.net","is-a-anarchist.com","is-a-blogger.com","is-a-bookkeeper.com","is-a-bruinsfan.org","is-a-bulls-fan.com","is-a-candidate.org","is-a-caterer.com","is-a-celticsfan.org","is-a-chef.com","is-a-chef.net","is-a-chef.org","is-a-conservative.com","is-a-cpa.com","is-a-cubicle-slave.com","is-a-democrat.com","is-a-designer.com","is-a-doctor.com","is-a-financialadvisor.com","is-a-geek.com","is-a-geek.net","is-a-geek.org","is-a-green.com","is-a-guru.com","is-a-hard-worker.com","is-a-hunter.com","is-a-knight.org","is-a-landscaper.com","is-a-lawyer.com","is-a-liberal.com","is-a-libertarian.com","is-a-linux-user.org","is-a-llama.com","is-a-musician.com","is-a-nascarfan.com","is-a-nurse.com","is-a-painter.com","is-a-patsfan.org","is-a-personaltrainer.com","is-a-photographer.com","is-a-player.com","is-a-republican.com","is-a-rockstar.com","is-a-socialist.com","is-a-soxfan.org","is-a-student.com","is-a-teacher.com","is-a-techie.com","is-a-therapist.com","is-an-accountant.com","is-an-actor.com","is-an-actress.com","is-an-anarchist.com","is-an-artist.com","is-an-engineer.com","is-an-entertainer.com","is-by.us","is-certified.com","is-found.org","is-gone.com","is-into-anime.com","is-into-cars.com","is-into-cartoons.com","is-into-games.com","is-leet.com","is-lost.org","is-not-certified.com","is-saved.org","is-slick.com","is-uberleet.com","is-very-bad.org","is-very-evil.org","is-very-good.org","is-very-nice.org","is-very-sweet.org","is-with-theband.com","isa-geek.com","isa-geek.net","isa-geek.org","isa-hockeynut.com","issmarterthanyou.com","isteingeek.de","istmein.de","kicks-ass.net","kicks-ass.org","knowsitall.info","land-4-sale.us","lebtimnetz.de","leitungsen.de","likes-pie.com","likescandy.com","merseine.nu","mine.nu","misconfused.org","mypets.ws","myphotos.cc","neat-url.com","office-on-the.net","on-the-web.tv","podzone.net","podzone.org","readmyblog.org","saves-the-whales.com","scrapper-site.net","scrapping.cc","selfip.biz","selfip.com","selfip.info","selfip.net","selfip.org","sells-for-less.com","sells-for-u.com","sells-it.net","sellsyourhome.org","servebbs.com","servebbs.net","servebbs.org","serveftp.net","serveftp.org","servegame.org","shacknet.nu","simple-url.com","space-to-rent.com","stuff-4-sale.org","stuff-4-sale.us","teaches-yoga.com","thruhere.net","traeumtgerade.de","webhop.biz","webhop.info","webhop.net","webhop.org","worse-than.tv","writesthisblog.com","ddnss.de","dyn.ddnss.de","dyndns.ddnss.de","dyndns1.de","dyn-ip24.de","home-webserver.de","dyn.home-webserver.de","myhome-server.de","ddnss.org","definima.net","definima.io","bci.dnstrace.pro","ddnsfree.com","ddnsgeek.com","giize.com","gleeze.com","kozow.com","loseyourip.com","ooguy.com","theworkpc.com","casacam.net","dynu.net","accesscam.org","camdvr.org","freeddns.org","mywire.org","webredirect.org","myddns.rocks","blogsite.xyz","dynv6.net","e4.cz","mytuleap.com","enonic.io","customer.enonic.io","eu.org","al.eu.org","asso.eu.org","at.eu.org","au.eu.org","be.eu.org","bg.eu.org","ca.eu.org","cd.eu.org","ch.eu.org","cn.eu.org","cy.eu.org","cz.eu.org","de.eu.org","dk.eu.org","edu.eu.org","ee.eu.org","es.eu.org","fi.eu.org","fr.eu.org","gr.eu.org","hr.eu.org","hu.eu.org","ie.eu.org","il.eu.org","in.eu.org","int.eu.org","is.eu.org","it.eu.org","jp.eu.org","kr.eu.org","lt.eu.org","lu.eu.org","lv.eu.org","mc.eu.org","me.eu.org","mk.eu.org","mt.eu.org","my.eu.org","net.eu.org","ng.eu.org","nl.eu.org","no.eu.org","nz.eu.org","paris.eu.org","pl.eu.org","pt.eu.org","q-a.eu.org","ro.eu.org","ru.eu.org","se.eu.org","si.eu.org","sk.eu.org","tr.eu.org","uk.eu.org","us.eu.org","eu-1.evennode.com","eu-2.evennode.com","eu-3.evennode.com","eu-4.evennode.com","us-1.evennode.com","us-2.evennode.com","us-3.evennode.com","us-4.evennode.com","twmail.cc","twmail.net","twmail.org","mymailer.com.tw","url.tw","apps.fbsbx.com","ru.net","adygeya.ru","bashkiria.ru","bir.ru","cbg.ru","com.ru","dagestan.ru","grozny.ru","kalmykia.ru","kustanai.ru","marine.ru","mordovia.ru","msk.ru","mytis.ru","nalchik.ru","nov.ru","pyatigorsk.ru","spb.ru","vladikavkaz.ru","vladimir.ru","abkhazia.su","adygeya.su","aktyubinsk.su","arkhangelsk.su","armenia.su","ashgabad.su","azerbaijan.su","balashov.su","bashkiria.su","bryansk.su","bukhara.su","chimkent.su","dagestan.su","east-kazakhstan.su","exnet.su","georgia.su","grozny.su","ivanovo.su","jambyl.su","kalmykia.su","kaluga.su","karacol.su","karaganda.su","karelia.su","khakassia.su","krasnodar.su","kurgan.su","kustanai.su","lenug.su","mangyshlak.su","mordovia.su","msk.su","murmansk.su","nalchik.su","navoi.su","north-kazakhstan.su","nov.su","obninsk.su","penza.su","pokrovsk.su","sochi.su","spb.su","tashkent.su","termez.su","togliatti.su","troitsk.su","tselinograd.su","tula.su","tuva.su","vladikavkaz.su","vladimir.su","vologda.su","channelsdvr.net","fastlylb.net","map.fastlylb.net","freetls.fastly.net","map.fastly.net","a.prod.fastly.net","global.prod.fastly.net","a.ssl.fastly.net","b.ssl.fastly.net","global.ssl.fastly.net","fastpanel.direct","fastvps-server.com","fhapp.xyz","fedorainfracloud.org","fedorapeople.org","cloud.fedoraproject.org","app.os.fedoraproject.org","app.os.stg.fedoraproject.org","filegear.me","firebaseapp.com","flynnhub.com","flynnhosting.net","freebox-os.com","freeboxos.com","fbx-os.fr","fbxos.fr","freebox-os.fr","freeboxos.fr","freedesktop.org","*.futurecms.at","*.ex.futurecms.at","*.in.futurecms.at","futurehosting.at","futuremailing.at","*.ex.ortsinfo.at","*.kunden.ortsinfo.at","*.statics.cloud","service.gov.uk","github.io","githubusercontent.com","gitlab.io","homeoffice.gov.uk","ro.im","shop.ro","goip.de","*.0emm.com","appspot.com","blogspot.ae","blogspot.al","blogspot.am","blogspot.ba","blogspot.be","blogspot.bg","blogspot.bj","blogspot.ca","blogspot.cf","blogspot.ch","blogspot.cl","blogspot.co.at","blogspot.co.id","blogspot.co.il","blogspot.co.ke","blogspot.co.nz","blogspot.co.uk","blogspot.co.za","blogspot.com","blogspot.com.ar","blogspot.com.au","blogspot.com.br","blogspot.com.by","blogspot.com.co","blogspot.com.cy","blogspot.com.ee","blogspot.com.eg","blogspot.com.es","blogspot.com.mt","blogspot.com.ng","blogspot.com.tr","blogspot.com.uy","blogspot.cv","blogspot.cz","blogspot.de","blogspot.dk","blogspot.fi","blogspot.fr","blogspot.gr","blogspot.hk","blogspot.hr","blogspot.hu","blogspot.ie","blogspot.in","blogspot.is","blogspot.it","blogspot.jp","blogspot.kr","blogspot.li","blogspot.lt","blogspot.lu","blogspot.md","blogspot.mk","blogspot.mr","blogspot.mx","blogspot.my","blogspot.nl","blogspot.no","blogspot.pe","blogspot.pt","blogspot.qa","blogspot.re","blogspot.ro","blogspot.rs","blogspot.ru","blogspot.se","blogspot.sg","blogspot.si","blogspot.sk","blogspot.sn","blogspot.td","blogspot.tw","blogspot.ug","blogspot.vn","cloudfunctions.net","cloud.goog","codespot.com","googleapis.com","googlecode.com","pagespeedmobilizer.com","publishproxy.com","withgoogle.com","withyoutube.com","hashbang.sh","hasura.app","hasura-app.io","hepforge.org","herokuapp.com","herokussl.com","myravendb.com","ravendb.community","ravendb.me","development.run","ravendb.run","moonscale.net","iki.fi","biz.at","info.at","info.cx","ac.leg.br","al.leg.br","am.leg.br","ap.leg.br","ba.leg.br","ce.leg.br","df.leg.br","es.leg.br","go.leg.br","ma.leg.br","mg.leg.br","ms.leg.br","mt.leg.br","pa.leg.br","pb.leg.br","pe.leg.br","pi.leg.br","pr.leg.br","rj.leg.br","rn.leg.br","ro.leg.br","rr.leg.br","rs.leg.br","sc.leg.br","se.leg.br","sp.leg.br","to.leg.br","pixolino.com","ipifony.net","mein-iserv.de","test-iserv.de","myjino.ru","*.hosting.myjino.ru","*.landing.myjino.ru","*.spectrum.myjino.ru","*.vps.myjino.ru","*.triton.zone","*.cns.joyent.com","js.org","keymachine.de","knightpoint.systems","co.krd","edu.krd","git-repos.de","lcube-server.de","svn-repos.de","app.lmpm.com","linkitools.space","linkyard.cloud","linkyard-cloud.ch","we.bs","uklugs.org","glug.org.uk","lug.org.uk","lugs.org.uk","barsy.bg","barsy.co.uk","barsyonline.co.uk","barsycenter.com","barsyonline.com","barsy.club","barsy.de","barsy.eu","barsy.in","barsy.info","barsy.io","barsy.me","barsy.menu","barsy.mobi","barsy.net","barsy.online","barsy.org","barsy.pro","barsy.pub","barsy.shop","barsy.site","barsy.support","barsy.uk","*.magentosite.cloud","mayfirst.info","mayfirst.org","hb.cldmail.ru","miniserver.com","memset.net","cloud.metacentrum.cz","custom.metacentrum.cz","flt.cloud.muni.cz","usr.cloud.muni.cz","meteorapp.com","eu.meteorapp.com","co.pl","azurecontainer.io","azurewebsites.net","azure-mobile.net","cloudapp.net","mozilla-iot.org","bmoattachments.org","net.ru","org.ru","pp.ru","bitballoon.com","netlify.com","4u.com","ngrok.io","nh-serv.co.uk","nfshost.com","dnsking.ch","mypi.co","n4t.co","001www.com","ddnslive.com","myiphost.com","forumz.info","16-b.it","32-b.it","64-b.it","soundcast.me","tcp4.me","dnsup.net","hicam.net","now-dns.net","ownip.net","vpndns.net","dynserv.org","now-dns.org","x443.pw","now-dns.top","ntdll.top","freeddns.us","crafting.xyz","zapto.xyz","nsupdate.info","nerdpol.ovh","blogsyte.com","brasilia.me","cable-modem.org","ciscofreak.com","collegefan.org","couchpotatofries.org","damnserver.com","ddns.me","ditchyourip.com","dnsfor.me","dnsiskinky.com","dvrcam.info","dynns.com","eating-organic.net","fantasyleague.cc","geekgalaxy.com","golffan.us","health-carereform.com","homesecuritymac.com","homesecuritypc.com","hopto.me","ilovecollege.info","loginto.me","mlbfan.org","mmafan.biz","myactivedirectory.com","mydissent.net","myeffect.net","mymediapc.net","mypsx.net","mysecuritycamera.com","mysecuritycamera.net","mysecuritycamera.org","net-freaks.com","nflfan.org","nhlfan.net","no-ip.ca","no-ip.co.uk","no-ip.net","noip.us","onthewifi.com","pgafan.net","point2this.com","pointto.us","privatizehealthinsurance.net","quicksytes.com","read-books.org","securitytactics.com","serveexchange.com","servehumour.com","servep2p.com","servesarcasm.com","stufftoread.com","ufcfan.org","unusualperson.com","workisboring.com","3utilities.com","bounceme.net","ddns.net","ddnsking.com","gotdns.ch","hopto.org","myftp.biz","myftp.org","myvnc.com","no-ip.biz","no-ip.info","no-ip.org","noip.me","redirectme.net","servebeer.com","serveblog.net","servecounterstrike.com","serveftp.com","servegame.com","servehalflife.com","servehttp.com","serveirc.com","serveminecraft.net","servemp3.com","servepics.com","servequake.com","sytes.net","webhop.me","zapto.org","stage.nodeart.io","nodum.co","nodum.io","pcloud.host","nyc.mn","nom.ae","nom.af","nom.ai","nom.al","nym.by","nym.bz","nom.cl","nom.gd","nom.ge","nom.gl","nym.gr","nom.gt","nym.gy","nom.hn","nym.ie","nom.im","nom.ke","nym.kz","nym.la","nym.lc","nom.li","nym.li","nym.lt","nym.lu","nym.me","nom.mk","nym.mn","nym.mx","nom.nu","nym.nz","nym.pe","nym.pt","nom.pw","nom.qa","nym.ro","nom.rs","nom.si","nym.sk","nom.st","nym.su","nym.sx","nom.tj","nym.tw","nom.ug","nom.uy","nom.vc","nom.vg","cya.gg","cloudycluster.net","nid.io","opencraft.hosting","operaunite.com","outsystemscloud.com","ownprovider.com","own.pm","ox.rs","oy.lc","pgfog.com","pagefrontapp.com","art.pl","gliwice.pl","krakow.pl","poznan.pl","wroc.pl","zakopane.pl","pantheonsite.io","gotpantheon.com","mypep.link","on-web.fr","*.platform.sh","*.platformsh.site","xen.prgmr.com","priv.at","protonet.io","chirurgiens-dentistes-en-france.fr","byen.site","ras.ru","qa2.com","dev-myqnapcloud.com","alpha-myqnapcloud.com","myqnapcloud.com","*.quipelements.com","vapor.cloud","vaporcloud.io","rackmaze.com","rackmaze.net","rhcloud.com","resindevice.io","devices.resinstaging.io","hzc.io","wellbeingzone.eu","ptplus.fit","wellbeingzone.co.uk","sandcats.io","logoip.de","logoip.com","schokokeks.net","scrysec.com","firewall-gateway.com","firewall-gateway.de","my-gateway.de","my-router.de","spdns.de","spdns.eu","firewall-gateway.net","my-firewall.org","myfirewall.org","spdns.org","*.s5y.io","*.sensiosite.cloud","biz.ua","co.ua","pp.ua","shiftedit.io","myshopblocks.com","1kapp.com","appchizi.com","applinzi.com","sinaapp.com","vipsinaapp.com","bounty-full.com","alpha.bounty-full.com","beta.bounty-full.com","static.land","dev.static.land","sites.static.land","apps.lair.io","*.stolos.io","spacekit.io","customer.speedpartner.de","storj.farm","utwente.io","temp-dns.com","diskstation.me","dscloud.biz","dscloud.me","dscloud.mobi","dsmynas.com","dsmynas.net","dsmynas.org","familyds.com","familyds.net","familyds.org","i234.me","myds.me","synology.me","vpnplus.to","taifun-dns.de","gda.pl","gdansk.pl","gdynia.pl","med.pl","sopot.pl","gwiddle.co.uk","cust.dev.thingdust.io","cust.disrec.thingdust.io","cust.prod.thingdust.io","cust.testing.thingdust.io","bloxcms.com","townnews-staging.com","12hp.at","2ix.at","4lima.at","lima-city.at","12hp.ch","2ix.ch","4lima.ch","lima-city.ch","trafficplex.cloud","de.cool","12hp.de","2ix.de","4lima.de","lima-city.de","1337.pictures","clan.rip","lima-city.rocks","webspace.rocks","lima.zone","*.transurl.be","*.transurl.eu","*.transurl.nl","tuxfamily.org","dd-dns.de","diskstation.eu","diskstation.org","dray-dns.de","draydns.de","dyn-vpn.de","dynvpn.de","mein-vigor.de","my-vigor.de","my-wan.de","syno-ds.de","synology-diskstation.de","synology-ds.de","uber.space","*.uberspace.de","hk.com","hk.org","ltd.hk","inc.hk","virtualuser.de","virtual-user.de","lib.de.us","2038.io","router.management","v-info.info","wedeploy.io","wedeploy.me","wedeploy.sh","remotewd.com","wmflabs.org","half.host","xnbay.com","u2.xnbay.com","u2-local.xnbay.com","cistron.nl","demon.nl","xs4all.space","official.academy","yolasite.com","ybo.faith","yombo.me","homelink.one","ybo.party","ybo.review","ybo.science","ybo.trade","nohost.me","noho.st","za.net","za.org","now.sh","zone.id"];

/***/ }),

/***/ "./node_modules/psl/index.js":
/*!***********************************!*\
  !*** ./node_modules/psl/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*eslint no-var:0, prefer-arrow-callback: 0, object-shorthand: 0 */



var Punycode = __webpack_require__(/*! punycode */ "punycode");


var internals = {};


//
// Read rules from file.
//
internals.rules = __webpack_require__(/*! ./data/rules.json */ "./node_modules/psl/data/rules.json").map(function (rule) {

  return {
    rule: rule,
    suffix: rule.replace(/^(\*\.|\!)/, ''),
    punySuffix: -1,
    wildcard: rule.charAt(0) === '*',
    exception: rule.charAt(0) === '!'
  };
});


//
// Check is given string ends with `suffix`.
//
internals.endsWith = function (str, suffix) {

  return str.indexOf(suffix, str.length - suffix.length) !== -1;
};


//
// Find rule for a given domain.
//
internals.findRule = function (domain) {

  var punyDomain = Punycode.toASCII(domain);
  return internals.rules.reduce(function (memo, rule) {

    if (rule.punySuffix === -1){
      rule.punySuffix = Punycode.toASCII(rule.suffix);
    }
    if (!internals.endsWith(punyDomain, '.' + rule.punySuffix) && punyDomain !== rule.punySuffix) {
      return memo;
    }
    // This has been commented out as it never seems to run. This is because
    // sub tlds always appear after their parents and we never find a shorter
    // match.
    //if (memo) {
    //  var memoSuffix = Punycode.toASCII(memo.suffix);
    //  if (memoSuffix.length >= punySuffix.length) {
    //    return memo;
    //  }
    //}
    return rule;
  }, null);
};


//
// Error codes and messages.
//
exports.errorCodes = {
  DOMAIN_TOO_SHORT: 'Domain name too short.',
  DOMAIN_TOO_LONG: 'Domain name too long. It should be no more than 255 chars.',
  LABEL_STARTS_WITH_DASH: 'Domain name label can not start with a dash.',
  LABEL_ENDS_WITH_DASH: 'Domain name label can not end with a dash.',
  LABEL_TOO_LONG: 'Domain name label should be at most 63 chars long.',
  LABEL_TOO_SHORT: 'Domain name label should be at least 1 character long.',
  LABEL_INVALID_CHARS: 'Domain name label can only contain alphanumeric characters or dashes.'
};


//
// Validate domain name and throw if not valid.
//
// From wikipedia:
//
// Hostnames are composed of series of labels concatenated with dots, as are all
// domain names. Each label must be between 1 and 63 characters long, and the
// entire hostname (including the delimiting dots) has a maximum of 255 chars.
//
// Allowed chars:
//
// * `a-z`
// * `0-9`
// * `-` but not as a starting or ending character
// * `.` as a separator for the textual portions of a domain name
//
// * http://en.wikipedia.org/wiki/Domain_name
// * http://en.wikipedia.org/wiki/Hostname
//
internals.validate = function (input) {

  // Before we can validate we need to take care of IDNs with unicode chars.
  var ascii = Punycode.toASCII(input);

  if (ascii.length < 1) {
    return 'DOMAIN_TOO_SHORT';
  }
  if (ascii.length > 255) {
    return 'DOMAIN_TOO_LONG';
  }

  // Check each part's length and allowed chars.
  var labels = ascii.split('.');
  var label;

  for (var i = 0; i < labels.length; ++i) {
    label = labels[i];
    if (!label.length) {
      return 'LABEL_TOO_SHORT';
    }
    if (label.length > 63) {
      return 'LABEL_TOO_LONG';
    }
    if (label.charAt(0) === '-') {
      return 'LABEL_STARTS_WITH_DASH';
    }
    if (label.charAt(label.length - 1) === '-') {
      return 'LABEL_ENDS_WITH_DASH';
    }
    if (!/^[a-z0-9\-]+$/.test(label)) {
      return 'LABEL_INVALID_CHARS';
    }
  }
};


//
// Public API
//


//
// Parse domain.
//
exports.parse = function (input) {

  if (typeof input !== 'string') {
    throw new TypeError('Domain name must be a string.');
  }

  // Force domain to lowercase.
  var domain = input.slice(0).toLowerCase();

  // Handle FQDN.
  // TODO: Simply remove trailing dot?
  if (domain.charAt(domain.length - 1) === '.') {
    domain = domain.slice(0, domain.length - 1);
  }

  // Validate and sanitise input.
  var error = internals.validate(domain);
  if (error) {
    return {
      input: input,
      error: {
        message: exports.errorCodes[error],
        code: error
      }
    };
  }

  var parsed = {
    input: input,
    tld: null,
    sld: null,
    domain: null,
    subdomain: null,
    listed: false
  };

  var domainParts = domain.split('.');

  // Non-Internet TLD
  if (domainParts[domainParts.length - 1] === 'local') {
    return parsed;
  }

  var handlePunycode = function () {

    if (!/xn--/.test(domain)) {
      return parsed;
    }
    if (parsed.domain) {
      parsed.domain = Punycode.toASCII(parsed.domain);
    }
    if (parsed.subdomain) {
      parsed.subdomain = Punycode.toASCII(parsed.subdomain);
    }
    return parsed;
  };

  var rule = internals.findRule(domain);

  // Unlisted tld.
  if (!rule) {
    if (domainParts.length < 2) {
      return parsed;
    }
    parsed.tld = domainParts.pop();
    parsed.sld = domainParts.pop();
    parsed.domain = [parsed.sld, parsed.tld].join('.');
    if (domainParts.length) {
      parsed.subdomain = domainParts.pop();
    }
    return handlePunycode();
  }

  // At this point we know the public suffix is listed.
  parsed.listed = true;

  var tldParts = rule.suffix.split('.');
  var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);

  if (rule.exception) {
    privateParts.push(tldParts.shift());
  }

  parsed.tld = tldParts.join('.');

  if (!privateParts.length) {
    return handlePunycode();
  }

  if (rule.wildcard) {
    tldParts.unshift(privateParts.pop());
    parsed.tld = tldParts.join('.');
  }

  if (!privateParts.length) {
    return handlePunycode();
  }

  parsed.sld = privateParts.pop();
  parsed.domain = [parsed.sld,  parsed.tld].join('.');

  if (privateParts.length) {
    parsed.subdomain = privateParts.join('.');
  }

  return handlePunycode();
};


//
// Get domain.
//
exports.get = function (domain) {

  if (!domain) {
    return null;
  }
  return exports.parse(domain).domain || null;
};


//
// Check whether domain belongs to a known public suffix.
//
exports.isValid = function (domain) {

  var parsed = exports.parse(domain);
  return Boolean(parsed.domain && parsed.listed);
};


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]') {
            obj = [];
            obj = obj.concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

var encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),

/***/ "./node_modules/request/index.js":
/*!***************************************!*\
  !*** ./node_modules/request/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright 2010-2012 Mikeal Rogers
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.



var extend = __webpack_require__(/*! extend */ "./node_modules/extend/index.js")
var cookies = __webpack_require__(/*! ./lib/cookies */ "./node_modules/request/lib/cookies.js")
var helpers = __webpack_require__(/*! ./lib/helpers */ "./node_modules/request/lib/helpers.js")

var paramsHaveRequestBody = helpers.paramsHaveRequestBody

// organize params for patch, post, put, head, del
function initParams (uri, options, callback) {
  if (typeof options === 'function') {
    callback = options
  }

  var params = {}
  if (typeof options === 'object') {
    extend(params, options, {uri: uri})
  } else if (typeof uri === 'string') {
    extend(params, {uri: uri})
  } else {
    extend(params, uri)
  }

  params.callback = callback || params.callback
  return params
}

function request (uri, options, callback) {
  if (typeof uri === 'undefined') {
    throw new Error('undefined is not a valid uri or options object.')
  }

  var params = initParams(uri, options, callback)

  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {
    throw new Error('HTTP HEAD requests MUST NOT include a request body.')
  }

  return new request.Request(params)
}

function verbFunc (verb) {
  var method = verb.toUpperCase()
  return function (uri, options, callback) {
    var params = initParams(uri, options, callback)
    params.method = method
    return request(params, params.callback)
  }
}

// define like this to please codeintel/intellisense IDEs
request.get = verbFunc('get')
request.head = verbFunc('head')
request.options = verbFunc('options')
request.post = verbFunc('post')
request.put = verbFunc('put')
request.patch = verbFunc('patch')
request.del = verbFunc('delete')
request['delete'] = verbFunc('delete')

request.jar = function (store) {
  return cookies.jar(store)
}

request.cookie = function (str) {
  return cookies.parse(str)
}

function wrapRequestMethod (method, options, requester, verb) {
  return function (uri, opts, callback) {
    var params = initParams(uri, opts, callback)

    var target = {}
    extend(true, target, options, params)

    target.pool = params.pool || options.pool

    if (verb) {
      target.method = verb.toUpperCase()
    }

    if (typeof requester === 'function') {
      method = requester
    }

    return method(target, target.callback)
  }
}

request.defaults = function (options, requester) {
  var self = this

  options = options || {}

  if (typeof options === 'function') {
    requester = options
    options = {}
  }

  var defaults = wrapRequestMethod(self, options, requester)

  var verbs = ['get', 'head', 'post', 'put', 'patch', 'del', 'delete']
  verbs.forEach(function (verb) {
    defaults[verb] = wrapRequestMethod(self[verb], options, requester, verb)
  })

  defaults.cookie = wrapRequestMethod(self.cookie, options, requester)
  defaults.jar = self.jar
  defaults.defaults = self.defaults
  return defaults
}

request.forever = function (agentOptions, optionsArg) {
  var options = {}
  if (optionsArg) {
    extend(options, optionsArg)
  }
  if (agentOptions) {
    options.agentOptions = agentOptions
  }

  options.forever = true
  return request.defaults(options)
}

// Exports

module.exports = request
request.Request = __webpack_require__(/*! ./request */ "./node_modules/request/request.js")
request.initParams = initParams

// Backwards compatibility for request.debug
Object.defineProperty(request, 'debug', {
  enumerable: true,
  get: function () {
    return request.Request.debug
  },
  set: function (debug) {
    request.Request.debug = debug
  }
})


/***/ }),

/***/ "./node_modules/request/lib/auth.js":
/*!******************************************!*\
  !*** ./node_modules/request/lib/auth.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var caseless = __webpack_require__(/*! caseless */ "./node_modules/caseless/index.js")
var uuid = __webpack_require__(/*! uuid/v4 */ "./node_modules/uuid/v4.js")
var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/request/lib/helpers.js")

var md5 = helpers.md5
var toBase64 = helpers.toBase64

function Auth (request) {
  // define all public properties here
  this.request = request
  this.hasAuth = false
  this.sentAuth = false
  this.bearerToken = null
  this.user = null
  this.pass = null
}

Auth.prototype.basic = function (user, pass, sendImmediately) {
  var self = this
  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {
    self.request.emit('error', new Error('auth() received invalid user or password'))
  }
  self.user = user
  self.pass = pass
  self.hasAuth = true
  var header = user + ':' + (pass || '')
  if (sendImmediately || typeof sendImmediately === 'undefined') {
    var authHeader = 'Basic ' + toBase64(header)
    self.sentAuth = true
    return authHeader
  }
}

Auth.prototype.bearer = function (bearer, sendImmediately) {
  var self = this
  self.bearerToken = bearer
  self.hasAuth = true
  if (sendImmediately || typeof sendImmediately === 'undefined') {
    if (typeof bearer === 'function') {
      bearer = bearer()
    }
    var authHeader = 'Bearer ' + (bearer || '')
    self.sentAuth = true
    return authHeader
  }
}

Auth.prototype.digest = function (method, path, authHeader) {
  // TODO: More complete implementation of RFC 2617.
  //   - handle challenge.domain
  //   - support qop="auth-int" only
  //   - handle Authentication-Info (not necessarily?)
  //   - check challenge.stale (not necessarily?)
  //   - increase nc (not necessarily?)
  // For reference:
  // http://tools.ietf.org/html/rfc2617#section-3
  // https://github.com/bagder/curl/blob/master/lib/http_digest.c

  var self = this

  var challenge = {}
  var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi
  for (;;) {
    var match = re.exec(authHeader)
    if (!match) {
      break
    }
    challenge[match[1]] = match[2] || match[3]
  }

  /**
   * RFC 2617: handle both MD5 and MD5-sess algorithms.
   *
   * If the algorithm directive's value is "MD5" or unspecified, then HA1 is
   *   HA1=MD5(username:realm:password)
   * If the algorithm directive's value is "MD5-sess", then HA1 is
   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)
   */
  var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) {
    var ha1 = md5(user + ':' + realm + ':' + pass)
    if (algorithm && algorithm.toLowerCase() === 'md5-sess') {
      return md5(ha1 + ':' + nonce + ':' + cnonce)
    } else {
      return ha1
    }
  }

  var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth'
  var nc = qop && '00000001'
  var cnonce = qop && uuid().replace(/-/g, '')
  var ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce)
  var ha2 = md5(method + ':' + path)
  var digestResponse = qop
    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)
    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)
  var authValues = {
    username: self.user,
    realm: challenge.realm,
    nonce: challenge.nonce,
    uri: path,
    qop: qop,
    response: digestResponse,
    nc: nc,
    cnonce: cnonce,
    algorithm: challenge.algorithm,
    opaque: challenge.opaque
  }

  authHeader = []
  for (var k in authValues) {
    if (authValues[k]) {
      if (k === 'qop' || k === 'nc' || k === 'algorithm') {
        authHeader.push(k + '=' + authValues[k])
      } else {
        authHeader.push(k + '="' + authValues[k] + '"')
      }
    }
  }
  authHeader = 'Digest ' + authHeader.join(', ')
  self.sentAuth = true
  return authHeader
}

Auth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {
  var self = this
  var request = self.request

  var authHeader
  if (bearer === undefined && user === undefined) {
    self.request.emit('error', new Error('no auth mechanism defined'))
  } else if (bearer !== undefined) {
    authHeader = self.bearer(bearer, sendImmediately)
  } else {
    authHeader = self.basic(user, pass, sendImmediately)
  }
  if (authHeader) {
    request.setHeader('authorization', authHeader)
  }
}

Auth.prototype.onResponse = function (response) {
  var self = this
  var request = self.request

  if (!self.hasAuth || self.sentAuth) { return null }

  var c = caseless(response.headers)

  var authHeader = c.get('www-authenticate')
  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()
  request.debug('reauth', authVerb)

  switch (authVerb) {
    case 'basic':
      return self.basic(self.user, self.pass, true)

    case 'bearer':
      return self.bearer(self.bearerToken, true)

    case 'digest':
      return self.digest(request.method, request.path, authHeader)
  }
}

exports.Auth = Auth


/***/ }),

/***/ "./node_modules/request/lib/cookies.js":
/*!*********************************************!*\
  !*** ./node_modules/request/lib/cookies.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var tough = __webpack_require__(/*! tough-cookie */ "./node_modules/tough-cookie/lib/cookie.js")

var Cookie = tough.Cookie
var CookieJar = tough.CookieJar

exports.parse = function (str) {
  if (str && str.uri) {
    str = str.uri
  }
  if (typeof str !== 'string') {
    throw new Error('The cookie function only accepts STRING as param')
  }
  return Cookie.parse(str, {loose: true})
}

// Adapt the sometimes-Async api of tough.CookieJar to our requirements
function RequestJar (store) {
  var self = this
  self._jar = new CookieJar(store, {looseMode: true})
}
RequestJar.prototype.setCookie = function (cookieOrStr, uri, options) {
  var self = this
  return self._jar.setCookieSync(cookieOrStr, uri, options || {})
}
RequestJar.prototype.getCookieString = function (uri) {
  var self = this
  return self._jar.getCookieStringSync(uri)
}
RequestJar.prototype.getCookies = function (uri) {
  var self = this
  return self._jar.getCookiesSync(uri)
}

exports.jar = function (store) {
  return new RequestJar(store)
}


/***/ }),

/***/ "./node_modules/request/lib/getProxyFromURI.js":
/*!*****************************************************!*\
  !*** ./node_modules/request/lib/getProxyFromURI.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function formatHostname (hostname) {
  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
  return hostname.replace(/^\.*/, '.').toLowerCase()
}

function parseNoProxyZone (zone) {
  zone = zone.trim().toLowerCase()

  var zoneParts = zone.split(':', 2)
  var zoneHost = formatHostname(zoneParts[0])
  var zonePort = zoneParts[1]
  var hasPort = zone.indexOf(':') > -1

  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}
}

function uriInNoProxy (uri, noProxy) {
  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80')
  var hostname = formatHostname(uri.hostname)
  var noProxyList = noProxy.split(',')

  // iterate through the noProxyList until it finds a match.
  return noProxyList.map(parseNoProxyZone).some(function (noProxyZone) {
    var isMatchedAt = hostname.indexOf(noProxyZone.hostname)
    var hostnameMatched = (
      isMatchedAt > -1 &&
        (isMatchedAt === hostname.length - noProxyZone.hostname.length)
    )

    if (noProxyZone.hasPort) {
      return (port === noProxyZone.port) && hostnameMatched
    }

    return hostnameMatched
  })
}

function getProxyFromURI (uri) {
  // Decide the proper request proxy to use based on the request URI object and the
  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)
  // respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)

  var noProxy = process.env.NO_PROXY || process.env.no_proxy || ''

  // if the noProxy is a wildcard then return null

  if (noProxy === '*') {
    return null
  }

  // if the noProxy is not empty and the uri is found return null

  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {
    return null
  }

  // Check for HTTP or HTTPS Proxy in environment Else default to null

  if (uri.protocol === 'http:') {
    return process.env.HTTP_PROXY ||
      process.env.http_proxy || null
  }

  if (uri.protocol === 'https:') {
    return process.env.HTTPS_PROXY ||
      process.env.https_proxy ||
      process.env.HTTP_PROXY ||
      process.env.http_proxy || null
  }

  // if none of that works, return null
  // (What uri protocol are you using then?)

  return null
}

module.exports = getProxyFromURI


/***/ }),

/***/ "./node_modules/request/lib/har.js":
/*!*****************************************!*\
  !*** ./node_modules/request/lib/har.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs = __webpack_require__(/*! fs */ "fs")
var qs = __webpack_require__(/*! querystring */ "querystring")
var validate = __webpack_require__(/*! har-validator */ "./node_modules/har-validator/lib/promise.js")
var extend = __webpack_require__(/*! extend */ "./node_modules/extend/index.js")

function Har (request) {
  this.request = request
}

Har.prototype.reducer = function (obj, pair) {
  // new property ?
  if (obj[pair.name] === undefined) {
    obj[pair.name] = pair.value
    return obj
  }

  // existing? convert to array
  var arr = [
    obj[pair.name],
    pair.value
  ]

  obj[pair.name] = arr

  return obj
}

Har.prototype.prep = function (data) {
  // construct utility properties
  data.queryObj = {}
  data.headersObj = {}
  data.postData.jsonObj = false
  data.postData.paramsObj = false

  // construct query objects
  if (data.queryString && data.queryString.length) {
    data.queryObj = data.queryString.reduce(this.reducer, {})
  }

  // construct headers objects
  if (data.headers && data.headers.length) {
    // loweCase header keys
    data.headersObj = data.headers.reduceRight(function (headers, header) {
      headers[header.name] = header.value
      return headers
    }, {})
  }

  // construct Cookie header
  if (data.cookies && data.cookies.length) {
    var cookies = data.cookies.map(function (cookie) {
      return cookie.name + '=' + cookie.value
    })

    if (cookies.length) {
      data.headersObj.cookie = cookies.join('; ')
    }
  }

  // prep body
  function some (arr) {
    return arr.some(function (type) {
      return data.postData.mimeType.indexOf(type) === 0
    })
  }

  if (some([
    'multipart/mixed',
    'multipart/related',
    'multipart/form-data',
    'multipart/alternative'])) {
    // reset values
    data.postData.mimeType = 'multipart/form-data'
  } else if (some([
    'application/x-www-form-urlencoded'])) {
    if (!data.postData.params) {
      data.postData.text = ''
    } else {
      data.postData.paramsObj = data.postData.params.reduce(this.reducer, {})

      // always overwrite
      data.postData.text = qs.stringify(data.postData.paramsObj)
    }
  } else if (some([
    'text/json',
    'text/x-json',
    'application/json',
    'application/x-json'])) {
    data.postData.mimeType = 'application/json'

    if (data.postData.text) {
      try {
        data.postData.jsonObj = JSON.parse(data.postData.text)
      } catch (e) {
        this.request.debug(e)

        // force back to text/plain
        data.postData.mimeType = 'text/plain'
      }
    }
  }

  return data
}

Har.prototype.options = function (options) {
  // skip if no har property defined
  if (!options.har) {
    return options
  }

  var har = {}
  extend(har, options.har)

  // only process the first entry
  if (har.log && har.log.entries) {
    har = har.log.entries[0]
  }

  // add optional properties to make validation successful
  har.url = har.url || options.url || options.uri || options.baseUrl || '/'
  har.httpVersion = har.httpVersion || 'HTTP/1.1'
  har.queryString = har.queryString || []
  har.headers = har.headers || []
  har.cookies = har.cookies || []
  har.postData = har.postData || {}
  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream'

  har.bodySize = 0
  har.headersSize = 0
  har.postData.size = 0

  if (!validate.request(har)) {
    return options
  }

  // clean up and get some utility properties
  var req = this.prep(har)

  // construct new options
  if (req.url) {
    options.url = req.url
  }

  if (req.method) {
    options.method = req.method
  }

  if (Object.keys(req.queryObj).length) {
    options.qs = req.queryObj
  }

  if (Object.keys(req.headersObj).length) {
    options.headers = req.headersObj
  }

  function test (type) {
    return req.postData.mimeType.indexOf(type) === 0
  }
  if (test('application/x-www-form-urlencoded')) {
    options.form = req.postData.paramsObj
  } else if (test('application/json')) {
    if (req.postData.jsonObj) {
      options.body = req.postData.jsonObj
      options.json = true
    }
  } else if (test('multipart/form-data')) {
    options.formData = {}

    req.postData.params.forEach(function (param) {
      var attachment = {}

      if (!param.fileName && !param.fileName && !param.contentType) {
        options.formData[param.name] = param.value
        return
      }

      // attempt to read from disk!
      if (param.fileName && !param.value) {
        attachment.value = fs.createReadStream(param.fileName)
      } else if (param.value) {
        attachment.value = param.value
      }

      if (param.fileName) {
        attachment.options = {
          filename: param.fileName,
          contentType: param.contentType ? param.contentType : null
        }
      }

      options.formData[param.name] = attachment
    })
  } else {
    if (req.postData.text) {
      options.body = req.postData.text
    }
  }

  return options
}

exports.Har = Har


/***/ }),

/***/ "./node_modules/request/lib/hawk.js":
/*!******************************************!*\
  !*** ./node_modules/request/lib/hawk.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var crypto = __webpack_require__(/*! crypto */ "crypto")

function randomString (size) {
  var bits = (size + 1) * 6
  var buffer = crypto.randomBytes(Math.ceil(bits / 8))
  var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '')
  return string.slice(0, size)
}

function calculatePayloadHash (payload, algorithm, contentType) {
  var hash = crypto.createHash(algorithm)
  hash.update('hawk.1.payload\n')
  hash.update((contentType ? contentType.split(';')[0].trim().toLowerCase() : '') + '\n')
  hash.update(payload || '')
  hash.update('\n')
  return hash.digest('base64')
}

exports.calculateMac = function (credentials, opts) {
  var normalized = 'hawk.1.header\n' +
    opts.ts + '\n' +
    opts.nonce + '\n' +
    (opts.method || '').toUpperCase() + '\n' +
    opts.resource + '\n' +
    opts.host.toLowerCase() + '\n' +
    opts.port + '\n' +
    (opts.hash || '') + '\n'

  if (opts.ext) {
    normalized = normalized + opts.ext.replace('\\', '\\\\').replace('\n', '\\n')
  }

  normalized = normalized + '\n'

  if (opts.app) {
    normalized = normalized + opts.app + '\n' + (opts.dlg || '') + '\n'
  }

  var hmac = crypto.createHmac(credentials.algorithm, credentials.key).update(normalized)
  var digest = hmac.digest('base64')
  return digest
}

exports.header = function (uri, method, opts) {
  var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1000)
  var credentials = opts.credentials
  if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
    return ''
  }

  if (['sha1', 'sha256'].indexOf(credentials.algorithm) === -1) {
    return ''
  }

  var artifacts = {
    ts: timestamp,
    nonce: opts.nonce || randomString(6),
    method: method,
    resource: uri.pathname + (uri.search || ''),
    host: uri.hostname,
    port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
    hash: opts.hash,
    ext: opts.ext,
    app: opts.app,
    dlg: opts.dlg
  }

  if (!artifacts.hash && (opts.payload || opts.payload === '')) {
    artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType)
  }

  var mac = exports.calculateMac(credentials, artifacts)

  var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== ''
  var header = 'Hawk id="' + credentials.id +
    '", ts="' + artifacts.ts +
    '", nonce="' + artifacts.nonce +
    (artifacts.hash ? '", hash="' + artifacts.hash : '') +
    (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, '\\\\').replace(/"/g, '\\"') : '') +
    '", mac="' + mac + '"'

  if (artifacts.app) {
    header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"'
  }

  return header
}


/***/ }),

/***/ "./node_modules/request/lib/helpers.js":
/*!*********************************************!*\
  !*** ./node_modules/request/lib/helpers.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var jsonSafeStringify = __webpack_require__(/*! json-stringify-safe */ "./node_modules/json-stringify-safe/stringify.js")
var crypto = __webpack_require__(/*! crypto */ "crypto")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var defer = typeof setImmediate === 'undefined'
  ? process.nextTick
  : setImmediate

function paramsHaveRequestBody (params) {
  return (
    params.body ||
    params.requestBodyStream ||
    (params.json && typeof params.json !== 'boolean') ||
    params.multipart
  )
}

function safeStringify (obj, replacer) {
  var ret
  try {
    ret = JSON.stringify(obj, replacer)
  } catch (e) {
    ret = jsonSafeStringify(obj, replacer)
  }
  return ret
}

function md5 (str) {
  return crypto.createHash('md5').update(str).digest('hex')
}

function isReadStream (rs) {
  return rs.readable && rs.path && rs.mode
}

function toBase64 (str) {
  return Buffer.from(str || '', 'utf8').toString('base64')
}

function copy (obj) {
  var o = {}
  Object.keys(obj).forEach(function (i) {
    o[i] = obj[i]
  })
  return o
}

function version () {
  var numbers = process.version.replace('v', '').split('.')
  return {
    major: parseInt(numbers[0], 10),
    minor: parseInt(numbers[1], 10),
    patch: parseInt(numbers[2], 10)
  }
}

exports.paramsHaveRequestBody = paramsHaveRequestBody
exports.safeStringify = safeStringify
exports.md5 = md5
exports.isReadStream = isReadStream
exports.toBase64 = toBase64
exports.copy = copy
exports.version = version
exports.defer = defer


/***/ }),

/***/ "./node_modules/request/lib/multipart.js":
/*!***********************************************!*\
  !*** ./node_modules/request/lib/multipart.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var uuid = __webpack_require__(/*! uuid/v4 */ "./node_modules/uuid/v4.js")
var CombinedStream = __webpack_require__(/*! combined-stream */ "./node_modules/combined-stream/lib/combined_stream.js")
var isstream = __webpack_require__(/*! isstream */ "./node_modules/isstream/isstream.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function Multipart (request) {
  this.request = request
  this.boundary = uuid()
  this.chunked = false
  this.body = null
}

Multipart.prototype.isChunked = function (options) {
  var self = this
  var chunked = false
  var parts = options.data || options

  if (!parts.forEach) {
    self.request.emit('error', new Error('Argument error, options.multipart.'))
  }

  if (options.chunked !== undefined) {
    chunked = options.chunked
  }

  if (self.request.getHeader('transfer-encoding') === 'chunked') {
    chunked = true
  }

  if (!chunked) {
    parts.forEach(function (part) {
      if (typeof part.body === 'undefined') {
        self.request.emit('error', new Error('Body attribute missing in multipart.'))
      }
      if (isstream(part.body)) {
        chunked = true
      }
    })
  }

  return chunked
}

Multipart.prototype.setHeaders = function (chunked) {
  var self = this

  if (chunked && !self.request.hasHeader('transfer-encoding')) {
    self.request.setHeader('transfer-encoding', 'chunked')
  }

  var header = self.request.getHeader('content-type')

  if (!header || header.indexOf('multipart') === -1) {
    self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary)
  } else {
    if (header.indexOf('boundary') !== -1) {
      self.boundary = header.replace(/.*boundary=([^\s;]+).*/, '$1')
    } else {
      self.request.setHeader('content-type', header + '; boundary=' + self.boundary)
    }
  }
}

Multipart.prototype.build = function (parts, chunked) {
  var self = this
  var body = chunked ? new CombinedStream() : []

  function add (part) {
    if (typeof part === 'number') {
      part = part.toString()
    }
    return chunked ? body.append(part) : body.push(Buffer.from(part))
  }

  if (self.request.preambleCRLF) {
    add('\r\n')
  }

  parts.forEach(function (part) {
    var preamble = '--' + self.boundary + '\r\n'
    Object.keys(part).forEach(function (key) {
      if (key === 'body') { return }
      preamble += key + ': ' + part[key] + '\r\n'
    })
    preamble += '\r\n'
    add(preamble)
    add(part.body)
    add('\r\n')
  })
  add('--' + self.boundary + '--')

  if (self.request.postambleCRLF) {
    add('\r\n')
  }

  return body
}

Multipart.prototype.onRequest = function (options) {
  var self = this

  var chunked = self.isChunked(options)
  var parts = options.data || options

  self.setHeaders(chunked)
  self.chunked = chunked
  self.body = self.build(parts, chunked)
}

exports.Multipart = Multipart


/***/ }),

/***/ "./node_modules/request/lib/oauth.js":
/*!*******************************************!*\
  !*** ./node_modules/request/lib/oauth.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var url = __webpack_require__(/*! url */ "url")
var qs = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js")
var caseless = __webpack_require__(/*! caseless */ "./node_modules/caseless/index.js")
var uuid = __webpack_require__(/*! uuid/v4 */ "./node_modules/uuid/v4.js")
var oauth = __webpack_require__(/*! oauth-sign */ "./node_modules/oauth-sign/index.js")
var crypto = __webpack_require__(/*! crypto */ "crypto")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

function OAuth (request) {
  this.request = request
  this.params = null
}

OAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {
  var oa = {}
  for (var i in _oauth) {
    oa['oauth_' + i] = _oauth[i]
  }
  if (!oa.oauth_version) {
    oa.oauth_version = '1.0'
  }
  if (!oa.oauth_timestamp) {
    oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString()
  }
  if (!oa.oauth_nonce) {
    oa.oauth_nonce = uuid().replace(/-/g, '')
  }
  if (!oa.oauth_signature_method) {
    oa.oauth_signature_method = 'HMAC-SHA1'
  }

  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key // eslint-disable-line camelcase
  delete oa.oauth_consumer_secret
  delete oa.oauth_private_key

  var token_secret = oa.oauth_token_secret // eslint-disable-line camelcase
  delete oa.oauth_token_secret

  var realm = oa.oauth_realm
  delete oa.oauth_realm
  delete oa.oauth_transport_method

  var baseurl = uri.protocol + '//' + uri.host + uri.pathname
  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))

  oa.oauth_signature = oauth.sign(
    oa.oauth_signature_method,
    method,
    baseurl,
    params,
    consumer_secret_or_private_key, // eslint-disable-line camelcase
    token_secret // eslint-disable-line camelcase
  )

  if (realm) {
    oa.realm = realm
  }

  return oa
}

OAuth.prototype.buildBodyHash = function (_oauth, body) {
  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {
    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +
      ' signature_method not supported with body_hash signing.'))
  }

  var shasum = crypto.createHash('sha1')
  shasum.update(body || '')
  var sha1 = shasum.digest('hex')

  return Buffer.from(sha1, 'hex').toString('base64')
}

OAuth.prototype.concatParams = function (oa, sep, wrap) {
  wrap = wrap || ''

  var params = Object.keys(oa).filter(function (i) {
    return i !== 'realm' && i !== 'oauth_signature'
  }).sort()

  if (oa.realm) {
    params.splice(0, 0, 'realm')
  }
  params.push('oauth_signature')

  return params.map(function (i) {
    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap
  }).join(sep)
}

OAuth.prototype.onRequest = function (_oauth) {
  var self = this
  self.params = _oauth

  var uri = self.request.uri || {}
  var method = self.request.method || ''
  var headers = caseless(self.request.headers)
  var body = self.request.body || ''
  var qsLib = self.request.qsLib || qs

  var form
  var query
  var contentType = headers.get('content-type') || ''
  var formContentType = 'application/x-www-form-urlencoded'
  var transport = _oauth.transport_method || 'header'

  if (contentType.slice(0, formContentType.length) === formContentType) {
    contentType = formContentType
    form = body
  }
  if (uri.query) {
    query = uri.query
  }
  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {
    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +
      'and content-type ' + formContentType))
  }

  if (!form && typeof _oauth.body_hash === 'boolean') {
    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString())
  }

  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)

  switch (transport) {
    case 'header':
      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '"'))
      break

    case 'query':
      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&')
      self.request.uri = url.parse(href)
      self.request.path = self.request.uri.path
      break

    case 'body':
      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')
      break

    default:
      self.request.emit('error', new Error('oauth: transport_method invalid'))
  }
}

exports.OAuth = OAuth


/***/ }),

/***/ "./node_modules/request/lib/querystring.js":
/*!*************************************************!*\
  !*** ./node_modules/request/lib/querystring.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var qs = __webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js")
var querystring = __webpack_require__(/*! querystring */ "querystring")

function Querystring (request) {
  this.request = request
  this.lib = null
  this.useQuerystring = null
  this.parseOptions = null
  this.stringifyOptions = null
}

Querystring.prototype.init = function (options) {
  if (this.lib) { return }

  this.useQuerystring = options.useQuerystring
  this.lib = (this.useQuerystring ? querystring : qs)

  this.parseOptions = options.qsParseOptions || {}
  this.stringifyOptions = options.qsStringifyOptions || {}
}

Querystring.prototype.stringify = function (obj) {
  return (this.useQuerystring)
    ? this.rfc3986(this.lib.stringify(obj,
      this.stringifyOptions.sep || null,
      this.stringifyOptions.eq || null,
      this.stringifyOptions))
    : this.lib.stringify(obj, this.stringifyOptions)
}

Querystring.prototype.parse = function (str) {
  return (this.useQuerystring)
    ? this.lib.parse(str,
      this.parseOptions.sep || null,
      this.parseOptions.eq || null,
      this.parseOptions)
    : this.lib.parse(str, this.parseOptions)
}

Querystring.prototype.rfc3986 = function (str) {
  return str.replace(/[!'()*]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

Querystring.prototype.unescape = querystring.unescape

exports.Querystring = Querystring


/***/ }),

/***/ "./node_modules/request/lib/redirect.js":
/*!**********************************************!*\
  !*** ./node_modules/request/lib/redirect.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var url = __webpack_require__(/*! url */ "url")
var isUrl = /^https?:/

function Redirect (request) {
  this.request = request
  this.followRedirect = true
  this.followRedirects = true
  this.followAllRedirects = false
  this.followOriginalHttpMethod = false
  this.allowRedirect = function () { return true }
  this.maxRedirects = 10
  this.redirects = []
  this.redirectsFollowed = 0
  this.removeRefererHeader = false
}

Redirect.prototype.onRequest = function (options) {
  var self = this

  if (options.maxRedirects !== undefined) {
    self.maxRedirects = options.maxRedirects
  }
  if (typeof options.followRedirect === 'function') {
    self.allowRedirect = options.followRedirect
  }
  if (options.followRedirect !== undefined) {
    self.followRedirects = !!options.followRedirect
  }
  if (options.followAllRedirects !== undefined) {
    self.followAllRedirects = options.followAllRedirects
  }
  if (self.followRedirects || self.followAllRedirects) {
    self.redirects = self.redirects || []
  }
  if (options.removeRefererHeader !== undefined) {
    self.removeRefererHeader = options.removeRefererHeader
  }
  if (options.followOriginalHttpMethod !== undefined) {
    self.followOriginalHttpMethod = options.followOriginalHttpMethod
  }
}

Redirect.prototype.redirectTo = function (response) {
  var self = this
  var request = self.request

  var redirectTo = null
  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {
    var location = response.caseless.get('location')
    request.debug('redirect', location)

    if (self.followAllRedirects) {
      redirectTo = location
    } else if (self.followRedirects) {
      switch (request.method) {
        case 'PATCH':
        case 'PUT':
        case 'POST':
        case 'DELETE':
          // Do not follow redirects
          break
        default:
          redirectTo = location
          break
      }
    }
  } else if (response.statusCode === 401) {
    var authHeader = request._auth.onResponse(response)
    if (authHeader) {
      request.setHeader('authorization', authHeader)
      redirectTo = request.uri
    }
  }
  return redirectTo
}

Redirect.prototype.onResponse = function (response) {
  var self = this
  var request = self.request

  var redirectTo = self.redirectTo(response)
  if (!redirectTo || !self.allowRedirect.call(request, response)) {
    return false
  }

  request.debug('redirect to', redirectTo)

  // ignore any potential response body.  it cannot possibly be useful
  // to us at this point.
  // response.resume should be defined, but check anyway before calling. Workaround for browserify.
  if (response.resume) {
    response.resume()
  }

  if (self.redirectsFollowed >= self.maxRedirects) {
    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href))
    return false
  }
  self.redirectsFollowed += 1

  if (!isUrl.test(redirectTo)) {
    redirectTo = url.resolve(request.uri.href, redirectTo)
  }

  var uriPrev = request.uri
  request.uri = url.parse(redirectTo)

  // handle the case where we change protocol from https to http or vice versa
  if (request.uri.protocol !== uriPrev.protocol) {
    delete request.agent
  }

  self.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo })

  if (self.followAllRedirects && request.method !== 'HEAD' &&
    response.statusCode !== 401 && response.statusCode !== 307) {
    request.method = self.followOriginalHttpMethod ? request.method : 'GET'
  }
  // request.method = 'GET' // Force all redirects to use GET || commented out fixes #215
  delete request.src
  delete request.req
  delete request._started
  if (response.statusCode !== 401 && response.statusCode !== 307) {
    // Remove parameters from the previous response, unless this is the second request
    // for a server that requires digest authentication.
    delete request.body
    delete request._form
    if (request.headers) {
      request.removeHeader('host')
      request.removeHeader('content-type')
      request.removeHeader('content-length')
      if (request.uri.hostname !== request.originalHost.split(':')[0]) {
        // Remove authorization if changing hostnames (but not if just
        // changing ports or protocols).  This matches the behavior of curl:
        // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710
        request.removeHeader('authorization')
      }
    }
  }

  if (!self.removeRefererHeader) {
    request.setHeader('referer', uriPrev.href)
  }

  request.emit('redirect')

  request.init()

  return true
}

exports.Redirect = Redirect


/***/ }),

/***/ "./node_modules/request/lib/tunnel.js":
/*!********************************************!*\
  !*** ./node_modules/request/lib/tunnel.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var url = __webpack_require__(/*! url */ "url")
var tunnel = __webpack_require__(/*! tunnel-agent */ "./node_modules/tunnel-agent/index.js")

var defaultProxyHeaderWhiteList = [
  'accept',
  'accept-charset',
  'accept-encoding',
  'accept-language',
  'accept-ranges',
  'cache-control',
  'content-encoding',
  'content-language',
  'content-location',
  'content-md5',
  'content-range',
  'content-type',
  'connection',
  'date',
  'expect',
  'max-forwards',
  'pragma',
  'referer',
  'te',
  'user-agent',
  'via'
]

var defaultProxyHeaderExclusiveList = [
  'proxy-authorization'
]

function constructProxyHost (uriObject) {
  var port = uriObject.port
  var protocol = uriObject.protocol
  var proxyHost = uriObject.hostname + ':'

  if (port) {
    proxyHost += port
  } else if (protocol === 'https:') {
    proxyHost += '443'
  } else {
    proxyHost += '80'
  }

  return proxyHost
}

function constructProxyHeaderWhiteList (headers, proxyHeaderWhiteList) {
  var whiteList = proxyHeaderWhiteList
    .reduce(function (set, header) {
      set[header.toLowerCase()] = true
      return set
    }, {})

  return Object.keys(headers)
    .filter(function (header) {
      return whiteList[header.toLowerCase()]
    })
    .reduce(function (set, header) {
      set[header] = headers[header]
      return set
    }, {})
}

function constructTunnelOptions (request, proxyHeaders) {
  var proxy = request.proxy

  var tunnelOptions = {
    proxy: {
      host: proxy.hostname,
      port: +proxy.port,
      proxyAuth: proxy.auth,
      headers: proxyHeaders
    },
    headers: request.headers,
    ca: request.ca,
    cert: request.cert,
    key: request.key,
    passphrase: request.passphrase,
    pfx: request.pfx,
    ciphers: request.ciphers,
    rejectUnauthorized: request.rejectUnauthorized,
    secureOptions: request.secureOptions,
    secureProtocol: request.secureProtocol
  }

  return tunnelOptions
}

function constructTunnelFnName (uri, proxy) {
  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http')
  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http')
  return [uriProtocol, proxyProtocol].join('Over')
}

function getTunnelFn (request) {
  var uri = request.uri
  var proxy = request.proxy
  var tunnelFnName = constructTunnelFnName(uri, proxy)
  return tunnel[tunnelFnName]
}

function Tunnel (request) {
  this.request = request
  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList
  this.proxyHeaderExclusiveList = []
  if (typeof request.tunnel !== 'undefined') {
    this.tunnelOverride = request.tunnel
  }
}

Tunnel.prototype.isEnabled = function () {
  var self = this
  var request = self.request
    // Tunnel HTTPS by default. Allow the user to override this setting.

  // If self.tunnelOverride is set (the user specified a value), use it.
  if (typeof self.tunnelOverride !== 'undefined') {
    return self.tunnelOverride
  }

  // If the destination is HTTPS, tunnel.
  if (request.uri.protocol === 'https:') {
    return true
  }

  // Otherwise, do not use tunnel.
  return false
}

Tunnel.prototype.setup = function (options) {
  var self = this
  var request = self.request

  options = options || {}

  if (typeof request.proxy === 'string') {
    request.proxy = url.parse(request.proxy)
  }

  if (!request.proxy || !request.tunnel) {
    return false
  }

  // Setup Proxy Header Exclusive List and White List
  if (options.proxyHeaderWhiteList) {
    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList
  }
  if (options.proxyHeaderExclusiveList) {
    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList
  }

  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList)
  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList)

  // Setup Proxy Headers and Proxy Headers Host
  // Only send the Proxy White Listed Header names
  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList)
  proxyHeaders.host = constructProxyHost(request.uri)

  proxyHeaderExclusiveList.forEach(request.removeHeader, request)

  // Set Agent from Tunnel Data
  var tunnelFn = getTunnelFn(request)
  var tunnelOptions = constructTunnelOptions(request, proxyHeaders)
  request.agent = tunnelFn(tunnelOptions)

  return true
}

Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList
Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList
exports.Tunnel = Tunnel


/***/ }),

/***/ "./node_modules/request/request.js":
/*!*****************************************!*\
  !*** ./node_modules/request/request.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var http = __webpack_require__(/*! http */ "http")
var https = __webpack_require__(/*! https */ "https")
var url = __webpack_require__(/*! url */ "url")
var util = __webpack_require__(/*! util */ "util")
var stream = __webpack_require__(/*! stream */ "stream")
var zlib = __webpack_require__(/*! zlib */ "zlib")
var aws2 = __webpack_require__(/*! aws-sign2 */ "./node_modules/aws-sign2/index.js")
var aws4 = __webpack_require__(/*! aws4 */ "./node_modules/aws4/aws4.js")
var httpSignature = __webpack_require__(/*! http-signature */ "./node_modules/http-signature/lib/index.js")
var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js")
var caseless = __webpack_require__(/*! caseless */ "./node_modules/caseless/index.js")
var ForeverAgent = __webpack_require__(/*! forever-agent */ "./node_modules/forever-agent/index.js")
var FormData = __webpack_require__(/*! form-data */ "./node_modules/form-data/lib/form_data.js")
var extend = __webpack_require__(/*! extend */ "./node_modules/extend/index.js")
var isstream = __webpack_require__(/*! isstream */ "./node_modules/isstream/isstream.js")
var isTypedArray = __webpack_require__(/*! is-typedarray */ "./node_modules/is-typedarray/index.js").strict
var helpers = __webpack_require__(/*! ./lib/helpers */ "./node_modules/request/lib/helpers.js")
var cookies = __webpack_require__(/*! ./lib/cookies */ "./node_modules/request/lib/cookies.js")
var getProxyFromURI = __webpack_require__(/*! ./lib/getProxyFromURI */ "./node_modules/request/lib/getProxyFromURI.js")
var Querystring = __webpack_require__(/*! ./lib/querystring */ "./node_modules/request/lib/querystring.js").Querystring
var Har = __webpack_require__(/*! ./lib/har */ "./node_modules/request/lib/har.js").Har
var Auth = __webpack_require__(/*! ./lib/auth */ "./node_modules/request/lib/auth.js").Auth
var OAuth = __webpack_require__(/*! ./lib/oauth */ "./node_modules/request/lib/oauth.js").OAuth
var hawk = __webpack_require__(/*! ./lib/hawk */ "./node_modules/request/lib/hawk.js")
var Multipart = __webpack_require__(/*! ./lib/multipart */ "./node_modules/request/lib/multipart.js").Multipart
var Redirect = __webpack_require__(/*! ./lib/redirect */ "./node_modules/request/lib/redirect.js").Redirect
var Tunnel = __webpack_require__(/*! ./lib/tunnel */ "./node_modules/request/lib/tunnel.js").Tunnel
var now = __webpack_require__(/*! performance-now */ "./node_modules/performance-now/lib/performance-now.js")
var Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer

var safeStringify = helpers.safeStringify
var isReadStream = helpers.isReadStream
var toBase64 = helpers.toBase64
var defer = helpers.defer
var copy = helpers.copy
var version = helpers.version
var globalCookieJar = cookies.jar()

var globalPool = {}

function filterForNonReserved (reserved, options) {
  // Filter out properties that are not reserved.
  // Reserved values are passed in at call site.

  var object = {}
  for (var i in options) {
    var notReserved = (reserved.indexOf(i) === -1)
    if (notReserved) {
      object[i] = options[i]
    }
  }
  return object
}

function filterOutReservedFunctions (reserved, options) {
  // Filter out properties that are functions and are reserved.
  // Reserved values are passed in at call site.

  var object = {}
  for (var i in options) {
    var isReserved = !(reserved.indexOf(i) === -1)
    var isFunction = (typeof options[i] === 'function')
    if (!(isReserved && isFunction)) {
      object[i] = options[i]
    }
  }
  return object
}

// Return a simpler request object to allow serialization
function requestToJSON () {
  var self = this
  return {
    uri: self.uri,
    method: self.method,
    headers: self.headers
  }
}

// Return a simpler response object to allow serialization
function responseToJSON () {
  var self = this
  return {
    statusCode: self.statusCode,
    body: self.body,
    headers: self.headers,
    request: requestToJSON.call(self.request)
  }
}

function Request (options) {
  // if given the method property in options, set property explicitMethod to true

  // extend the Request instance with any non-reserved properties
  // remove any reserved functions from the options object
  // set Request instance to be readable and writable
  // call init

  var self = this

  // start with HAR, then override with additional options
  if (options.har) {
    self._har = new Har(self)
    options = self._har.options(options)
  }

  stream.Stream.call(self)
  var reserved = Object.keys(Request.prototype)
  var nonReserved = filterForNonReserved(reserved, options)

  extend(self, nonReserved)
  options = filterOutReservedFunctions(reserved, options)

  self.readable = true
  self.writable = true
  if (options.method) {
    self.explicitMethod = true
  }
  self._qs = new Querystring(self)
  self._auth = new Auth(self)
  self._oauth = new OAuth(self)
  self._multipart = new Multipart(self)
  self._redirect = new Redirect(self)
  self._tunnel = new Tunnel(self)
  self.init(options)
}

util.inherits(Request, stream.Stream)

// Debugging
Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG)
function debug () {
  if (Request.debug) {
    console.error('REQUEST %s', util.format.apply(util, arguments))
  }
}
Request.prototype.debug = debug

Request.prototype.init = function (options) {
  // init() contains all the code to setup the request object.
  // the actual outgoing request is not started until start() is called
  // this function is called from both the constructor and on redirect.
  var self = this
  if (!options) {
    options = {}
  }
  self.headers = self.headers ? copy(self.headers) : {}

  // Delete headers with value undefined since they break
  // ClientRequest.OutgoingMessage.setHeader in node 0.12
  for (var headerName in self.headers) {
    if (typeof self.headers[headerName] === 'undefined') {
      delete self.headers[headerName]
    }
  }

  caseless.httpify(self, self.headers)

  if (!self.method) {
    self.method = options.method || 'GET'
  }
  if (!self.localAddress) {
    self.localAddress = options.localAddress
  }

  self._qs.init(options)

  debug(options)
  if (!self.pool && self.pool !== false) {
    self.pool = globalPool
  }
  self.dests = self.dests || []
  self.__isRequestRequest = true

  // Protect against double callback
  if (!self._callback && self.callback) {
    self._callback = self.callback
    self.callback = function () {
      if (self._callbackCalled) {
        return // Print a warning maybe?
      }
      self._callbackCalled = true
      self._callback.apply(self, arguments)
    }
    self.on('error', self.callback.bind())
    self.on('complete', self.callback.bind(self, null))
  }

  // People use this property instead all the time, so support it
  if (!self.uri && self.url) {
    self.uri = self.url
    delete self.url
  }

  // If there's a baseUrl, then use it as the base URL (i.e. uri must be
  // specified as a relative path and is appended to baseUrl).
  if (self.baseUrl) {
    if (typeof self.baseUrl !== 'string') {
      return self.emit('error', new Error('options.baseUrl must be a string'))
    }

    if (typeof self.uri !== 'string') {
      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))
    }

    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {
      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))
    }

    // Handle all cases to make sure that there's only one slash between
    // baseUrl and uri.
    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1
    var uriStartsWithSlash = self.uri.indexOf('/') === 0

    if (baseUrlEndsWithSlash && uriStartsWithSlash) {
      self.uri = self.baseUrl + self.uri.slice(1)
    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
      self.uri = self.baseUrl + self.uri
    } else if (self.uri === '') {
      self.uri = self.baseUrl
    } else {
      self.uri = self.baseUrl + '/' + self.uri
    }
    delete self.baseUrl
  }

  // A URI is needed by this point, emit error if we haven't been able to get one
  if (!self.uri) {
    return self.emit('error', new Error('options.uri is a required argument'))
  }

  // If a string URI/URL was given, parse it into a URL object
  if (typeof self.uri === 'string') {
    self.uri = url.parse(self.uri)
  }

  // Some URL objects are not from a URL parsed string and need href added
  if (!self.uri.href) {
    self.uri.href = url.format(self.uri)
  }

  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme
  if (self.uri.protocol === 'unix:') {
    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))
  }

  // Support Unix Sockets
  if (self.uri.host === 'unix') {
    self.enableUnixSocket()
  }

  if (self.strictSSL === false) {
    self.rejectUnauthorized = false
  }

  if (!self.uri.pathname) { self.uri.pathname = '/' }

  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {
    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar
    // Detect and reject it as soon as possible
    var faultyUri = url.format(self.uri)
    var message = 'Invalid URI "' + faultyUri + '"'
    if (Object.keys(options).length === 0) {
      // No option ? This can be the sign of a redirect
      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)
      // they should be warned that it can be caused by a redirection (can save some hair)
      message += '. This can be caused by a crappy redirection.'
    }
    // This error was fatal
    self.abort()
    return self.emit('error', new Error(message))
  }

  if (!self.hasOwnProperty('proxy')) {
    self.proxy = getProxyFromURI(self.uri)
  }

  self.tunnel = self._tunnel.isEnabled()
  if (self.proxy) {
    self._tunnel.setup(options)
  }

  self._redirect.onRequest(options)

  self.setHost = false
  if (!self.hasHeader('host')) {
    var hostHeaderName = self.originalHostHeaderName || 'host'
    self.setHeader(hostHeaderName, self.uri.host)
    // Drop :port suffix from Host header if known protocol.
    if (self.uri.port) {
      if ((self.uri.port === '80' && self.uri.protocol === 'http:') ||
          (self.uri.port === '443' && self.uri.protocol === 'https:')) {
        self.setHeader(hostHeaderName, self.uri.hostname)
      }
    }
    self.setHost = true
  }

  self.jar(self._jar || options.jar)

  if (!self.uri.port) {
    if (self.uri.protocol === 'http:') { self.uri.port = 80 } else if (self.uri.protocol === 'https:') { self.uri.port = 443 }
  }

  if (self.proxy && !self.tunnel) {
    self.port = self.proxy.port
    self.host = self.proxy.hostname
  } else {
    self.port = self.uri.port
    self.host = self.uri.hostname
  }

  if (options.form) {
    self.form(options.form)
  }

  if (options.formData) {
    var formData = options.formData
    var requestForm = self.form()
    var appendFormValue = function (key, value) {
      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {
        requestForm.append(key, value.value, value.options)
      } else {
        requestForm.append(key, value)
      }
    }
    for (var formKey in formData) {
      if (formData.hasOwnProperty(formKey)) {
        var formValue = formData[formKey]
        if (formValue instanceof Array) {
          for (var j = 0; j < formValue.length; j++) {
            appendFormValue(formKey, formValue[j])
          }
        } else {
          appendFormValue(formKey, formValue)
        }
      }
    }
  }

  if (options.qs) {
    self.qs(options.qs)
  }

  if (self.uri.path) {
    self.path = self.uri.path
  } else {
    self.path = self.uri.pathname + (self.uri.search || '')
  }

  if (self.path.length === 0) {
    self.path = '/'
  }

  // Auth must happen last in case signing is dependent on other headers
  if (options.aws) {
    self.aws(options.aws)
  }

  if (options.hawk) {
    self.hawk(options.hawk)
  }

  if (options.httpSignature) {
    self.httpSignature(options.httpSignature)
  }

  if (options.auth) {
    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {
      options.auth.user = options.auth.username
    }
    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {
      options.auth.pass = options.auth.password
    }

    self.auth(
      options.auth.user,
      options.auth.pass,
      options.auth.sendImmediately,
      options.auth.bearer
    )
  }

  if (self.gzip && !self.hasHeader('accept-encoding')) {
    self.setHeader('accept-encoding', 'gzip, deflate')
  }

  if (self.uri.auth && !self.hasHeader('authorization')) {
    var uriAuthPieces = self.uri.auth.split(':').map(function (item) { return self._qs.unescape(item) })
    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)
  }

  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {
    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) { return self._qs.unescape(item) })
    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))
    self.setHeader('proxy-authorization', authHeader)
  }

  if (self.proxy && !self.tunnel) {
    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)
  }

  if (options.json) {
    self.json(options.json)
  }
  if (options.multipart) {
    self.multipart(options.multipart)
  }

  if (options.time) {
    self.timing = true

    // NOTE: elapsedTime is deprecated in favor of .timings
    self.elapsedTime = self.elapsedTime || 0
  }

  function setContentLength () {
    if (isTypedArray(self.body)) {
      self.body = Buffer.from(self.body)
    }

    if (!self.hasHeader('content-length')) {
      var length
      if (typeof self.body === 'string') {
        length = Buffer.byteLength(self.body)
      } else if (Array.isArray(self.body)) {
        length = self.body.reduce(function (a, b) { return a + b.length }, 0)
      } else {
        length = self.body.length
      }

      if (length) {
        self.setHeader('content-length', length)
      } else {
        self.emit('error', new Error('Argument error, options.body.'))
      }
    }
  }
  if (self.body && !isstream(self.body)) {
    setContentLength()
  }

  if (options.oauth) {
    self.oauth(options.oauth)
  } else if (self._oauth.params && self.hasHeader('authorization')) {
    self.oauth(self._oauth.params)
  }

  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol
  var defaultModules = {'http:': http, 'https:': https}
  var httpModules = self.httpModules || {}

  self.httpModule = httpModules[protocol] || defaultModules[protocol]

  if (!self.httpModule) {
    return self.emit('error', new Error('Invalid protocol: ' + protocol))
  }

  if (options.ca) {
    self.ca = options.ca
  }

  if (!self.agent) {
    if (options.agentOptions) {
      self.agentOptions = options.agentOptions
    }

    if (options.agentClass) {
      self.agentClass = options.agentClass
    } else if (options.forever) {
      var v = version()
      // use ForeverAgent in node 0.10- only
      if (v.major === 0 && v.minor <= 10) {
        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL
      } else {
        self.agentClass = self.httpModule.Agent
        self.agentOptions = self.agentOptions || {}
        self.agentOptions.keepAlive = true
      }
    } else {
      self.agentClass = self.httpModule.Agent
    }
  }

  if (self.pool === false) {
    self.agent = false
  } else {
    self.agent = self.agent || self.getNewAgent()
  }

  self.on('pipe', function (src) {
    if (self.ntick && self._started) {
      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))
    }
    self.src = src
    if (isReadStream(src)) {
      if (!self.hasHeader('content-type')) {
        self.setHeader('content-type', mime.lookup(src.path))
      }
    } else {
      if (src.headers) {
        for (var i in src.headers) {
          if (!self.hasHeader(i)) {
            self.setHeader(i, src.headers[i])
          }
        }
      }
      if (self._json && !self.hasHeader('content-type')) {
        self.setHeader('content-type', 'application/json')
      }
      if (src.method && !self.explicitMethod) {
        self.method = src.method
      }
    }

  // self.on('pipe', function () {
  //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')
  // })
  })

  defer(function () {
    if (self._aborted) {
      return
    }

    var end = function () {
      if (self._form) {
        if (!self._auth.hasAuth) {
          self._form.pipe(self)
        } else if (self._auth.hasAuth && self._auth.sentAuth) {
          self._form.pipe(self)
        }
      }
      if (self._multipart && self._multipart.chunked) {
        self._multipart.body.pipe(self)
      }
      if (self.body) {
        if (isstream(self.body)) {
          self.body.pipe(self)
        } else {
          setContentLength()
          if (Array.isArray(self.body)) {
            self.body.forEach(function (part) {
              self.write(part)
            })
          } else {
            self.write(self.body)
          }
          self.end()
        }
      } else if (self.requestBodyStream) {
        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')
        self.requestBodyStream.pipe(self)
      } else if (!self.src) {
        if (self._auth.hasAuth && !self._auth.sentAuth) {
          self.end()
          return
        }
        if (self.method !== 'GET' && typeof self.method !== 'undefined') {
          self.setHeader('content-length', 0)
        }
        self.end()
      }
    }

    if (self._form && !self.hasHeader('content-length')) {
      // Before ending the request, we had to compute the length of the whole form, asyncly
      self.setHeader(self._form.getHeaders(), true)
      self._form.getLength(function (err, length) {
        if (!err && !isNaN(length)) {
          self.setHeader('content-length', length)
        }
        end()
      })
    } else {
      end()
    }

    self.ntick = true
  })
}

Request.prototype.getNewAgent = function () {
  var self = this
  var Agent = self.agentClass
  var options = {}
  if (self.agentOptions) {
    for (var i in self.agentOptions) {
      options[i] = self.agentOptions[i]
    }
  }
  if (self.ca) {
    options.ca = self.ca
  }
  if (self.ciphers) {
    options.ciphers = self.ciphers
  }
  if (self.secureProtocol) {
    options.secureProtocol = self.secureProtocol
  }
  if (self.secureOptions) {
    options.secureOptions = self.secureOptions
  }
  if (typeof self.rejectUnauthorized !== 'undefined') {
    options.rejectUnauthorized = self.rejectUnauthorized
  }

  if (self.cert && self.key) {
    options.key = self.key
    options.cert = self.cert
  }

  if (self.pfx) {
    options.pfx = self.pfx
  }

  if (self.passphrase) {
    options.passphrase = self.passphrase
  }

  var poolKey = ''

  // different types of agents are in different pools
  if (Agent !== self.httpModule.Agent) {
    poolKey += Agent.name
  }

  // ca option is only relevant if proxy or destination are https
  var proxy = self.proxy
  if (typeof proxy === 'string') {
    proxy = url.parse(proxy)
  }
  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'

  if (isHttps) {
    if (options.ca) {
      if (poolKey) {
        poolKey += ':'
      }
      poolKey += options.ca
    }

    if (typeof options.rejectUnauthorized !== 'undefined') {
      if (poolKey) {
        poolKey += ':'
      }
      poolKey += options.rejectUnauthorized
    }

    if (options.cert) {
      if (poolKey) {
        poolKey += ':'
      }
      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')
    }

    if (options.pfx) {
      if (poolKey) {
        poolKey += ':'
      }
      poolKey += options.pfx.toString('ascii')
    }

    if (options.ciphers) {
      if (poolKey) {
        poolKey += ':'
      }
      poolKey += options.ciphers
    }

    if (options.secureProtocol) {
      if (poolKey) {
        poolKey += ':'
      }
      poolKey += options.secureProtocol
    }

    if (options.secureOptions) {
      if (poolKey) {
        poolKey += ':'
      }
      poolKey += options.secureOptions
    }
  }

  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {
    // not doing anything special.  Use the globalAgent
    return self.httpModule.globalAgent
  }

  // we're using a stored agent.  Make sure it's protocol-specific
  poolKey = self.uri.protocol + poolKey

  // generate a new agent for this setting if none yet exists
  if (!self.pool[poolKey]) {
    self.pool[poolKey] = new Agent(options)
    // properly set maxSockets on new agents
    if (self.pool.maxSockets) {
      self.pool[poolKey].maxSockets = self.pool.maxSockets
    }
  }

  return self.pool[poolKey]
}

Request.prototype.start = function () {
  // start() is called once we are ready to send the outgoing HTTP request.
  // this is usually called on the first write(), end() or on nextTick()
  var self = this

  if (self.timing) {
    // All timings will be relative to this request's startTime.  In order to do this,
    // we need to capture the wall-clock start time (via Date), immediately followed
    // by the high-resolution timer (via now()).  While these two won't be set
    // at the _exact_ same time, they should be close enough to be able to calculate
    // high-resolution, monotonically non-decreasing timestamps relative to startTime.
    var startTime = new Date().getTime()
    var startTimeNow = now()
  }

  if (self._aborted) {
    return
  }

  self._started = true
  self.method = self.method || 'GET'
  self.href = self.uri.href

  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {
    self.setHeader('content-length', self.src.stat.size)
  }
  if (self._aws) {
    self.aws(self._aws, true)
  }

  // We have a method named auth, which is completely different from the http.request
  // auth option.  If we don't remove it, we're gonna have a bad time.
  var reqOptions = copy(self)
  delete reqOptions.auth

  debug('make request', self.uri.href)

  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we
  // should delete it for now since we handle timeouts manually for better
  // consistency with node versions before v6.8.0
  delete reqOptions.timeout

  try {
    self.req = self.httpModule.request(reqOptions)
  } catch (err) {
    self.emit('error', err)
    return
  }

  if (self.timing) {
    self.startTime = startTime
    self.startTimeNow = startTimeNow

    // Timing values will all be relative to startTime (by comparing to startTimeNow
    // so we have an accurate clock)
    self.timings = {}
  }

  var timeout
  if (self.timeout && !self.timeoutTimer) {
    if (self.timeout < 0) {
      timeout = 0
    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {
      timeout = self.timeout
    }
  }

  self.req.on('response', self.onRequestResponse.bind(self))
  self.req.on('error', self.onRequestError.bind(self))
  self.req.on('drain', function () {
    self.emit('drain')
  })

  self.req.on('socket', function (socket) {
    // `._connecting` was the old property which was made public in node v6.1.0
    var isConnecting = socket._connecting || socket.connecting
    if (self.timing) {
      self.timings.socket = now() - self.startTimeNow

      if (isConnecting) {
        var onLookupTiming = function () {
          self.timings.lookup = now() - self.startTimeNow
        }

        var onConnectTiming = function () {
          self.timings.connect = now() - self.startTimeNow
        }

        socket.once('lookup', onLookupTiming)
        socket.once('connect', onConnectTiming)

        // clean up timing event listeners if needed on error
        self.req.once('error', function () {
          socket.removeListener('lookup', onLookupTiming)
          socket.removeListener('connect', onConnectTiming)
        })
      }
    }

    var setReqTimeout = function () {
      // This timeout sets the amount of time to wait *between* bytes sent
      // from the server once connected.
      //
      // In particular, it's useful for erroring if the server fails to send
      // data halfway through streaming a response.
      self.req.setTimeout(timeout, function () {
        if (self.req) {
          self.abort()
          var e = new Error('ESOCKETTIMEDOUT')
          e.code = 'ESOCKETTIMEDOUT'
          e.connect = false
          self.emit('error', e)
        }
      })
    }
    if (timeout !== undefined) {
      // Only start the connection timer if we're actually connecting a new
      // socket, otherwise if we're already connected (because this is a
      // keep-alive connection) do not bother. This is important since we won't
      // get a 'connect' event for an already connected socket.
      if (isConnecting) {
        var onReqSockConnect = function () {
          socket.removeListener('connect', onReqSockConnect)
          clearTimeout(self.timeoutTimer)
          self.timeoutTimer = null
          setReqTimeout()
        }

        socket.on('connect', onReqSockConnect)

        self.req.on('error', function (err) { // eslint-disable-line handle-callback-err
          socket.removeListener('connect', onReqSockConnect)
        })

        // Set a timeout in memory - this block will throw if the server takes more
        // than `timeout` to write the HTTP status and headers (corresponding to
        // the on('response') event on the client). NB: this measures wall-clock
        // time, not the time between bytes sent by the server.
        self.timeoutTimer = setTimeout(function () {
          socket.removeListener('connect', onReqSockConnect)
          self.abort()
          var e = new Error('ETIMEDOUT')
          e.code = 'ETIMEDOUT'
          e.connect = true
          self.emit('error', e)
        }, timeout)
      } else {
        // We're already connected
        setReqTimeout()
      }
    }
    self.emit('socket', socket)
  })

  self.emit('request', self.req)
}

Request.prototype.onRequestError = function (error) {
  var self = this
  if (self._aborted) {
    return
  }
  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' &&
    self.agent.addRequestNoreuse) {
    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
    self.start()
    self.req.end()
    return
  }
  if (self.timeout && self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }
  self.emit('error', error)
}

Request.prototype.onRequestResponse = function (response) {
  var self = this

  if (self.timing) {
    self.timings.response = now() - self.startTimeNow
  }

  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)
  response.on('end', function () {
    if (self.timing) {
      self.timings.end = now() - self.startTimeNow
      response.timingStart = self.startTime

      // fill in the blanks for any periods that didn't trigger, such as
      // no lookup or connect due to keep alive
      if (!self.timings.socket) {
        self.timings.socket = 0
      }
      if (!self.timings.lookup) {
        self.timings.lookup = self.timings.socket
      }
      if (!self.timings.connect) {
        self.timings.connect = self.timings.lookup
      }
      if (!self.timings.response) {
        self.timings.response = self.timings.connect
      }

      debug('elapsed time', self.timings.end)

      // elapsedTime includes all redirects
      self.elapsedTime += Math.round(self.timings.end)

      // NOTE: elapsedTime is deprecated in favor of .timings
      response.elapsedTime = self.elapsedTime

      // timings is just for the final fetch
      response.timings = self.timings

      // pre-calculate phase timings as well
      response.timingPhases = {
        wait: self.timings.socket,
        dns: self.timings.lookup - self.timings.socket,
        tcp: self.timings.connect - self.timings.lookup,
        firstByte: self.timings.response - self.timings.connect,
        download: self.timings.end - self.timings.response,
        total: self.timings.end
      }
    }
    debug('response end', self.uri.href, response.statusCode, response.headers)
  })

  if (self._aborted) {
    debug('aborted', self.uri.href)
    response.resume()
    return
  }

  self.response = response
  response.request = self
  response.toJSON = responseToJSON

  // XXX This is different on 0.10, because SSL is strict by default
  if (self.httpModule === https &&
    self.strictSSL && (!response.hasOwnProperty('socket') ||
    !response.socket.authorized)) {
    debug('strict ssl error', self.uri.href)
    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'
    self.emit('error', new Error('SSL Error: ' + sslErr))
    return
  }

  // Save the original host before any redirect (if it changes, we need to
  // remove any authorization headers).  Also remember the case of the header
  // name because lots of broken servers expect Host instead of host and we
  // want the caller to be able to specify this.
  self.originalHost = self.getHeader('host')
  if (!self.originalHostHeaderName) {
    self.originalHostHeaderName = self.hasHeader('host')
  }
  if (self.setHost) {
    self.removeHeader('host')
  }
  if (self.timeout && self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }

  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar
  var addCookie = function (cookie) {
    // set the cookie if it's domain in the href's domain.
    try {
      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})
    } catch (e) {
      self.emit('error', e)
    }
  }

  response.caseless = caseless(response.headers)

  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {
    var headerName = response.caseless.has('set-cookie')
    if (Array.isArray(response.headers[headerName])) {
      response.headers[headerName].forEach(addCookie)
    } else {
      addCookie(response.headers[headerName])
    }
  }

  if (self._redirect.onResponse(response)) {
    return // Ignore the rest of the response
  } else {
    // Be a good stream and emit end when the response is finished.
    // Hack to emit end on close because of a core bug that never fires end
    response.on('close', function () {
      if (!self._ended) {
        self.response.emit('end')
      }
    })

    response.once('end', function () {
      self._ended = true
    })

    var noBody = function (code) {
      return (
        self.method === 'HEAD' ||
        // Informational
        (code >= 100 && code < 200) ||
        // No Content
        code === 204 ||
        // Not Modified
        code === 304
      )
    }

    var responseContent
    if (self.gzip && !noBody(response.statusCode)) {
      var contentEncoding = response.headers['content-encoding'] || 'identity'
      contentEncoding = contentEncoding.trim().toLowerCase()

      // Be more lenient with decoding compressed responses, since (very rarely)
      // servers send slightly invalid gzip responses that are still accepted
      // by common browsers.
      // Always using Z_SYNC_FLUSH is what cURL does.
      var zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      }

      if (contentEncoding === 'gzip') {
        responseContent = zlib.createGunzip(zlibOptions)
        response.pipe(responseContent)
      } else if (contentEncoding === 'deflate') {
        responseContent = zlib.createInflate(zlibOptions)
        response.pipe(responseContent)
      } else {
        // Since previous versions didn't check for Content-Encoding header,
        // ignore any invalid values to preserve backwards-compatibility
        if (contentEncoding !== 'identity') {
          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)
        }
        responseContent = response
      }
    } else {
      responseContent = response
    }

    if (self.encoding) {
      if (self.dests.length !== 0) {
        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')
      } else {
        responseContent.setEncoding(self.encoding)
      }
    }

    if (self._paused) {
      responseContent.pause()
    }

    self.responseContent = responseContent

    self.emit('response', response)

    self.dests.forEach(function (dest) {
      self.pipeDest(dest)
    })

    responseContent.on('data', function (chunk) {
      if (self.timing && !self.responseStarted) {
        self.responseStartTime = (new Date()).getTime()

        // NOTE: responseStartTime is deprecated in favor of .timings
        response.responseStartTime = self.responseStartTime
      }
      self._destdata = true
      self.emit('data', chunk)
    })
    responseContent.once('end', function (chunk) {
      self.emit('end', chunk)
    })
    responseContent.on('error', function (error) {
      self.emit('error', error)
    })
    responseContent.on('close', function () { self.emit('close') })

    if (self.callback) {
      self.readResponseBody(response)
    } else { // if no callback
      self.on('end', function () {
        if (self._aborted) {
          debug('aborted', self.uri.href)
          return
        }
        self.emit('complete', response)
      })
    }
  }
  debug('finish init function', self.uri.href)
}

Request.prototype.readResponseBody = function (response) {
  var self = this
  debug("reading response's body")
  var buffers = []
  var bufferLength = 0
  var strings = []

  self.on('data', function (chunk) {
    if (!Buffer.isBuffer(chunk)) {
      strings.push(chunk)
    } else if (chunk.length) {
      bufferLength += chunk.length
      buffers.push(chunk)
    }
  })
  self.on('end', function () {
    debug('end event', self.uri.href)
    if (self._aborted) {
      debug('aborted', self.uri.href)
      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.
      // This can lead to leaky behavior if the user retains a reference to the request object.
      buffers = []
      bufferLength = 0
      return
    }

    if (bufferLength) {
      debug('has body', self.uri.href, bufferLength)
      response.body = Buffer.concat(buffers, bufferLength)
      if (self.encoding !== null) {
        response.body = response.body.toString(self.encoding)
      }
      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.
      // This can lead to leaky behavior if the user retains a reference to the request object.
      buffers = []
      bufferLength = 0
    } else if (strings.length) {
      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().
      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\uFEFF') {
        strings[0] = strings[0].substring(1)
      }
      response.body = strings.join('')
    }

    if (self._json) {
      try {
        response.body = JSON.parse(response.body, self._jsonReviver)
      } catch (e) {
        debug('invalid JSON received', self.uri.href)
      }
    }
    debug('emitting complete', self.uri.href)
    if (typeof response.body === 'undefined' && !self._json) {
      response.body = self.encoding === null ? Buffer.alloc(0) : ''
    }
    self.emit('complete', response, response.body)
  })
}

Request.prototype.abort = function () {
  var self = this
  self._aborted = true

  if (self.req) {
    self.req.abort()
  } else if (self.response) {
    self.response.destroy()
  }

  self.emit('abort')
}

Request.prototype.pipeDest = function (dest) {
  var self = this
  var response = self.response
  // Called after the response is received
  if (dest.headers && !dest.headersSent) {
    if (response.caseless.has('content-type')) {
      var ctname = response.caseless.has('content-type')
      if (dest.setHeader) {
        dest.setHeader(ctname, response.headers[ctname])
      } else {
        dest.headers[ctname] = response.headers[ctname]
      }
    }

    if (response.caseless.has('content-length')) {
      var clname = response.caseless.has('content-length')
      if (dest.setHeader) {
        dest.setHeader(clname, response.headers[clname])
      } else {
        dest.headers[clname] = response.headers[clname]
      }
    }
  }
  if (dest.setHeader && !dest.headersSent) {
    for (var i in response.headers) {
      // If the response content is being decoded, the Content-Encoding header
      // of the response doesn't represent the piped content, so don't pass it.
      if (!self.gzip || i !== 'content-encoding') {
        dest.setHeader(i, response.headers[i])
      }
    }
    dest.statusCode = response.statusCode
  }
  if (self.pipefilter) {
    self.pipefilter(response, dest)
  }
}

Request.prototype.qs = function (q, clobber) {
  var self = this
  var base
  if (!clobber && self.uri.query) {
    base = self._qs.parse(self.uri.query)
  } else {
    base = {}
  }

  for (var i in q) {
    base[i] = q[i]
  }

  var qs = self._qs.stringify(base)

  if (qs === '') {
    return self
  }

  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)
  self.url = self.uri
  self.path = self.uri.path

  if (self.uri.host === 'unix') {
    self.enableUnixSocket()
  }

  return self
}
Request.prototype.form = function (form) {
  var self = this
  if (form) {
    if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type'))) {
      self.setHeader('content-type', 'application/x-www-form-urlencoded')
    }
    self.body = (typeof form === 'string')
      ? self._qs.rfc3986(form.toString('utf8'))
      : self._qs.stringify(form).toString('utf8')
    return self
  }
  // create form-data object
  self._form = new FormData()
  self._form.on('error', function (err) {
    err.message = 'form-data: ' + err.message
    self.emit('error', err)
    self.abort()
  })
  return self._form
}
Request.prototype.multipart = function (multipart) {
  var self = this

  self._multipart.onRequest(multipart)

  if (!self._multipart.chunked) {
    self.body = self._multipart.body
  }

  return self
}
Request.prototype.json = function (val) {
  var self = this

  if (!self.hasHeader('accept')) {
    self.setHeader('accept', 'application/json')
  }

  if (typeof self.jsonReplacer === 'function') {
    self._jsonReplacer = self.jsonReplacer
  }

  self._json = true
  if (typeof val === 'boolean') {
    if (self.body !== undefined) {
      if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type'))) {
        self.body = safeStringify(self.body, self._jsonReplacer)
      } else {
        self.body = self._qs.rfc3986(self.body)
      }
      if (!self.hasHeader('content-type')) {
        self.setHeader('content-type', 'application/json')
      }
    }
  } else {
    self.body = safeStringify(val, self._jsonReplacer)
    if (!self.hasHeader('content-type')) {
      self.setHeader('content-type', 'application/json')
    }
  }

  if (typeof self.jsonReviver === 'function') {
    self._jsonReviver = self.jsonReviver
  }

  return self
}
Request.prototype.getHeader = function (name, headers) {
  var self = this
  var result, re, match
  if (!headers) {
    headers = self.headers
  }
  Object.keys(headers).forEach(function (key) {
    if (key.length !== name.length) {
      return
    }
    re = new RegExp(name, 'i')
    match = key.match(re)
    if (match) {
      result = headers[key]
    }
  })
  return result
}
Request.prototype.enableUnixSocket = function () {
  // Get the socket & request paths from the URL
  var unixParts = this.uri.path.split(':')
  var host = unixParts[0]
  var path = unixParts[1]
  // Apply unix properties to request
  this.socketPath = host
  this.uri.pathname = path
  this.uri.path = path
  this.uri.host = host
  this.uri.hostname = host
  this.uri.isUnix = true
}

Request.prototype.auth = function (user, pass, sendImmediately, bearer) {
  var self = this

  self._auth.onRequest(user, pass, sendImmediately, bearer)

  return self
}
Request.prototype.aws = function (opts, now) {
  var self = this

  if (!now) {
    self._aws = opts
    return self
  }

  if (opts.sign_version === 4 || opts.sign_version === '4') {
    // use aws4
    var options = {
      host: self.uri.host,
      path: self.uri.path,
      method: self.method,
      headers: self.headers,
      body: self.body
    }
    if (opts.service) {
      options.service = opts.service
    }
    var signRes = aws4.sign(options, {
      accessKeyId: opts.key,
      secretAccessKey: opts.secret,
      sessionToken: opts.session
    })
    self.setHeader('authorization', signRes.headers.Authorization)
    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])
    if (signRes.headers['X-Amz-Security-Token']) {
      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token'])
    }
  } else {
    // default: use aws-sign2
    var date = new Date()
    self.setHeader('date', date.toUTCString())
    var auth = {
      key: opts.key,
      secret: opts.secret,
      verb: self.method.toUpperCase(),
      date: date,
      contentType: self.getHeader('content-type') || '',
      md5: self.getHeader('content-md5') || '',
      amazonHeaders: aws2.canonicalizeHeaders(self.headers)
    }
    var path = self.uri.path
    if (opts.bucket && path) {
      auth.resource = '/' + opts.bucket + path
    } else if (opts.bucket && !path) {
      auth.resource = '/' + opts.bucket
    } else if (!opts.bucket && path) {
      auth.resource = path
    } else if (!opts.bucket && !path) {
      auth.resource = '/'
    }
    auth.resource = aws2.canonicalizeResource(auth.resource)
    self.setHeader('authorization', aws2.authorization(auth))
  }

  return self
}
Request.prototype.httpSignature = function (opts) {
  var self = this
  httpSignature.signRequest({
    getHeader: function (header) {
      return self.getHeader(header, self.headers)
    },
    setHeader: function (header, value) {
      self.setHeader(header, value)
    },
    method: self.method,
    path: self.path
  }, opts)
  debug('httpSignature authorization', self.getHeader('authorization'))

  return self
}
Request.prototype.hawk = function (opts) {
  var self = this
  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts))
}
Request.prototype.oauth = function (_oauth) {
  var self = this

  self._oauth.onRequest(_oauth)

  return self
}

Request.prototype.jar = function (jar) {
  var self = this
  var cookies

  if (self._redirect.redirectsFollowed === 0) {
    self.originalCookieHeader = self.getHeader('cookie')
  }

  if (!jar) {
    // disable cookies
    cookies = false
    self._disableCookies = true
  } else {
    var targetCookieJar = (jar && jar.getCookieString) ? jar : globalCookieJar
    var urihref = self.uri.href
    // fetch cookie in the Specified host
    if (targetCookieJar) {
      cookies = targetCookieJar.getCookieString(urihref)
    }
  }

  // if need cookie and cookie is not empty
  if (cookies && cookies.length) {
    if (self.originalCookieHeader) {
      // Don't overwrite existing Cookie header
      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)
    } else {
      self.setHeader('cookie', cookies)
    }
  }
  self._jar = jar
  return self
}

// Stream API
Request.prototype.pipe = function (dest, opts) {
  var self = this

  if (self.response) {
    if (self._destdata) {
      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))
    } else if (self._ended) {
      self.emit('error', new Error('You cannot pipe after the response has been ended.'))
    } else {
      stream.Stream.prototype.pipe.call(self, dest, opts)
      self.pipeDest(dest)
      return dest
    }
  } else {
    self.dests.push(dest)
    stream.Stream.prototype.pipe.call(self, dest, opts)
    return dest
  }
}
Request.prototype.write = function () {
  var self = this
  if (self._aborted) { return }

  if (!self._started) {
    self.start()
  }
  if (self.req) {
    return self.req.write.apply(self.req, arguments)
  }
}
Request.prototype.end = function (chunk) {
  var self = this
  if (self._aborted) { return }

  if (chunk) {
    self.write(chunk)
  }
  if (!self._started) {
    self.start()
  }
  if (self.req) {
    self.req.end()
  }
}
Request.prototype.pause = function () {
  var self = this
  if (!self.responseContent) {
    self._paused = true
  } else {
    self.responseContent.pause.apply(self.responseContent, arguments)
  }
}
Request.prototype.resume = function () {
  var self = this
  if (!self.responseContent) {
    self._paused = false
  } else {
    self.responseContent.resume.apply(self.responseContent, arguments)
  }
}
Request.prototype.destroy = function () {
  var self = this
  if (!self._ended) {
    self.end()
  } else if (self.response) {
    self.response.destroy()
  }
}

Request.defaultProxyHeaderWhiteList =
  Tunnel.defaultProxyHeaderWhiteList.slice()

Request.defaultProxyHeaderExclusiveList =
  Tunnel.defaultProxyHeaderExclusiveList.slice()

// Exports

Request.prototype.toJSON = requestToJSON
module.exports = Request


/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "buffer")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "./node_modules/safer-buffer/safer.js":
/*!********************************************!*\
  !*** ./node_modules/safer-buffer/safer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable node/no-deprecated-api */



var buffer = __webpack_require__(/*! buffer */ "buffer")
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer


/***/ }),

/***/ "./node_modules/sshpk/lib/algs.js":
/*!****************************************!*\
  !*** ./node_modules/sshpk/lib/algs.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;

var algInfo = {
	'dsa': {
		parts: ['p', 'q', 'g', 'y'],
		sizePart: 'p'
	},
	'rsa': {
		parts: ['e', 'n'],
		sizePart: 'n'
	},
	'ecdsa': {
		parts: ['curve', 'Q'],
		sizePart: 'Q'
	},
	'ed25519': {
		parts: ['A'],
		sizePart: 'A'
	}
};
algInfo['curve25519'] = algInfo['ed25519'];

var algPrivInfo = {
	'dsa': {
		parts: ['p', 'q', 'g', 'y', 'x']
	},
	'rsa': {
		parts: ['n', 'e', 'd', 'iqmp', 'p', 'q']
	},
	'ecdsa': {
		parts: ['curve', 'Q', 'd']
	},
	'ed25519': {
		parts: ['A', 'k']
	}
};
algPrivInfo['curve25519'] = algPrivInfo['ed25519'];

var hashAlgs = {
	'md5': true,
	'sha1': true,
	'sha256': true,
	'sha384': true,
	'sha512': true
};

/*
 * Taken from
 * http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf
 */
var curves = {
	'nistp256': {
		size: 256,
		pkcs8oid: '1.2.840.10045.3.1.7',
		p: Buffer.from(('00' +
		    'ffffffff 00000001 00000000 00000000' +
		    '00000000 ffffffff ffffffff ffffffff').
		    replace(/ /g, ''), 'hex'),
		a: Buffer.from(('00' +
		    'FFFFFFFF 00000001 00000000 00000000' +
		    '00000000 FFFFFFFF FFFFFFFF FFFFFFFC').
		    replace(/ /g, ''), 'hex'),
		b: Buffer.from((
		    '5ac635d8 aa3a93e7 b3ebbd55 769886bc' +
		    '651d06b0 cc53b0f6 3bce3c3e 27d2604b').
		    replace(/ /g, ''), 'hex'),
		s: Buffer.from(('00' +
		    'c49d3608 86e70493 6a6678e1 139d26b7' +
		    '819f7e90').
		    replace(/ /g, ''), 'hex'),
		n: Buffer.from(('00' +
		    'ffffffff 00000000 ffffffff ffffffff' +
		    'bce6faad a7179e84 f3b9cac2 fc632551').
		    replace(/ /g, ''), 'hex'),
		G: Buffer.from(('04' +
		    '6b17d1f2 e12c4247 f8bce6e5 63a440f2' +
		    '77037d81 2deb33a0 f4a13945 d898c296' +
		    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16' +
		    '2bce3357 6b315ece cbb64068 37bf51f5').
		    replace(/ /g, ''), 'hex')
	},
	'nistp384': {
		size: 384,
		pkcs8oid: '1.3.132.0.34',
		p: Buffer.from(('00' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff ffffffff fffffffe' +
		    'ffffffff 00000000 00000000 ffffffff').
		    replace(/ /g, ''), 'hex'),
		a: Buffer.from(('00' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE' +
		    'FFFFFFFF 00000000 00000000 FFFFFFFC').
		    replace(/ /g, ''), 'hex'),
		b: Buffer.from((
		    'b3312fa7 e23ee7e4 988e056b e3f82d19' +
		    '181d9c6e fe814112 0314088f 5013875a' +
		    'c656398d 8a2ed19d 2a85c8ed d3ec2aef').
		    replace(/ /g, ''), 'hex'),
		s: Buffer.from(('00' +
		    'a335926a a319a27a 1d00896a 6773a482' +
		    '7acdac73').
		    replace(/ /g, ''), 'hex'),
		n: Buffer.from(('00' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff c7634d81 f4372ddf' +
		    '581a0db2 48b0a77a ecec196a ccc52973').
		    replace(/ /g, ''), 'hex'),
		G: Buffer.from(('04' +
		    'aa87ca22 be8b0537 8eb1c71e f320ad74' +
		    '6e1d3b62 8ba79b98 59f741e0 82542a38' +
		    '5502f25d bf55296c 3a545e38 72760ab7' +
		    '3617de4a 96262c6f 5d9e98bf 9292dc29' +
		    'f8f41dbd 289a147c e9da3113 b5f0b8c0' +
		    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f').
		    replace(/ /g, ''), 'hex')
	},
	'nistp521': {
		size: 521,
		pkcs8oid: '1.3.132.0.35',
		p: Buffer.from((
		    '01ffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffff').replace(/ /g, ''), 'hex'),
		a: Buffer.from(('01FF' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC').
		    replace(/ /g, ''), 'hex'),
		b: Buffer.from(('51' +
		    '953eb961 8e1c9a1f 929a21a0 b68540ee' +
		    'a2da725b 99b315f3 b8b48991 8ef109e1' +
		    '56193951 ec7e937b 1652c0bd 3bb1bf07' +
		    '3573df88 3d2c34f1 ef451fd4 6b503f00').
		    replace(/ /g, ''), 'hex'),
		s: Buffer.from(('00' +
		    'd09e8800 291cb853 96cc6717 393284aa' +
		    'a0da64ba').replace(/ /g, ''), 'hex'),
		n: Buffer.from(('01ff' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff ffffffff fffffffa' +
		    '51868783 bf2f966b 7fcc0148 f709a5d0' +
		    '3bb5c9b8 899c47ae bb6fb71e 91386409').
		    replace(/ /g, ''), 'hex'),
		G: Buffer.from(('04' +
		    '00c6 858e06b7 0404e9cd 9e3ecb66 2395b442' +
		         '9c648139 053fb521 f828af60 6b4d3dba' +
		         'a14b5e77 efe75928 fe1dc127 a2ffa8de' +
		         '3348b3c1 856a429b f97e7e31 c2e5bd66' +
		    '0118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9' +
		         '98f54449 579b4468 17afbd17 273e662c' +
		         '97ee7299 5ef42640 c550b901 3fad0761' +
		         '353c7086 a272c240 88be9476 9fd16650').
		    replace(/ /g, ''), 'hex')
	}
};

module.exports = {
	info: algInfo,
	privInfo: algPrivInfo,
	hashAlgs: hashAlgs,
	curves: curves
};


/***/ }),

/***/ "./node_modules/sshpk/lib/certificate.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/certificate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2016 Joyent, Inc.

module.exports = Certificate;

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ./algs */ "./node_modules/sshpk/lib/algs.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var Fingerprint = __webpack_require__(/*! ./fingerprint */ "./node_modules/sshpk/lib/fingerprint.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/sshpk/lib/signature.js");
var errs = __webpack_require__(/*! ./errors */ "./node_modules/sshpk/lib/errors.js");
var util = __webpack_require__(/*! util */ "util");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/sshpk/lib/utils.js");
var Key = __webpack_require__(/*! ./key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ./private-key */ "./node_modules/sshpk/lib/private-key.js");
var Identity = __webpack_require__(/*! ./identity */ "./node_modules/sshpk/lib/identity.js");

var formats = {};
formats['openssh'] = __webpack_require__(/*! ./formats/openssh-cert */ "./node_modules/sshpk/lib/formats/openssh-cert.js");
formats['x509'] = __webpack_require__(/*! ./formats/x509 */ "./node_modules/sshpk/lib/formats/x509.js");
formats['pem'] = __webpack_require__(/*! ./formats/x509-pem */ "./node_modules/sshpk/lib/formats/x509-pem.js");

var CertificateParseError = errs.CertificateParseError;
var InvalidAlgorithmError = errs.InvalidAlgorithmError;

function Certificate(opts) {
	assert.object(opts, 'options');
	assert.arrayOfObject(opts.subjects, 'options.subjects');
	utils.assertCompatible(opts.subjects[0], Identity, [1, 0],
	    'options.subjects');
	utils.assertCompatible(opts.subjectKey, Key, [1, 0],
	    'options.subjectKey');
	utils.assertCompatible(opts.issuer, Identity, [1, 0], 'options.issuer');
	if (opts.issuerKey !== undefined) {
		utils.assertCompatible(opts.issuerKey, Key, [1, 0],
		    'options.issuerKey');
	}
	assert.object(opts.signatures, 'options.signatures');
	assert.buffer(opts.serial, 'options.serial');
	assert.date(opts.validFrom, 'options.validFrom');
	assert.date(opts.validUntil, 'optons.validUntil');

	assert.optionalArrayOfString(opts.purposes, 'options.purposes');

	this._hashCache = {};

	this.subjects = opts.subjects;
	this.issuer = opts.issuer;
	this.subjectKey = opts.subjectKey;
	this.issuerKey = opts.issuerKey;
	this.signatures = opts.signatures;
	this.serial = opts.serial;
	this.validFrom = opts.validFrom;
	this.validUntil = opts.validUntil;
	this.purposes = opts.purposes;
}

Certificate.formats = formats;

Certificate.prototype.toBuffer = function (format, options) {
	if (format === undefined)
		format = 'x509';
	assert.string(format, 'format');
	assert.object(formats[format], 'formats[format]');
	assert.optionalObject(options, 'options');

	return (formats[format].write(this, options));
};

Certificate.prototype.toString = function (format, options) {
	if (format === undefined)
		format = 'pem';
	return (this.toBuffer(format, options).toString());
};

Certificate.prototype.fingerprint = function (algo) {
	if (algo === undefined)
		algo = 'sha256';
	assert.string(algo, 'algorithm');
	var opts = {
		type: 'certificate',
		hash: this.hash(algo),
		algorithm: algo
	};
	return (new Fingerprint(opts));
};

Certificate.prototype.hash = function (algo) {
	assert.string(algo, 'algorithm');
	algo = algo.toLowerCase();
	if (algs.hashAlgs[algo] === undefined)
		throw (new InvalidAlgorithmError(algo));

	if (this._hashCache[algo])
		return (this._hashCache[algo]);

	var hash = crypto.createHash(algo).
	    update(this.toBuffer('x509')).digest();
	this._hashCache[algo] = hash;
	return (hash);
};

Certificate.prototype.isExpired = function (when) {
	if (when === undefined)
		when = new Date();
	return (!((when.getTime() >= this.validFrom.getTime()) &&
		(when.getTime() < this.validUntil.getTime())));
};

Certificate.prototype.isSignedBy = function (issuerCert) {
	utils.assertCompatible(issuerCert, Certificate, [1, 0], 'issuer');

	if (!this.issuer.equals(issuerCert.subjects[0]))
		return (false);
	if (this.issuer.purposes && this.issuer.purposes.length > 0 &&
	    this.issuer.purposes.indexOf('ca') === -1) {
		return (false);
	}

	return (this.isSignedByKey(issuerCert.subjectKey));
};

Certificate.prototype.getExtension = function (keyOrOid) {
	assert.string(keyOrOid, 'keyOrOid');
	var ext = this.getExtensions().filter(function (maybeExt) {
		if (maybeExt.format === 'x509')
			return (maybeExt.oid === keyOrOid);
		if (maybeExt.format === 'openssh')
			return (maybeExt.name === keyOrOid);
		return (false);
	})[0];
	return (ext);
};

Certificate.prototype.getExtensions = function () {
	var exts = [];
	var x509 = this.signatures.x509;
	if (x509 && x509.extras && x509.extras.exts) {
		x509.extras.exts.forEach(function (ext) {
			ext.format = 'x509';
			exts.push(ext);
		});
	}
	var openssh = this.signatures.openssh;
	if (openssh && openssh.exts) {
		openssh.exts.forEach(function (ext) {
			ext.format = 'openssh';
			exts.push(ext);
		});
	}
	return (exts);
};

Certificate.prototype.isSignedByKey = function (issuerKey) {
	utils.assertCompatible(issuerKey, Key, [1, 2], 'issuerKey');

	if (this.issuerKey !== undefined) {
		return (this.issuerKey.
		    fingerprint('sha512').matches(issuerKey));
	}

	var fmt = Object.keys(this.signatures)[0];
	var valid = formats[fmt].verify(this, issuerKey);
	if (valid)
		this.issuerKey = issuerKey;
	return (valid);
};

Certificate.prototype.signWith = function (key) {
	utils.assertCompatible(key, PrivateKey, [1, 2], 'key');
	var fmts = Object.keys(formats);
	var didOne = false;
	for (var i = 0; i < fmts.length; ++i) {
		if (fmts[i] !== 'pem') {
			var ret = formats[fmts[i]].sign(this, key);
			if (ret === true)
				didOne = true;
		}
	}
	if (!didOne) {
		throw (new Error('Failed to sign the certificate for any ' +
		    'available certificate formats'));
	}
};

Certificate.createSelfSigned = function (subjectOrSubjects, key, options) {
	var subjects;
	if (Array.isArray(subjectOrSubjects))
		subjects = subjectOrSubjects;
	else
		subjects = [subjectOrSubjects];

	assert.arrayOfObject(subjects);
	subjects.forEach(function (subject) {
		utils.assertCompatible(subject, Identity, [1, 0], 'subject');
	});

	utils.assertCompatible(key, PrivateKey, [1, 2], 'private key');

	assert.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	assert.optionalObject(options.validFrom, 'options.validFrom');
	assert.optionalObject(options.validUntil, 'options.validUntil');
	var validFrom = options.validFrom;
	var validUntil = options.validUntil;
	if (validFrom === undefined)
		validFrom = new Date();
	if (validUntil === undefined) {
		assert.optionalNumber(options.lifetime, 'options.lifetime');
		var lifetime = options.lifetime;
		if (lifetime === undefined)
			lifetime = 10*365*24*3600;
		validUntil = new Date();
		validUntil.setTime(validUntil.getTime() + lifetime*1000);
	}
	assert.optionalBuffer(options.serial, 'options.serial');
	var serial = options.serial;
	if (serial === undefined)
		serial = Buffer.from('0000000000000001', 'hex');

	var purposes = options.purposes;
	if (purposes === undefined)
		purposes = [];

	if (purposes.indexOf('signature') === -1)
		purposes.push('signature');

	/* Self-signed certs are always CAs. */
	if (purposes.indexOf('ca') === -1)
		purposes.push('ca');
	if (purposes.indexOf('crl') === -1)
		purposes.push('crl');

	/*
	 * If we weren't explicitly given any other purposes, do the sensible
	 * thing and add some basic ones depending on the subject type.
	 */
	if (purposes.length <= 3) {
		var hostSubjects = subjects.filter(function (subject) {
			return (subject.type === 'host');
		});
		var userSubjects = subjects.filter(function (subject) {
			return (subject.type === 'user');
		});
		if (hostSubjects.length > 0) {
			if (purposes.indexOf('serverAuth') === -1)
				purposes.push('serverAuth');
		}
		if (userSubjects.length > 0) {
			if (purposes.indexOf('clientAuth') === -1)
				purposes.push('clientAuth');
		}
		if (userSubjects.length > 0 || hostSubjects.length > 0) {
			if (purposes.indexOf('keyAgreement') === -1)
				purposes.push('keyAgreement');
			if (key.type === 'rsa' &&
			    purposes.indexOf('encryption') === -1)
				purposes.push('encryption');
		}
	}

	var cert = new Certificate({
		subjects: subjects,
		issuer: subjects[0],
		subjectKey: key.toPublic(),
		issuerKey: key.toPublic(),
		signatures: {},
		serial: serial,
		validFrom: validFrom,
		validUntil: validUntil,
		purposes: purposes
	});
	cert.signWith(key);

	return (cert);
};

Certificate.create =
    function (subjectOrSubjects, key, issuer, issuerKey, options) {
	var subjects;
	if (Array.isArray(subjectOrSubjects))
		subjects = subjectOrSubjects;
	else
		subjects = [subjectOrSubjects];

	assert.arrayOfObject(subjects);
	subjects.forEach(function (subject) {
		utils.assertCompatible(subject, Identity, [1, 0], 'subject');
	});

	utils.assertCompatible(key, Key, [1, 0], 'key');
	if (PrivateKey.isPrivateKey(key))
		key = key.toPublic();
	utils.assertCompatible(issuer, Identity, [1, 0], 'issuer');
	utils.assertCompatible(issuerKey, PrivateKey, [1, 2], 'issuer key');

	assert.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	assert.optionalObject(options.validFrom, 'options.validFrom');
	assert.optionalObject(options.validUntil, 'options.validUntil');
	var validFrom = options.validFrom;
	var validUntil = options.validUntil;
	if (validFrom === undefined)
		validFrom = new Date();
	if (validUntil === undefined) {
		assert.optionalNumber(options.lifetime, 'options.lifetime');
		var lifetime = options.lifetime;
		if (lifetime === undefined)
			lifetime = 10*365*24*3600;
		validUntil = new Date();
		validUntil.setTime(validUntil.getTime() + lifetime*1000);
	}
	assert.optionalBuffer(options.serial, 'options.serial');
	var serial = options.serial;
	if (serial === undefined)
		serial = Buffer.from('0000000000000001', 'hex');

	var purposes = options.purposes;
	if (purposes === undefined)
		purposes = [];

	if (purposes.indexOf('signature') === -1)
		purposes.push('signature');

	if (options.ca === true) {
		if (purposes.indexOf('ca') === -1)
			purposes.push('ca');
		if (purposes.indexOf('crl') === -1)
			purposes.push('crl');
	}

	var hostSubjects = subjects.filter(function (subject) {
		return (subject.type === 'host');
	});
	var userSubjects = subjects.filter(function (subject) {
		return (subject.type === 'user');
	});
	if (hostSubjects.length > 0) {
		if (purposes.indexOf('serverAuth') === -1)
			purposes.push('serverAuth');
	}
	if (userSubjects.length > 0) {
		if (purposes.indexOf('clientAuth') === -1)
			purposes.push('clientAuth');
	}
	if (userSubjects.length > 0 || hostSubjects.length > 0) {
		if (purposes.indexOf('keyAgreement') === -1)
			purposes.push('keyAgreement');
		if (key.type === 'rsa' &&
		    purposes.indexOf('encryption') === -1)
			purposes.push('encryption');
	}

	var cert = new Certificate({
		subjects: subjects,
		issuer: issuer,
		subjectKey: key,
		issuerKey: issuerKey.toPublic(),
		signatures: {},
		serial: serial,
		validFrom: validFrom,
		validUntil: validUntil,
		purposes: purposes
	});
	cert.signWith(issuerKey);

	return (cert);
};

Certificate.parse = function (data, format, options) {
	if (typeof (data) !== 'string')
		assert.buffer(data, 'data');
	if (format === undefined)
		format = 'auto';
	assert.string(format, 'format');
	if (typeof (options) === 'string')
		options = { filename: options };
	assert.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	assert.optionalString(options.filename, 'options.filename');
	if (options.filename === undefined)
		options.filename = '(unnamed)';

	assert.object(formats[format], 'formats[format]');

	try {
		var k = formats[format].read(data, options);
		return (k);
	} catch (e) {
		throw (new CertificateParseError(options.filename, format, e));
	}
};

Certificate.isCertificate = function (obj, ver) {
	return (utils.isCompatible(obj, Certificate, ver));
};

/*
 * API versions for Certificate:
 * [1,0] -- initial ver
 * [1,1] -- openssh format now unpacks extensions
 */
Certificate.prototype._sshpkApiVersion = [1, 1];

Certificate._oldVersionDetect = function (obj) {
	return ([1, 0]);
};


/***/ }),

/***/ "./node_modules/sshpk/lib/dhe.js":
/*!***************************************!*\
  !*** ./node_modules/sshpk/lib/dhe.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 Joyent, Inc.

module.exports = {
	DiffieHellman: DiffieHellman,
	generateECDSA: generateECDSA,
	generateED25519: generateED25519
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ./algs */ "./node_modules/sshpk/lib/algs.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/sshpk/lib/utils.js");
var nacl = __webpack_require__(/*! tweetnacl */ "./node_modules/tweetnacl/nacl-fast.js");

var Key = __webpack_require__(/*! ./key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ./private-key */ "./node_modules/sshpk/lib/private-key.js");

var CRYPTO_HAVE_ECDH = (crypto.createECDH !== undefined);

var ecdh = __webpack_require__(/*! ecc-jsbn */ "./node_modules/ecc-jsbn/index.js");
var ec = __webpack_require__(/*! ecc-jsbn/lib/ec */ "./node_modules/ecc-jsbn/lib/ec.js");
var jsbn = __webpack_require__(/*! jsbn */ "./node_modules/jsbn/index.js").BigInteger;

function DiffieHellman(key) {
	utils.assertCompatible(key, Key, [1, 4], 'key');
	this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
	this._algo = key.type;
	this._curve = key.curve;
	this._key = key;
	if (key.type === 'dsa') {
		if (!CRYPTO_HAVE_ECDH) {
			throw (new Error('Due to bugs in the node 0.10 ' +
			    'crypto API, node 0.12.x or later is required ' +
			    'to use DH'));
		}
		this._dh = crypto.createDiffieHellman(
		    key.part.p.data, undefined,
		    key.part.g.data, undefined);
		this._p = key.part.p;
		this._g = key.part.g;
		if (this._isPriv)
			this._dh.setPrivateKey(key.part.x.data);
		this._dh.setPublicKey(key.part.y.data);

	} else if (key.type === 'ecdsa') {
		if (!CRYPTO_HAVE_ECDH) {
			this._ecParams = new X9ECParameters(this._curve);

			if (this._isPriv) {
				this._priv = new ECPrivate(
				    this._ecParams, key.part.d.data);
			}
			return;
		}

		var curve = {
			'nistp256': 'prime256v1',
			'nistp384': 'secp384r1',
			'nistp521': 'secp521r1'
		}[key.curve];
		this._dh = crypto.createECDH(curve);
		if (typeof (this._dh) !== 'object' ||
		    typeof (this._dh.setPrivateKey) !== 'function') {
			CRYPTO_HAVE_ECDH = false;
			DiffieHellman.call(this, key);
			return;
		}
		if (this._isPriv)
			this._dh.setPrivateKey(key.part.d.data);
		this._dh.setPublicKey(key.part.Q.data);

	} else if (key.type === 'curve25519') {
		if (this._isPriv) {
			utils.assertCompatible(key, PrivateKey, [1, 5], 'key');
			this._priv = key.part.k.data;
		}

	} else {
		throw (new Error('DH not supported for ' + key.type + ' keys'));
	}
}

DiffieHellman.prototype.getPublicKey = function () {
	if (this._isPriv)
		return (this._key.toPublic());
	return (this._key);
};

DiffieHellman.prototype.getPrivateKey = function () {
	if (this._isPriv)
		return (this._key);
	else
		return (undefined);
};
DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;

DiffieHellman.prototype._keyCheck = function (pk, isPub) {
	assert.object(pk, 'key');
	if (!isPub)
		utils.assertCompatible(pk, PrivateKey, [1, 3], 'key');
	utils.assertCompatible(pk, Key, [1, 4], 'key');

	if (pk.type !== this._algo) {
		throw (new Error('A ' + pk.type + ' key cannot be used in ' +
		    this._algo + ' Diffie-Hellman'));
	}

	if (pk.curve !== this._curve) {
		throw (new Error('A key from the ' + pk.curve + ' curve ' +
		    'cannot be used with a ' + this._curve +
		    ' Diffie-Hellman'));
	}

	if (pk.type === 'dsa') {
		assert.deepEqual(pk.part.p, this._p,
		    'DSA key prime does not match');
		assert.deepEqual(pk.part.g, this._g,
		    'DSA key generator does not match');
	}
};

DiffieHellman.prototype.setKey = function (pk) {
	this._keyCheck(pk);

	if (pk.type === 'dsa') {
		this._dh.setPrivateKey(pk.part.x.data);
		this._dh.setPublicKey(pk.part.y.data);

	} else if (pk.type === 'ecdsa') {
		if (CRYPTO_HAVE_ECDH) {
			this._dh.setPrivateKey(pk.part.d.data);
			this._dh.setPublicKey(pk.part.Q.data);
		} else {
			this._priv = new ECPrivate(
			    this._ecParams, pk.part.d.data);
		}

	} else if (pk.type === 'curve25519') {
		var k = pk.part.k;
		if (!pk.part.k)
			k = pk.part.r;
		this._priv = k.data;
		if (this._priv[0] === 0x00)
			this._priv = this._priv.slice(1);
		this._priv = this._priv.slice(0, 32);
	}
	this._key = pk;
	this._isPriv = true;
};
DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;

DiffieHellman.prototype.computeSecret = function (otherpk) {
	this._keyCheck(otherpk, true);
	if (!this._isPriv)
		throw (new Error('DH exchange has not been initialized with ' +
		    'a private key yet'));

	var pub;
	if (this._algo === 'dsa') {
		return (this._dh.computeSecret(
		    otherpk.part.y.data));

	} else if (this._algo === 'ecdsa') {
		if (CRYPTO_HAVE_ECDH) {
			return (this._dh.computeSecret(
			    otherpk.part.Q.data));
		} else {
			pub = new ECPublic(
			    this._ecParams, otherpk.part.Q.data);
			return (this._priv.deriveSharedSecret(pub));
		}

	} else if (this._algo === 'curve25519') {
		pub = otherpk.part.A.data;
		while (pub[0] === 0x00 && pub.length > 32)
			pub = pub.slice(1);
		var priv = this._priv;
		assert.strictEqual(pub.length, 32);
		assert.strictEqual(priv.length, 32);

		var secret = nacl.box.before(new Uint8Array(pub),
		    new Uint8Array(priv));

		return (Buffer.from(secret));
	}

	throw (new Error('Invalid algorithm: ' + this._algo));
};

DiffieHellman.prototype.generateKey = function () {
	var parts = [];
	var priv, pub;
	if (this._algo === 'dsa') {
		this._dh.generateKeys();

		parts.push({name: 'p', data: this._p.data});
		parts.push({name: 'q', data: this._key.part.q.data});
		parts.push({name: 'g', data: this._g.data});
		parts.push({name: 'y', data: this._dh.getPublicKey()});
		parts.push({name: 'x', data: this._dh.getPrivateKey()});
		this._key = new PrivateKey({
			type: 'dsa',
			parts: parts
		});
		this._isPriv = true;
		return (this._key);

	} else if (this._algo === 'ecdsa') {
		if (CRYPTO_HAVE_ECDH) {
			this._dh.generateKeys();

			parts.push({name: 'curve',
			    data: Buffer.from(this._curve)});
			parts.push({name: 'Q', data: this._dh.getPublicKey()});
			parts.push({name: 'd', data: this._dh.getPrivateKey()});
			this._key = new PrivateKey({
				type: 'ecdsa',
				curve: this._curve,
				parts: parts
			});
			this._isPriv = true;
			return (this._key);

		} else {
			var n = this._ecParams.getN();
			var r = new jsbn(crypto.randomBytes(n.bitLength()));
			var n1 = n.subtract(jsbn.ONE);
			priv = r.mod(n1).add(jsbn.ONE);
			pub = this._ecParams.getG().multiply(priv);

			priv = Buffer.from(priv.toByteArray());
			pub = Buffer.from(this._ecParams.getCurve().
			    encodePointHex(pub), 'hex');

			this._priv = new ECPrivate(this._ecParams, priv);

			parts.push({name: 'curve',
			    data: Buffer.from(this._curve)});
			parts.push({name: 'Q', data: pub});
			parts.push({name: 'd', data: priv});

			this._key = new PrivateKey({
				type: 'ecdsa',
				curve: this._curve,
				parts: parts
			});
			this._isPriv = true;
			return (this._key);
		}

	} else if (this._algo === 'curve25519') {
		var pair = nacl.box.keyPair();
		priv = Buffer.from(pair.secretKey);
		pub = Buffer.from(pair.publicKey);
		priv = Buffer.concat([priv, pub]);
		assert.strictEqual(priv.length, 64);
		assert.strictEqual(pub.length, 32);

		parts.push({name: 'A', data: pub});
		parts.push({name: 'k', data: priv});
		this._key = new PrivateKey({
			type: 'curve25519',
			parts: parts
		});
		this._isPriv = true;
		return (this._key);
	}

	throw (new Error('Invalid algorithm: ' + this._algo));
};
DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;

/* These are helpers for using ecc-jsbn (for node 0.10 compatibility). */

function X9ECParameters(name) {
	var params = algs.curves[name];
	assert.object(params);

	var p = new jsbn(params.p);
	var a = new jsbn(params.a);
	var b = new jsbn(params.b);
	var n = new jsbn(params.n);
	var h = jsbn.ONE;
	var curve = new ec.ECCurveFp(p, a, b);
	var G = curve.decodePointHex(params.G.toString('hex'));

	this.curve = curve;
	this.g = G;
	this.n = n;
	this.h = h;
}
X9ECParameters.prototype.getCurve = function () { return (this.curve); };
X9ECParameters.prototype.getG = function () { return (this.g); };
X9ECParameters.prototype.getN = function () { return (this.n); };
X9ECParameters.prototype.getH = function () { return (this.h); };

function ECPublic(params, buffer) {
	this._params = params;
	if (buffer[0] === 0x00)
		buffer = buffer.slice(1);
	this._pub = params.getCurve().decodePointHex(buffer.toString('hex'));
}

function ECPrivate(params, buffer) {
	this._params = params;
	this._priv = new jsbn(utils.mpNormalize(buffer));
}
ECPrivate.prototype.deriveSharedSecret = function (pubKey) {
	assert.ok(pubKey instanceof ECPublic);
	var S = pubKey._pub.multiply(this._priv);
	return (Buffer.from(S.getX().toBigInteger().toByteArray()));
};

function generateED25519() {
	var pair = nacl.sign.keyPair();
	var priv = Buffer.from(pair.secretKey);
	var pub = Buffer.from(pair.publicKey);
	assert.strictEqual(priv.length, 64);
	assert.strictEqual(pub.length, 32);

	var parts = [];
	parts.push({name: 'A', data: pub});
	parts.push({name: 'k', data: priv.slice(0, 32)});
	var key = new PrivateKey({
		type: 'ed25519',
		parts: parts
	});
	return (key);
}

/* Generates a new ECDSA private key on a given curve. */
function generateECDSA(curve) {
	var parts = [];
	var key;

	if (CRYPTO_HAVE_ECDH) {
		/*
		 * Node crypto doesn't expose key generation directly, but the
		 * ECDH instances can generate keys. It turns out this just
		 * calls into the OpenSSL generic key generator, and we can
		 * read its output happily without doing an actual DH. So we
		 * use that here.
		 */
		var osCurve = {
			'nistp256': 'prime256v1',
			'nistp384': 'secp384r1',
			'nistp521': 'secp521r1'
		}[curve];

		var dh = crypto.createECDH(osCurve);
		dh.generateKeys();

		parts.push({name: 'curve',
		    data: Buffer.from(curve)});
		parts.push({name: 'Q', data: dh.getPublicKey()});
		parts.push({name: 'd', data: dh.getPrivateKey()});

		key = new PrivateKey({
			type: 'ecdsa',
			curve: curve,
			parts: parts
		});
		return (key);
	} else {

		var ecParams = new X9ECParameters(curve);

		/* This algorithm taken from FIPS PUB 186-4 (section B.4.1) */
		var n = ecParams.getN();
		/*
		 * The crypto.randomBytes() function can only give us whole
		 * bytes, so taking a nod from X9.62, we round up.
		 */
		var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
		var c = new jsbn(crypto.randomBytes(cByteLen));

		var n1 = n.subtract(jsbn.ONE);
		var priv = c.mod(n1).add(jsbn.ONE);
		var pub = ecParams.getG().multiply(priv);

		priv = Buffer.from(priv.toByteArray());
		pub = Buffer.from(ecParams.getCurve().
		    encodePointHex(pub), 'hex');

		parts.push({name: 'curve', data: Buffer.from(curve)});
		parts.push({name: 'Q', data: pub});
		parts.push({name: 'd', data: priv});

		key = new PrivateKey({
			type: 'ecdsa',
			curve: curve,
			parts: parts
		});
		return (key);
	}
}


/***/ }),

/***/ "./node_modules/sshpk/lib/ed-compat.js":
/*!*********************************************!*\
  !*** ./node_modules/sshpk/lib/ed-compat.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

module.exports = {
	Verifier: Verifier,
	Signer: Signer
};

var nacl = __webpack_require__(/*! tweetnacl */ "./node_modules/tweetnacl/nacl-fast.js");
var stream = __webpack_require__(/*! stream */ "stream");
var util = __webpack_require__(/*! util */ "util");
var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/sshpk/lib/signature.js");

function Verifier(key, hashAlgo) {
	if (hashAlgo.toLowerCase() !== 'sha512')
		throw (new Error('ED25519 only supports the use of ' +
		    'SHA-512 hashes'));

	this.key = key;
	this.chunks = [];

	stream.Writable.call(this, {});
}
util.inherits(Verifier, stream.Writable);

Verifier.prototype._write = function (chunk, enc, cb) {
	this.chunks.push(chunk);
	cb();
};

Verifier.prototype.update = function (chunk) {
	if (typeof (chunk) === 'string')
		chunk = Buffer.from(chunk, 'binary');
	this.chunks.push(chunk);
};

Verifier.prototype.verify = function (signature, fmt) {
	var sig;
	if (Signature.isSignature(signature, [2, 0])) {
		if (signature.type !== 'ed25519')
			return (false);
		sig = signature.toBuffer('raw');

	} else if (typeof (signature) === 'string') {
		sig = Buffer.from(signature, 'base64');

	} else if (Signature.isSignature(signature, [1, 0])) {
		throw (new Error('signature was created by too old ' +
		    'a version of sshpk and cannot be verified'));
	}

	assert.buffer(sig);
	return (nacl.sign.detached.verify(
	    new Uint8Array(Buffer.concat(this.chunks)),
	    new Uint8Array(sig),
	    new Uint8Array(this.key.part.A.data)));
};

function Signer(key, hashAlgo) {
	if (hashAlgo.toLowerCase() !== 'sha512')
		throw (new Error('ED25519 only supports the use of ' +
		    'SHA-512 hashes'));

	this.key = key;
	this.chunks = [];

	stream.Writable.call(this, {});
}
util.inherits(Signer, stream.Writable);

Signer.prototype._write = function (chunk, enc, cb) {
	this.chunks.push(chunk);
	cb();
};

Signer.prototype.update = function (chunk) {
	if (typeof (chunk) === 'string')
		chunk = Buffer.from(chunk, 'binary');
	this.chunks.push(chunk);
};

Signer.prototype.sign = function () {
	var sig = nacl.sign.detached(
	    new Uint8Array(Buffer.concat(this.chunks)),
	    new Uint8Array(Buffer.concat([
		this.key.part.k.data, this.key.part.A.data])));
	var sigBuf = Buffer.from(sig);
	var sigObj = Signature.parse(sigBuf, 'ed25519', 'raw');
	sigObj.hashAlgorithm = 'sha512';
	return (sigObj);
};


/***/ }),

/***/ "./node_modules/sshpk/lib/errors.js":
/*!******************************************!*\
  !*** ./node_modules/sshpk/lib/errors.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var util = __webpack_require__(/*! util */ "util");

function FingerprintFormatError(fp, format) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, FingerprintFormatError);
	this.name = 'FingerprintFormatError';
	this.fingerprint = fp;
	this.format = format;
	this.message = 'Fingerprint format is not supported, or is invalid: ';
	if (fp !== undefined)
		this.message += ' fingerprint = ' + fp;
	if (format !== undefined)
		this.message += ' format = ' + format;
}
util.inherits(FingerprintFormatError, Error);

function InvalidAlgorithmError(alg) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, InvalidAlgorithmError);
	this.name = 'InvalidAlgorithmError';
	this.algorithm = alg;
	this.message = 'Algorithm "' + alg + '" is not supported';
}
util.inherits(InvalidAlgorithmError, Error);

function KeyParseError(name, format, innerErr) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, KeyParseError);
	this.name = 'KeyParseError';
	this.format = format;
	this.keyName = name;
	this.innerErr = innerErr;
	this.message = 'Failed to parse ' + name + ' as a valid ' + format +
	    ' format key: ' + innerErr.message;
}
util.inherits(KeyParseError, Error);

function SignatureParseError(type, format, innerErr) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, SignatureParseError);
	this.name = 'SignatureParseError';
	this.type = type;
	this.format = format;
	this.innerErr = innerErr;
	this.message = 'Failed to parse the given data as a ' + type +
	    ' signature in ' + format + ' format: ' + innerErr.message;
}
util.inherits(SignatureParseError, Error);

function CertificateParseError(name, format, innerErr) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, CertificateParseError);
	this.name = 'CertificateParseError';
	this.format = format;
	this.certName = name;
	this.innerErr = innerErr;
	this.message = 'Failed to parse ' + name + ' as a valid ' + format +
	    ' format certificate: ' + innerErr.message;
}
util.inherits(CertificateParseError, Error);

function KeyEncryptedError(name, format) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, KeyEncryptedError);
	this.name = 'KeyEncryptedError';
	this.format = format;
	this.keyName = name;
	this.message = 'The ' + format + ' format key ' + name + ' is ' +
	    'encrypted (password-protected), and no passphrase was ' +
	    'provided in `options`';
}
util.inherits(KeyEncryptedError, Error);

module.exports = {
	FingerprintFormatError: FingerprintFormatError,
	InvalidAlgorithmError: InvalidAlgorithmError,
	KeyParseError: KeyParseError,
	SignatureParseError: SignatureParseError,
	KeyEncryptedError: KeyEncryptedError,
	CertificateParseError: CertificateParseError
};


/***/ }),

/***/ "./node_modules/sshpk/lib/fingerprint.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/fingerprint.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 Joyent, Inc.

module.exports = Fingerprint;

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ./algs */ "./node_modules/sshpk/lib/algs.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var errs = __webpack_require__(/*! ./errors */ "./node_modules/sshpk/lib/errors.js");
var Key = __webpack_require__(/*! ./key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ./private-key */ "./node_modules/sshpk/lib/private-key.js");
var Certificate = __webpack_require__(/*! ./certificate */ "./node_modules/sshpk/lib/certificate.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/sshpk/lib/utils.js");

var FingerprintFormatError = errs.FingerprintFormatError;
var InvalidAlgorithmError = errs.InvalidAlgorithmError;

function Fingerprint(opts) {
	assert.object(opts, 'options');
	assert.string(opts.type, 'options.type');
	assert.buffer(opts.hash, 'options.hash');
	assert.string(opts.algorithm, 'options.algorithm');

	this.algorithm = opts.algorithm.toLowerCase();
	if (algs.hashAlgs[this.algorithm] !== true)
		throw (new InvalidAlgorithmError(this.algorithm));

	this.hash = opts.hash;
	this.type = opts.type;
	this.hashType = opts.hashType;
}

Fingerprint.prototype.toString = function (format) {
	if (format === undefined) {
		if (this.algorithm === 'md5' || this.hashType === 'spki')
			format = 'hex';
		else
			format = 'base64';
	}
	assert.string(format);

	switch (format) {
	case 'hex':
		if (this.hashType === 'spki')
			return (this.hash.toString('hex'));
		return (addColons(this.hash.toString('hex')));
	case 'base64':
		if (this.hashType === 'spki')
			return (this.hash.toString('base64'));
		return (sshBase64Format(this.algorithm,
		    this.hash.toString('base64')));
	default:
		throw (new FingerprintFormatError(undefined, format));
	}
};

Fingerprint.prototype.matches = function (other) {
	assert.object(other, 'key or certificate');
	if (this.type === 'key' && this.hashType !== 'ssh') {
		utils.assertCompatible(other, Key, [1, 7], 'key with spki');
		if (PrivateKey.isPrivateKey(other)) {
			utils.assertCompatible(other, PrivateKey, [1, 6],
			    'privatekey with spki support');
		}
	} else if (this.type === 'key') {
		utils.assertCompatible(other, Key, [1, 0], 'key');
	} else {
		utils.assertCompatible(other, Certificate, [1, 0],
		    'certificate');
	}

	var theirHash = other.hash(this.algorithm, this.hashType);
	var theirHash2 = crypto.createHash(this.algorithm).
	    update(theirHash).digest('base64');

	if (this.hash2 === undefined)
		this.hash2 = crypto.createHash(this.algorithm).
		    update(this.hash).digest('base64');

	return (this.hash2 === theirHash2);
};

/*JSSTYLED*/
var base64RE = /^[A-Za-z0-9+\/=]+$/;
/*JSSTYLED*/
var hexRE = /^[a-fA-F0-9]+$/;

Fingerprint.parse = function (fp, options) {
	assert.string(fp, 'fingerprint');

	var alg, hash, enAlgs;
	if (Array.isArray(options)) {
		enAlgs = options;
		options = {};
	}
	assert.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	if (options.enAlgs !== undefined)
		enAlgs = options.enAlgs;
	if (options.algorithms !== undefined)
		enAlgs = options.algorithms;
	assert.optionalArrayOfString(enAlgs, 'algorithms');

	var hashType = 'ssh';
	if (options.hashType !== undefined)
		hashType = options.hashType;
	assert.string(hashType, 'options.hashType');

	var parts = fp.split(':');
	if (parts.length == 2) {
		alg = parts[0].toLowerCase();
		if (!base64RE.test(parts[1]))
			throw (new FingerprintFormatError(fp));
		try {
			hash = Buffer.from(parts[1], 'base64');
		} catch (e) {
			throw (new FingerprintFormatError(fp));
		}
	} else if (parts.length > 2) {
		alg = 'md5';
		if (parts[0].toLowerCase() === 'md5')
			parts = parts.slice(1);
		parts = parts.map(function (p) {
			while (p.length < 2)
				p = '0' + p;
			if (p.length > 2)
				throw (new FingerprintFormatError(fp));
			return (p);
		});
		parts = parts.join('');
		if (!hexRE.test(parts) || parts.length % 2 !== 0)
			throw (new FingerprintFormatError(fp));
		try {
			hash = Buffer.from(parts, 'hex');
		} catch (e) {
			throw (new FingerprintFormatError(fp));
		}
	} else {
		if (hexRE.test(fp)) {
			hash = Buffer.from(fp, 'hex');
		} else if (base64RE.test(fp)) {
			hash = Buffer.from(fp, 'base64');
		} else {
			throw (new FingerprintFormatError(fp));
		}

		switch (hash.length) {
		case 32:
			alg = 'sha256';
			break;
		case 16:
			alg = 'md5';
			break;
		case 20:
			alg = 'sha1';
			break;
		case 64:
			alg = 'sha512';
			break;
		default:
			throw (new FingerprintFormatError(fp));
		}

		/* Plain hex/base64: guess it's probably SPKI unless told. */
		if (options.hashType === undefined)
			hashType = 'spki';
	}

	if (alg === undefined)
		throw (new FingerprintFormatError(fp));

	if (algs.hashAlgs[alg] === undefined)
		throw (new InvalidAlgorithmError(alg));

	if (enAlgs !== undefined) {
		enAlgs = enAlgs.map(function (a) { return a.toLowerCase(); });
		if (enAlgs.indexOf(alg) === -1)
			throw (new InvalidAlgorithmError(alg));
	}

	return (new Fingerprint({
		algorithm: alg,
		hash: hash,
		type: options.type || 'key',
		hashType: hashType
	}));
};

function addColons(s) {
	/*JSSTYLED*/
	return (s.replace(/(.{2})(?=.)/g, '$1:'));
}

function base64Strip(s) {
	/*JSSTYLED*/
	return (s.replace(/=*$/, ''));
}

function sshBase64Format(alg, h) {
	return (alg.toUpperCase() + ':' + base64Strip(h));
}

Fingerprint.isFingerprint = function (obj, ver) {
	return (utils.isCompatible(obj, Fingerprint, ver));
};

/*
 * API versions for Fingerprint:
 * [1,0] -- initial ver
 * [1,1] -- first tagged ver
 * [1,2] -- hashType and spki support
 */
Fingerprint.prototype._sshpkApiVersion = [1, 2];

Fingerprint._oldVersionDetect = function (obj) {
	assert.func(obj.toString);
	assert.func(obj.matches);
	return ([1, 0]);
};


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/auto.js":
/*!************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/auto.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 Joyent, Inc.

module.exports = {
	read: read,
	write: write
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");
var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");

var pem = __webpack_require__(/*! ./pem */ "./node_modules/sshpk/lib/formats/pem.js");
var ssh = __webpack_require__(/*! ./ssh */ "./node_modules/sshpk/lib/formats/ssh.js");
var rfc4253 = __webpack_require__(/*! ./rfc4253 */ "./node_modules/sshpk/lib/formats/rfc4253.js");
var dnssec = __webpack_require__(/*! ./dnssec */ "./node_modules/sshpk/lib/formats/dnssec.js");
var putty = __webpack_require__(/*! ./putty */ "./node_modules/sshpk/lib/formats/putty.js");

var DNSSEC_PRIVKEY_HEADER_PREFIX = 'Private-key-format: v1';

function read(buf, options) {
	if (typeof (buf) === 'string') {
		if (buf.trim().match(/^[-]+[ ]*BEGIN/))
			return (pem.read(buf, options));
		if (buf.match(/^\s*ssh-[a-z]/))
			return (ssh.read(buf, options));
		if (buf.match(/^\s*ecdsa-/))
			return (ssh.read(buf, options));
		if (buf.match(/^putty-user-key-file-2:/i))
			return (putty.read(buf, options));
		if (findDNSSECHeader(buf))
			return (dnssec.read(buf, options));
		buf = Buffer.from(buf, 'binary');
	} else {
		assert.buffer(buf);
		if (findPEMHeader(buf))
			return (pem.read(buf, options));
		if (findSSHHeader(buf))
			return (ssh.read(buf, options));
		if (findPuTTYHeader(buf))
			return (putty.read(buf, options));
		if (findDNSSECHeader(buf))
			return (dnssec.read(buf, options));
	}
	if (buf.readUInt32BE(0) < buf.length)
		return (rfc4253.read(buf, options));
	throw (new Error('Failed to auto-detect format of key'));
}

function findPuTTYHeader(buf) {
	var offset = 0;
	while (offset < buf.length &&
	    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
		++offset;
	if (offset + 22 <= buf.length &&
	    buf.slice(offset, offset + 22).toString('ascii').toLowerCase() ===
	    'putty-user-key-file-2:')
		return (true);
	return (false);
}

function findSSHHeader(buf) {
	var offset = 0;
	while (offset < buf.length &&
	    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
		++offset;
	if (offset + 4 <= buf.length &&
	    buf.slice(offset, offset + 4).toString('ascii') === 'ssh-')
		return (true);
	if (offset + 6 <= buf.length &&
	    buf.slice(offset, offset + 6).toString('ascii') === 'ecdsa-')
		return (true);
	return (false);
}

function findPEMHeader(buf) {
	var offset = 0;
	while (offset < buf.length &&
	    (buf[offset] === 32 || buf[offset] === 10))
		++offset;
	if (buf[offset] !== 45)
		return (false);
	while (offset < buf.length &&
	    (buf[offset] === 45))
		++offset;
	while (offset < buf.length &&
	    (buf[offset] === 32))
		++offset;
	if (offset + 5 > buf.length ||
	    buf.slice(offset, offset + 5).toString('ascii') !== 'BEGIN')
		return (false);
	return (true);
}

function findDNSSECHeader(buf) {
	// private case first
	if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
		return (false);
	var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
	if (headerCheck.toString('ascii') === DNSSEC_PRIVKEY_HEADER_PREFIX)
		return (true);

	// public-key RFC3110 ?
	// 'domain.com. IN KEY ...' or 'domain.com. IN DNSKEY ...'
	// skip any comment-lines
	if (typeof (buf) !== 'string') {
		buf = buf.toString('ascii');
	}
	var lines = buf.split('\n');
	var line = 0;
	/* JSSTYLED */
	while (lines[line].match(/^\;/))
		line++;
	if (lines[line].toString('ascii').match(/\. IN KEY /))
		return (true);
	if (lines[line].toString('ascii').match(/\. IN DNSKEY /))
		return (true);
	return (false);
}

function write(key, options) {
	throw (new Error('"auto" format cannot be used for writing'));
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/dnssec.js":
/*!**************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/dnssec.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 Joyent, Inc.

module.exports = {
	read: read,
	write: write
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");
var SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ "./node_modules/sshpk/lib/ssh-buffer.js");
var Dhe = __webpack_require__(/*! ../dhe */ "./node_modules/sshpk/lib/dhe.js");

var supportedAlgos = {
	'rsa-sha1' : 5,
	'rsa-sha256' : 8,
	'rsa-sha512' : 10,
	'ecdsa-p256-sha256' : 13,
	'ecdsa-p384-sha384' : 14
	/*
	 * ed25519 is hypothetically supported with id 15
	 * but the common tools available don't appear to be
	 * capable of generating/using ed25519 keys
	 */
};

var supportedAlgosById = {};
Object.keys(supportedAlgos).forEach(function (k) {
	supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
});

function read(buf, options) {
	if (typeof (buf) !== 'string') {
		assert.buffer(buf, 'buf');
		buf = buf.toString('ascii');
	}
	var lines = buf.split('\n');
	if (lines[0].match(/^Private-key-format\: v1/)) {
		var algElems = lines[1].split(' ');
		var algoNum = parseInt(algElems[1], 10);
		var algoName = algElems[2];
		if (!supportedAlgosById[algoNum])
			throw (new Error('Unsupported algorithm: ' + algoName));
		return (readDNSSECPrivateKey(algoNum, lines.slice(2)));
	}

	// skip any comment-lines
	var line = 0;
	/* JSSTYLED */
	while (lines[line].match(/^\;/))
		line++;
	// we should now have *one single* line left with our KEY on it.
	if ((lines[line].match(/\. IN KEY /) ||
	    lines[line].match(/\. IN DNSKEY /)) && lines[line+1].length === 0) {
		return (readRFC3110(lines[line]));
	}
	throw (new Error('Cannot parse dnssec key'));
}

function readRFC3110(keyString) {
	var elems = keyString.split(' ');
	//unused var flags = parseInt(elems[3], 10);
	//unused var protocol = parseInt(elems[4], 10);
	var algorithm = parseInt(elems[5], 10);
	if (!supportedAlgosById[algorithm])
		throw (new Error('Unsupported algorithm: ' + algorithm));
	var base64key = elems.slice(6, elems.length).join();
	var keyBuffer = Buffer.from(base64key, 'base64');
	if (supportedAlgosById[algorithm].match(/^RSA-/)) {
		// join the rest of the body into a single base64-blob
		var publicExponentLen = keyBuffer.readUInt8(0);
		if (publicExponentLen != 3 && publicExponentLen != 1)
			throw (new Error('Cannot parse dnssec key: ' +
			    'unsupported exponent length'));

		var publicExponent = keyBuffer.slice(1, publicExponentLen+1);
		publicExponent = utils.mpNormalize(publicExponent);
		var modulus = keyBuffer.slice(1+publicExponentLen);
		modulus = utils.mpNormalize(modulus);
		// now, make the key
		var rsaKey = {
			type: 'rsa',
			parts: []
		};
		rsaKey.parts.push({ name: 'e', data: publicExponent});
		rsaKey.parts.push({ name: 'n', data: modulus});
		return (new Key(rsaKey));
	}
	if (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' ||
	    supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') {
		var curve = 'nistp384';
		var size = 384;
		if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
			curve = 'nistp256';
			size = 256;
		}

		var ecdsaKey = {
			type: 'ecdsa',
			curve: curve,
			size: size,
			parts: [
				{name: 'curve', data: Buffer.from(curve) },
				{name: 'Q', data: utils.ecNormalize(keyBuffer) }
			]
		};
		return (new Key(ecdsaKey));
	}
	throw (new Error('Unsupported algorithm: ' +
	    supportedAlgosById[algorithm]));
}

function elementToBuf(e) {
	return (Buffer.from(e.split(' ')[1], 'base64'));
}

function readDNSSECRSAPrivateKey(elements) {
	var rsaParams = {};
	elements.forEach(function (element) {
		if (element.split(' ')[0] === 'Modulus:')
			rsaParams['n'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'PublicExponent:')
			rsaParams['e'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'PrivateExponent:')
			rsaParams['d'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Prime1:')
			rsaParams['p'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Prime2:')
			rsaParams['q'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Exponent1:')
			rsaParams['dmodp'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Exponent2:')
			rsaParams['dmodq'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Coefficient:')
			rsaParams['iqmp'] = elementToBuf(element);
	});
	// now, make the key
	var key = {
		type: 'rsa',
		parts: [
			{ name: 'e', data: utils.mpNormalize(rsaParams['e'])},
			{ name: 'n', data: utils.mpNormalize(rsaParams['n'])},
			{ name: 'd', data: utils.mpNormalize(rsaParams['d'])},
			{ name: 'p', data: utils.mpNormalize(rsaParams['p'])},
			{ name: 'q', data: utils.mpNormalize(rsaParams['q'])},
			{ name: 'dmodp',
			    data: utils.mpNormalize(rsaParams['dmodp'])},
			{ name: 'dmodq',
			    data: utils.mpNormalize(rsaParams['dmodq'])},
			{ name: 'iqmp',
			    data: utils.mpNormalize(rsaParams['iqmp'])}
		]
	};
	return (new PrivateKey(key));
}

function readDNSSECPrivateKey(alg, elements) {
	if (supportedAlgosById[alg].match(/^RSA-/)) {
		return (readDNSSECRSAPrivateKey(elements));
	}
	if (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' ||
	    supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
		var d = Buffer.from(elements[0].split(' ')[1], 'base64');
		var curve = 'nistp384';
		var size = 384;
		if (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
			curve = 'nistp256';
			size = 256;
		}
		// DNSSEC generates the public-key on the fly (go calculate it)
		var publicKey = utils.publicFromPrivateECDSA(curve, d);
		var Q = publicKey.part['Q'].data;
		var ecdsaKey = {
			type: 'ecdsa',
			curve: curve,
			size: size,
			parts: [
				{name: 'curve', data: Buffer.from(curve) },
				{name: 'd', data: d },
				{name: 'Q', data: Q }
			]
		};
		return (new PrivateKey(ecdsaKey));
	}
	throw (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));
}

function dnssecTimestamp(date) {
	var year = date.getFullYear() + ''; //stringify
	var month = (date.getMonth() + 1);
	var timestampStr = year + month + date.getUTCDate();
	timestampStr += '' + date.getUTCHours() + date.getUTCMinutes();
	timestampStr += date.getUTCSeconds();
	return (timestampStr);
}

function rsaAlgFromOptions(opts) {
	if (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1')
		return ('5 (RSASHA1)');
	else if (opts.hashAlgo === 'sha256')
		return ('8 (RSASHA256)');
	else if (opts.hashAlgo === 'sha512')
		return ('10 (RSASHA512)');
	else
		throw (new Error('Unknown or unsupported hash: ' +
		    opts.hashAlgo));
}

function writeRSA(key, options) {
	// if we're missing parts, add them.
	if (!key.part.dmodp || !key.part.dmodq) {
		utils.addRSAMissing(key);
	}

	var out = '';
	out += 'Private-key-format: v1.3\n';
	out += 'Algorithm: ' + rsaAlgFromOptions(options) + '\n';
	var n = utils.mpDenormalize(key.part['n'].data);
	out += 'Modulus: ' + n.toString('base64') + '\n';
	var e = utils.mpDenormalize(key.part['e'].data);
	out += 'PublicExponent: ' + e.toString('base64') + '\n';
	var d = utils.mpDenormalize(key.part['d'].data);
	out += 'PrivateExponent: ' + d.toString('base64') + '\n';
	var p = utils.mpDenormalize(key.part['p'].data);
	out += 'Prime1: ' + p.toString('base64') + '\n';
	var q = utils.mpDenormalize(key.part['q'].data);
	out += 'Prime2: ' + q.toString('base64') + '\n';
	var dmodp = utils.mpDenormalize(key.part['dmodp'].data);
	out += 'Exponent1: ' + dmodp.toString('base64') + '\n';
	var dmodq = utils.mpDenormalize(key.part['dmodq'].data);
	out += 'Exponent2: ' + dmodq.toString('base64') + '\n';
	var iqmp = utils.mpDenormalize(key.part['iqmp'].data);
	out += 'Coefficient: ' + iqmp.toString('base64') + '\n';
	// Assume that we're valid as-of now
	var timestamp = new Date();
	out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';
	return (Buffer.from(out, 'ascii'));
}

function writeECDSA(key, options) {
	var out = '';
	out += 'Private-key-format: v1.3\n';

	if (key.curve === 'nistp256') {
		out += 'Algorithm: 13 (ECDSAP256SHA256)\n';
	} else if (key.curve === 'nistp384') {
		out += 'Algorithm: 14 (ECDSAP384SHA384)\n';
	} else {
		throw (new Error('Unsupported curve'));
	}
	var base64Key = key.part['d'].data.toString('base64');
	out += 'PrivateKey: ' + base64Key + '\n';

	// Assume that we're valid as-of now
	var timestamp = new Date();
	out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';

	return (Buffer.from(out, 'ascii'));
}

function write(key, options) {
	if (PrivateKey.isPrivateKey(key)) {
		if (key.type === 'rsa') {
			return (writeRSA(key, options));
		} else if (key.type === 'ecdsa') {
			return (writeECDSA(key, options));
		} else {
			throw (new Error('Unsupported algorithm: ' + key.type));
		}
	} else if (Key.isKey(key)) {
		/*
		 * RFC3110 requires a keyname, and a keytype, which we
		 * don't really have a mechanism for specifying such
		 * additional metadata.
		 */
		throw (new Error('Format "dnssec" only supports ' +
		    'writing private keys'));
	} else {
		throw (new Error('key is not a Key or PrivateKey'));
	}
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/openssh-cert.js":
/*!********************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/openssh-cert.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 Joyent, Inc.

module.exports = {
	read: read,
	verify: verify,
	sign: sign,
	signAsync: signAsync,
	write: write,

	/* Internal private API */
	fromBuffer: fromBuffer,
	toBuffer: toBuffer
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ "./node_modules/sshpk/lib/ssh-buffer.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ../algs */ "./node_modules/sshpk/lib/algs.js");
var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");
var Identity = __webpack_require__(/*! ../identity */ "./node_modules/sshpk/lib/identity.js");
var rfc4253 = __webpack_require__(/*! ./rfc4253 */ "./node_modules/sshpk/lib/formats/rfc4253.js");
var Signature = __webpack_require__(/*! ../signature */ "./node_modules/sshpk/lib/signature.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");
var Certificate = __webpack_require__(/*! ../certificate */ "./node_modules/sshpk/lib/certificate.js");

function verify(cert, key) {
	/*
	 * We always give an issuerKey, so if our verify() is being called then
	 * there was no signature. Return false.
	 */
	return (false);
}

var TYPES = {
	'user': 1,
	'host': 2
};
Object.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });

var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;

function read(buf, options) {
	if (Buffer.isBuffer(buf))
		buf = buf.toString('ascii');
	var parts = buf.trim().split(/[ \t\n]+/g);
	if (parts.length < 2 || parts.length > 3)
		throw (new Error('Not a valid SSH certificate line'));

	var algo = parts[0];
	var data = parts[1];

	data = Buffer.from(data, 'base64');
	return (fromBuffer(data, algo));
}

function fromBuffer(data, algo, partial) {
	var sshbuf = new SSHBuffer({ buffer: data });
	var innerAlgo = sshbuf.readString();
	if (algo !== undefined && innerAlgo !== algo)
		throw (new Error('SSH certificate algorithm mismatch'));
	if (algo === undefined)
		algo = innerAlgo;

	var cert = {};
	cert.signatures = {};
	cert.signatures.openssh = {};

	cert.signatures.openssh.nonce = sshbuf.readBuffer();

	var key = {};
	var parts = (key.parts = []);
	key.type = getAlg(algo);

	var partCount = algs.info[key.type].parts.length;
	while (parts.length < partCount)
		parts.push(sshbuf.readPart());
	assert.ok(parts.length >= 1, 'key must have at least one part');

	var algInfo = algs.info[key.type];
	if (key.type === 'ecdsa') {
		var res = ECDSA_ALGO.exec(algo);
		assert.ok(res !== null);
		assert.strictEqual(res[1], parts[0].data.toString());
	}

	for (var i = 0; i < algInfo.parts.length; ++i) {
		parts[i].name = algInfo.parts[i];
		if (parts[i].name !== 'curve' &&
		    algInfo.normalize !== false) {
			var p = parts[i];
			p.data = utils.mpNormalize(p.data);
		}
	}

	cert.subjectKey = new Key(key);

	cert.serial = sshbuf.readInt64();

	var type = TYPES[sshbuf.readInt()];
	assert.string(type, 'valid cert type');

	cert.signatures.openssh.keyId = sshbuf.readString();

	var principals = [];
	var pbuf = sshbuf.readBuffer();
	var psshbuf = new SSHBuffer({ buffer: pbuf });
	while (!psshbuf.atEnd())
		principals.push(psshbuf.readString());
	if (principals.length === 0)
		principals = ['*'];

	cert.subjects = principals.map(function (pr) {
		if (type === 'user')
			return (Identity.forUser(pr));
		else if (type === 'host')
			return (Identity.forHost(pr));
		throw (new Error('Unknown identity type ' + type));
	});

	cert.validFrom = int64ToDate(sshbuf.readInt64());
	cert.validUntil = int64ToDate(sshbuf.readInt64());

	var exts = [];
	var extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
	var ext;
	while (!extbuf.atEnd()) {
		ext = { critical: true };
		ext.name = extbuf.readString();
		ext.data = extbuf.readBuffer();
		exts.push(ext);
	}
	extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
	while (!extbuf.atEnd()) {
		ext = { critical: false };
		ext.name = extbuf.readString();
		ext.data = extbuf.readBuffer();
		exts.push(ext);
	}
	cert.signatures.openssh.exts = exts;

	/* reserved */
	sshbuf.readBuffer();

	var signingKeyBuf = sshbuf.readBuffer();
	cert.issuerKey = rfc4253.read(signingKeyBuf);

	/*
	 * OpenSSH certs don't give the identity of the issuer, just their
	 * public key. So, we use an Identity that matches anything. The
	 * isSignedBy() function will later tell you if the key matches.
	 */
	cert.issuer = Identity.forHost('**');

	var sigBuf = sshbuf.readBuffer();
	cert.signatures.openssh.signature =
	    Signature.parse(sigBuf, cert.issuerKey.type, 'ssh');

	if (partial !== undefined) {
		partial.remainder = sshbuf.remainder();
		partial.consumed = sshbuf._offset;
	}

	return (new Certificate(cert));
}

function int64ToDate(buf) {
	var i = buf.readUInt32BE(0) * 4294967296;
	i += buf.readUInt32BE(4);
	var d = new Date();
	d.setTime(i * 1000);
	d.sourceInt64 = buf;
	return (d);
}

function dateToInt64(date) {
	if (date.sourceInt64 !== undefined)
		return (date.sourceInt64);
	var i = Math.round(date.getTime() / 1000);
	var upper = Math.floor(i / 4294967296);
	var lower = Math.floor(i % 4294967296);
	var buf = Buffer.alloc(8);
	buf.writeUInt32BE(upper, 0);
	buf.writeUInt32BE(lower, 4);
	return (buf);
}

function sign(cert, key) {
	if (cert.signatures.openssh === undefined)
		cert.signatures.openssh = {};
	try {
		var blob = toBuffer(cert, true);
	} catch (e) {
		delete (cert.signatures.openssh);
		return (false);
	}
	var sig = cert.signatures.openssh;
	var hashAlgo = undefined;
	if (key.type === 'rsa' || key.type === 'dsa')
		hashAlgo = 'sha1';
	var signer = key.createSign(hashAlgo);
	signer.write(blob);
	sig.signature = signer.sign();
	return (true);
}

function signAsync(cert, signer, done) {
	if (cert.signatures.openssh === undefined)
		cert.signatures.openssh = {};
	try {
		var blob = toBuffer(cert, true);
	} catch (e) {
		delete (cert.signatures.openssh);
		done(e);
		return;
	}
	var sig = cert.signatures.openssh;

	signer(blob, function (err, signature) {
		if (err) {
			done(err);
			return;
		}
		try {
			/*
			 * This will throw if the signature isn't of a
			 * type/algo that can be used for SSH.
			 */
			signature.toBuffer('ssh');
		} catch (e) {
			done(e);
			return;
		}
		sig.signature = signature;
		done();
	});
}

function write(cert, options) {
	if (options === undefined)
		options = {};

	var blob = toBuffer(cert);
	var out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');
	if (options.comment)
		out = out + ' ' + options.comment;
	return (out);
}


function toBuffer(cert, noSig) {
	assert.object(cert.signatures.openssh, 'signature for openssh format');
	var sig = cert.signatures.openssh;

	if (sig.nonce === undefined)
		sig.nonce = crypto.randomBytes(16);
	var buf = new SSHBuffer({});
	buf.writeString(getCertType(cert.subjectKey));
	buf.writeBuffer(sig.nonce);

	var key = cert.subjectKey;
	var algInfo = algs.info[key.type];
	algInfo.parts.forEach(function (part) {
		buf.writePart(key.part[part]);
	});

	buf.writeInt64(cert.serial);

	var type = cert.subjects[0].type;
	assert.notStrictEqual(type, 'unknown');
	cert.subjects.forEach(function (id) {
		assert.strictEqual(id.type, type);
	});
	type = TYPES[type];
	buf.writeInt(type);

	if (sig.keyId === undefined) {
		sig.keyId = cert.subjects[0].type + '_' +
		    (cert.subjects[0].uid || cert.subjects[0].hostname);
	}
	buf.writeString(sig.keyId);

	var sub = new SSHBuffer({});
	cert.subjects.forEach(function (id) {
		if (type === TYPES.host)
			sub.writeString(id.hostname);
		else if (type === TYPES.user)
			sub.writeString(id.uid);
	});
	buf.writeBuffer(sub.toBuffer());

	buf.writeInt64(dateToInt64(cert.validFrom));
	buf.writeInt64(dateToInt64(cert.validUntil));

	var exts = sig.exts;
	if (exts === undefined)
		exts = [];

	var extbuf = new SSHBuffer({});
	exts.forEach(function (ext) {
		if (ext.critical !== true)
			return;
		extbuf.writeString(ext.name);
		extbuf.writeBuffer(ext.data);
	});
	buf.writeBuffer(extbuf.toBuffer());

	extbuf = new SSHBuffer({});
	exts.forEach(function (ext) {
		if (ext.critical === true)
			return;
		extbuf.writeString(ext.name);
		extbuf.writeBuffer(ext.data);
	});
	buf.writeBuffer(extbuf.toBuffer());

	/* reserved */
	buf.writeBuffer(Buffer.alloc(0));

	sub = rfc4253.write(cert.issuerKey);
	buf.writeBuffer(sub);

	if (!noSig)
		buf.writeBuffer(sig.signature.toBuffer('ssh'));

	return (buf.toBuffer());
}

function getAlg(certType) {
	if (certType === 'ssh-rsa-cert-v01@openssh.com')
		return ('rsa');
	if (certType === 'ssh-dss-cert-v01@openssh.com')
		return ('dsa');
	if (certType.match(ECDSA_ALGO))
		return ('ecdsa');
	if (certType === 'ssh-ed25519-cert-v01@openssh.com')
		return ('ed25519');
	throw (new Error('Unsupported cert type ' + certType));
}

function getCertType(key) {
	if (key.type === 'rsa')
		return ('ssh-rsa-cert-v01@openssh.com');
	if (key.type === 'dsa')
		return ('ssh-dss-cert-v01@openssh.com');
	if (key.type === 'ecdsa')
		return ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');
	if (key.type === 'ed25519')
		return ('ssh-ed25519-cert-v01@openssh.com');
	throw (new Error('Unsupported key type ' + key.type));
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/pem.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/formats/pem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 Joyent, Inc.

module.exports = {
	read: read,
	write: write
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var asn1 = __webpack_require__(/*! asn1 */ "./node_modules/asn1/lib/index.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ../algs */ "./node_modules/sshpk/lib/algs.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");
var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");

var pkcs1 = __webpack_require__(/*! ./pkcs1 */ "./node_modules/sshpk/lib/formats/pkcs1.js");
var pkcs8 = __webpack_require__(/*! ./pkcs8 */ "./node_modules/sshpk/lib/formats/pkcs8.js");
var sshpriv = __webpack_require__(/*! ./ssh-private */ "./node_modules/sshpk/lib/formats/ssh-private.js");
var rfc4253 = __webpack_require__(/*! ./rfc4253 */ "./node_modules/sshpk/lib/formats/rfc4253.js");

var errors = __webpack_require__(/*! ../errors */ "./node_modules/sshpk/lib/errors.js");

var OID_PBES2 = '1.2.840.113549.1.5.13';
var OID_PBKDF2 = '1.2.840.113549.1.5.12';

var OID_TO_CIPHER = {
	'1.2.840.113549.3.7': '3des-cbc',
	'2.16.840.1.101.3.4.1.2': 'aes128-cbc',
	'2.16.840.1.101.3.4.1.42': 'aes256-cbc'
};
var CIPHER_TO_OID = {};
Object.keys(OID_TO_CIPHER).forEach(function (k) {
	CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;
});

var OID_TO_HASH = {
	'1.2.840.113549.2.7': 'sha1',
	'1.2.840.113549.2.9': 'sha256',
	'1.2.840.113549.2.11': 'sha512'
};
var HASH_TO_OID = {};
Object.keys(OID_TO_HASH).forEach(function (k) {
	HASH_TO_OID[OID_TO_HASH[k]] = k;
});

/*
 * For reading we support both PKCS#1 and PKCS#8. If we find a private key,
 * we just take the public component of it and use that.
 */
function read(buf, options, forceType) {
	var input = buf;
	if (typeof (buf) !== 'string') {
		assert.buffer(buf, 'buf');
		buf = buf.toString('ascii');
	}

	var lines = buf.trim().split(/[\r\n]+/g);

	var m;
	var si = -1;
	while (!m && si < lines.length) {
		m = lines[++si].match(/*JSSTYLED*/
		    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
	}
	assert.ok(m, 'invalid PEM header');

	var m2;
	var ei = lines.length;
	while (!m2 && ei > 0) {
		m2 = lines[--ei].match(/*JSSTYLED*/
		    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
	}
	assert.ok(m2, 'invalid PEM footer');

	/* Begin and end banners must match key type */
	assert.equal(m[2], m2[2]);
	var type = m[2].toLowerCase();

	var alg;
	if (m[1]) {
		/* They also must match algorithms, if given */
		assert.equal(m[1], m2[1], 'PEM header and footer mismatch');
		alg = m[1].trim();
	}

	lines = lines.slice(si, ei + 1);

	var headers = {};
	while (true) {
		lines = lines.slice(1);
		m = lines[0].match(/*JSSTYLED*/
		    /^([A-Za-z0-9-]+): (.+)$/);
		if (!m)
			break;
		headers[m[1].toLowerCase()] = m[2];
	}

	/* Chop off the first and last lines */
	lines = lines.slice(0, -1).join('');
	buf = Buffer.from(lines, 'base64');

	var cipher, key, iv;
	if (headers['proc-type']) {
		var parts = headers['proc-type'].split(',');
		if (parts[0] === '4' && parts[1] === 'ENCRYPTED') {
			if (typeof (options.passphrase) === 'string') {
				options.passphrase = Buffer.from(
				    options.passphrase, 'utf-8');
			}
			if (!Buffer.isBuffer(options.passphrase)) {
				throw (new errors.KeyEncryptedError(
				    options.filename, 'PEM'));
			} else {
				parts = headers['dek-info'].split(',');
				assert.ok(parts.length === 2);
				cipher = parts[0].toLowerCase();
				iv = Buffer.from(parts[1], 'hex');
				key = utils.opensslKeyDeriv(cipher, iv,
				    options.passphrase, 1).key;
			}
		}
	}

	if (alg && alg.toLowerCase() === 'encrypted') {
		var eder = new asn1.BerReader(buf);
		var pbesEnd;
		eder.readSequence();

		eder.readSequence();
		pbesEnd = eder.offset + eder.length;

		var method = eder.readOID();
		if (method !== OID_PBES2) {
			throw (new Error('Unsupported PEM/PKCS8 encryption ' +
			    'scheme: ' + method));
		}

		eder.readSequence();	/* PBES2-params */

		eder.readSequence();	/* keyDerivationFunc */
		var kdfEnd = eder.offset + eder.length;
		var kdfOid = eder.readOID();
		if (kdfOid !== OID_PBKDF2)
			throw (new Error('Unsupported PBES2 KDF: ' + kdfOid));
		eder.readSequence();
		var salt = eder.readString(asn1.Ber.OctetString, true);
		var iterations = eder.readInt();
		var hashAlg = 'sha1';
		if (eder.offset < kdfEnd) {
			eder.readSequence();
			var hashAlgOid = eder.readOID();
			hashAlg = OID_TO_HASH[hashAlgOid];
			if (hashAlg === undefined) {
				throw (new Error('Unsupported PBKDF2 hash: ' +
				    hashAlgOid));
			}
		}
		eder._offset = kdfEnd;

		eder.readSequence();	/* encryptionScheme */
		var cipherOid = eder.readOID();
		cipher = OID_TO_CIPHER[cipherOid];
		if (cipher === undefined) {
			throw (new Error('Unsupported PBES2 cipher: ' +
			    cipherOid));
		}
		iv = eder.readString(asn1.Ber.OctetString, true);

		eder._offset = pbesEnd;
		buf = eder.readString(asn1.Ber.OctetString, true);

		if (typeof (options.passphrase) === 'string') {
			options.passphrase = Buffer.from(
			    options.passphrase, 'utf-8');
		}
		if (!Buffer.isBuffer(options.passphrase)) {
			throw (new errors.KeyEncryptedError(
			    options.filename, 'PEM'));
		}

		var cinfo = utils.opensshCipherInfo(cipher);

		cipher = cinfo.opensslName;
		key = utils.pbkdf2(hashAlg, salt, iterations, cinfo.keySize,
		    options.passphrase);
		alg = undefined;
	}

	if (cipher && key && iv) {
		var cipherStream = crypto.createDecipheriv(cipher, key, iv);
		var chunk, chunks = [];
		cipherStream.once('error', function (e) {
			if (e.toString().indexOf('bad decrypt') !== -1) {
				throw (new Error('Incorrect passphrase ' +
				    'supplied, could not decrypt key'));
			}
			throw (e);
		});
		cipherStream.write(buf);
		cipherStream.end();
		while ((chunk = cipherStream.read()) !== null)
			chunks.push(chunk);
		buf = Buffer.concat(chunks);
	}

	/* The new OpenSSH internal format abuses PEM headers */
	if (alg && alg.toLowerCase() === 'openssh')
		return (sshpriv.readSSHPrivate(type, buf, options));
	if (alg && alg.toLowerCase() === 'ssh2')
		return (rfc4253.readType(type, buf, options));

	var der = new asn1.BerReader(buf);
	der.originalInput = input;

	/*
	 * All of the PEM file types start with a sequence tag, so chop it
	 * off here
	 */
	der.readSequence();

	/* PKCS#1 type keys name an algorithm in the banner explicitly */
	if (alg) {
		if (forceType)
			assert.strictEqual(forceType, 'pkcs1');
		return (pkcs1.readPkcs1(alg, type, der));
	} else {
		if (forceType)
			assert.strictEqual(forceType, 'pkcs8');
		return (pkcs8.readPkcs8(alg, type, der));
	}
}

function write(key, options, type) {
	assert.object(key);

	var alg = {
	    'ecdsa': 'EC',
	    'rsa': 'RSA',
	    'dsa': 'DSA',
	    'ed25519': 'EdDSA'
	}[key.type];
	var header;

	var der = new asn1.BerWriter();

	if (PrivateKey.isPrivateKey(key)) {
		if (type && type === 'pkcs8') {
			header = 'PRIVATE KEY';
			pkcs8.writePkcs8(der, key);
		} else {
			if (type)
				assert.strictEqual(type, 'pkcs1');
			header = alg + ' PRIVATE KEY';
			pkcs1.writePkcs1(der, key);
		}

	} else if (Key.isKey(key)) {
		if (type && type === 'pkcs1') {
			header = alg + ' PUBLIC KEY';
			pkcs1.writePkcs1(der, key);
		} else {
			if (type)
				assert.strictEqual(type, 'pkcs8');
			header = 'PUBLIC KEY';
			pkcs8.writePkcs8(der, key);
		}

	} else {
		throw (new Error('key is not a Key or PrivateKey'));
	}

	var tmp = der.buffer.toString('base64');
	var len = tmp.length + (tmp.length / 64) +
	    18 + 16 + header.length*2 + 10;
	var buf = Buffer.alloc(len);
	var o = 0;
	o += buf.write('-----BEGIN ' + header + '-----\n', o);
	for (var i = 0; i < tmp.length; ) {
		var limit = i + 64;
		if (limit > tmp.length)
			limit = tmp.length;
		o += buf.write(tmp.slice(i, limit), o);
		buf[o++] = 10;
		i = limit;
	}
	o += buf.write('-----END ' + header + '-----\n', o);

	return (buf.slice(0, o));
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/pkcs1.js":
/*!*************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/pkcs1.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

module.exports = {
	read: read,
	readPkcs1: readPkcs1,
	write: write,
	writePkcs1: writePkcs1
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var asn1 = __webpack_require__(/*! asn1 */ "./node_modules/asn1/lib/index.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ../algs */ "./node_modules/sshpk/lib/algs.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");

var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");
var pem = __webpack_require__(/*! ./pem */ "./node_modules/sshpk/lib/formats/pem.js");

var pkcs8 = __webpack_require__(/*! ./pkcs8 */ "./node_modules/sshpk/lib/formats/pkcs8.js");
var readECDSACurve = pkcs8.readECDSACurve;

function read(buf, options) {
	return (pem.read(buf, options, 'pkcs1'));
}

function write(key, options) {
	return (pem.write(key, options, 'pkcs1'));
}

/* Helper to read in a single mpint */
function readMPInt(der, nm) {
	assert.strictEqual(der.peek(), asn1.Ber.Integer,
	    nm + ' is not an Integer');
	return (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
}

function readPkcs1(alg, type, der) {
	switch (alg) {
	case 'RSA':
		if (type === 'public')
			return (readPkcs1RSAPublic(der));
		else if (type === 'private')
			return (readPkcs1RSAPrivate(der));
		throw (new Error('Unknown key type: ' + type));
	case 'DSA':
		if (type === 'public')
			return (readPkcs1DSAPublic(der));
		else if (type === 'private')
			return (readPkcs1DSAPrivate(der));
		throw (new Error('Unknown key type: ' + type));
	case 'EC':
	case 'ECDSA':
		if (type === 'private')
			return (readPkcs1ECDSAPrivate(der));
		else if (type === 'public')
			return (readPkcs1ECDSAPublic(der));
		throw (new Error('Unknown key type: ' + type));
	case 'EDDSA':
	case 'EdDSA':
		if (type === 'private')
			return (readPkcs1EdDSAPrivate(der));
		throw (new Error(type + ' keys not supported with EdDSA'));
	default:
		throw (new Error('Unknown key algo: ' + alg));
	}
}

function readPkcs1RSAPublic(der) {
	// modulus and exponent
	var n = readMPInt(der, 'modulus');
	var e = readMPInt(der, 'exponent');

	// now, make the key
	var key = {
		type: 'rsa',
		parts: [
			{ name: 'e', data: e },
			{ name: 'n', data: n }
		]
	};

	return (new Key(key));
}

function readPkcs1RSAPrivate(der) {
	var version = readMPInt(der, 'version');
	assert.strictEqual(version[0], 0);

	// modulus then public exponent
	var n = readMPInt(der, 'modulus');
	var e = readMPInt(der, 'public exponent');
	var d = readMPInt(der, 'private exponent');
	var p = readMPInt(der, 'prime1');
	var q = readMPInt(der, 'prime2');
	var dmodp = readMPInt(der, 'exponent1');
	var dmodq = readMPInt(der, 'exponent2');
	var iqmp = readMPInt(der, 'iqmp');

	// now, make the key
	var key = {
		type: 'rsa',
		parts: [
			{ name: 'n', data: n },
			{ name: 'e', data: e },
			{ name: 'd', data: d },
			{ name: 'iqmp', data: iqmp },
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'dmodp', data: dmodp },
			{ name: 'dmodq', data: dmodq }
		]
	};

	return (new PrivateKey(key));
}

function readPkcs1DSAPrivate(der) {
	var version = readMPInt(der, 'version');
	assert.strictEqual(version.readUInt8(0), 0);

	var p = readMPInt(der, 'p');
	var q = readMPInt(der, 'q');
	var g = readMPInt(der, 'g');
	var y = readMPInt(der, 'y');
	var x = readMPInt(der, 'x');

	// now, make the key
	var key = {
		type: 'dsa',
		parts: [
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'g', data: g },
			{ name: 'y', data: y },
			{ name: 'x', data: x }
		]
	};

	return (new PrivateKey(key));
}

function readPkcs1EdDSAPrivate(der) {
	var version = readMPInt(der, 'version');
	assert.strictEqual(version.readUInt8(0), 1);

	// private key
	var k = der.readString(asn1.Ber.OctetString, true);

	der.readSequence(0xa0);
	var oid = der.readOID();
	assert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');

	der.readSequence(0xa1);
	var A = utils.readBitString(der);

	var key = {
		type: 'ed25519',
		parts: [
			{ name: 'A', data: utils.zeroPadToLength(A, 32) },
			{ name: 'k', data: k }
		]
	};

	return (new PrivateKey(key));
}

function readPkcs1DSAPublic(der) {
	var y = readMPInt(der, 'y');
	var p = readMPInt(der, 'p');
	var q = readMPInt(der, 'q');
	var g = readMPInt(der, 'g');

	var key = {
		type: 'dsa',
		parts: [
			{ name: 'y', data: y },
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'g', data: g }
		]
	};

	return (new Key(key));
}

function readPkcs1ECDSAPublic(der) {
	der.readSequence();

	var oid = der.readOID();
	assert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');

	var curveOid = der.readOID();

	var curve;
	var curves = Object.keys(algs.curves);
	for (var j = 0; j < curves.length; ++j) {
		var c = curves[j];
		var cd = algs.curves[c];
		if (cd.pkcs8oid === curveOid) {
			curve = c;
			break;
		}
	}
	assert.string(curve, 'a known ECDSA named curve');

	var Q = der.readString(asn1.Ber.BitString, true);
	Q = utils.ecNormalize(Q);

	var key = {
		type: 'ecdsa',
		parts: [
			{ name: 'curve', data: Buffer.from(curve) },
			{ name: 'Q', data: Q }
		]
	};

	return (new Key(key));
}

function readPkcs1ECDSAPrivate(der) {
	var version = readMPInt(der, 'version');
	assert.strictEqual(version.readUInt8(0), 1);

	// private key
	var d = der.readString(asn1.Ber.OctetString, true);

	der.readSequence(0xa0);
	var curve = readECDSACurve(der);
	assert.string(curve, 'a known elliptic curve');

	der.readSequence(0xa1);
	var Q = der.readString(asn1.Ber.BitString, true);
	Q = utils.ecNormalize(Q);

	var key = {
		type: 'ecdsa',
		parts: [
			{ name: 'curve', data: Buffer.from(curve) },
			{ name: 'Q', data: Q },
			{ name: 'd', data: d }
		]
	};

	return (new PrivateKey(key));
}

function writePkcs1(der, key) {
	der.startSequence();

	switch (key.type) {
	case 'rsa':
		if (PrivateKey.isPrivateKey(key))
			writePkcs1RSAPrivate(der, key);
		else
			writePkcs1RSAPublic(der, key);
		break;
	case 'dsa':
		if (PrivateKey.isPrivateKey(key))
			writePkcs1DSAPrivate(der, key);
		else
			writePkcs1DSAPublic(der, key);
		break;
	case 'ecdsa':
		if (PrivateKey.isPrivateKey(key))
			writePkcs1ECDSAPrivate(der, key);
		else
			writePkcs1ECDSAPublic(der, key);
		break;
	case 'ed25519':
		if (PrivateKey.isPrivateKey(key))
			writePkcs1EdDSAPrivate(der, key);
		else
			writePkcs1EdDSAPublic(der, key);
		break;
	default:
		throw (new Error('Unknown key algo: ' + key.type));
	}

	der.endSequence();
}

function writePkcs1RSAPublic(der, key) {
	der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
}

function writePkcs1RSAPrivate(der, key) {
	var ver = Buffer.from([0]);
	der.writeBuffer(ver, asn1.Ber.Integer);

	der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
	if (!key.part.dmodp || !key.part.dmodq)
		utils.addRSAMissing(key);
	der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
}

function writePkcs1DSAPrivate(der, key) {
	var ver = Buffer.from([0]);
	der.writeBuffer(ver, asn1.Ber.Integer);

	der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
}

function writePkcs1DSAPublic(der, key) {
	der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
}

function writePkcs1ECDSAPublic(der, key) {
	der.startSequence();

	der.writeOID('1.2.840.10045.2.1'); /* ecPublicKey */
	var curve = key.part.curve.data.toString();
	var curveOid = algs.curves[curve].pkcs8oid;
	assert.string(curveOid, 'a known ECDSA named curve');
	der.writeOID(curveOid);

	der.endSequence();

	var Q = utils.ecNormalize(key.part.Q.data, true);
	der.writeBuffer(Q, asn1.Ber.BitString);
}

function writePkcs1ECDSAPrivate(der, key) {
	var ver = Buffer.from([1]);
	der.writeBuffer(ver, asn1.Ber.Integer);

	der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);

	der.startSequence(0xa0);
	var curve = key.part.curve.data.toString();
	var curveOid = algs.curves[curve].pkcs8oid;
	assert.string(curveOid, 'a known ECDSA named curve');
	der.writeOID(curveOid);
	der.endSequence();

	der.startSequence(0xa1);
	var Q = utils.ecNormalize(key.part.Q.data, true);
	der.writeBuffer(Q, asn1.Ber.BitString);
	der.endSequence();
}

function writePkcs1EdDSAPrivate(der, key) {
	var ver = Buffer.from([1]);
	der.writeBuffer(ver, asn1.Ber.Integer);

	der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);

	der.startSequence(0xa0);
	der.writeOID('1.3.101.112');
	der.endSequence();

	der.startSequence(0xa1);
	utils.writeBitString(der, key.part.A.data);
	der.endSequence();
}

function writePkcs1EdDSAPublic(der, key) {
	throw (new Error('Public keys are not supported for EdDSA PKCS#1'));
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/pkcs8.js":
/*!*************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/pkcs8.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 Joyent, Inc.

module.exports = {
	read: read,
	readPkcs8: readPkcs8,
	write: write,
	writePkcs8: writePkcs8,
	pkcs8ToBuffer: pkcs8ToBuffer,

	readECDSACurve: readECDSACurve,
	writeECDSACurve: writeECDSACurve
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var asn1 = __webpack_require__(/*! asn1 */ "./node_modules/asn1/lib/index.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ../algs */ "./node_modules/sshpk/lib/algs.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");
var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");
var pem = __webpack_require__(/*! ./pem */ "./node_modules/sshpk/lib/formats/pem.js");

function read(buf, options) {
	return (pem.read(buf, options, 'pkcs8'));
}

function write(key, options) {
	return (pem.write(key, options, 'pkcs8'));
}

/* Helper to read in a single mpint */
function readMPInt(der, nm) {
	assert.strictEqual(der.peek(), asn1.Ber.Integer,
	    nm + ' is not an Integer');
	return (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
}

function readPkcs8(alg, type, der) {
	/* Private keys in pkcs#8 format have a weird extra int */
	if (der.peek() === asn1.Ber.Integer) {
		assert.strictEqual(type, 'private',
		    'unexpected Integer at start of public key');
		der.readString(asn1.Ber.Integer, true);
	}

	der.readSequence();
	var next = der.offset + der.length;

	var oid = der.readOID();
	switch (oid) {
	case '1.2.840.113549.1.1.1':
		der._offset = next;
		if (type === 'public')
			return (readPkcs8RSAPublic(der));
		else
			return (readPkcs8RSAPrivate(der));
	case '1.2.840.10040.4.1':
		if (type === 'public')
			return (readPkcs8DSAPublic(der));
		else
			return (readPkcs8DSAPrivate(der));
	case '1.2.840.10045.2.1':
		if (type === 'public')
			return (readPkcs8ECDSAPublic(der));
		else
			return (readPkcs8ECDSAPrivate(der));
	case '1.3.101.112':
		if (type === 'public') {
			return (readPkcs8EdDSAPublic(der));
		} else {
			return (readPkcs8EdDSAPrivate(der));
		}
	case '1.3.101.110':
		if (type === 'public') {
			return (readPkcs8X25519Public(der));
		} else {
			return (readPkcs8X25519Private(der));
		}
	default:
		throw (new Error('Unknown key type OID ' + oid));
	}
}

function readPkcs8RSAPublic(der) {
	// bit string sequence
	der.readSequence(asn1.Ber.BitString);
	der.readByte();
	der.readSequence();

	// modulus
	var n = readMPInt(der, 'modulus');
	var e = readMPInt(der, 'exponent');

	// now, make the key
	var key = {
		type: 'rsa',
		source: der.originalInput,
		parts: [
			{ name: 'e', data: e },
			{ name: 'n', data: n }
		]
	};

	return (new Key(key));
}

function readPkcs8RSAPrivate(der) {
	der.readSequence(asn1.Ber.OctetString);
	der.readSequence();

	var ver = readMPInt(der, 'version');
	assert.equal(ver[0], 0x0, 'unknown RSA private key version');

	// modulus then public exponent
	var n = readMPInt(der, 'modulus');
	var e = readMPInt(der, 'public exponent');
	var d = readMPInt(der, 'private exponent');
	var p = readMPInt(der, 'prime1');
	var q = readMPInt(der, 'prime2');
	var dmodp = readMPInt(der, 'exponent1');
	var dmodq = readMPInt(der, 'exponent2');
	var iqmp = readMPInt(der, 'iqmp');

	// now, make the key
	var key = {
		type: 'rsa',
		parts: [
			{ name: 'n', data: n },
			{ name: 'e', data: e },
			{ name: 'd', data: d },
			{ name: 'iqmp', data: iqmp },
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'dmodp', data: dmodp },
			{ name: 'dmodq', data: dmodq }
		]
	};

	return (new PrivateKey(key));
}

function readPkcs8DSAPublic(der) {
	der.readSequence();

	var p = readMPInt(der, 'p');
	var q = readMPInt(der, 'q');
	var g = readMPInt(der, 'g');

	// bit string sequence
	der.readSequence(asn1.Ber.BitString);
	der.readByte();

	var y = readMPInt(der, 'y');

	// now, make the key
	var key = {
		type: 'dsa',
		parts: [
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'g', data: g },
			{ name: 'y', data: y }
		]
	};

	return (new Key(key));
}

function readPkcs8DSAPrivate(der) {
	der.readSequence();

	var p = readMPInt(der, 'p');
	var q = readMPInt(der, 'q');
	var g = readMPInt(der, 'g');

	der.readSequence(asn1.Ber.OctetString);
	var x = readMPInt(der, 'x');

	/* The pkcs#8 format does not include the public key */
	var y = utils.calculateDSAPublic(g, p, x);

	var key = {
		type: 'dsa',
		parts: [
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'g', data: g },
			{ name: 'y', data: y },
			{ name: 'x', data: x }
		]
	};

	return (new PrivateKey(key));
}

function readECDSACurve(der) {
	var curveName, curveNames;
	var j, c, cd;

	if (der.peek() === asn1.Ber.OID) {
		var oid = der.readOID();

		curveNames = Object.keys(algs.curves);
		for (j = 0; j < curveNames.length; ++j) {
			c = curveNames[j];
			cd = algs.curves[c];
			if (cd.pkcs8oid === oid) {
				curveName = c;
				break;
			}
		}

	} else {
		// ECParameters sequence
		der.readSequence();
		var version = der.readString(asn1.Ber.Integer, true);
		assert.strictEqual(version[0], 1, 'ECDSA key not version 1');

		var curve = {};

		// FieldID sequence
		der.readSequence();
		var fieldTypeOid = der.readOID();
		assert.strictEqual(fieldTypeOid, '1.2.840.10045.1.1',
		    'ECDSA key is not from a prime-field');
		var p = curve.p = utils.mpNormalize(
		    der.readString(asn1.Ber.Integer, true));
		/*
		 * p always starts with a 1 bit, so count the zeros to get its
		 * real size.
		 */
		curve.size = p.length * 8 - utils.countZeros(p);

		// Curve sequence
		der.readSequence();
		curve.a = utils.mpNormalize(
		    der.readString(asn1.Ber.OctetString, true));
		curve.b = utils.mpNormalize(
		    der.readString(asn1.Ber.OctetString, true));
		if (der.peek() === asn1.Ber.BitString)
			curve.s = der.readString(asn1.Ber.BitString, true);

		// Combined Gx and Gy
		curve.G = der.readString(asn1.Ber.OctetString, true);
		assert.strictEqual(curve.G[0], 0x4,
		    'uncompressed G is required');

		curve.n = utils.mpNormalize(
		    der.readString(asn1.Ber.Integer, true));
		curve.h = utils.mpNormalize(
		    der.readString(asn1.Ber.Integer, true));
		assert.strictEqual(curve.h[0], 0x1, 'a cofactor=1 curve is ' +
		    'required');

		curveNames = Object.keys(algs.curves);
		var ks = Object.keys(curve);
		for (j = 0; j < curveNames.length; ++j) {
			c = curveNames[j];
			cd = algs.curves[c];
			var equal = true;
			for (var i = 0; i < ks.length; ++i) {
				var k = ks[i];
				if (cd[k] === undefined)
					continue;
				if (typeof (cd[k]) === 'object' &&
				    cd[k].equals !== undefined) {
					if (!cd[k].equals(curve[k])) {
						equal = false;
						break;
					}
				} else if (Buffer.isBuffer(cd[k])) {
					if (cd[k].toString('binary')
					    !== curve[k].toString('binary')) {
						equal = false;
						break;
					}
				} else {
					if (cd[k] !== curve[k]) {
						equal = false;
						break;
					}
				}
			}
			if (equal) {
				curveName = c;
				break;
			}
		}
	}
	return (curveName);
}

function readPkcs8ECDSAPrivate(der) {
	var curveName = readECDSACurve(der);
	assert.string(curveName, 'a known elliptic curve');

	der.readSequence(asn1.Ber.OctetString);
	der.readSequence();

	var version = readMPInt(der, 'version');
	assert.equal(version[0], 1, 'unknown version of ECDSA key');

	var d = der.readString(asn1.Ber.OctetString, true);
	var Q;

	if (der.peek() == 0xa0) {
		der.readSequence(0xa0);
		der._offset += der.length;
	}
	if (der.peek() == 0xa1) {
		der.readSequence(0xa1);
		Q = der.readString(asn1.Ber.BitString, true);
		Q = utils.ecNormalize(Q);
	}

	if (Q === undefined) {
		var pub = utils.publicFromPrivateECDSA(curveName, d);
		Q = pub.part.Q.data;
	}

	var key = {
		type: 'ecdsa',
		parts: [
			{ name: 'curve', data: Buffer.from(curveName) },
			{ name: 'Q', data: Q },
			{ name: 'd', data: d }
		]
	};

	return (new PrivateKey(key));
}

function readPkcs8ECDSAPublic(der) {
	var curveName = readECDSACurve(der);
	assert.string(curveName, 'a known elliptic curve');

	var Q = der.readString(asn1.Ber.BitString, true);
	Q = utils.ecNormalize(Q);

	var key = {
		type: 'ecdsa',
		parts: [
			{ name: 'curve', data: Buffer.from(curveName) },
			{ name: 'Q', data: Q }
		]
	};

	return (new Key(key));
}

function readPkcs8EdDSAPublic(der) {
	if (der.peek() === 0x00)
		der.readByte();

	var A = utils.readBitString(der);

	var key = {
		type: 'ed25519',
		parts: [
			{ name: 'A', data: utils.zeroPadToLength(A, 32) }
		]
	};

	return (new Key(key));
}

function readPkcs8X25519Public(der) {
	var A = utils.readBitString(der);

	var key = {
		type: 'curve25519',
		parts: [
			{ name: 'A', data: utils.zeroPadToLength(A, 32) }
		]
	};

	return (new Key(key));
}

function readPkcs8EdDSAPrivate(der) {
	if (der.peek() === 0x00)
		der.readByte();

	der.readSequence(asn1.Ber.OctetString);
	var k = der.readString(asn1.Ber.OctetString, true);
	k = utils.zeroPadToLength(k, 32);

	var A;
	if (der.peek() === asn1.Ber.BitString) {
		A = utils.readBitString(der);
		A = utils.zeroPadToLength(A, 32);
	} else {
		A = utils.calculateED25519Public(k);
	}

	var key = {
		type: 'ed25519',
		parts: [
			{ name: 'A', data: utils.zeroPadToLength(A, 32) },
			{ name: 'k', data: utils.zeroPadToLength(k, 32) }
		]
	};

	return (new PrivateKey(key));
}

function readPkcs8X25519Private(der) {
	if (der.peek() === 0x00)
		der.readByte();

	der.readSequence(asn1.Ber.OctetString);
	var k = der.readString(asn1.Ber.OctetString, true);
	k = utils.zeroPadToLength(k, 32);

	var A = utils.calculateX25519Public(k);

	var key = {
		type: 'curve25519',
		parts: [
			{ name: 'A', data: utils.zeroPadToLength(A, 32) },
			{ name: 'k', data: utils.zeroPadToLength(k, 32) }
		]
	};

	return (new PrivateKey(key));
}

function pkcs8ToBuffer(key) {
	var der = new asn1.BerWriter();
	writePkcs8(der, key);
	return (der.buffer);
}

function writePkcs8(der, key) {
	der.startSequence();

	if (PrivateKey.isPrivateKey(key)) {
		var sillyInt = Buffer.from([0]);
		der.writeBuffer(sillyInt, asn1.Ber.Integer);
	}

	der.startSequence();
	switch (key.type) {
	case 'rsa':
		der.writeOID('1.2.840.113549.1.1.1');
		if (PrivateKey.isPrivateKey(key))
			writePkcs8RSAPrivate(key, der);
		else
			writePkcs8RSAPublic(key, der);
		break;
	case 'dsa':
		der.writeOID('1.2.840.10040.4.1');
		if (PrivateKey.isPrivateKey(key))
			writePkcs8DSAPrivate(key, der);
		else
			writePkcs8DSAPublic(key, der);
		break;
	case 'ecdsa':
		der.writeOID('1.2.840.10045.2.1');
		if (PrivateKey.isPrivateKey(key))
			writePkcs8ECDSAPrivate(key, der);
		else
			writePkcs8ECDSAPublic(key, der);
		break;
	case 'ed25519':
		der.writeOID('1.3.101.112');
		if (PrivateKey.isPrivateKey(key))
			throw (new Error('Ed25519 private keys in pkcs8 ' +
			    'format are not supported'));
		writePkcs8EdDSAPublic(key, der);
		break;
	default:
		throw (new Error('Unsupported key type: ' + key.type));
	}

	der.endSequence();
}

function writePkcs8RSAPrivate(key, der) {
	der.writeNull();
	der.endSequence();

	der.startSequence(asn1.Ber.OctetString);
	der.startSequence();

	var version = Buffer.from([0]);
	der.writeBuffer(version, asn1.Ber.Integer);

	der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
	if (!key.part.dmodp || !key.part.dmodq)
		utils.addRSAMissing(key);
	der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);

	der.endSequence();
	der.endSequence();
}

function writePkcs8RSAPublic(key, der) {
	der.writeNull();
	der.endSequence();

	der.startSequence(asn1.Ber.BitString);
	der.writeByte(0x00);

	der.startSequence();
	der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
	der.endSequence();

	der.endSequence();
}

function writePkcs8DSAPrivate(key, der) {
	der.startSequence();
	der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
	der.endSequence();

	der.endSequence();

	der.startSequence(asn1.Ber.OctetString);
	der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
	der.endSequence();
}

function writePkcs8DSAPublic(key, der) {
	der.startSequence();
	der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
	der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
	der.endSequence();
	der.endSequence();

	der.startSequence(asn1.Ber.BitString);
	der.writeByte(0x00);
	der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
	der.endSequence();
}

function writeECDSACurve(key, der) {
	var curve = algs.curves[key.curve];
	if (curve.pkcs8oid) {
		/* This one has a name in pkcs#8, so just write the oid */
		der.writeOID(curve.pkcs8oid);

	} else {
		// ECParameters sequence
		der.startSequence();

		var version = Buffer.from([1]);
		der.writeBuffer(version, asn1.Ber.Integer);

		// FieldID sequence
		der.startSequence();
		der.writeOID('1.2.840.10045.1.1'); // prime-field
		der.writeBuffer(curve.p, asn1.Ber.Integer);
		der.endSequence();

		// Curve sequence
		der.startSequence();
		var a = curve.p;
		if (a[0] === 0x0)
			a = a.slice(1);
		der.writeBuffer(a, asn1.Ber.OctetString);
		der.writeBuffer(curve.b, asn1.Ber.OctetString);
		der.writeBuffer(curve.s, asn1.Ber.BitString);
		der.endSequence();

		der.writeBuffer(curve.G, asn1.Ber.OctetString);
		der.writeBuffer(curve.n, asn1.Ber.Integer);
		var h = curve.h;
		if (!h) {
			h = Buffer.from([1]);
		}
		der.writeBuffer(h, asn1.Ber.Integer);

		// ECParameters
		der.endSequence();
	}
}

function writePkcs8ECDSAPublic(key, der) {
	writeECDSACurve(key, der);
	der.endSequence();

	var Q = utils.ecNormalize(key.part.Q.data, true);
	der.writeBuffer(Q, asn1.Ber.BitString);
}

function writePkcs8ECDSAPrivate(key, der) {
	writeECDSACurve(key, der);
	der.endSequence();

	der.startSequence(asn1.Ber.OctetString);
	der.startSequence();

	var version = Buffer.from([1]);
	der.writeBuffer(version, asn1.Ber.Integer);

	der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);

	der.startSequence(0xa1);
	var Q = utils.ecNormalize(key.part.Q.data, true);
	der.writeBuffer(Q, asn1.Ber.BitString);
	der.endSequence();

	der.endSequence();
	der.endSequence();
}

function writePkcs8EdDSAPublic(key, der) {
	der.endSequence();

	utils.writeBitString(der, key.part.A.data);
}

function writePkcs8EdDSAPrivate(key, der) {
	der.endSequence();

	var k = utils.mpNormalize(key.part.k.data, true);
	der.startSequence(asn1.Ber.OctetString);
	der.writeBuffer(k, asn1.Ber.OctetString);
	der.endSequence();
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/putty.js":
/*!*************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/putty.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 Joyent, Inc.

module.exports = {
	read: read,
	write: write
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var rfc4253 = __webpack_require__(/*! ./rfc4253 */ "./node_modules/sshpk/lib/formats/rfc4253.js");
var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");

var errors = __webpack_require__(/*! ../errors */ "./node_modules/sshpk/lib/errors.js");

function read(buf, options) {
	var lines = buf.toString('ascii').split(/[\r\n]+/);
	var found = false;
	var parts;
	var si = 0;
	while (si < lines.length) {
		parts = splitHeader(lines[si++]);
		if (parts &&
		    parts[0].toLowerCase() === 'putty-user-key-file-2') {
			found = true;
			break;
		}
	}
	if (!found) {
		throw (new Error('No PuTTY format first line found'));
	}
	var alg = parts[1];

	parts = splitHeader(lines[si++]);
	assert.equal(parts[0].toLowerCase(), 'encryption');

	parts = splitHeader(lines[si++]);
	assert.equal(parts[0].toLowerCase(), 'comment');
	var comment = parts[1];

	parts = splitHeader(lines[si++]);
	assert.equal(parts[0].toLowerCase(), 'public-lines');
	var publicLines = parseInt(parts[1], 10);
	if (!isFinite(publicLines) || publicLines < 0 ||
	    publicLines > lines.length) {
		throw (new Error('Invalid public-lines count'));
	}

	var publicBuf = Buffer.from(
	    lines.slice(si, si + publicLines).join(''), 'base64');
	var keyType = rfc4253.algToKeyType(alg);
	var key = rfc4253.read(publicBuf);
	if (key.type !== keyType) {
		throw (new Error('Outer key algorithm mismatch'));
	}
	key.comment = comment;
	return (key);
}

function splitHeader(line) {
	var idx = line.indexOf(':');
	if (idx === -1)
		return (null);
	var header = line.slice(0, idx);
	++idx;
	while (line[idx] === ' ')
		++idx;
	var rest = line.slice(idx);
	return ([header, rest]);
}

function write(key, options) {
	assert.object(key);
	if (!Key.isKey(key))
		throw (new Error('Must be a public key'));

	var alg = rfc4253.keyTypeToAlg(key);
	var buf = rfc4253.write(key);
	var comment = key.comment || '';

	var b64 = buf.toString('base64');
	var lines = wrap(b64, 64);

	lines.unshift('Public-Lines: ' + lines.length);
	lines.unshift('Comment: ' + comment);
	lines.unshift('Encryption: none');
	lines.unshift('PuTTY-User-Key-File-2: ' + alg);

	return (Buffer.from(lines.join('\n') + '\n'));
}

function wrap(txt, len) {
	var lines = [];
	var pos = 0;
	while (pos < txt.length) {
		lines.push(txt.slice(pos, pos + 64));
		pos += 64;
	}
	return (lines);
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/rfc4253.js":
/*!***************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/rfc4253.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

module.exports = {
	read: read.bind(undefined, false, undefined),
	readType: read.bind(undefined, false),
	write: write,
	/* semi-private api, used by sshpk-agent */
	readPartial: read.bind(undefined, true),

	/* shared with ssh format */
	readInternal: read,
	keyTypeToAlg: keyTypeToAlg,
	algToKeyType: algToKeyType
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ../algs */ "./node_modules/sshpk/lib/algs.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");
var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");
var SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ "./node_modules/sshpk/lib/ssh-buffer.js");

function algToKeyType(alg) {
	assert.string(alg);
	if (alg === 'ssh-dss')
		return ('dsa');
	else if (alg === 'ssh-rsa')
		return ('rsa');
	else if (alg === 'ssh-ed25519')
		return ('ed25519');
	else if (alg === 'ssh-curve25519')
		return ('curve25519');
	else if (alg.match(/^ecdsa-sha2-/))
		return ('ecdsa');
	else
		throw (new Error('Unknown algorithm ' + alg));
}

function keyTypeToAlg(key) {
	assert.object(key);
	if (key.type === 'dsa')
		return ('ssh-dss');
	else if (key.type === 'rsa')
		return ('ssh-rsa');
	else if (key.type === 'ed25519')
		return ('ssh-ed25519');
	else if (key.type === 'curve25519')
		return ('ssh-curve25519');
	else if (key.type === 'ecdsa')
		return ('ecdsa-sha2-' + key.part.curve.data.toString());
	else
		throw (new Error('Unknown key type ' + key.type));
}

function read(partial, type, buf, options) {
	if (typeof (buf) === 'string')
		buf = Buffer.from(buf);
	assert.buffer(buf, 'buf');

	var key = {};

	var parts = key.parts = [];
	var sshbuf = new SSHBuffer({buffer: buf});

	var alg = sshbuf.readString();
	assert.ok(!sshbuf.atEnd(), 'key must have at least one part');

	key.type = algToKeyType(alg);

	var partCount = algs.info[key.type].parts.length;
	if (type && type === 'private')
		partCount = algs.privInfo[key.type].parts.length;

	while (!sshbuf.atEnd() && parts.length < partCount)
		parts.push(sshbuf.readPart());
	while (!partial && !sshbuf.atEnd())
		parts.push(sshbuf.readPart());

	assert.ok(parts.length >= 1,
	    'key must have at least one part');
	assert.ok(partial || sshbuf.atEnd(),
	    'leftover bytes at end of key');

	var Constructor = Key;
	var algInfo = algs.info[key.type];
	if (type === 'private' || algInfo.parts.length !== parts.length) {
		algInfo = algs.privInfo[key.type];
		Constructor = PrivateKey;
	}
	assert.strictEqual(algInfo.parts.length, parts.length);

	if (key.type === 'ecdsa') {
		var res = /^ecdsa-sha2-(.+)$/.exec(alg);
		assert.ok(res !== null);
		assert.strictEqual(res[1], parts[0].data.toString());
	}

	var normalized = true;
	for (var i = 0; i < algInfo.parts.length; ++i) {
		var p = parts[i];
		p.name = algInfo.parts[i];
		/*
		 * OpenSSH stores ed25519 "private" keys as seed + public key
		 * concat'd together (k followed by A). We want to keep them
		 * separate for other formats that don't do this.
		 */
		if (key.type === 'ed25519' && p.name === 'k')
			p.data = p.data.slice(0, 32);

		if (p.name !== 'curve' && algInfo.normalize !== false) {
			var nd;
			if (key.type === 'ed25519') {
				nd = utils.zeroPadToLength(p.data, 32);
			} else {
				nd = utils.mpNormalize(p.data);
			}
			if (nd.toString('binary') !==
			    p.data.toString('binary')) {
				p.data = nd;
				normalized = false;
			}
		}
	}

	if (normalized)
		key._rfc4253Cache = sshbuf.toBuffer();

	if (partial && typeof (partial) === 'object') {
		partial.remainder = sshbuf.remainder();
		partial.consumed = sshbuf._offset;
	}

	return (new Constructor(key));
}

function write(key, options) {
	assert.object(key);

	var alg = keyTypeToAlg(key);
	var i;

	var algInfo = algs.info[key.type];
	if (PrivateKey.isPrivateKey(key))
		algInfo = algs.privInfo[key.type];
	var parts = algInfo.parts;

	var buf = new SSHBuffer({});

	buf.writeString(alg);

	for (i = 0; i < parts.length; ++i) {
		var data = key.part[parts[i]].data;
		if (algInfo.normalize !== false) {
			if (key.type === 'ed25519')
				data = utils.zeroPadToLength(data, 32);
			else
				data = utils.mpNormalize(data);
		}
		if (key.type === 'ed25519' && parts[i] === 'k')
			data = Buffer.concat([data, key.part.A.data]);
		buf.writeBuffer(data);
	}

	return (buf.toBuffer());
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/ssh-private.js":
/*!*******************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/ssh-private.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

module.exports = {
	read: read,
	readSSHPrivate: readSSHPrivate,
	write: write
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var asn1 = __webpack_require__(/*! asn1 */ "./node_modules/asn1/lib/index.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ../algs */ "./node_modules/sshpk/lib/algs.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");

var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");
var pem = __webpack_require__(/*! ./pem */ "./node_modules/sshpk/lib/formats/pem.js");
var rfc4253 = __webpack_require__(/*! ./rfc4253 */ "./node_modules/sshpk/lib/formats/rfc4253.js");
var SSHBuffer = __webpack_require__(/*! ../ssh-buffer */ "./node_modules/sshpk/lib/ssh-buffer.js");
var errors = __webpack_require__(/*! ../errors */ "./node_modules/sshpk/lib/errors.js");

var bcrypt;

function read(buf, options) {
	return (pem.read(buf, options));
}

var MAGIC = 'openssh-key-v1';

function readSSHPrivate(type, buf, options) {
	buf = new SSHBuffer({buffer: buf});

	var magic = buf.readCString();
	assert.strictEqual(magic, MAGIC, 'bad magic string');

	var cipher = buf.readString();
	var kdf = buf.readString();
	var kdfOpts = buf.readBuffer();

	var nkeys = buf.readInt();
	if (nkeys !== 1) {
		throw (new Error('OpenSSH-format key file contains ' +
		    'multiple keys: this is unsupported.'));
	}

	var pubKey = buf.readBuffer();

	if (type === 'public') {
		assert.ok(buf.atEnd(), 'excess bytes left after key');
		return (rfc4253.read(pubKey));
	}

	var privKeyBlob = buf.readBuffer();
	assert.ok(buf.atEnd(), 'excess bytes left after key');

	var kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });
	switch (kdf) {
	case 'none':
		if (cipher !== 'none') {
			throw (new Error('OpenSSH-format key uses KDF "none" ' +
			     'but specifies a cipher other than "none"'));
		}
		break;
	case 'bcrypt':
		var salt = kdfOptsBuf.readBuffer();
		var rounds = kdfOptsBuf.readInt();
		var cinf = utils.opensshCipherInfo(cipher);
		if (bcrypt === undefined) {
			bcrypt = __webpack_require__(/*! bcrypt-pbkdf */ "./node_modules/bcrypt-pbkdf/index.js");
		}

		if (typeof (options.passphrase) === 'string') {
			options.passphrase = Buffer.from(options.passphrase,
			    'utf-8');
		}
		if (!Buffer.isBuffer(options.passphrase)) {
			throw (new errors.KeyEncryptedError(
			    options.filename, 'OpenSSH'));
		}

		var pass = new Uint8Array(options.passphrase);
		var salti = new Uint8Array(salt);
		/* Use the pbkdf to derive both the key and the IV. */
		var out = new Uint8Array(cinf.keySize + cinf.blockSize);
		var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,
		    out, out.length, rounds);
		if (res !== 0) {
			throw (new Error('bcrypt_pbkdf function returned ' +
			    'failure, parameters invalid'));
		}
		out = Buffer.from(out);
		var ckey = out.slice(0, cinf.keySize);
		var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
		var cipherStream = crypto.createDecipheriv(cinf.opensslName,
		    ckey, iv);
		cipherStream.setAutoPadding(false);
		var chunk, chunks = [];
		cipherStream.once('error', function (e) {
			if (e.toString().indexOf('bad decrypt') !== -1) {
				throw (new Error('Incorrect passphrase ' +
				    'supplied, could not decrypt key'));
			}
			throw (e);
		});
		cipherStream.write(privKeyBlob);
		cipherStream.end();
		while ((chunk = cipherStream.read()) !== null)
			chunks.push(chunk);
		privKeyBlob = Buffer.concat(chunks);
		break;
	default:
		throw (new Error(
		    'OpenSSH-format key uses unknown KDF "' + kdf + '"'));
	}

	buf = new SSHBuffer({buffer: privKeyBlob});

	var checkInt1 = buf.readInt();
	var checkInt2 = buf.readInt();
	if (checkInt1 !== checkInt2) {
		throw (new Error('Incorrect passphrase supplied, could not ' +
		    'decrypt key'));
	}

	var ret = {};
	var key = rfc4253.readInternal(ret, 'private', buf.remainder());

	buf.skip(ret.consumed);

	var comment = buf.readString();
	key.comment = comment;

	return (key);
}

function write(key, options) {
	var pubKey;
	if (PrivateKey.isPrivateKey(key))
		pubKey = key.toPublic();
	else
		pubKey = key;

	var cipher = 'none';
	var kdf = 'none';
	var kdfopts = Buffer.alloc(0);
	var cinf = { blockSize: 8 };
	var passphrase;
	if (options !== undefined) {
		passphrase = options.passphrase;
		if (typeof (passphrase) === 'string')
			passphrase = Buffer.from(passphrase, 'utf-8');
		if (passphrase !== undefined) {
			assert.buffer(passphrase, 'options.passphrase');
			assert.optionalString(options.cipher, 'options.cipher');
			cipher = options.cipher;
			if (cipher === undefined)
				cipher = 'aes128-ctr';
			cinf = utils.opensshCipherInfo(cipher);
			kdf = 'bcrypt';
		}
	}

	var privBuf;
	if (PrivateKey.isPrivateKey(key)) {
		privBuf = new SSHBuffer({});
		var checkInt = crypto.randomBytes(4).readUInt32BE(0);
		privBuf.writeInt(checkInt);
		privBuf.writeInt(checkInt);
		privBuf.write(key.toBuffer('rfc4253'));
		privBuf.writeString(key.comment || '');

		var n = 1;
		while (privBuf._offset % cinf.blockSize !== 0)
			privBuf.writeChar(n++);
		privBuf = privBuf.toBuffer();
	}

	switch (kdf) {
	case 'none':
		break;
	case 'bcrypt':
		var salt = crypto.randomBytes(16);
		var rounds = 16;
		var kdfssh = new SSHBuffer({});
		kdfssh.writeBuffer(salt);
		kdfssh.writeInt(rounds);
		kdfopts = kdfssh.toBuffer();

		if (bcrypt === undefined) {
			bcrypt = __webpack_require__(/*! bcrypt-pbkdf */ "./node_modules/bcrypt-pbkdf/index.js");
		}
		var pass = new Uint8Array(passphrase);
		var salti = new Uint8Array(salt);
		/* Use the pbkdf to derive both the key and the IV. */
		var out = new Uint8Array(cinf.keySize + cinf.blockSize);
		var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,
		    out, out.length, rounds);
		if (res !== 0) {
			throw (new Error('bcrypt_pbkdf function returned ' +
			    'failure, parameters invalid'));
		}
		out = Buffer.from(out);
		var ckey = out.slice(0, cinf.keySize);
		var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);

		var cipherStream = crypto.createCipheriv(cinf.opensslName,
		    ckey, iv);
		cipherStream.setAutoPadding(false);
		var chunk, chunks = [];
		cipherStream.once('error', function (e) {
			throw (e);
		});
		cipherStream.write(privBuf);
		cipherStream.end();
		while ((chunk = cipherStream.read()) !== null)
			chunks.push(chunk);
		privBuf = Buffer.concat(chunks);
		break;
	default:
		throw (new Error('Unsupported kdf ' + kdf));
	}

	var buf = new SSHBuffer({});

	buf.writeCString(MAGIC);
	buf.writeString(cipher);	/* cipher */
	buf.writeString(kdf);		/* kdf */
	buf.writeBuffer(kdfopts);	/* kdfoptions */

	buf.writeInt(1);		/* nkeys */
	buf.writeBuffer(pubKey.toBuffer('rfc4253'));

	if (privBuf)
		buf.writeBuffer(privBuf);

	buf = buf.toBuffer();

	var header;
	if (PrivateKey.isPrivateKey(key))
		header = 'OPENSSH PRIVATE KEY';
	else
		header = 'OPENSSH PUBLIC KEY';

	var tmp = buf.toString('base64');
	var len = tmp.length + (tmp.length / 70) +
	    18 + 16 + header.length*2 + 10;
	buf = Buffer.alloc(len);
	var o = 0;
	o += buf.write('-----BEGIN ' + header + '-----\n', o);
	for (var i = 0; i < tmp.length; ) {
		var limit = i + 70;
		if (limit > tmp.length)
			limit = tmp.length;
		o += buf.write(tmp.slice(i, limit), o);
		buf[o++] = 10;
		i = limit;
	}
	o += buf.write('-----END ' + header + '-----\n', o);

	return (buf.slice(0, o));
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/ssh.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/formats/ssh.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

module.exports = {
	read: read,
	write: write
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var rfc4253 = __webpack_require__(/*! ./rfc4253 */ "./node_modules/sshpk/lib/formats/rfc4253.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");
var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");

var sshpriv = __webpack_require__(/*! ./ssh-private */ "./node_modules/sshpk/lib/formats/ssh-private.js");

/*JSSTYLED*/
var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
/*JSSTYLED*/
var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;

function read(buf, options) {
	if (typeof (buf) !== 'string') {
		assert.buffer(buf, 'buf');
		buf = buf.toString('ascii');
	}

	var trimmed = buf.trim().replace(/[\\\r]/g, '');
	var m = trimmed.match(SSHKEY_RE);
	if (!m)
		m = trimmed.match(SSHKEY_RE2);
	assert.ok(m, 'key must match regex');

	var type = rfc4253.algToKeyType(m[1]);
	var kbuf = Buffer.from(m[2], 'base64');

	/*
	 * This is a bit tricky. If we managed to parse the key and locate the
	 * key comment with the regex, then do a non-partial read and assert
	 * that we have consumed all bytes. If we couldn't locate the key
	 * comment, though, there may be whitespace shenanigans going on that
	 * have conjoined the comment to the rest of the key. We do a partial
	 * read in this case to try to make the best out of a sorry situation.
	 */
	var key;
	var ret = {};
	if (m[4]) {
		try {
			key = rfc4253.read(kbuf);

		} catch (e) {
			m = trimmed.match(SSHKEY_RE2);
			assert.ok(m, 'key must match regex');
			kbuf = Buffer.from(m[2], 'base64');
			key = rfc4253.readInternal(ret, 'public', kbuf);
		}
	} else {
		key = rfc4253.readInternal(ret, 'public', kbuf);
	}

	assert.strictEqual(type, key.type);

	if (m[4] && m[4].length > 0) {
		key.comment = m[4];

	} else if (ret.consumed) {
		/*
		 * Now the magic: trying to recover the key comment when it's
		 * gotten conjoined to the key or otherwise shenanigan'd.
		 *
		 * Work out how much base64 we used, then drop all non-base64
		 * chars from the beginning up to this point in the the string.
		 * Then offset in this and try to make up for missing = chars.
		 */
		var data = m[2] + (m[3] ? m[3] : '');
		var realOffset = Math.ceil(ret.consumed / 3) * 4;
		data = data.slice(0, realOffset - 2). /*JSSTYLED*/
		    replace(/[^a-zA-Z0-9+\/=]/g, '') +
		    data.slice(realOffset - 2);

		var padding = ret.consumed % 3;
		if (padding > 0 &&
		    data.slice(realOffset - 1, realOffset) !== '=')
			realOffset--;
		while (data.slice(realOffset, realOffset + 1) === '=')
			realOffset++;

		/* Finally, grab what we think is the comment & clean it up. */
		var trailer = data.slice(realOffset);
		trailer = trailer.replace(/[\r\n]/g, ' ').
		    replace(/^\s+/, '');
		if (trailer.match(/^[a-zA-Z0-9]/))
			key.comment = trailer;
	}

	return (key);
}

function write(key, options) {
	assert.object(key);
	if (!Key.isKey(key))
		throw (new Error('Must be a public key'));

	var parts = [];
	var alg = rfc4253.keyTypeToAlg(key);
	parts.push(alg);

	var buf = rfc4253.write(key);
	parts.push(buf.toString('base64'));

	if (key.comment)
		parts.push(key.comment);

	return (Buffer.from(parts.join(' ')));
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/x509-pem.js":
/*!****************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/x509-pem.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2016 Joyent, Inc.

var x509 = __webpack_require__(/*! ./x509 */ "./node_modules/sshpk/lib/formats/x509.js");

module.exports = {
	read: read,
	verify: x509.verify,
	sign: x509.sign,
	write: write
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var asn1 = __webpack_require__(/*! asn1 */ "./node_modules/asn1/lib/index.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ../algs */ "./node_modules/sshpk/lib/algs.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");
var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");
var pem = __webpack_require__(/*! ./pem */ "./node_modules/sshpk/lib/formats/pem.js");
var Identity = __webpack_require__(/*! ../identity */ "./node_modules/sshpk/lib/identity.js");
var Signature = __webpack_require__(/*! ../signature */ "./node_modules/sshpk/lib/signature.js");
var Certificate = __webpack_require__(/*! ../certificate */ "./node_modules/sshpk/lib/certificate.js");

function read(buf, options) {
	if (typeof (buf) !== 'string') {
		assert.buffer(buf, 'buf');
		buf = buf.toString('ascii');
	}

	var lines = buf.trim().split(/[\r\n]+/g);

	var m;
	var si = -1;
	while (!m && si < lines.length) {
		m = lines[++si].match(/*JSSTYLED*/
		    /[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
	}
	assert.ok(m, 'invalid PEM header');

	var m2;
	var ei = lines.length;
	while (!m2 && ei > 0) {
		m2 = lines[--ei].match(/*JSSTYLED*/
		    /[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
	}
	assert.ok(m2, 'invalid PEM footer');

	lines = lines.slice(si, ei + 1);

	var headers = {};
	while (true) {
		lines = lines.slice(1);
		m = lines[0].match(/*JSSTYLED*/
		    /^([A-Za-z0-9-]+): (.+)$/);
		if (!m)
			break;
		headers[m[1].toLowerCase()] = m[2];
	}

	/* Chop off the first and last lines */
	lines = lines.slice(0, -1).join('');
	buf = Buffer.from(lines, 'base64');

	return (x509.read(buf, options));
}

function write(cert, options) {
	var dbuf = x509.write(cert, options);

	var header = 'CERTIFICATE';
	var tmp = dbuf.toString('base64');
	var len = tmp.length + (tmp.length / 64) +
	    18 + 16 + header.length*2 + 10;
	var buf = Buffer.alloc(len);
	var o = 0;
	o += buf.write('-----BEGIN ' + header + '-----\n', o);
	for (var i = 0; i < tmp.length; ) {
		var limit = i + 64;
		if (limit > tmp.length)
			limit = tmp.length;
		o += buf.write(tmp.slice(i, limit), o);
		buf[o++] = 10;
		i = limit;
	}
	o += buf.write('-----END ' + header + '-----\n', o);

	return (buf.slice(0, o));
}


/***/ }),

/***/ "./node_modules/sshpk/lib/formats/x509.js":
/*!************************************************!*\
  !*** ./node_modules/sshpk/lib/formats/x509.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 Joyent, Inc.

module.exports = {
	read: read,
	verify: verify,
	sign: sign,
	signAsync: signAsync,
	write: write
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var asn1 = __webpack_require__(/*! asn1 */ "./node_modules/asn1/lib/index.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ../algs */ "./node_modules/sshpk/lib/algs.js");
var utils = __webpack_require__(/*! ../utils */ "./node_modules/sshpk/lib/utils.js");
var Key = __webpack_require__(/*! ../key */ "./node_modules/sshpk/lib/key.js");
var PrivateKey = __webpack_require__(/*! ../private-key */ "./node_modules/sshpk/lib/private-key.js");
var pem = __webpack_require__(/*! ./pem */ "./node_modules/sshpk/lib/formats/pem.js");
var Identity = __webpack_require__(/*! ../identity */ "./node_modules/sshpk/lib/identity.js");
var Signature = __webpack_require__(/*! ../signature */ "./node_modules/sshpk/lib/signature.js");
var Certificate = __webpack_require__(/*! ../certificate */ "./node_modules/sshpk/lib/certificate.js");
var pkcs8 = __webpack_require__(/*! ./pkcs8 */ "./node_modules/sshpk/lib/formats/pkcs8.js");

/*
 * This file is based on RFC5280 (X.509).
 */

/* Helper to read in a single mpint */
function readMPInt(der, nm) {
	assert.strictEqual(der.peek(), asn1.Ber.Integer,
	    nm + ' is not an Integer');
	return (utils.mpNormalize(der.readString(asn1.Ber.Integer, true)));
}

function verify(cert, key) {
	var sig = cert.signatures.x509;
	assert.object(sig, 'x509 signature');

	var algParts = sig.algo.split('-');
	if (algParts[0] !== key.type)
		return (false);

	var blob = sig.cache;
	if (blob === undefined) {
		var der = new asn1.BerWriter();
		writeTBSCert(cert, der);
		blob = der.buffer;
	}

	var verifier = key.createVerify(algParts[1]);
	verifier.write(blob);
	return (verifier.verify(sig.signature));
}

function Local(i) {
	return (asn1.Ber.Context | asn1.Ber.Constructor | i);
}

function Context(i) {
	return (asn1.Ber.Context | i);
}

var SIGN_ALGS = {
	'rsa-md5': '1.2.840.113549.1.1.4',
	'rsa-sha1': '1.2.840.113549.1.1.5',
	'rsa-sha256': '1.2.840.113549.1.1.11',
	'rsa-sha384': '1.2.840.113549.1.1.12',
	'rsa-sha512': '1.2.840.113549.1.1.13',
	'dsa-sha1': '1.2.840.10040.4.3',
	'dsa-sha256': '2.16.840.1.101.3.4.3.2',
	'ecdsa-sha1': '1.2.840.10045.4.1',
	'ecdsa-sha256': '1.2.840.10045.4.3.2',
	'ecdsa-sha384': '1.2.840.10045.4.3.3',
	'ecdsa-sha512': '1.2.840.10045.4.3.4',
	'ed25519-sha512': '1.3.101.112'
};
Object.keys(SIGN_ALGS).forEach(function (k) {
	SIGN_ALGS[SIGN_ALGS[k]] = k;
});
SIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';
SIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';

var EXTS = {
	'issuerKeyId': '2.5.29.35',
	'altName': '2.5.29.17',
	'basicConstraints': '2.5.29.19',
	'keyUsage': '2.5.29.15',
	'extKeyUsage': '2.5.29.37'
};

function read(buf, options) {
	if (typeof (buf) === 'string') {
		buf = Buffer.from(buf, 'binary');
	}
	assert.buffer(buf, 'buf');

	var der = new asn1.BerReader(buf);

	der.readSequence();
	if (Math.abs(der.length - der.remain) > 1) {
		throw (new Error('DER sequence does not contain whole byte ' +
		    'stream'));
	}

	var tbsStart = der.offset;
	der.readSequence();
	var sigOffset = der.offset + der.length;
	var tbsEnd = sigOffset;

	if (der.peek() === Local(0)) {
		der.readSequence(Local(0));
		var version = der.readInt();
		assert.ok(version <= 3,
		    'only x.509 versions up to v3 supported');
	}

	var cert = {};
	cert.signatures = {};
	var sig = (cert.signatures.x509 = {});
	sig.extras = {};

	cert.serial = readMPInt(der, 'serial');

	der.readSequence();
	var after = der.offset + der.length;
	var certAlgOid = der.readOID();
	var certAlg = SIGN_ALGS[certAlgOid];
	if (certAlg === undefined)
		throw (new Error('unknown signature algorithm ' + certAlgOid));

	der._offset = after;
	cert.issuer = Identity.parseAsn1(der);

	der.readSequence();
	cert.validFrom = readDate(der);
	cert.validUntil = readDate(der);

	cert.subjects = [Identity.parseAsn1(der)];

	der.readSequence();
	after = der.offset + der.length;
	cert.subjectKey = pkcs8.readPkcs8(undefined, 'public', der);
	der._offset = after;

	/* issuerUniqueID */
	if (der.peek() === Local(1)) {
		der.readSequence(Local(1));
		sig.extras.issuerUniqueID =
		    buf.slice(der.offset, der.offset + der.length);
		der._offset += der.length;
	}

	/* subjectUniqueID */
	if (der.peek() === Local(2)) {
		der.readSequence(Local(2));
		sig.extras.subjectUniqueID =
		    buf.slice(der.offset, der.offset + der.length);
		der._offset += der.length;
	}

	/* extensions */
	if (der.peek() === Local(3)) {
		der.readSequence(Local(3));
		var extEnd = der.offset + der.length;
		der.readSequence();

		while (der.offset < extEnd)
			readExtension(cert, buf, der);

		assert.strictEqual(der.offset, extEnd);
	}

	assert.strictEqual(der.offset, sigOffset);

	der.readSequence();
	after = der.offset + der.length;
	var sigAlgOid = der.readOID();
	var sigAlg = SIGN_ALGS[sigAlgOid];
	if (sigAlg === undefined)
		throw (new Error('unknown signature algorithm ' + sigAlgOid));
	der._offset = after;

	var sigData = der.readString(asn1.Ber.BitString, true);
	if (sigData[0] === 0)
		sigData = sigData.slice(1);
	var algParts = sigAlg.split('-');

	sig.signature = Signature.parse(sigData, algParts[0], 'asn1');
	sig.signature.hashAlgorithm = algParts[1];
	sig.algo = sigAlg;
	sig.cache = buf.slice(tbsStart, tbsEnd);

	return (new Certificate(cert));
}

function readDate(der) {
	if (der.peek() === asn1.Ber.UTCTime) {
		return (utcTimeToDate(der.readString(asn1.Ber.UTCTime)));
	} else if (der.peek() === asn1.Ber.GeneralizedTime) {
		return (gTimeToDate(der.readString(asn1.Ber.GeneralizedTime)));
	} else {
		throw (new Error('Unsupported date format'));
	}
}

function writeDate(der, date) {
	if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
		der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);
	} else {
		der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);
	}
}

/* RFC5280, section 4.2.1.6 (GeneralName type) */
var ALTNAME = {
	OtherName: Local(0),
	RFC822Name: Context(1),
	DNSName: Context(2),
	X400Address: Local(3),
	DirectoryName: Local(4),
	EDIPartyName: Local(5),
	URI: Context(6),
	IPAddress: Context(7),
	OID: Context(8)
};

/* RFC5280, section 4.2.1.12 (KeyPurposeId) */
var EXTPURPOSE = {
	'serverAuth': '1.3.6.1.5.5.7.3.1',
	'clientAuth': '1.3.6.1.5.5.7.3.2',
	'codeSigning': '1.3.6.1.5.5.7.3.3',

	/* See https://github.com/joyent/oid-docs/blob/master/root.md */
	'joyentDocker': '1.3.6.1.4.1.38678.1.4.1',
	'joyentCmon': '1.3.6.1.4.1.38678.1.4.2'
};
var EXTPURPOSE_REV = {};
Object.keys(EXTPURPOSE).forEach(function (k) {
	EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
});

var KEYUSEBITS = [
	'signature', 'identity', 'keyEncryption',
	'encryption', 'keyAgreement', 'ca', 'crl'
];

function readExtension(cert, buf, der) {
	der.readSequence();
	var after = der.offset + der.length;
	var extId = der.readOID();
	var id;
	var sig = cert.signatures.x509;
	if (!sig.extras.exts)
		sig.extras.exts = [];

	var critical;
	if (der.peek() === asn1.Ber.Boolean)
		critical = der.readBoolean();

	switch (extId) {
	case (EXTS.basicConstraints):
		der.readSequence(asn1.Ber.OctetString);
		der.readSequence();
		var bcEnd = der.offset + der.length;
		var ca = false;
		if (der.peek() === asn1.Ber.Boolean)
			ca = der.readBoolean();
		if (cert.purposes === undefined)
			cert.purposes = [];
		if (ca === true)
			cert.purposes.push('ca');
		var bc = { oid: extId, critical: critical };
		if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)
			bc.pathLen = der.readInt();
		sig.extras.exts.push(bc);
		break;
	case (EXTS.extKeyUsage):
		der.readSequence(asn1.Ber.OctetString);
		der.readSequence();
		if (cert.purposes === undefined)
			cert.purposes = [];
		var ekEnd = der.offset + der.length;
		while (der.offset < ekEnd) {
			var oid = der.readOID();
			cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
		}
		/*
		 * This is a bit of a hack: in the case where we have a cert
		 * that's only allowed to do serverAuth or clientAuth (and not
		 * the other), we want to make sure all our Subjects are of
		 * the right type. But we already parsed our Subjects and
		 * decided if they were hosts or users earlier (since it appears
		 * first in the cert).
		 *
		 * So we go through and mutate them into the right kind here if
		 * it doesn't match. This might not be hugely beneficial, as it
		 * seems that single-purpose certs are not often seen in the
		 * wild.
		 */
		if (cert.purposes.indexOf('serverAuth') !== -1 &&
		    cert.purposes.indexOf('clientAuth') === -1) {
			cert.subjects.forEach(function (ide) {
				if (ide.type !== 'host') {
					ide.type = 'host';
					ide.hostname = ide.uid ||
					    ide.email ||
					    ide.components[0].value;
				}
			});
		} else if (cert.purposes.indexOf('clientAuth') !== -1 &&
		    cert.purposes.indexOf('serverAuth') === -1) {
			cert.subjects.forEach(function (ide) {
				if (ide.type !== 'user') {
					ide.type = 'user';
					ide.uid = ide.hostname ||
					    ide.email ||
					    ide.components[0].value;
				}
			});
		}
		sig.extras.exts.push({ oid: extId, critical: critical });
		break;
	case (EXTS.keyUsage):
		der.readSequence(asn1.Ber.OctetString);
		var bits = der.readString(asn1.Ber.BitString, true);
		var setBits = readBitField(bits, KEYUSEBITS);
		setBits.forEach(function (bit) {
			if (cert.purposes === undefined)
				cert.purposes = [];
			if (cert.purposes.indexOf(bit) === -1)
				cert.purposes.push(bit);
		});
		sig.extras.exts.push({ oid: extId, critical: critical,
		    bits: bits });
		break;
	case (EXTS.altName):
		der.readSequence(asn1.Ber.OctetString);
		der.readSequence();
		var aeEnd = der.offset + der.length;
		while (der.offset < aeEnd) {
			switch (der.peek()) {
			case ALTNAME.OtherName:
			case ALTNAME.EDIPartyName:
				der.readSequence();
				der._offset += der.length;
				break;
			case ALTNAME.OID:
				der.readOID(ALTNAME.OID);
				break;
			case ALTNAME.RFC822Name:
				/* RFC822 specifies email addresses */
				var email = der.readString(ALTNAME.RFC822Name);
				id = Identity.forEmail(email);
				if (!cert.subjects[0].equals(id))
					cert.subjects.push(id);
				break;
			case ALTNAME.DirectoryName:
				der.readSequence(ALTNAME.DirectoryName);
				id = Identity.parseAsn1(der);
				if (!cert.subjects[0].equals(id))
					cert.subjects.push(id);
				break;
			case ALTNAME.DNSName:
				var host = der.readString(
				    ALTNAME.DNSName);
				id = Identity.forHost(host);
				if (!cert.subjects[0].equals(id))
					cert.subjects.push(id);
				break;
			default:
				der.readString(der.peek());
				break;
			}
		}
		sig.extras.exts.push({ oid: extId, critical: critical });
		break;
	default:
		sig.extras.exts.push({
			oid: extId,
			critical: critical,
			data: der.readString(asn1.Ber.OctetString, true)
		});
		break;
	}

	der._offset = after;
}

var UTCTIME_RE =
    /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
function utcTimeToDate(t) {
	var m = t.match(UTCTIME_RE);
	assert.ok(m, 'timestamps must be in UTC');
	var d = new Date();

	var thisYear = d.getUTCFullYear();
	var century = Math.floor(thisYear / 100) * 100;

	var year = parseInt(m[1], 10);
	if (thisYear % 100 < 50 && year >= 60)
		year += (century - 1);
	else
		year += century;
	d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
	d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
	if (m[6] && m[6].length > 0)
		d.setUTCSeconds(parseInt(m[6], 10));
	return (d);
}

var GTIME_RE =
    /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
function gTimeToDate(t) {
	var m = t.match(GTIME_RE);
	assert.ok(m);
	var d = new Date();

	d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1,
	    parseInt(m[3], 10));
	d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
	if (m[6] && m[6].length > 0)
		d.setUTCSeconds(parseInt(m[6], 10));
	return (d);
}

function zeroPad(n, m) {
	if (m === undefined)
		m = 2;
	var s = '' + n;
	while (s.length < m)
		s = '0' + s;
	return (s);
}

function dateToUTCTime(d) {
	var s = '';
	s += zeroPad(d.getUTCFullYear() % 100);
	s += zeroPad(d.getUTCMonth() + 1);
	s += zeroPad(d.getUTCDate());
	s += zeroPad(d.getUTCHours());
	s += zeroPad(d.getUTCMinutes());
	s += zeroPad(d.getUTCSeconds());
	s += 'Z';
	return (s);
}

function dateToGTime(d) {
	var s = '';
	s += zeroPad(d.getUTCFullYear(), 4);
	s += zeroPad(d.getUTCMonth() + 1);
	s += zeroPad(d.getUTCDate());
	s += zeroPad(d.getUTCHours());
	s += zeroPad(d.getUTCMinutes());
	s += zeroPad(d.getUTCSeconds());
	s += 'Z';
	return (s);
}

function sign(cert, key) {
	if (cert.signatures.x509 === undefined)
		cert.signatures.x509 = {};
	var sig = cert.signatures.x509;

	sig.algo = key.type + '-' + key.defaultHashAlgorithm();
	if (SIGN_ALGS[sig.algo] === undefined)
		return (false);

	var der = new asn1.BerWriter();
	writeTBSCert(cert, der);
	var blob = der.buffer;
	sig.cache = blob;

	var signer = key.createSign();
	signer.write(blob);
	cert.signatures.x509.signature = signer.sign();

	return (true);
}

function signAsync(cert, signer, done) {
	if (cert.signatures.x509 === undefined)
		cert.signatures.x509 = {};
	var sig = cert.signatures.x509;

	var der = new asn1.BerWriter();
	writeTBSCert(cert, der);
	var blob = der.buffer;
	sig.cache = blob;

	signer(blob, function (err, signature) {
		if (err) {
			done(err);
			return;
		}
		sig.algo = signature.type + '-' + signature.hashAlgorithm;
		if (SIGN_ALGS[sig.algo] === undefined) {
			done(new Error('Invalid signing algorithm "' +
			    sig.algo + '"'));
			return;
		}
		sig.signature = signature;
		done();
	});
}

function write(cert, options) {
	var sig = cert.signatures.x509;
	assert.object(sig, 'x509 signature');

	var der = new asn1.BerWriter();
	der.startSequence();
	if (sig.cache) {
		der._ensure(sig.cache.length);
		sig.cache.copy(der._buf, der._offset);
		der._offset += sig.cache.length;
	} else {
		writeTBSCert(cert, der);
	}

	der.startSequence();
	der.writeOID(SIGN_ALGS[sig.algo]);
	if (sig.algo.match(/^rsa-/))
		der.writeNull();
	der.endSequence();

	var sigData = sig.signature.toBuffer('asn1');
	var data = Buffer.alloc(sigData.length + 1);
	data[0] = 0;
	sigData.copy(data, 1);
	der.writeBuffer(data, asn1.Ber.BitString);
	der.endSequence();

	return (der.buffer);
}

function writeTBSCert(cert, der) {
	var sig = cert.signatures.x509;
	assert.object(sig, 'x509 signature');

	der.startSequence();

	der.startSequence(Local(0));
	der.writeInt(2);
	der.endSequence();

	der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);

	der.startSequence();
	der.writeOID(SIGN_ALGS[sig.algo]);
	if (sig.algo.match(/^rsa-/))
		der.writeNull();
	der.endSequence();

	cert.issuer.toAsn1(der);

	der.startSequence();
	writeDate(der, cert.validFrom);
	writeDate(der, cert.validUntil);
	der.endSequence();

	var subject = cert.subjects[0];
	var altNames = cert.subjects.slice(1);
	subject.toAsn1(der);

	pkcs8.writePkcs8(der, cert.subjectKey);

	if (sig.extras && sig.extras.issuerUniqueID) {
		der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
	}

	if (sig.extras && sig.extras.subjectUniqueID) {
		der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
	}

	if (altNames.length > 0 || subject.type === 'host' ||
	    (cert.purposes !== undefined && cert.purposes.length > 0) ||
	    (sig.extras && sig.extras.exts)) {
		der.startSequence(Local(3));
		der.startSequence();

		var exts = [];
		if (cert.purposes !== undefined && cert.purposes.length > 0) {
			exts.push({
				oid: EXTS.basicConstraints,
				critical: true
			});
			exts.push({
				oid: EXTS.keyUsage,
				critical: true
			});
			exts.push({
				oid: EXTS.extKeyUsage,
				critical: true
			});
		}
		exts.push({ oid: EXTS.altName });
		if (sig.extras && sig.extras.exts)
			exts = sig.extras.exts;

		for (var i = 0; i < exts.length; ++i) {
			der.startSequence();
			der.writeOID(exts[i].oid);

			if (exts[i].critical !== undefined)
				der.writeBoolean(exts[i].critical);

			if (exts[i].oid === EXTS.altName) {
				der.startSequence(asn1.Ber.OctetString);
				der.startSequence();
				if (subject.type === 'host') {
					der.writeString(subject.hostname,
					    Context(2));
				}
				for (var j = 0; j < altNames.length; ++j) {
					if (altNames[j].type === 'host') {
						der.writeString(
						    altNames[j].hostname,
						    ALTNAME.DNSName);
					} else if (altNames[j].type ===
					    'email') {
						der.writeString(
						    altNames[j].email,
						    ALTNAME.RFC822Name);
					} else {
						/*
						 * Encode anything else as a
						 * DN style name for now.
						 */
						der.startSequence(
						    ALTNAME.DirectoryName);
						altNames[j].toAsn1(der);
						der.endSequence();
					}
				}
				der.endSequence();
				der.endSequence();
			} else if (exts[i].oid === EXTS.basicConstraints) {
				der.startSequence(asn1.Ber.OctetString);
				der.startSequence();
				var ca = (cert.purposes.indexOf('ca') !== -1);
				var pathLen = exts[i].pathLen;
				der.writeBoolean(ca);
				if (pathLen !== undefined)
					der.writeInt(pathLen);
				der.endSequence();
				der.endSequence();
			} else if (exts[i].oid === EXTS.extKeyUsage) {
				der.startSequence(asn1.Ber.OctetString);
				der.startSequence();
				cert.purposes.forEach(function (purpose) {
					if (purpose === 'ca')
						return;
					if (KEYUSEBITS.indexOf(purpose) !== -1)
						return;
					var oid = purpose;
					if (EXTPURPOSE[purpose] !== undefined)
						oid = EXTPURPOSE[purpose];
					der.writeOID(oid);
				});
				der.endSequence();
				der.endSequence();
			} else if (exts[i].oid === EXTS.keyUsage) {
				der.startSequence(asn1.Ber.OctetString);
				/*
				 * If we parsed this certificate from a byte
				 * stream (i.e. we didn't generate it in sshpk)
				 * then we'll have a ".bits" property on the
				 * ext with the original raw byte contents.
				 *
				 * If we have this, use it here instead of
				 * regenerating it. This guarantees we output
				 * the same data we parsed, so signatures still
				 * validate.
				 */
				if (exts[i].bits !== undefined) {
					der.writeBuffer(exts[i].bits,
					    asn1.Ber.BitString);
				} else {
					var bits = writeBitField(cert.purposes,
					    KEYUSEBITS);
					der.writeBuffer(bits,
					    asn1.Ber.BitString);
				}
				der.endSequence();
			} else {
				der.writeBuffer(exts[i].data,
				    asn1.Ber.OctetString);
			}

			der.endSequence();
		}

		der.endSequence();
		der.endSequence();
	}

	der.endSequence();
}

/*
 * Reads an ASN.1 BER bitfield out of the Buffer produced by doing
 * `BerReader#readString(asn1.Ber.BitString)`. That function gives us the raw
 * contents of the BitString tag, which is a count of unused bits followed by
 * the bits as a right-padded byte string.
 *
 * `bits` is the Buffer, `bitIndex` should contain an array of string names
 * for the bits in the string, ordered starting with bit #0 in the ASN.1 spec.
 *
 * Returns an array of Strings, the names of the bits that were set to 1.
 */
function readBitField(bits, bitIndex) {
	var bitLen = 8 * (bits.length - 1) - bits[0];
	var setBits = {};
	for (var i = 0; i < bitLen; ++i) {
		var byteN = 1 + Math.floor(i / 8);
		var bit = 7 - (i % 8);
		var mask = 1 << bit;
		var bitVal = ((bits[byteN] & mask) !== 0);
		var name = bitIndex[i];
		if (bitVal && typeof (name) === 'string') {
			setBits[name] = true;
		}
	}
	return (Object.keys(setBits));
}

/*
 * `setBits` is an array of strings, containing the names for each bit that
 * sould be set to 1. `bitIndex` is same as in `readBitField()`.
 *
 * Returns a Buffer, ready to be written out with `BerWriter#writeString()`.
 */
function writeBitField(setBits, bitIndex) {
	var bitLen = bitIndex.length;
	var blen = Math.ceil(bitLen / 8);
	var unused = blen * 8 - bitLen;
	var bits = Buffer.alloc(1 + blen); // zero-filled
	bits[0] = unused;
	for (var i = 0; i < bitLen; ++i) {
		var byteN = 1 + Math.floor(i / 8);
		var bit = 7 - (i % 8);
		var mask = 1 << bit;
		var name = bitIndex[i];
		if (name === undefined)
			continue;
		var bitVal = (setBits.indexOf(name) !== -1);
		if (bitVal) {
			bits[byteN] |= mask;
		}
	}
	return (bits);
}


/***/ }),

/***/ "./node_modules/sshpk/lib/identity.js":
/*!********************************************!*\
  !*** ./node_modules/sshpk/lib/identity.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 Joyent, Inc.

module.exports = Identity;

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var algs = __webpack_require__(/*! ./algs */ "./node_modules/sshpk/lib/algs.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var Fingerprint = __webpack_require__(/*! ./fingerprint */ "./node_modules/sshpk/lib/fingerprint.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/sshpk/lib/signature.js");
var errs = __webpack_require__(/*! ./errors */ "./node_modules/sshpk/lib/errors.js");
var util = __webpack_require__(/*! util */ "util");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/sshpk/lib/utils.js");
var asn1 = __webpack_require__(/*! asn1 */ "./node_modules/asn1/lib/index.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;

/*JSSTYLED*/
var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;

var oids = {};
oids.cn = '2.5.4.3';
oids.o = '2.5.4.10';
oids.ou = '2.5.4.11';
oids.l = '2.5.4.7';
oids.s = '2.5.4.8';
oids.c = '2.5.4.6';
oids.sn = '2.5.4.4';
oids.postalCode = '2.5.4.17';
oids.serialNumber = '2.5.4.5';
oids.street = '2.5.4.9';
oids.x500UniqueIdentifier = '2.5.4.45';
oids.role = '2.5.4.72';
oids.telephoneNumber = '2.5.4.20';
oids.description = '2.5.4.13';
oids.dc = '0.9.2342.19200300.100.1.25';
oids.uid = '0.9.2342.19200300.100.1.1';
oids.mail = '0.9.2342.19200300.100.1.3';
oids.title = '2.5.4.12';
oids.gn = '2.5.4.42';
oids.initials = '2.5.4.43';
oids.pseudonym = '2.5.4.65';
oids.emailAddress = '1.2.840.113549.1.9.1';

var unoids = {};
Object.keys(oids).forEach(function (k) {
	unoids[oids[k]] = k;
});

function Identity(opts) {
	var self = this;
	assert.object(opts, 'options');
	assert.arrayOfObject(opts.components, 'options.components');
	this.components = opts.components;
	this.componentLookup = {};
	this.components.forEach(function (c) {
		if (c.name && !c.oid)
			c.oid = oids[c.name];
		if (c.oid && !c.name)
			c.name = unoids[c.oid];
		if (self.componentLookup[c.name] === undefined)
			self.componentLookup[c.name] = [];
		self.componentLookup[c.name].push(c);
	});
	if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
		this.cn = this.componentLookup.cn[0].value;
	}
	assert.optionalString(opts.type, 'options.type');
	if (opts.type === undefined) {
		if (this.components.length === 1 &&
		    this.componentLookup.cn &&
		    this.componentLookup.cn.length === 1 &&
		    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
			this.type = 'host';
			this.hostname = this.componentLookup.cn[0].value;

		} else if (this.componentLookup.dc &&
		    this.components.length === this.componentLookup.dc.length) {
			this.type = 'host';
			this.hostname = this.componentLookup.dc.map(
			    function (c) {
				return (c.value);
			}).join('.');

		} else if (this.componentLookup.uid &&
		    this.components.length ===
		    this.componentLookup.uid.length) {
			this.type = 'user';
			this.uid = this.componentLookup.uid[0].value;

		} else if (this.componentLookup.cn &&
		    this.componentLookup.cn.length === 1 &&
		    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
			this.type = 'host';
			this.hostname = this.componentLookup.cn[0].value;

		} else if (this.componentLookup.uid &&
		    this.componentLookup.uid.length === 1) {
			this.type = 'user';
			this.uid = this.componentLookup.uid[0].value;

		} else if (this.componentLookup.mail &&
		    this.componentLookup.mail.length === 1) {
			this.type = 'email';
			this.email = this.componentLookup.mail[0].value;

		} else if (this.componentLookup.cn &&
		    this.componentLookup.cn.length === 1) {
			this.type = 'user';
			this.uid = this.componentLookup.cn[0].value;

		} else {
			this.type = 'unknown';
		}
	} else {
		this.type = opts.type;
		if (this.type === 'host')
			this.hostname = opts.hostname;
		else if (this.type === 'user')
			this.uid = opts.uid;
		else if (this.type === 'email')
			this.email = opts.email;
		else
			throw (new Error('Unknown type ' + this.type));
	}
}

Identity.prototype.toString = function () {
	return (this.components.map(function (c) {
		var n = c.name.toUpperCase();
		/*JSSTYLED*/
		n = n.replace(/=/g, '\\=');
		var v = c.value;
		/*JSSTYLED*/
		v = v.replace(/,/g, '\\,');
		return (n + '=' + v);
	}).join(', '));
};

Identity.prototype.get = function (name, asArray) {
	assert.string(name, 'name');
	var arr = this.componentLookup[name];
	if (arr === undefined || arr.length === 0)
		return (undefined);
	if (!asArray && arr.length > 1)
		throw (new Error('Multiple values for attribute ' + name));
	if (!asArray)
		return (arr[0].value);
	return (arr.map(function (c) {
		return (c.value);
	}));
};

Identity.prototype.toArray = function (idx) {
	return (this.components.map(function (c) {
		return ({
			name: c.name,
			value: c.value
		});
	}));
};

/*
 * These are from X.680 -- PrintableString allowed chars are in section 37.4
 * table 8. Spec for IA5Strings is "1,6 + SPACE + DEL" where 1 refers to
 * ISO IR #001 (standard ASCII control characters) and 6 refers to ISO IR #006
 * (the basic ASCII character set).
 */
/* JSSTYLED */
var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
/* JSSTYLED */
var NOT_IA5 = /[^\x00-\x7f]/;

Identity.prototype.toAsn1 = function (der, tag) {
	der.startSequence(tag);
	this.components.forEach(function (c) {
		der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
		der.startSequence();
		der.writeOID(c.oid);
		/*
		 * If we fit in a PrintableString, use that. Otherwise use an
		 * IA5String or UTF8String.
		 *
		 * If this identity was parsed from a DN, use the ASN.1 types
		 * from the original representation (otherwise this might not
		 * be a full match for the original in some validators).
		 */
		if (c.asn1type === asn1.Ber.Utf8String ||
		    c.value.match(NOT_IA5)) {
			var v = Buffer.from(c.value, 'utf8');
			der.writeBuffer(v, asn1.Ber.Utf8String);

		} else if (c.asn1type === asn1.Ber.IA5String ||
		    c.value.match(NOT_PRINTABLE)) {
			der.writeString(c.value, asn1.Ber.IA5String);

		} else {
			var type = asn1.Ber.PrintableString;
			if (c.asn1type !== undefined)
				type = c.asn1type;
			der.writeString(c.value, type);
		}
		der.endSequence();
		der.endSequence();
	});
	der.endSequence();
};

function globMatch(a, b) {
	if (a === '**' || b === '**')
		return (true);
	var aParts = a.split('.');
	var bParts = b.split('.');
	if (aParts.length !== bParts.length)
		return (false);
	for (var i = 0; i < aParts.length; ++i) {
		if (aParts[i] === '*' || bParts[i] === '*')
			continue;
		if (aParts[i] !== bParts[i])
			return (false);
	}
	return (true);
}

Identity.prototype.equals = function (other) {
	if (!Identity.isIdentity(other, [1, 0]))
		return (false);
	if (other.components.length !== this.components.length)
		return (false);
	for (var i = 0; i < this.components.length; ++i) {
		if (this.components[i].oid !== other.components[i].oid)
			return (false);
		if (!globMatch(this.components[i].value,
		    other.components[i].value)) {
			return (false);
		}
	}
	return (true);
};

Identity.forHost = function (hostname) {
	assert.string(hostname, 'hostname');
	return (new Identity({
		type: 'host',
		hostname: hostname,
		components: [ { name: 'cn', value: hostname } ]
	}));
};

Identity.forUser = function (uid) {
	assert.string(uid, 'uid');
	return (new Identity({
		type: 'user',
		uid: uid,
		components: [ { name: 'uid', value: uid } ]
	}));
};

Identity.forEmail = function (email) {
	assert.string(email, 'email');
	return (new Identity({
		type: 'email',
		email: email,
		components: [ { name: 'mail', value: email } ]
	}));
};

Identity.parseDN = function (dn) {
	assert.string(dn, 'dn');
	var parts = [''];
	var idx = 0;
	var rem = dn;
	while (rem.length > 0) {
		var m;
		/*JSSTYLED*/
		if ((m = /^,/.exec(rem)) !== null) {
			parts[++idx] = '';
			rem = rem.slice(m[0].length);
		/*JSSTYLED*/
		} else if ((m = /^\\,/.exec(rem)) !== null) {
			parts[idx] += ',';
			rem = rem.slice(m[0].length);
		/*JSSTYLED*/
		} else if ((m = /^\\./.exec(rem)) !== null) {
			parts[idx] += m[0];
			rem = rem.slice(m[0].length);
		/*JSSTYLED*/
		} else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
			parts[idx] += m[0];
			rem = rem.slice(m[0].length);
		} else {
			throw (new Error('Failed to parse DN'));
		}
	}
	var cmps = parts.map(function (c) {
		c = c.trim();
		var eqPos = c.indexOf('=');
		while (eqPos > 0 && c.charAt(eqPos - 1) === '\\')
			eqPos = c.indexOf('=', eqPos + 1);
		if (eqPos === -1) {
			throw (new Error('Failed to parse DN'));
		}
		/*JSSTYLED*/
		var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, '=');
		var value = c.slice(eqPos + 1);
		return ({ name: name, value: value });
	});
	return (new Identity({ components: cmps }));
};

Identity.fromArray = function (components) {
	assert.arrayOfObject(components, 'components');
	components.forEach(function (cmp) {
		assert.object(cmp, 'component');
		assert.string(cmp.name, 'component.name');
		if (!Buffer.isBuffer(cmp.value) &&
		    !(typeof (cmp.value) === 'string')) {
			throw (new Error('Invalid component value'));
		}
	});
	return (new Identity({ components: components }));
};

Identity.parseAsn1 = function (der, top) {
	var components = [];
	der.readSequence(top);
	var end = der.offset + der.length;
	while (der.offset < end) {
		der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
		var after = der.offset + der.length;
		der.readSequence();
		var oid = der.readOID();
		var type = der.peek();
		var value;
		switch (type) {
		case asn1.Ber.PrintableString:
		case asn1.Ber.IA5String:
		case asn1.Ber.OctetString:
		case asn1.Ber.T61String:
			value = der.readString(type);
			break;
		case asn1.Ber.Utf8String:
			value = der.readString(type, true);
			value = value.toString('utf8');
			break;
		case asn1.Ber.CharacterString:
		case asn1.Ber.BMPString:
			value = der.readString(type, true);
			value = value.toString('utf16le');
			break;
		default:
			throw (new Error('Unknown asn1 type ' + type));
		}
		components.push({ oid: oid, asn1type: type, value: value });
		der._offset = after;
	}
	der._offset = end;
	return (new Identity({
		components: components
	}));
};

Identity.isIdentity = function (obj, ver) {
	return (utils.isCompatible(obj, Identity, ver));
};

/*
 * API versions for Identity:
 * [1,0] -- initial ver
 */
Identity.prototype._sshpkApiVersion = [1, 0];

Identity._oldVersionDetect = function (obj) {
	return ([1, 0]);
};


/***/ }),

/***/ "./node_modules/sshpk/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sshpk/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

var Key = __webpack_require__(/*! ./key */ "./node_modules/sshpk/lib/key.js");
var Fingerprint = __webpack_require__(/*! ./fingerprint */ "./node_modules/sshpk/lib/fingerprint.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/sshpk/lib/signature.js");
var PrivateKey = __webpack_require__(/*! ./private-key */ "./node_modules/sshpk/lib/private-key.js");
var Certificate = __webpack_require__(/*! ./certificate */ "./node_modules/sshpk/lib/certificate.js");
var Identity = __webpack_require__(/*! ./identity */ "./node_modules/sshpk/lib/identity.js");
var errs = __webpack_require__(/*! ./errors */ "./node_modules/sshpk/lib/errors.js");

module.exports = {
	/* top-level classes */
	Key: Key,
	parseKey: Key.parse,
	Fingerprint: Fingerprint,
	parseFingerprint: Fingerprint.parse,
	Signature: Signature,
	parseSignature: Signature.parse,
	PrivateKey: PrivateKey,
	parsePrivateKey: PrivateKey.parse,
	generatePrivateKey: PrivateKey.generate,
	Certificate: Certificate,
	parseCertificate: Certificate.parse,
	createSelfSignedCertificate: Certificate.createSelfSigned,
	createCertificate: Certificate.create,
	Identity: Identity,
	identityFromDN: Identity.parseDN,
	identityForHost: Identity.forHost,
	identityForUser: Identity.forUser,
	identityForEmail: Identity.forEmail,
	identityFromArray: Identity.fromArray,

	/* errors */
	FingerprintFormatError: errs.FingerprintFormatError,
	InvalidAlgorithmError: errs.InvalidAlgorithmError,
	KeyParseError: errs.KeyParseError,
	SignatureParseError: errs.SignatureParseError,
	KeyEncryptedError: errs.KeyEncryptedError,
	CertificateParseError: errs.CertificateParseError
};


/***/ }),

/***/ "./node_modules/sshpk/lib/key.js":
/*!***************************************!*\
  !*** ./node_modules/sshpk/lib/key.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2018 Joyent, Inc.

module.exports = Key;

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var algs = __webpack_require__(/*! ./algs */ "./node_modules/sshpk/lib/algs.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var Fingerprint = __webpack_require__(/*! ./fingerprint */ "./node_modules/sshpk/lib/fingerprint.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/sshpk/lib/signature.js");
var DiffieHellman = __webpack_require__(/*! ./dhe */ "./node_modules/sshpk/lib/dhe.js").DiffieHellman;
var errs = __webpack_require__(/*! ./errors */ "./node_modules/sshpk/lib/errors.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/sshpk/lib/utils.js");
var PrivateKey = __webpack_require__(/*! ./private-key */ "./node_modules/sshpk/lib/private-key.js");
var edCompat;

try {
	edCompat = __webpack_require__(/*! ./ed-compat */ "./node_modules/sshpk/lib/ed-compat.js");
} catch (e) {
	/* Just continue through, and bail out if we try to use it. */
}

var InvalidAlgorithmError = errs.InvalidAlgorithmError;
var KeyParseError = errs.KeyParseError;

var formats = {};
formats['auto'] = __webpack_require__(/*! ./formats/auto */ "./node_modules/sshpk/lib/formats/auto.js");
formats['pem'] = __webpack_require__(/*! ./formats/pem */ "./node_modules/sshpk/lib/formats/pem.js");
formats['pkcs1'] = __webpack_require__(/*! ./formats/pkcs1 */ "./node_modules/sshpk/lib/formats/pkcs1.js");
formats['pkcs8'] = __webpack_require__(/*! ./formats/pkcs8 */ "./node_modules/sshpk/lib/formats/pkcs8.js");
formats['rfc4253'] = __webpack_require__(/*! ./formats/rfc4253 */ "./node_modules/sshpk/lib/formats/rfc4253.js");
formats['ssh'] = __webpack_require__(/*! ./formats/ssh */ "./node_modules/sshpk/lib/formats/ssh.js");
formats['ssh-private'] = __webpack_require__(/*! ./formats/ssh-private */ "./node_modules/sshpk/lib/formats/ssh-private.js");
formats['openssh'] = formats['ssh-private'];
formats['dnssec'] = __webpack_require__(/*! ./formats/dnssec */ "./node_modules/sshpk/lib/formats/dnssec.js");
formats['putty'] = __webpack_require__(/*! ./formats/putty */ "./node_modules/sshpk/lib/formats/putty.js");
formats['ppk'] = formats['putty'];

function Key(opts) {
	assert.object(opts, 'options');
	assert.arrayOfObject(opts.parts, 'options.parts');
	assert.string(opts.type, 'options.type');
	assert.optionalString(opts.comment, 'options.comment');

	var algInfo = algs.info[opts.type];
	if (typeof (algInfo) !== 'object')
		throw (new InvalidAlgorithmError(opts.type));

	var partLookup = {};
	for (var i = 0; i < opts.parts.length; ++i) {
		var part = opts.parts[i];
		partLookup[part.name] = part;
	}

	this.type = opts.type;
	this.parts = opts.parts;
	this.part = partLookup;
	this.comment = undefined;
	this.source = opts.source;

	/* for speeding up hashing/fingerprint operations */
	this._rfc4253Cache = opts._rfc4253Cache;
	this._hashCache = {};

	var sz;
	this.curve = undefined;
	if (this.type === 'ecdsa') {
		var curve = this.part.curve.data.toString();
		this.curve = curve;
		sz = algs.curves[curve].size;
	} else if (this.type === 'ed25519' || this.type === 'curve25519') {
		sz = 256;
		this.curve = 'curve25519';
	} else {
		var szPart = this.part[algInfo.sizePart];
		sz = szPart.data.length;
		sz = sz * 8 - utils.countZeros(szPart.data);
	}
	this.size = sz;
}

Key.formats = formats;

Key.prototype.toBuffer = function (format, options) {
	if (format === undefined)
		format = 'ssh';
	assert.string(format, 'format');
	assert.object(formats[format], 'formats[format]');
	assert.optionalObject(options, 'options');

	if (format === 'rfc4253') {
		if (this._rfc4253Cache === undefined)
			this._rfc4253Cache = formats['rfc4253'].write(this);
		return (this._rfc4253Cache);
	}

	return (formats[format].write(this, options));
};

Key.prototype.toString = function (format, options) {
	return (this.toBuffer(format, options).toString());
};

Key.prototype.hash = function (algo, type) {
	assert.string(algo, 'algorithm');
	assert.optionalString(type, 'type');
	if (type === undefined)
		type = 'ssh';
	algo = algo.toLowerCase();
	if (algs.hashAlgs[algo] === undefined)
		throw (new InvalidAlgorithmError(algo));

	var cacheKey = algo + '||' + type;
	if (this._hashCache[cacheKey])
		return (this._hashCache[cacheKey]);

	var buf;
	if (type === 'ssh') {
		buf = this.toBuffer('rfc4253');
	} else if (type === 'spki') {
		buf = formats.pkcs8.pkcs8ToBuffer(this);
	} else {
		throw (new Error('Hash type ' + type + ' not supported'));
	}
	var hash = crypto.createHash(algo).update(buf).digest();
	this._hashCache[cacheKey] = hash;
	return (hash);
};

Key.prototype.fingerprint = function (algo, type) {
	if (algo === undefined)
		algo = 'sha256';
	if (type === undefined)
		type = 'ssh';
	assert.string(algo, 'algorithm');
	assert.string(type, 'type');
	var opts = {
		type: 'key',
		hash: this.hash(algo, type),
		algorithm: algo,
		hashType: type
	};
	return (new Fingerprint(opts));
};

Key.prototype.defaultHashAlgorithm = function () {
	var hashAlgo = 'sha1';
	if (this.type === 'rsa')
		hashAlgo = 'sha256';
	if (this.type === 'dsa' && this.size > 1024)
		hashAlgo = 'sha256';
	if (this.type === 'ed25519')
		hashAlgo = 'sha512';
	if (this.type === 'ecdsa') {
		if (this.size <= 256)
			hashAlgo = 'sha256';
		else if (this.size <= 384)
			hashAlgo = 'sha384';
		else
			hashAlgo = 'sha512';
	}
	return (hashAlgo);
};

Key.prototype.createVerify = function (hashAlgo) {
	if (hashAlgo === undefined)
		hashAlgo = this.defaultHashAlgorithm();
	assert.string(hashAlgo, 'hash algorithm');

	/* ED25519 is not supported by OpenSSL, use a javascript impl. */
	if (this.type === 'ed25519' && edCompat !== undefined)
		return (new edCompat.Verifier(this, hashAlgo));
	if (this.type === 'curve25519')
		throw (new Error('Curve25519 keys are not suitable for ' +
		    'signing or verification'));

	var v, nm, err;
	try {
		nm = hashAlgo.toUpperCase();
		v = crypto.createVerify(nm);
	} catch (e) {
		err = e;
	}
	if (v === undefined || (err instanceof Error &&
	    err.message.match(/Unknown message digest/))) {
		nm = 'RSA-';
		nm += hashAlgo.toUpperCase();
		v = crypto.createVerify(nm);
	}
	assert.ok(v, 'failed to create verifier');
	var oldVerify = v.verify.bind(v);
	var key = this.toBuffer('pkcs8');
	var curve = this.curve;
	var self = this;
	v.verify = function (signature, fmt) {
		if (Signature.isSignature(signature, [2, 0])) {
			if (signature.type !== self.type)
				return (false);
			if (signature.hashAlgorithm &&
			    signature.hashAlgorithm !== hashAlgo)
				return (false);
			if (signature.curve && self.type === 'ecdsa' &&
			    signature.curve !== curve)
				return (false);
			return (oldVerify(key, signature.toBuffer('asn1')));

		} else if (typeof (signature) === 'string' ||
		    Buffer.isBuffer(signature)) {
			return (oldVerify(key, signature, fmt));

		/*
		 * Avoid doing this on valid arguments, walking the prototype
		 * chain can be quite slow.
		 */
		} else if (Signature.isSignature(signature, [1, 0])) {
			throw (new Error('signature was created by too old ' +
			    'a version of sshpk and cannot be verified'));

		} else {
			throw (new TypeError('signature must be a string, ' +
			    'Buffer, or Signature object'));
		}
	};
	return (v);
};

Key.prototype.createDiffieHellman = function () {
	if (this.type === 'rsa')
		throw (new Error('RSA keys do not support Diffie-Hellman'));

	return (new DiffieHellman(this));
};
Key.prototype.createDH = Key.prototype.createDiffieHellman;

Key.parse = function (data, format, options) {
	if (typeof (data) !== 'string')
		assert.buffer(data, 'data');
	if (format === undefined)
		format = 'auto';
	assert.string(format, 'format');
	if (typeof (options) === 'string')
		options = { filename: options };
	assert.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	assert.optionalString(options.filename, 'options.filename');
	if (options.filename === undefined)
		options.filename = '(unnamed)';

	assert.object(formats[format], 'formats[format]');

	try {
		var k = formats[format].read(data, options);
		if (k instanceof PrivateKey)
			k = k.toPublic();
		if (!k.comment)
			k.comment = options.filename;
		return (k);
	} catch (e) {
		if (e.name === 'KeyEncryptedError')
			throw (e);
		throw (new KeyParseError(options.filename, format, e));
	}
};

Key.isKey = function (obj, ver) {
	return (utils.isCompatible(obj, Key, ver));
};

/*
 * API versions for Key:
 * [1,0] -- initial ver, may take Signature for createVerify or may not
 * [1,1] -- added pkcs1, pkcs8 formats
 * [1,2] -- added auto, ssh-private, openssh formats
 * [1,3] -- added defaultHashAlgorithm
 * [1,4] -- added ed support, createDH
 * [1,5] -- first explicitly tagged version
 * [1,6] -- changed ed25519 part names
 * [1,7] -- spki hash types
 */
Key.prototype._sshpkApiVersion = [1, 7];

Key._oldVersionDetect = function (obj) {
	assert.func(obj.toBuffer);
	assert.func(obj.fingerprint);
	if (obj.createDH)
		return ([1, 4]);
	if (obj.defaultHashAlgorithm)
		return ([1, 3]);
	if (obj.formats['auto'])
		return ([1, 2]);
	if (obj.formats['pkcs1'])
		return ([1, 1]);
	return ([1, 0]);
};


/***/ }),

/***/ "./node_modules/sshpk/lib/private-key.js":
/*!***********************************************!*\
  !*** ./node_modules/sshpk/lib/private-key.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2017 Joyent, Inc.

module.exports = PrivateKey;

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ./algs */ "./node_modules/sshpk/lib/algs.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var Fingerprint = __webpack_require__(/*! ./fingerprint */ "./node_modules/sshpk/lib/fingerprint.js");
var Signature = __webpack_require__(/*! ./signature */ "./node_modules/sshpk/lib/signature.js");
var errs = __webpack_require__(/*! ./errors */ "./node_modules/sshpk/lib/errors.js");
var util = __webpack_require__(/*! util */ "util");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/sshpk/lib/utils.js");
var dhe = __webpack_require__(/*! ./dhe */ "./node_modules/sshpk/lib/dhe.js");
var generateECDSA = dhe.generateECDSA;
var generateED25519 = dhe.generateED25519;
var edCompat = __webpack_require__(/*! ./ed-compat */ "./node_modules/sshpk/lib/ed-compat.js");
var nacl = __webpack_require__(/*! tweetnacl */ "./node_modules/tweetnacl/nacl-fast.js");

var Key = __webpack_require__(/*! ./key */ "./node_modules/sshpk/lib/key.js");

var InvalidAlgorithmError = errs.InvalidAlgorithmError;
var KeyParseError = errs.KeyParseError;
var KeyEncryptedError = errs.KeyEncryptedError;

var formats = {};
formats['auto'] = __webpack_require__(/*! ./formats/auto */ "./node_modules/sshpk/lib/formats/auto.js");
formats['pem'] = __webpack_require__(/*! ./formats/pem */ "./node_modules/sshpk/lib/formats/pem.js");
formats['pkcs1'] = __webpack_require__(/*! ./formats/pkcs1 */ "./node_modules/sshpk/lib/formats/pkcs1.js");
formats['pkcs8'] = __webpack_require__(/*! ./formats/pkcs8 */ "./node_modules/sshpk/lib/formats/pkcs8.js");
formats['rfc4253'] = __webpack_require__(/*! ./formats/rfc4253 */ "./node_modules/sshpk/lib/formats/rfc4253.js");
formats['ssh-private'] = __webpack_require__(/*! ./formats/ssh-private */ "./node_modules/sshpk/lib/formats/ssh-private.js");
formats['openssh'] = formats['ssh-private'];
formats['ssh'] = formats['ssh-private'];
formats['dnssec'] = __webpack_require__(/*! ./formats/dnssec */ "./node_modules/sshpk/lib/formats/dnssec.js");

function PrivateKey(opts) {
	assert.object(opts, 'options');
	Key.call(this, opts);

	this._pubCache = undefined;
}
util.inherits(PrivateKey, Key);

PrivateKey.formats = formats;

PrivateKey.prototype.toBuffer = function (format, options) {
	if (format === undefined)
		format = 'pkcs1';
	assert.string(format, 'format');
	assert.object(formats[format], 'formats[format]');
	assert.optionalObject(options, 'options');

	return (formats[format].write(this, options));
};

PrivateKey.prototype.hash = function (algo, type) {
	return (this.toPublic().hash(algo, type));
};

PrivateKey.prototype.fingerprint = function (algo, type) {
	return (this.toPublic().fingerprint(algo, type));
};

PrivateKey.prototype.toPublic = function () {
	if (this._pubCache)
		return (this._pubCache);

	var algInfo = algs.info[this.type];
	var pubParts = [];
	for (var i = 0; i < algInfo.parts.length; ++i) {
		var p = algInfo.parts[i];
		pubParts.push(this.part[p]);
	}

	this._pubCache = new Key({
		type: this.type,
		source: this,
		parts: pubParts
	});
	if (this.comment)
		this._pubCache.comment = this.comment;
	return (this._pubCache);
};

PrivateKey.prototype.derive = function (newType) {
	assert.string(newType, 'type');
	var priv, pub, pair;

	if (this.type === 'ed25519' && newType === 'curve25519') {
		priv = this.part.k.data;
		if (priv[0] === 0x00)
			priv = priv.slice(1);

		pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
		pub = Buffer.from(pair.publicKey);

		return (new PrivateKey({
			type: 'curve25519',
			parts: [
				{ name: 'A', data: utils.mpNormalize(pub) },
				{ name: 'k', data: utils.mpNormalize(priv) }
			]
		}));
	} else if (this.type === 'curve25519' && newType === 'ed25519') {
		priv = this.part.k.data;
		if (priv[0] === 0x00)
			priv = priv.slice(1);

		pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
		pub = Buffer.from(pair.publicKey);

		return (new PrivateKey({
			type: 'ed25519',
			parts: [
				{ name: 'A', data: utils.mpNormalize(pub) },
				{ name: 'k', data: utils.mpNormalize(priv) }
			]
		}));
	}
	throw (new Error('Key derivation not supported from ' + this.type +
	    ' to ' + newType));
};

PrivateKey.prototype.createVerify = function (hashAlgo) {
	return (this.toPublic().createVerify(hashAlgo));
};

PrivateKey.prototype.createSign = function (hashAlgo) {
	if (hashAlgo === undefined)
		hashAlgo = this.defaultHashAlgorithm();
	assert.string(hashAlgo, 'hash algorithm');

	/* ED25519 is not supported by OpenSSL, use a javascript impl. */
	if (this.type === 'ed25519' && edCompat !== undefined)
		return (new edCompat.Signer(this, hashAlgo));
	if (this.type === 'curve25519')
		throw (new Error('Curve25519 keys are not suitable for ' +
		    'signing or verification'));

	var v, nm, err;
	try {
		nm = hashAlgo.toUpperCase();
		v = crypto.createSign(nm);
	} catch (e) {
		err = e;
	}
	if (v === undefined || (err instanceof Error &&
	    err.message.match(/Unknown message digest/))) {
		nm = 'RSA-';
		nm += hashAlgo.toUpperCase();
		v = crypto.createSign(nm);
	}
	assert.ok(v, 'failed to create verifier');
	var oldSign = v.sign.bind(v);
	var key = this.toBuffer('pkcs1');
	var type = this.type;
	var curve = this.curve;
	v.sign = function () {
		var sig = oldSign(key);
		if (typeof (sig) === 'string')
			sig = Buffer.from(sig, 'binary');
		sig = Signature.parse(sig, type, 'asn1');
		sig.hashAlgorithm = hashAlgo;
		sig.curve = curve;
		return (sig);
	};
	return (v);
};

PrivateKey.parse = function (data, format, options) {
	if (typeof (data) !== 'string')
		assert.buffer(data, 'data');
	if (format === undefined)
		format = 'auto';
	assert.string(format, 'format');
	if (typeof (options) === 'string')
		options = { filename: options };
	assert.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	assert.optionalString(options.filename, 'options.filename');
	if (options.filename === undefined)
		options.filename = '(unnamed)';

	assert.object(formats[format], 'formats[format]');

	try {
		var k = formats[format].read(data, options);
		assert.ok(k instanceof PrivateKey, 'key is not a private key');
		if (!k.comment)
			k.comment = options.filename;
		return (k);
	} catch (e) {
		if (e.name === 'KeyEncryptedError')
			throw (e);
		throw (new KeyParseError(options.filename, format, e));
	}
};

PrivateKey.isPrivateKey = function (obj, ver) {
	return (utils.isCompatible(obj, PrivateKey, ver));
};

PrivateKey.generate = function (type, options) {
	if (options === undefined)
		options = {};
	assert.object(options, 'options');

	switch (type) {
	case 'ecdsa':
		if (options.curve === undefined)
			options.curve = 'nistp256';
		assert.string(options.curve, 'options.curve');
		return (generateECDSA(options.curve));
	case 'ed25519':
		return (generateED25519());
	default:
		throw (new Error('Key generation not supported with key ' +
		    'type "' + type + '"'));
	}
};

/*
 * API versions for PrivateKey:
 * [1,0] -- initial ver
 * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats
 * [1,2] -- added defaultHashAlgorithm
 * [1,3] -- added derive, ed, createDH
 * [1,4] -- first tagged version
 * [1,5] -- changed ed25519 part names and format
 * [1,6] -- type arguments for hash() and fingerprint()
 */
PrivateKey.prototype._sshpkApiVersion = [1, 6];

PrivateKey._oldVersionDetect = function (obj) {
	assert.func(obj.toPublic);
	assert.func(obj.createSign);
	if (obj.derive)
		return ([1, 3]);
	if (obj.defaultHashAlgorithm)
		return ([1, 2]);
	if (obj.formats['auto'])
		return ([1, 1]);
	return ([1, 0]);
};


/***/ }),

/***/ "./node_modules/sshpk/lib/signature.js":
/*!*********************************************!*\
  !*** ./node_modules/sshpk/lib/signature.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

module.exports = Signature;

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var algs = __webpack_require__(/*! ./algs */ "./node_modules/sshpk/lib/algs.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var errs = __webpack_require__(/*! ./errors */ "./node_modules/sshpk/lib/errors.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/sshpk/lib/utils.js");
var asn1 = __webpack_require__(/*! asn1 */ "./node_modules/asn1/lib/index.js");
var SSHBuffer = __webpack_require__(/*! ./ssh-buffer */ "./node_modules/sshpk/lib/ssh-buffer.js");

var InvalidAlgorithmError = errs.InvalidAlgorithmError;
var SignatureParseError = errs.SignatureParseError;

function Signature(opts) {
	assert.object(opts, 'options');
	assert.arrayOfObject(opts.parts, 'options.parts');
	assert.string(opts.type, 'options.type');

	var partLookup = {};
	for (var i = 0; i < opts.parts.length; ++i) {
		var part = opts.parts[i];
		partLookup[part.name] = part;
	}

	this.type = opts.type;
	this.hashAlgorithm = opts.hashAlgo;
	this.curve = opts.curve;
	this.parts = opts.parts;
	this.part = partLookup;
}

Signature.prototype.toBuffer = function (format) {
	if (format === undefined)
		format = 'asn1';
	assert.string(format, 'format');

	var buf;
	var stype = 'ssh-' + this.type;

	switch (this.type) {
	case 'rsa':
		switch (this.hashAlgorithm) {
		case 'sha256':
			stype = 'rsa-sha2-256';
			break;
		case 'sha512':
			stype = 'rsa-sha2-512';
			break;
		case 'sha1':
		case undefined:
			break;
		default:
			throw (new Error('SSH signature ' +
			    'format does not support hash ' +
			    'algorithm ' + this.hashAlgorithm));
		}
		if (format === 'ssh') {
			buf = new SSHBuffer({});
			buf.writeString(stype);
			buf.writePart(this.part.sig);
			return (buf.toBuffer());
		} else {
			return (this.part.sig.data);
		}
		break;

	case 'ed25519':
		if (format === 'ssh') {
			buf = new SSHBuffer({});
			buf.writeString(stype);
			buf.writePart(this.part.sig);
			return (buf.toBuffer());
		} else {
			return (this.part.sig.data);
		}
		break;

	case 'dsa':
	case 'ecdsa':
		var r, s;
		if (format === 'asn1') {
			var der = new asn1.BerWriter();
			der.startSequence();
			r = utils.mpNormalize(this.part.r.data);
			s = utils.mpNormalize(this.part.s.data);
			der.writeBuffer(r, asn1.Ber.Integer);
			der.writeBuffer(s, asn1.Ber.Integer);
			der.endSequence();
			return (der.buffer);
		} else if (format === 'ssh' && this.type === 'dsa') {
			buf = new SSHBuffer({});
			buf.writeString('ssh-dss');
			r = this.part.r.data;
			if (r.length > 20 && r[0] === 0x00)
				r = r.slice(1);
			s = this.part.s.data;
			if (s.length > 20 && s[0] === 0x00)
				s = s.slice(1);
			if ((this.hashAlgorithm &&
			    this.hashAlgorithm !== 'sha1') ||
			    r.length + s.length !== 40) {
				throw (new Error('OpenSSH only supports ' +
				    'DSA signatures with SHA1 hash'));
			}
			buf.writeBuffer(Buffer.concat([r, s]));
			return (buf.toBuffer());
		} else if (format === 'ssh' && this.type === 'ecdsa') {
			var inner = new SSHBuffer({});
			r = this.part.r.data;
			inner.writeBuffer(r);
			inner.writePart(this.part.s);

			buf = new SSHBuffer({});
			/* XXX: find a more proper way to do this? */
			var curve;
			if (r[0] === 0x00)
				r = r.slice(1);
			var sz = r.length * 8;
			if (sz === 256)
				curve = 'nistp256';
			else if (sz === 384)
				curve = 'nistp384';
			else if (sz === 528)
				curve = 'nistp521';
			buf.writeString('ecdsa-sha2-' + curve);
			buf.writeBuffer(inner.toBuffer());
			return (buf.toBuffer());
		}
		throw (new Error('Invalid signature format'));
	default:
		throw (new Error('Invalid signature data'));
	}
};

Signature.prototype.toString = function (format) {
	assert.optionalString(format, 'format');
	return (this.toBuffer(format).toString('base64'));
};

Signature.parse = function (data, type, format) {
	if (typeof (data) === 'string')
		data = Buffer.from(data, 'base64');
	assert.buffer(data, 'data');
	assert.string(format, 'format');
	assert.string(type, 'type');

	var opts = {};
	opts.type = type.toLowerCase();
	opts.parts = [];

	try {
		assert.ok(data.length > 0, 'signature must not be empty');
		switch (opts.type) {
		case 'rsa':
			return (parseOneNum(data, type, format, opts));
		case 'ed25519':
			return (parseOneNum(data, type, format, opts));

		case 'dsa':
		case 'ecdsa':
			if (format === 'asn1')
				return (parseDSAasn1(data, type, format, opts));
			else if (opts.type === 'dsa')
				return (parseDSA(data, type, format, opts));
			else
				return (parseECDSA(data, type, format, opts));

		default:
			throw (new InvalidAlgorithmError(type));
		}

	} catch (e) {
		if (e instanceof InvalidAlgorithmError)
			throw (e);
		throw (new SignatureParseError(type, format, e));
	}
};

function parseOneNum(data, type, format, opts) {
	if (format === 'ssh') {
		try {
			var buf = new SSHBuffer({buffer: data});
			var head = buf.readString();
		} catch (e) {
			/* fall through */
		}
		if (buf !== undefined) {
			var msg = 'SSH signature does not match expected ' +
			    'type (expected ' + type + ', got ' + head + ')';
			switch (head) {
			case 'ssh-rsa':
				assert.strictEqual(type, 'rsa', msg);
				opts.hashAlgo = 'sha1';
				break;
			case 'rsa-sha2-256':
				assert.strictEqual(type, 'rsa', msg);
				opts.hashAlgo = 'sha256';
				break;
			case 'rsa-sha2-512':
				assert.strictEqual(type, 'rsa', msg);
				opts.hashAlgo = 'sha512';
				break;
			case 'ssh-ed25519':
				assert.strictEqual(type, 'ed25519', msg);
				opts.hashAlgo = 'sha512';
				break;
			default:
				throw (new Error('Unknown SSH signature ' +
				    'type: ' + head));
			}
			var sig = buf.readPart();
			assert.ok(buf.atEnd(), 'extra trailing bytes');
			sig.name = 'sig';
			opts.parts.push(sig);
			return (new Signature(opts));
		}
	}
	opts.parts.push({name: 'sig', data: data});
	return (new Signature(opts));
}

function parseDSAasn1(data, type, format, opts) {
	var der = new asn1.BerReader(data);
	der.readSequence();
	var r = der.readString(asn1.Ber.Integer, true);
	var s = der.readString(asn1.Ber.Integer, true);

	opts.parts.push({name: 'r', data: utils.mpNormalize(r)});
	opts.parts.push({name: 's', data: utils.mpNormalize(s)});

	return (new Signature(opts));
}

function parseDSA(data, type, format, opts) {
	if (data.length != 40) {
		var buf = new SSHBuffer({buffer: data});
		var d = buf.readBuffer();
		if (d.toString('ascii') === 'ssh-dss')
			d = buf.readBuffer();
		assert.ok(buf.atEnd(), 'extra trailing bytes');
		assert.strictEqual(d.length, 40, 'invalid inner length');
		data = d;
	}
	opts.parts.push({name: 'r', data: data.slice(0, 20)});
	opts.parts.push({name: 's', data: data.slice(20, 40)});
	return (new Signature(opts));
}

function parseECDSA(data, type, format, opts) {
	var buf = new SSHBuffer({buffer: data});

	var r, s;
	var inner = buf.readBuffer();
	var stype = inner.toString('ascii');
	if (stype.slice(0, 6) === 'ecdsa-') {
		var parts = stype.split('-');
		assert.strictEqual(parts[0], 'ecdsa');
		assert.strictEqual(parts[1], 'sha2');
		opts.curve = parts[2];
		switch (opts.curve) {
		case 'nistp256':
			opts.hashAlgo = 'sha256';
			break;
		case 'nistp384':
			opts.hashAlgo = 'sha384';
			break;
		case 'nistp521':
			opts.hashAlgo = 'sha512';
			break;
		default:
			throw (new Error('Unsupported ECDSA curve: ' +
			    opts.curve));
		}
		inner = buf.readBuffer();
		assert.ok(buf.atEnd(), 'extra trailing bytes on outer');
		buf = new SSHBuffer({buffer: inner});
		r = buf.readPart();
	} else {
		r = {data: inner};
	}

	s = buf.readPart();
	assert.ok(buf.atEnd(), 'extra trailing bytes');

	r.name = 'r';
	s.name = 's';

	opts.parts.push(r);
	opts.parts.push(s);
	return (new Signature(opts));
}

Signature.isSignature = function (obj, ver) {
	return (utils.isCompatible(obj, Signature, ver));
};

/*
 * API versions for Signature:
 * [1,0] -- initial ver
 * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent
 *          hashAlgorithm property
 * [2,1] -- first tagged version
 */
Signature.prototype._sshpkApiVersion = [2, 1];

Signature._oldVersionDetect = function (obj) {
	assert.func(obj.toBuffer);
	if (obj.hasOwnProperty('hashAlgorithm'))
		return ([2, 0]);
	return ([1, 0]);
};


/***/ }),

/***/ "./node_modules/sshpk/lib/ssh-buffer.js":
/*!**********************************************!*\
  !*** ./node_modules/sshpk/lib/ssh-buffer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

module.exports = SSHBuffer;

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;

function SSHBuffer(opts) {
	assert.object(opts, 'options');
	if (opts.buffer !== undefined)
		assert.buffer(opts.buffer, 'options.buffer');

	this._size = opts.buffer ? opts.buffer.length : 1024;
	this._buffer = opts.buffer || Buffer.alloc(this._size);
	this._offset = 0;
}

SSHBuffer.prototype.toBuffer = function () {
	return (this._buffer.slice(0, this._offset));
};

SSHBuffer.prototype.atEnd = function () {
	return (this._offset >= this._buffer.length);
};

SSHBuffer.prototype.remainder = function () {
	return (this._buffer.slice(this._offset));
};

SSHBuffer.prototype.skip = function (n) {
	this._offset += n;
};

SSHBuffer.prototype.expand = function () {
	this._size *= 2;
	var buf = Buffer.alloc(this._size);
	this._buffer.copy(buf, 0);
	this._buffer = buf;
};

SSHBuffer.prototype.readPart = function () {
	return ({data: this.readBuffer()});
};

SSHBuffer.prototype.readBuffer = function () {
	var len = this._buffer.readUInt32BE(this._offset);
	this._offset += 4;
	assert.ok(this._offset + len <= this._buffer.length,
	    'length out of bounds at +0x' + this._offset.toString(16) +
	    ' (data truncated?)');
	var buf = this._buffer.slice(this._offset, this._offset + len);
	this._offset += len;
	return (buf);
};

SSHBuffer.prototype.readString = function () {
	return (this.readBuffer().toString());
};

SSHBuffer.prototype.readCString = function () {
	var offset = this._offset;
	while (offset < this._buffer.length &&
	    this._buffer[offset] !== 0x00)
		offset++;
	assert.ok(offset < this._buffer.length, 'c string does not terminate');
	var str = this._buffer.slice(this._offset, offset).toString();
	this._offset = offset + 1;
	return (str);
};

SSHBuffer.prototype.readInt = function () {
	var v = this._buffer.readUInt32BE(this._offset);
	this._offset += 4;
	return (v);
};

SSHBuffer.prototype.readInt64 = function () {
	assert.ok(this._offset + 8 < this._buffer.length,
	    'buffer not long enough to read Int64');
	var v = this._buffer.slice(this._offset, this._offset + 8);
	this._offset += 8;
	return (v);
};

SSHBuffer.prototype.readChar = function () {
	var v = this._buffer[this._offset++];
	return (v);
};

SSHBuffer.prototype.writeBuffer = function (buf) {
	while (this._offset + 4 + buf.length > this._size)
		this.expand();
	this._buffer.writeUInt32BE(buf.length, this._offset);
	this._offset += 4;
	buf.copy(this._buffer, this._offset);
	this._offset += buf.length;
};

SSHBuffer.prototype.writeString = function (str) {
	this.writeBuffer(Buffer.from(str, 'utf8'));
};

SSHBuffer.prototype.writeCString = function (str) {
	while (this._offset + 1 + str.length > this._size)
		this.expand();
	this._buffer.write(str, this._offset);
	this._offset += str.length;
	this._buffer[this._offset++] = 0;
};

SSHBuffer.prototype.writeInt = function (v) {
	while (this._offset + 4 > this._size)
		this.expand();
	this._buffer.writeUInt32BE(v, this._offset);
	this._offset += 4;
};

SSHBuffer.prototype.writeInt64 = function (v) {
	assert.buffer(v, 'value');
	if (v.length > 8) {
		var lead = v.slice(0, v.length - 8);
		for (var i = 0; i < lead.length; ++i) {
			assert.strictEqual(lead[i], 0,
			    'must fit in 64 bits of precision');
		}
		v = v.slice(v.length - 8, v.length);
	}
	while (this._offset + 8 > this._size)
		this.expand();
	v.copy(this._buffer, this._offset);
	this._offset += 8;
};

SSHBuffer.prototype.writeChar = function (v) {
	while (this._offset + 1 > this._size)
		this.expand();
	this._buffer[this._offset++] = v;
};

SSHBuffer.prototype.writePart = function (p) {
	this.writeBuffer(p.data);
};

SSHBuffer.prototype.write = function (buf) {
	while (this._offset + buf.length > this._size)
		this.expand();
	buf.copy(this._buffer, this._offset);
	this._offset += buf.length;
};


/***/ }),

/***/ "./node_modules/sshpk/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/sshpk/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright 2015 Joyent, Inc.

module.exports = {
	bufferSplit: bufferSplit,
	addRSAMissing: addRSAMissing,
	calculateDSAPublic: calculateDSAPublic,
	calculateED25519Public: calculateED25519Public,
	calculateX25519Public: calculateX25519Public,
	mpNormalize: mpNormalize,
	mpDenormalize: mpDenormalize,
	ecNormalize: ecNormalize,
	countZeros: countZeros,
	assertCompatible: assertCompatible,
	isCompatible: isCompatible,
	opensslKeyDeriv: opensslKeyDeriv,
	opensshCipherInfo: opensshCipherInfo,
	publicFromPrivateECDSA: publicFromPrivateECDSA,
	zeroPadToLength: zeroPadToLength,
	writeBitString: writeBitString,
	readBitString: readBitString,
	pbkdf2: pbkdf2
};

var assert = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var Buffer = __webpack_require__(/*! safer-buffer */ "./node_modules/safer-buffer/safer.js").Buffer;
var PrivateKey = __webpack_require__(/*! ./private-key */ "./node_modules/sshpk/lib/private-key.js");
var Key = __webpack_require__(/*! ./key */ "./node_modules/sshpk/lib/key.js");
var crypto = __webpack_require__(/*! crypto */ "crypto");
var algs = __webpack_require__(/*! ./algs */ "./node_modules/sshpk/lib/algs.js");
var asn1 = __webpack_require__(/*! asn1 */ "./node_modules/asn1/lib/index.js");

var ec = __webpack_require__(/*! ecc-jsbn/lib/ec */ "./node_modules/ecc-jsbn/lib/ec.js");
var jsbn = __webpack_require__(/*! jsbn */ "./node_modules/jsbn/index.js").BigInteger;
var nacl = __webpack_require__(/*! tweetnacl */ "./node_modules/tweetnacl/nacl-fast.js");

var MAX_CLASS_DEPTH = 3;

function isCompatible(obj, klass, needVer) {
	if (obj === null || typeof (obj) !== 'object')
		return (false);
	if (needVer === undefined)
		needVer = klass.prototype._sshpkApiVersion;
	if (obj instanceof klass &&
	    klass.prototype._sshpkApiVersion[0] == needVer[0])
		return (true);
	var proto = Object.getPrototypeOf(obj);
	var depth = 0;
	while (proto.constructor.name !== klass.name) {
		proto = Object.getPrototypeOf(proto);
		if (!proto || ++depth > MAX_CLASS_DEPTH)
			return (false);
	}
	if (proto.constructor.name !== klass.name)
		return (false);
	var ver = proto._sshpkApiVersion;
	if (ver === undefined)
		ver = klass._oldVersionDetect(obj);
	if (ver[0] != needVer[0] || ver[1] < needVer[1])
		return (false);
	return (true);
}

function assertCompatible(obj, klass, needVer, name) {
	if (name === undefined)
		name = 'object';
	assert.ok(obj, name + ' must not be null');
	assert.object(obj, name + ' must be an object');
	if (needVer === undefined)
		needVer = klass.prototype._sshpkApiVersion;
	if (obj instanceof klass &&
	    klass.prototype._sshpkApiVersion[0] == needVer[0])
		return;
	var proto = Object.getPrototypeOf(obj);
	var depth = 0;
	while (proto.constructor.name !== klass.name) {
		proto = Object.getPrototypeOf(proto);
		assert.ok(proto && ++depth <= MAX_CLASS_DEPTH,
		    name + ' must be a ' + klass.name + ' instance');
	}
	assert.strictEqual(proto.constructor.name, klass.name,
	    name + ' must be a ' + klass.name + ' instance');
	var ver = proto._sshpkApiVersion;
	if (ver === undefined)
		ver = klass._oldVersionDetect(obj);
	assert.ok(ver[0] == needVer[0] && ver[1] >= needVer[1],
	    name + ' must be compatible with ' + klass.name + ' klass ' +
	    'version ' + needVer[0] + '.' + needVer[1]);
}

var CIPHER_LEN = {
	'des-ede3-cbc': { key: 24, iv: 8 },
	'aes-128-cbc': { key: 16, iv: 16 },
	'aes-256-cbc': { key: 32, iv: 16 }
};
var PKCS5_SALT_LEN = 8;

function opensslKeyDeriv(cipher, salt, passphrase, count) {
	assert.buffer(salt, 'salt');
	assert.buffer(passphrase, 'passphrase');
	assert.number(count, 'iteration count');

	var clen = CIPHER_LEN[cipher];
	assert.object(clen, 'supported cipher');

	salt = salt.slice(0, PKCS5_SALT_LEN);

	var D, D_prev, bufs;
	var material = Buffer.alloc(0);
	while (material.length < clen.key + clen.iv) {
		bufs = [];
		if (D_prev)
			bufs.push(D_prev);
		bufs.push(passphrase);
		bufs.push(salt);
		D = Buffer.concat(bufs);
		for (var j = 0; j < count; ++j)
			D = crypto.createHash('md5').update(D).digest();
		material = Buffer.concat([material, D]);
		D_prev = D;
	}

	return ({
	    key: material.slice(0, clen.key),
	    iv: material.slice(clen.key, clen.key + clen.iv)
	});
}

/* See: RFC2898 */
function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
	var hkey = Buffer.alloc(salt.length + 4);
	salt.copy(hkey);

	var gen = 0, ts = [];
	var i = 1;
	while (gen < size) {
		var t = T(i++);
		gen += t.length;
		ts.push(t);
	}
	return (Buffer.concat(ts).slice(0, size));

	function T(I) {
		hkey.writeUInt32BE(I, hkey.length - 4);

		var hmac = crypto.createHmac(hashAlg, passphrase);
		hmac.update(hkey);

		var Ti = hmac.digest();
		var Uc = Ti;
		var c = 1;
		while (c++ < iterations) {
			hmac = crypto.createHmac(hashAlg, passphrase);
			hmac.update(Uc);
			Uc = hmac.digest();
			for (var x = 0; x < Ti.length; ++x)
				Ti[x] ^= Uc[x];
		}
		return (Ti);
	}
}

/* Count leading zero bits on a buffer */
function countZeros(buf) {
	var o = 0, obit = 8;
	while (o < buf.length) {
		var mask = (1 << obit);
		if ((buf[o] & mask) === mask)
			break;
		obit--;
		if (obit < 0) {
			o++;
			obit = 8;
		}
	}
	return (o*8 + (8 - obit) - 1);
}

function bufferSplit(buf, chr) {
	assert.buffer(buf);
	assert.string(chr);

	var parts = [];
	var lastPart = 0;
	var matches = 0;
	for (var i = 0; i < buf.length; ++i) {
		if (buf[i] === chr.charCodeAt(matches))
			++matches;
		else if (buf[i] === chr.charCodeAt(0))
			matches = 1;
		else
			matches = 0;

		if (matches >= chr.length) {
			var newPart = i + 1;
			parts.push(buf.slice(lastPart, newPart - matches));
			lastPart = newPart;
			matches = 0;
		}
	}
	if (lastPart <= buf.length)
		parts.push(buf.slice(lastPart, buf.length));

	return (parts);
}

function ecNormalize(buf, addZero) {
	assert.buffer(buf);
	if (buf[0] === 0x00 && buf[1] === 0x04) {
		if (addZero)
			return (buf);
		return (buf.slice(1));
	} else if (buf[0] === 0x04) {
		if (!addZero)
			return (buf);
	} else {
		while (buf[0] === 0x00)
			buf = buf.slice(1);
		if (buf[0] === 0x02 || buf[0] === 0x03)
			throw (new Error('Compressed elliptic curve points ' +
			    'are not supported'));
		if (buf[0] !== 0x04)
			throw (new Error('Not a valid elliptic curve point'));
		if (!addZero)
			return (buf);
	}
	var b = Buffer.alloc(buf.length + 1);
	b[0] = 0x0;
	buf.copy(b, 1);
	return (b);
}

function readBitString(der, tag) {
	if (tag === undefined)
		tag = asn1.Ber.BitString;
	var buf = der.readString(tag, true);
	assert.strictEqual(buf[0], 0x00, 'bit strings with unused bits are ' +
	    'not supported (0x' + buf[0].toString(16) + ')');
	return (buf.slice(1));
}

function writeBitString(der, buf, tag) {
	if (tag === undefined)
		tag = asn1.Ber.BitString;
	var b = Buffer.alloc(buf.length + 1);
	b[0] = 0x00;
	buf.copy(b, 1);
	der.writeBuffer(b, tag);
}

function mpNormalize(buf) {
	assert.buffer(buf);
	while (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) === 0x00)
		buf = buf.slice(1);
	if ((buf[0] & 0x80) === 0x80) {
		var b = Buffer.alloc(buf.length + 1);
		b[0] = 0x00;
		buf.copy(b, 1);
		buf = b;
	}
	return (buf);
}

function mpDenormalize(buf) {
	assert.buffer(buf);
	while (buf.length > 1 && buf[0] === 0x00)
		buf = buf.slice(1);
	return (buf);
}

function zeroPadToLength(buf, len) {
	assert.buffer(buf);
	assert.number(len);
	while (buf.length > len) {
		assert.equal(buf[0], 0x00);
		buf = buf.slice(1);
	}
	while (buf.length < len) {
		var b = Buffer.alloc(buf.length + 1);
		b[0] = 0x00;
		buf.copy(b, 1);
		buf = b;
	}
	return (buf);
}

function bigintToMpBuf(bigint) {
	var buf = Buffer.from(bigint.toByteArray());
	buf = mpNormalize(buf);
	return (buf);
}

function calculateDSAPublic(g, p, x) {
	assert.buffer(g);
	assert.buffer(p);
	assert.buffer(x);
	g = new jsbn(g);
	p = new jsbn(p);
	x = new jsbn(x);
	var y = g.modPow(x, p);
	var ybuf = bigintToMpBuf(y);
	return (ybuf);
}

function calculateED25519Public(k) {
	assert.buffer(k);

	var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
	return (Buffer.from(kp.publicKey));
}

function calculateX25519Public(k) {
	assert.buffer(k);

	var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
	return (Buffer.from(kp.publicKey));
}

function addRSAMissing(key) {
	assert.object(key);
	assertCompatible(key, PrivateKey, [1, 1]);

	var d = new jsbn(key.part.d.data);
	var buf;

	if (!key.part.dmodp) {
		var p = new jsbn(key.part.p.data);
		var dmodp = d.mod(p.subtract(1));

		buf = bigintToMpBuf(dmodp);
		key.part.dmodp = {name: 'dmodp', data: buf};
		key.parts.push(key.part.dmodp);
	}
	if (!key.part.dmodq) {
		var q = new jsbn(key.part.q.data);
		var dmodq = d.mod(q.subtract(1));

		buf = bigintToMpBuf(dmodq);
		key.part.dmodq = {name: 'dmodq', data: buf};
		key.parts.push(key.part.dmodq);
	}
}

function publicFromPrivateECDSA(curveName, priv) {
	assert.string(curveName, 'curveName');
	assert.buffer(priv);
	var params = algs.curves[curveName];
	var p = new jsbn(params.p);
	var a = new jsbn(params.a);
	var b = new jsbn(params.b);
	var curve = new ec.ECCurveFp(p, a, b);
	var G = curve.decodePointHex(params.G.toString('hex'));

	var d = new jsbn(mpNormalize(priv));
	var pub = G.multiply(d);
	pub = Buffer.from(curve.encodePointHex(pub), 'hex');

	var parts = [];
	parts.push({name: 'curve', data: Buffer.from(curveName)});
	parts.push({name: 'Q', data: pub});

	var key = new Key({type: 'ecdsa', curve: curve, parts: parts});
	return (key);
}

function opensshCipherInfo(cipher) {
	var inf = {};
	switch (cipher) {
	case '3des-cbc':
		inf.keySize = 24;
		inf.blockSize = 8;
		inf.opensslName = 'des-ede3-cbc';
		break;
	case 'blowfish-cbc':
		inf.keySize = 16;
		inf.blockSize = 8;
		inf.opensslName = 'bf-cbc';
		break;
	case 'aes128-cbc':
	case 'aes128-ctr':
	case 'aes128-gcm@openssh.com':
		inf.keySize = 16;
		inf.blockSize = 16;
		inf.opensslName = 'aes-128-' + cipher.slice(7, 10);
		break;
	case 'aes192-cbc':
	case 'aes192-ctr':
	case 'aes192-gcm@openssh.com':
		inf.keySize = 24;
		inf.blockSize = 16;
		inf.opensslName = 'aes-192-' + cipher.slice(7, 10);
		break;
	case 'aes256-cbc':
	case 'aes256-ctr':
	case 'aes256-gcm@openssh.com':
		inf.keySize = 32;
		inf.blockSize = 16;
		inf.opensslName = 'aes-256-' + cipher.slice(7, 10);
		break;
	default:
		throw (new Error(
		    'Unsupported openssl cipher "' + cipher + '"'));
	}
	return (inf);
}


/***/ }),

/***/ "./node_modules/tough-cookie/lib/cookie.js":
/*!*************************************************!*\
  !*** ./node_modules/tough-cookie/lib/cookie.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var net = __webpack_require__(/*! net */ "net");
var urlParse = __webpack_require__(/*! url */ "url").parse;
var util = __webpack_require__(/*! util */ "util");
var pubsuffix = __webpack_require__(/*! ./pubsuffix-psl */ "./node_modules/tough-cookie/lib/pubsuffix-psl.js");
var Store = __webpack_require__(/*! ./store */ "./node_modules/tough-cookie/lib/store.js").Store;
var MemoryCookieStore = __webpack_require__(/*! ./memstore */ "./node_modules/tough-cookie/lib/memstore.js").MemoryCookieStore;
var pathMatch = __webpack_require__(/*! ./pathMatch */ "./node_modules/tough-cookie/lib/pathMatch.js").pathMatch;
var VERSION = __webpack_require__(/*! ../package.json */ "./node_modules/tough-cookie/package.json").version;

var punycode;
try {
  punycode = __webpack_require__(/*! punycode */ "punycode");
} catch(e) {
  console.warn("tough-cookie: can't load punycode; won't use punycode for domain normalization");
}

// From RFC6265 S4.1.1
// note that it excludes \x3B ";"
var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;

var CONTROL_CHARS = /[\x00-\x1F]/;

// From Chromium // '\r', '\n' and '\0' should be treated as a terminator in
// the "relaxed" mode, see:
// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60
var TERMINATORS = ['\n', '\r', '\0'];

// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
// Note ';' is \x3B
var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;

// date-time parsing constants (RFC6265 S5.1.1)

var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;

var MONTH_TO_NUM = {
  jan:0, feb:1, mar:2, apr:3, may:4, jun:5,
  jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
};
var NUM_TO_MONTH = [
  'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'
];
var NUM_TO_DAY = [
  'Sun','Mon','Tue','Wed','Thu','Fri','Sat'
];

var MAX_TIME = 2147483647000; // 31-bit max
var MIN_TIME = 0; // 31-bit min

/*
 * Parses a Natural number (i.e., non-negative integer) with either the
 *    <min>*<max>DIGIT ( non-digit *OCTET )
 * or
 *    <min>*<max>DIGIT
 * grammar (RFC6265 S5.1.1).
 *
 * The "trailingOK" boolean controls if the grammar accepts a
 * "( non-digit *OCTET )" trailer.
 */
function parseDigits(token, minDigits, maxDigits, trailingOK) {
  var count = 0;
  while (count < token.length) {
    var c = token.charCodeAt(count);
    // "non-digit = %x00-2F / %x3A-FF"
    if (c <= 0x2F || c >= 0x3A) {
      break;
    }
    count++;
  }

  // constrain to a minimum and maximum number of digits.
  if (count < minDigits || count > maxDigits) {
    return null;
  }

  if (!trailingOK && count != token.length) {
    return null;
  }

  return parseInt(token.substr(0,count), 10);
}

function parseTime(token) {
  var parts = token.split(':');
  var result = [0,0,0];

  /* RF6256 S5.1.1:
   *      time            = hms-time ( non-digit *OCTET )
   *      hms-time        = time-field ":" time-field ":" time-field
   *      time-field      = 1*2DIGIT
   */

  if (parts.length !== 3) {
    return null;
  }

  for (var i = 0; i < 3; i++) {
    // "time-field" must be strictly "1*2DIGIT", HOWEVER, "hms-time" can be
    // followed by "( non-digit *OCTET )" so therefore the last time-field can
    // have a trailer
    var trailingOK = (i == 2);
    var num = parseDigits(parts[i], 1, 2, trailingOK);
    if (num === null) {
      return null;
    }
    result[i] = num;
  }

  return result;
}

function parseMonth(token) {
  token = String(token).substr(0,3).toLowerCase();
  var num = MONTH_TO_NUM[token];
  return num >= 0 ? num : null;
}

/*
 * RFC6265 S5.1.1 date parser (see RFC for full grammar)
 */
function parseDate(str) {
  if (!str) {
    return;
  }

  /* RFC6265 S5.1.1:
   * 2. Process each date-token sequentially in the order the date-tokens
   * appear in the cookie-date
   */
  var tokens = str.split(DATE_DELIM);
  if (!tokens) {
    return;
  }

  var hour = null;
  var minute = null;
  var second = null;
  var dayOfMonth = null;
  var month = null;
  var year = null;

  for (var i=0; i<tokens.length; i++) {
    var token = tokens[i].trim();
    if (!token.length) {
      continue;
    }

    var result;

    /* 2.1. If the found-time flag is not set and the token matches the time
     * production, set the found-time flag and set the hour- value,
     * minute-value, and second-value to the numbers denoted by the digits in
     * the date-token, respectively.  Skip the remaining sub-steps and continue
     * to the next date-token.
     */
    if (second === null) {
      result = parseTime(token);
      if (result) {
        hour = result[0];
        minute = result[1];
        second = result[2];
        continue;
      }
    }

    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
     * the day-of-month production, set the found-day-of- month flag and set
     * the day-of-month-value to the number denoted by the date-token.  Skip
     * the remaining sub-steps and continue to the next date-token.
     */
    if (dayOfMonth === null) {
      // "day-of-month = 1*2DIGIT ( non-digit *OCTET )"
      result = parseDigits(token, 1, 2, true);
      if (result !== null) {
        dayOfMonth = result;
        continue;
      }
    }

    /* 2.3. If the found-month flag is not set and the date-token matches the
     * month production, set the found-month flag and set the month-value to
     * the month denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (month === null) {
      result = parseMonth(token);
      if (result !== null) {
        month = result;
        continue;
      }
    }

    /* 2.4. If the found-year flag is not set and the date-token matches the
     * year production, set the found-year flag and set the year-value to the
     * number denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (year === null) {
      // "year = 2*4DIGIT ( non-digit *OCTET )"
      result = parseDigits(token, 2, 4, true);
      if (result !== null) {
        year = result;
        /* From S5.1.1:
         * 3.  If the year-value is greater than or equal to 70 and less
         * than or equal to 99, increment the year-value by 1900.
         * 4.  If the year-value is greater than or equal to 0 and less
         * than or equal to 69, increment the year-value by 2000.
         */
        if (year >= 70 && year <= 99) {
          year += 1900;
        } else if (year >= 0 && year <= 69) {
          year += 2000;
        }
      }
    }
  }

  /* RFC 6265 S5.1.1
   * "5. Abort these steps and fail to parse the cookie-date if:
   *     *  at least one of the found-day-of-month, found-month, found-
   *        year, or found-time flags is not set,
   *     *  the day-of-month-value is less than 1 or greater than 31,
   *     *  the year-value is less than 1601,
   *     *  the hour-value is greater than 23,
   *     *  the minute-value is greater than 59, or
   *     *  the second-value is greater than 59.
   *     (Note that leap seconds cannot be represented in this syntax.)"
   *
   * So, in order as above:
   */
  if (
    dayOfMonth === null || month === null || year === null || second === null ||
    dayOfMonth < 1 || dayOfMonth > 31 ||
    year < 1601 ||
    hour > 23 ||
    minute > 59 ||
    second > 59
  ) {
    return;
  }

  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
}

function formatDate(date) {
  var d = date.getUTCDate(); d = d >= 10 ? d : '0'+d;
  var h = date.getUTCHours(); h = h >= 10 ? h : '0'+h;
  var m = date.getUTCMinutes(); m = m >= 10 ? m : '0'+m;
  var s = date.getUTCSeconds(); s = s >= 10 ? s : '0'+s;
  return NUM_TO_DAY[date.getUTCDay()] + ', ' +
    d+' '+ NUM_TO_MONTH[date.getUTCMonth()] +' '+ date.getUTCFullYear() +' '+
    h+':'+m+':'+s+' GMT';
}

// S5.1.2 Canonicalized Host Names
function canonicalDomain(str) {
  if (str == null) {
    return null;
  }
  str = str.trim().replace(/^\./,''); // S4.1.2.3 & S5.2.3: ignore leading .

  // convert to IDN if any non-ASCII characters
  if (punycode && /[^\u0001-\u007f]/.test(str)) {
    str = punycode.toASCII(str);
  }

  return str.toLowerCase();
}

// S5.1.3 Domain Matching
function domainMatch(str, domStr, canonicalize) {
  if (str == null || domStr == null) {
    return null;
  }
  if (canonicalize !== false) {
    str = canonicalDomain(str);
    domStr = canonicalDomain(domStr);
  }

  /*
   * "The domain string and the string are identical. (Note that both the
   * domain string and the string will have been canonicalized to lower case at
   * this point)"
   */
  if (str == domStr) {
    return true;
  }

  /* "All of the following [three] conditions hold:" (order adjusted from the RFC) */

  /* "* The string is a host name (i.e., not an IP address)." */
  if (net.isIP(str)) {
    return false;
  }

  /* "* The domain string is a suffix of the string" */
  var idx = str.indexOf(domStr);
  if (idx <= 0) {
    return false; // it's a non-match (-1) or prefix (0)
  }

  // e.g "a.b.c".indexOf("b.c") === 2
  // 5 === 3+2
  if (str.length !== domStr.length + idx) { // it's not a suffix
    return false;
  }

  /* "* The last character of the string that is not included in the domain
  * string is a %x2E (".") character." */
  if (str.substr(idx-1,1) !== '.') {
    return false;
  }

  return true;
}


// RFC6265 S5.1.4 Paths and Path-Match

/*
 * "The user agent MUST use an algorithm equivalent to the following algorithm
 * to compute the default-path of a cookie:"
 *
 * Assumption: the path (and not query part or absolute uri) is passed in.
 */
function defaultPath(path) {
  // "2. If the uri-path is empty or if the first character of the uri-path is not
  // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
  if (!path || path.substr(0,1) !== "/") {
    return "/";
  }

  // "3. If the uri-path contains no more than one %x2F ("/") character, output
  // %x2F ("/") and skip the remaining step."
  if (path === "/") {
    return path;
  }

  var rightSlash = path.lastIndexOf("/");
  if (rightSlash === 0) {
    return "/";
  }

  // "4. Output the characters of the uri-path from the first character up to,
  // but not including, the right-most %x2F ("/")."
  return path.slice(0, rightSlash);
}

function trimTerminator(str) {
  for (var t = 0; t < TERMINATORS.length; t++) {
    var terminatorIdx = str.indexOf(TERMINATORS[t]);
    if (terminatorIdx !== -1) {
      str = str.substr(0,terminatorIdx);
    }
  }

  return str;
}

function parseCookiePair(cookiePair, looseMode) {
  cookiePair = trimTerminator(cookiePair);

  var firstEq = cookiePair.indexOf('=');
  if (looseMode) {
    if (firstEq === 0) { // '=' is immediately at start
      cookiePair = cookiePair.substr(1);
      firstEq = cookiePair.indexOf('='); // might still need to split on '='
    }
  } else { // non-loose mode
    if (firstEq <= 0) { // no '=' or is at start
      return; // needs to have non-empty "cookie-name"
    }
  }

  var cookieName, cookieValue;
  if (firstEq <= 0) {
    cookieName = "";
    cookieValue = cookiePair.trim();
  } else {
    cookieName = cookiePair.substr(0, firstEq).trim();
    cookieValue = cookiePair.substr(firstEq+1).trim();
  }

  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
    return;
  }

  var c = new Cookie();
  c.key = cookieName;
  c.value = cookieValue;
  return c;
}

function parse(str, options) {
  if (!options || typeof options !== 'object') {
    options = {};
  }
  str = str.trim();

  // We use a regex to parse the "name-value-pair" part of S5.2
  var firstSemi = str.indexOf(';'); // S5.2 step 1
  var cookiePair = (firstSemi === -1) ? str : str.substr(0, firstSemi);
  var c = parseCookiePair(cookiePair, !!options.loose);
  if (!c) {
    return;
  }

  if (firstSemi === -1) {
    return c;
  }

  // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
  // (including the %x3B (";") in question)." plus later on in the same section
  // "discard the first ";" and trim".
  var unparsed = str.slice(firstSemi + 1).trim();

  // "If the unparsed-attributes string is empty, skip the rest of these
  // steps."
  if (unparsed.length === 0) {
    return c;
  }

  /*
   * S5.2 says that when looping over the items "[p]rocess the attribute-name
   * and attribute-value according to the requirements in the following
   * subsections" for every item.  Plus, for many of the individual attributes
   * in S5.3 it says to use the "attribute-value of the last attribute in the
   * cookie-attribute-list".  Therefore, in this implementation, we overwrite
   * the previous value.
   */
  var cookie_avs = unparsed.split(';');
  while (cookie_avs.length) {
    var av = cookie_avs.shift().trim();
    if (av.length === 0) { // happens if ";;" appears
      continue;
    }
    var av_sep = av.indexOf('=');
    var av_key, av_value;

    if (av_sep === -1) {
      av_key = av;
      av_value = null;
    } else {
      av_key = av.substr(0,av_sep);
      av_value = av.substr(av_sep+1);
    }

    av_key = av_key.trim().toLowerCase();

    if (av_value) {
      av_value = av_value.trim();
    }

    switch(av_key) {
    case 'expires': // S5.2.1
      if (av_value) {
        var exp = parseDate(av_value);
        // "If the attribute-value failed to parse as a cookie date, ignore the
        // cookie-av."
        if (exp) {
          // over and underflow not realistically a concern: V8's getTime() seems to
          // store something larger than a 32-bit time_t (even with 32-bit node)
          c.expires = exp;
        }
      }
      break;

    case 'max-age': // S5.2.2
      if (av_value) {
        // "If the first character of the attribute-value is not a DIGIT or a "-"
        // character ...[or]... If the remainder of attribute-value contains a
        // non-DIGIT character, ignore the cookie-av."
        if (/^-?[0-9]+$/.test(av_value)) {
          var delta = parseInt(av_value, 10);
          // "If delta-seconds is less than or equal to zero (0), let expiry-time
          // be the earliest representable date and time."
          c.setMaxAge(delta);
        }
      }
      break;

    case 'domain': // S5.2.3
      // "If the attribute-value is empty, the behavior is undefined.  However,
      // the user agent SHOULD ignore the cookie-av entirely."
      if (av_value) {
        // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
        // (".") character."
        var domain = av_value.trim().replace(/^\./, '');
        if (domain) {
          // "Convert the cookie-domain to lower case."
          c.domain = domain.toLowerCase();
        }
      }
      break;

    case 'path': // S5.2.4
      /*
       * "If the attribute-value is empty or if the first character of the
       * attribute-value is not %x2F ("/"):
       *   Let cookie-path be the default-path.
       * Otherwise:
       *   Let cookie-path be the attribute-value."
       *
       * We'll represent the default-path as null since it depends on the
       * context of the parsing.
       */
      c.path = av_value && av_value[0] === "/" ? av_value : null;
      break;

    case 'secure': // S5.2.5
      /*
       * "If the attribute-name case-insensitively matches the string "Secure",
       * the user agent MUST append an attribute to the cookie-attribute-list
       * with an attribute-name of Secure and an empty attribute-value."
       */
      c.secure = true;
      break;

    case 'httponly': // S5.2.6 -- effectively the same as 'secure'
      c.httpOnly = true;
      break;

    default:
      c.extensions = c.extensions || [];
      c.extensions.push(av);
      break;
    }
  }

  return c;
}

// avoid the V8 deoptimization monster!
function jsonParse(str) {
  var obj;
  try {
    obj = JSON.parse(str);
  } catch (e) {
    return e;
  }
  return obj;
}

function fromJSON(str) {
  if (!str) {
    return null;
  }

  var obj;
  if (typeof str === 'string') {
    obj = jsonParse(str);
    if (obj instanceof Error) {
      return null;
    }
  } else {
    // assume it's an Object
    obj = str;
  }

  var c = new Cookie();
  for (var i=0; i<Cookie.serializableProperties.length; i++) {
    var prop = Cookie.serializableProperties[i];
    if (obj[prop] === undefined ||
        obj[prop] === Cookie.prototype[prop])
    {
      continue; // leave as prototype default
    }

    if (prop === 'expires' ||
        prop === 'creation' ||
        prop === 'lastAccessed')
    {
      if (obj[prop] === null) {
        c[prop] = null;
      } else {
        c[prop] = obj[prop] == "Infinity" ?
          "Infinity" : new Date(obj[prop]);
      }
    } else {
      c[prop] = obj[prop];
    }
  }

  return c;
}

/* Section 5.4 part 2:
 * "*  Cookies with longer paths are listed before cookies with
 *     shorter paths.
 *
 *  *  Among cookies that have equal-length path fields, cookies with
 *     earlier creation-times are listed before cookies with later
 *     creation-times."
 */

function cookieCompare(a,b) {
  var cmp = 0;

  // descending for length: b CMP a
  var aPathLen = a.path ? a.path.length : 0;
  var bPathLen = b.path ? b.path.length : 0;
  cmp = bPathLen - aPathLen;
  if (cmp !== 0) {
    return cmp;
  }

  // ascending for time: a CMP b
  var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
  var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
  cmp = aTime - bTime;
  if (cmp !== 0) {
    return cmp;
  }

  // break ties for the same millisecond (precision of JavaScript's clock)
  cmp = a.creationIndex - b.creationIndex;

  return cmp;
}

// Gives the permutation of all possible pathMatch()es of a given path. The
// array is in longest-to-shortest order.  Handy for indexing.
function permutePath(path) {
  if (path === '/') {
    return ['/'];
  }
  if (path.lastIndexOf('/') === path.length-1) {
    path = path.substr(0,path.length-1);
  }
  var permutations = [path];
  while (path.length > 1) {
    var lindex = path.lastIndexOf('/');
    if (lindex === 0) {
      break;
    }
    path = path.substr(0,lindex);
    permutations.push(path);
  }
  permutations.push('/');
  return permutations;
}

function getCookieContext(url) {
  if (url instanceof Object) {
    return url;
  }
  // NOTE: decodeURI will throw on malformed URIs (see GH-32).
  // Therefore, we will just skip decoding for such URIs.
  try {
    url = decodeURI(url);
  }
  catch(err) {
    // Silently swallow error
  }

  return urlParse(url);
}

function Cookie(options) {
  options = options || {};

  Object.keys(options).forEach(function(prop) {
    if (Cookie.prototype.hasOwnProperty(prop) &&
        Cookie.prototype[prop] !== options[prop] &&
        prop.substr(0,1) !== '_')
    {
      this[prop] = options[prop];
    }
  }, this);

  this.creation = this.creation || new Date();

  // used to break creation ties in cookieCompare():
  Object.defineProperty(this, 'creationIndex', {
    configurable: false,
    enumerable: false, // important for assert.deepEqual checks
    writable: true,
    value: ++Cookie.cookiesCreated
  });
}

Cookie.cookiesCreated = 0; // incremented each time a cookie is created

Cookie.parse = parse;
Cookie.fromJSON = fromJSON;

Cookie.prototype.key = "";
Cookie.prototype.value = "";

// the order in which the RFC has them:
Cookie.prototype.expires = "Infinity"; // coerces to literal Infinity
Cookie.prototype.maxAge = null; // takes precedence over expires for TTL
Cookie.prototype.domain = null;
Cookie.prototype.path = null;
Cookie.prototype.secure = false;
Cookie.prototype.httpOnly = false;
Cookie.prototype.extensions = null;

// set by the CookieJar:
Cookie.prototype.hostOnly = null; // boolean when set
Cookie.prototype.pathIsDefault = null; // boolean when set
Cookie.prototype.creation = null; // Date when set; defaulted by Cookie.parse
Cookie.prototype.lastAccessed = null; // Date when set
Object.defineProperty(Cookie.prototype, 'creationIndex', {
  configurable: true,
  enumerable: false,
  writable: true,
  value: 0
});

Cookie.serializableProperties = Object.keys(Cookie.prototype)
  .filter(function(prop) {
    return !(
      Cookie.prototype[prop] instanceof Function ||
      prop === 'creationIndex' ||
      prop.substr(0,1) === '_'
    );
  });

Cookie.prototype.inspect = function inspect() {
  var now = Date.now();
  return 'Cookie="'+this.toString() +
    '; hostOnly='+(this.hostOnly != null ? this.hostOnly : '?') +
    '; aAge='+(this.lastAccessed ? (now-this.lastAccessed.getTime())+'ms' : '?') +
    '; cAge='+(this.creation ? (now-this.creation.getTime())+'ms' : '?') +
    '"';
};

// Use the new custom inspection symbol to add the custom inspect function if
// available.
if (util.inspect.custom) {
  Cookie.prototype[util.inspect.custom] = Cookie.prototype.inspect;
}

Cookie.prototype.toJSON = function() {
  var obj = {};

  var props = Cookie.serializableProperties;
  for (var i=0; i<props.length; i++) {
    var prop = props[i];
    if (this[prop] === Cookie.prototype[prop]) {
      continue; // leave as prototype default
    }

    if (prop === 'expires' ||
        prop === 'creation' ||
        prop === 'lastAccessed')
    {
      if (this[prop] === null) {
        obj[prop] = null;
      } else {
        obj[prop] = this[prop] == "Infinity" ? // intentionally not ===
          "Infinity" : this[prop].toISOString();
      }
    } else if (prop === 'maxAge') {
      if (this[prop] !== null) {
        // again, intentionally not ===
        obj[prop] = (this[prop] == Infinity || this[prop] == -Infinity) ?
          this[prop].toString() : this[prop];
      }
    } else {
      if (this[prop] !== Cookie.prototype[prop]) {
        obj[prop] = this[prop];
      }
    }
  }

  return obj;
};

Cookie.prototype.clone = function() {
  return fromJSON(this.toJSON());
};

Cookie.prototype.validate = function validate() {
  if (!COOKIE_OCTETS.test(this.value)) {
    return false;
  }
  if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
    return false;
  }
  if (this.maxAge != null && this.maxAge <= 0) {
    return false; // "Max-Age=" non-zero-digit *DIGIT
  }
  if (this.path != null && !PATH_VALUE.test(this.path)) {
    return false;
  }

  var cdomain = this.cdomain();
  if (cdomain) {
    if (cdomain.match(/\.$/)) {
      return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
    }
    var suffix = pubsuffix.getPublicSuffix(cdomain);
    if (suffix == null) { // it's a public suffix
      return false;
    }
  }
  return true;
};

Cookie.prototype.setExpires = function setExpires(exp) {
  if (exp instanceof Date) {
    this.expires = exp;
  } else {
    this.expires = parseDate(exp) || "Infinity";
  }
};

Cookie.prototype.setMaxAge = function setMaxAge(age) {
  if (age === Infinity || age === -Infinity) {
    this.maxAge = age.toString(); // so JSON.stringify() works
  } else {
    this.maxAge = age;
  }
};

// gives Cookie header format
Cookie.prototype.cookieString = function cookieString() {
  var val = this.value;
  if (val == null) {
    val = '';
  }
  if (this.key === '') {
    return val;
  }
  return this.key+'='+val;
};

// gives Set-Cookie header format
Cookie.prototype.toString = function toString() {
  var str = this.cookieString();

  if (this.expires != Infinity) {
    if (this.expires instanceof Date) {
      str += '; Expires='+formatDate(this.expires);
    } else {
      str += '; Expires='+this.expires;
    }
  }

  if (this.maxAge != null && this.maxAge != Infinity) {
    str += '; Max-Age='+this.maxAge;
  }

  if (this.domain && !this.hostOnly) {
    str += '; Domain='+this.domain;
  }
  if (this.path) {
    str += '; Path='+this.path;
  }

  if (this.secure) {
    str += '; Secure';
  }
  if (this.httpOnly) {
    str += '; HttpOnly';
  }
  if (this.extensions) {
    this.extensions.forEach(function(ext) {
      str += '; '+ext;
    });
  }

  return str;
};

// TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
// elsewhere)
// S5.3 says to give the "latest representable date" for which we use Infinity
// For "expired" we use 0
Cookie.prototype.TTL = function TTL(now) {
  /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
   * attribute, the Max-Age attribute has precedence and controls the
   * expiration date of the cookie.
   * (Concurs with S5.3 step 3)
   */
  if (this.maxAge != null) {
    return this.maxAge<=0 ? 0 : this.maxAge*1000;
  }

  var expires = this.expires;
  if (expires != Infinity) {
    if (!(expires instanceof Date)) {
      expires = parseDate(expires) || Infinity;
    }

    if (expires == Infinity) {
      return Infinity;
    }

    return expires.getTime() - (now || Date.now());
  }

  return Infinity;
};

// expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
// elsewhere)
Cookie.prototype.expiryTime = function expiryTime(now) {
  if (this.maxAge != null) {
    var relativeTo = now || this.creation || new Date();
    var age = (this.maxAge <= 0) ? -Infinity : this.maxAge*1000;
    return relativeTo.getTime() + age;
  }

  if (this.expires == Infinity) {
    return Infinity;
  }
  return this.expires.getTime();
};

// expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
// elsewhere), except it returns a Date
Cookie.prototype.expiryDate = function expiryDate(now) {
  var millisec = this.expiryTime(now);
  if (millisec == Infinity) {
    return new Date(MAX_TIME);
  } else if (millisec == -Infinity) {
    return new Date(MIN_TIME);
  } else {
    return new Date(millisec);
  }
};

// This replaces the "persistent-flag" parts of S5.3 step 3
Cookie.prototype.isPersistent = function isPersistent() {
  return (this.maxAge != null || this.expires != Infinity);
};

// Mostly S5.1.2 and S5.2.3:
Cookie.prototype.cdomain =
Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
  if (this.domain == null) {
    return null;
  }
  return canonicalDomain(this.domain);
};

function CookieJar(store, options) {
  if (typeof options === "boolean") {
    options = {rejectPublicSuffixes: options};
  } else if (options == null) {
    options = {};
  }
  if (options.rejectPublicSuffixes != null) {
    this.rejectPublicSuffixes = options.rejectPublicSuffixes;
  }
  if (options.looseMode != null) {
    this.enableLooseMode = options.looseMode;
  }

  if (!store) {
    store = new MemoryCookieStore();
  }
  this.store = store;
}
CookieJar.prototype.store = null;
CookieJar.prototype.rejectPublicSuffixes = true;
CookieJar.prototype.enableLooseMode = false;
var CAN_BE_SYNC = [];

CAN_BE_SYNC.push('setCookie');
CookieJar.prototype.setCookie = function(cookie, url, options, cb) {
  var err;
  var context = getCookieContext(url);
  if (options instanceof Function) {
    cb = options;
    options = {};
  }

  var host = canonicalDomain(context.hostname);
  var loose = this.enableLooseMode;
  if (options.loose != null) {
    loose = options.loose;
  }

  // S5.3 step 1
  if (!(cookie instanceof Cookie)) {
    cookie = Cookie.parse(cookie, { loose: loose });
  }
  if (!cookie) {
    err = new Error("Cookie failed to parse");
    return cb(options.ignoreError ? null : err);
  }

  // S5.3 step 2
  var now = options.now || new Date(); // will assign later to save effort in the face of errors

  // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()

  // S5.3 step 4: NOOP; domain is null by default

  // S5.3 step 5: public suffixes
  if (this.rejectPublicSuffixes && cookie.domain) {
    var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
    if (suffix == null) { // e.g. "com"
      err = new Error("Cookie has domain set to a public suffix");
      return cb(options.ignoreError ? null : err);
    }
  }

  // S5.3 step 6:
  if (cookie.domain) {
    if (!domainMatch(host, cookie.cdomain(), false)) {
      err = new Error("Cookie not in this host's domain. Cookie:"+cookie.cdomain()+" Request:"+host);
      return cb(options.ignoreError ? null : err);
    }

    if (cookie.hostOnly == null) { // don't reset if already set
      cookie.hostOnly = false;
    }

  } else {
    cookie.hostOnly = true;
    cookie.domain = host;
  }

  //S5.2.4 If the attribute-value is empty or if the first character of the
  //attribute-value is not %x2F ("/"):
  //Let cookie-path be the default-path.
  if (!cookie.path || cookie.path[0] !== '/') {
    cookie.path = defaultPath(context.pathname);
    cookie.pathIsDefault = true;
  }

  // S5.3 step 8: NOOP; secure attribute
  // S5.3 step 9: NOOP; httpOnly attribute

  // S5.3 step 10
  if (options.http === false && cookie.httpOnly) {
    err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
    return cb(options.ignoreError ? null : err);
  }

  var store = this.store;

  if (!store.updateCookie) {
    store.updateCookie = function(oldCookie, newCookie, cb) {
      this.putCookie(newCookie, cb);
    };
  }

  function withCookie(err, oldCookie) {
    if (err) {
      return cb(err);
    }

    var next = function(err) {
      if (err) {
        return cb(err);
      } else {
        cb(null, cookie);
      }
    };

    if (oldCookie) {
      // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
      // domain, and path as the newly created cookie:"
      if (options.http === false && oldCookie.httpOnly) { // step 11.2
        err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
        return cb(options.ignoreError ? null : err);
      }
      cookie.creation = oldCookie.creation; // step 11.3
      cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
      cookie.lastAccessed = now;
      // Step 11.4 (delete cookie) is implied by just setting the new one:
      store.updateCookie(oldCookie, cookie, next); // step 12

    } else {
      cookie.creation = cookie.lastAccessed = now;
      store.putCookie(cookie, next); // step 12
    }
  }

  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
};

// RFC6365 S5.4
CAN_BE_SYNC.push('getCookies');
CookieJar.prototype.getCookies = function(url, options, cb) {
  var context = getCookieContext(url);
  if (options instanceof Function) {
    cb = options;
    options = {};
  }

  var host = canonicalDomain(context.hostname);
  var path = context.pathname || '/';

  var secure = options.secure;
  if (secure == null && context.protocol &&
      (context.protocol == 'https:' || context.protocol == 'wss:'))
  {
    secure = true;
  }

  var http = options.http;
  if (http == null) {
    http = true;
  }

  var now = options.now || Date.now();
  var expireCheck = options.expire !== false;
  var allPaths = !!options.allPaths;
  var store = this.store;

  function matchingCookie(c) {
    // "Either:
    //   The cookie's host-only-flag is true and the canonicalized
    //   request-host is identical to the cookie's domain.
    // Or:
    //   The cookie's host-only-flag is false and the canonicalized
    //   request-host domain-matches the cookie's domain."
    if (c.hostOnly) {
      if (c.domain != host) {
        return false;
      }
    } else {
      if (!domainMatch(host, c.domain, false)) {
        return false;
      }
    }

    // "The request-uri's path path-matches the cookie's path."
    if (!allPaths && !pathMatch(path, c.path)) {
      return false;
    }

    // "If the cookie's secure-only-flag is true, then the request-uri's
    // scheme must denote a "secure" protocol"
    if (c.secure && !secure) {
      return false;
    }

    // "If the cookie's http-only-flag is true, then exclude the cookie if the
    // cookie-string is being generated for a "non-HTTP" API"
    if (c.httpOnly && !http) {
      return false;
    }

    // deferred from S5.3
    // non-RFC: allow retention of expired cookies by choice
    if (expireCheck && c.expiryTime() <= now) {
      store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored
      return false;
    }

    return true;
  }

  store.findCookies(host, allPaths ? null : path, function(err,cookies) {
    if (err) {
      return cb(err);
    }

    cookies = cookies.filter(matchingCookie);

    // sorting of S5.4 part 2
    if (options.sort !== false) {
      cookies = cookies.sort(cookieCompare);
    }

    // S5.4 part 3
    var now = new Date();
    cookies.forEach(function(c) {
      c.lastAccessed = now;
    });
    // TODO persist lastAccessed

    cb(null,cookies);
  });
};

CAN_BE_SYNC.push('getCookieString');
CookieJar.prototype.getCookieString = function(/*..., cb*/) {
  var args = Array.prototype.slice.call(arguments,0);
  var cb = args.pop();
  var next = function(err,cookies) {
    if (err) {
      cb(err);
    } else {
      cb(null, cookies
        .sort(cookieCompare)
        .map(function(c){
          return c.cookieString();
        })
        .join('; '));
    }
  };
  args.push(next);
  this.getCookies.apply(this,args);
};

CAN_BE_SYNC.push('getSetCookieStrings');
CookieJar.prototype.getSetCookieStrings = function(/*..., cb*/) {
  var args = Array.prototype.slice.call(arguments,0);
  var cb = args.pop();
  var next = function(err,cookies) {
    if (err) {
      cb(err);
    } else {
      cb(null, cookies.map(function(c){
        return c.toString();
      }));
    }
  };
  args.push(next);
  this.getCookies.apply(this,args);
};

CAN_BE_SYNC.push('serialize');
CookieJar.prototype.serialize = function(cb) {
  var type = this.store.constructor.name;
  if (type === 'Object') {
    type = null;
  }

  // update README.md "Serialization Format" if you change this, please!
  var serialized = {
    // The version of tough-cookie that serialized this jar. Generally a good
    // practice since future versions can make data import decisions based on
    // known past behavior. When/if this matters, use `semver`.
    version: 'tough-cookie@'+VERSION,

    // add the store type, to make humans happy:
    storeType: type,

    // CookieJar configuration:
    rejectPublicSuffixes: !!this.rejectPublicSuffixes,

    // this gets filled from getAllCookies:
    cookies: []
  };

  if (!(this.store.getAllCookies &&
        typeof this.store.getAllCookies === 'function'))
  {
    return cb(new Error('store does not support getAllCookies and cannot be serialized'));
  }

  this.store.getAllCookies(function(err,cookies) {
    if (err) {
      return cb(err);
    }

    serialized.cookies = cookies.map(function(cookie) {
      // convert to serialized 'raw' cookies
      cookie = (cookie instanceof Cookie) ? cookie.toJSON() : cookie;

      // Remove the index so new ones get assigned during deserialization
      delete cookie.creationIndex;

      return cookie;
    });

    return cb(null, serialized);
  });
};

// well-known name that JSON.stringify calls
CookieJar.prototype.toJSON = function() {
  return this.serializeSync();
};

// use the class method CookieJar.deserialize instead of calling this directly
CAN_BE_SYNC.push('_importCookies');
CookieJar.prototype._importCookies = function(serialized, cb) {
  var jar = this;
  var cookies = serialized.cookies;
  if (!cookies || !Array.isArray(cookies)) {
    return cb(new Error('serialized jar has no cookies array'));
  }
  cookies = cookies.slice(); // do not modify the original

  function putNext(err) {
    if (err) {
      return cb(err);
    }

    if (!cookies.length) {
      return cb(err, jar);
    }

    var cookie;
    try {
      cookie = fromJSON(cookies.shift());
    } catch (e) {
      return cb(e);
    }

    if (cookie === null) {
      return putNext(null); // skip this cookie
    }

    jar.store.putCookie(cookie, putNext);
  }

  putNext();
};

CookieJar.deserialize = function(strOrObj, store, cb) {
  if (arguments.length !== 3) {
    // store is optional
    cb = store;
    store = null;
  }

  var serialized;
  if (typeof strOrObj === 'string') {
    serialized = jsonParse(strOrObj);
    if (serialized instanceof Error) {
      return cb(serialized);
    }
  } else {
    serialized = strOrObj;
  }

  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
  jar._importCookies(serialized, function(err) {
    if (err) {
      return cb(err);
    }
    cb(null, jar);
  });
};

CookieJar.deserializeSync = function(strOrObj, store) {
  var serialized = typeof strOrObj === 'string' ?
    JSON.parse(strOrObj) : strOrObj;
  var jar = new CookieJar(store, serialized.rejectPublicSuffixes);

  // catch this mistake early:
  if (!jar.store.synchronous) {
    throw new Error('CookieJar store is not synchronous; use async API instead.');
  }

  jar._importCookiesSync(serialized);
  return jar;
};
CookieJar.fromJSON = CookieJar.deserializeSync;

CAN_BE_SYNC.push('clone');
CookieJar.prototype.clone = function(newStore, cb) {
  if (arguments.length === 1) {
    cb = newStore;
    newStore = null;
  }

  this.serialize(function(err,serialized) {
    if (err) {
      return cb(err);
    }
    CookieJar.deserialize(newStore, serialized, cb);
  });
};

// Use a closure to provide a true imperative API for synchronous stores.
function syncWrap(method) {
  return function() {
    if (!this.store.synchronous) {
      throw new Error('CookieJar store is not synchronous; use async API instead.');
    }

    var args = Array.prototype.slice.call(arguments);
    var syncErr, syncResult;
    args.push(function syncCb(err, result) {
      syncErr = err;
      syncResult = result;
    });
    this[method].apply(this, args);

    if (syncErr) {
      throw syncErr;
    }
    return syncResult;
  };
}

// wrap all declared CAN_BE_SYNC methods in the sync wrapper
CAN_BE_SYNC.forEach(function(method) {
  CookieJar.prototype[method+'Sync'] = syncWrap(method);
});

exports.CookieJar = CookieJar;
exports.Cookie = Cookie;
exports.Store = Store;
exports.MemoryCookieStore = MemoryCookieStore;
exports.parseDate = parseDate;
exports.formatDate = formatDate;
exports.parse = parse;
exports.fromJSON = fromJSON;
exports.domainMatch = domainMatch;
exports.defaultPath = defaultPath;
exports.pathMatch = pathMatch;
exports.getPublicSuffix = pubsuffix.getPublicSuffix;
exports.cookieCompare = cookieCompare;
exports.permuteDomain = __webpack_require__(/*! ./permuteDomain */ "./node_modules/tough-cookie/lib/permuteDomain.js").permuteDomain;
exports.permutePath = permutePath;
exports.canonicalDomain = canonicalDomain;


/***/ }),

/***/ "./node_modules/tough-cookie/lib/memstore.js":
/*!***************************************************!*\
  !*** ./node_modules/tough-cookie/lib/memstore.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var Store = __webpack_require__(/*! ./store */ "./node_modules/tough-cookie/lib/store.js").Store;
var permuteDomain = __webpack_require__(/*! ./permuteDomain */ "./node_modules/tough-cookie/lib/permuteDomain.js").permuteDomain;
var pathMatch = __webpack_require__(/*! ./pathMatch */ "./node_modules/tough-cookie/lib/pathMatch.js").pathMatch;
var util = __webpack_require__(/*! util */ "util");

function MemoryCookieStore() {
  Store.call(this);
  this.idx = {};
}
util.inherits(MemoryCookieStore, Store);
exports.MemoryCookieStore = MemoryCookieStore;
MemoryCookieStore.prototype.idx = null;

// Since it's just a struct in RAM, this Store is synchronous
MemoryCookieStore.prototype.synchronous = true;

// force a default depth:
MemoryCookieStore.prototype.inspect = function() {
  return "{ idx: "+util.inspect(this.idx, false, 2)+' }';
};

// Use the new custom inspection symbol to add the custom inspect function if
// available.
if (util.inspect.custom) {
  MemoryCookieStore.prototype[util.inspect.custom] = MemoryCookieStore.prototype.inspect;
}

MemoryCookieStore.prototype.findCookie = function(domain, path, key, cb) {
  if (!this.idx[domain]) {
    return cb(null,undefined);
  }
  if (!this.idx[domain][path]) {
    return cb(null,undefined);
  }
  return cb(null,this.idx[domain][path][key]||null);
};

MemoryCookieStore.prototype.findCookies = function(domain, path, cb) {
  var results = [];
  if (!domain) {
    return cb(null,[]);
  }

  var pathMatcher;
  if (!path) {
    // null means "all paths"
    pathMatcher = function matchAll(domainIndex) {
      for (var curPath in domainIndex) {
        var pathIndex = domainIndex[curPath];
        for (var key in pathIndex) {
          results.push(pathIndex[key]);
        }
      }
    };

  } else {
    pathMatcher = function matchRFC(domainIndex) {
       //NOTE: we should use path-match algorithm from S5.1.4 here
       //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
       Object.keys(domainIndex).forEach(function (cookiePath) {
         if (pathMatch(path, cookiePath)) {
           var pathIndex = domainIndex[cookiePath];

           for (var key in pathIndex) {
             results.push(pathIndex[key]);
           }
         }
       });
     };
  }

  var domains = permuteDomain(domain) || [domain];
  var idx = this.idx;
  domains.forEach(function(curDomain) {
    var domainIndex = idx[curDomain];
    if (!domainIndex) {
      return;
    }
    pathMatcher(domainIndex);
  });

  cb(null,results);
};

MemoryCookieStore.prototype.putCookie = function(cookie, cb) {
  if (!this.idx[cookie.domain]) {
    this.idx[cookie.domain] = {};
  }
  if (!this.idx[cookie.domain][cookie.path]) {
    this.idx[cookie.domain][cookie.path] = {};
  }
  this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
  cb(null);
};

MemoryCookieStore.prototype.updateCookie = function(oldCookie, newCookie, cb) {
  // updateCookie() may avoid updating cookies that are identical.  For example,
  // lastAccessed may not be important to some stores and an equality
  // comparison could exclude that field.
  this.putCookie(newCookie,cb);
};

MemoryCookieStore.prototype.removeCookie = function(domain, path, key, cb) {
  if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
    delete this.idx[domain][path][key];
  }
  cb(null);
};

MemoryCookieStore.prototype.removeCookies = function(domain, path, cb) {
  if (this.idx[domain]) {
    if (path) {
      delete this.idx[domain][path];
    } else {
      delete this.idx[domain];
    }
  }
  return cb(null);
};

MemoryCookieStore.prototype.getAllCookies = function(cb) {
  var cookies = [];
  var idx = this.idx;

  var domains = Object.keys(idx);
  domains.forEach(function(domain) {
    var paths = Object.keys(idx[domain]);
    paths.forEach(function(path) {
      var keys = Object.keys(idx[domain][path]);
      keys.forEach(function(key) {
        if (key !== null) {
          cookies.push(idx[domain][path][key]);
        }
      });
    });
  });

  // Sort by creationIndex so deserializing retains the creation order.
  // When implementing your own store, this SHOULD retain the order too
  cookies.sort(function(a,b) {
    return (a.creationIndex||0) - (b.creationIndex||0);
  });

  cb(null, cookies);
};


/***/ }),

/***/ "./node_modules/tough-cookie/lib/pathMatch.js":
/*!****************************************************!*\
  !*** ./node_modules/tough-cookie/lib/pathMatch.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * "A request-path path-matches a given cookie-path if at least one of the
 * following conditions holds:"
 */
function pathMatch (reqPath, cookiePath) {
  // "o  The cookie-path and the request-path are identical."
  if (cookiePath === reqPath) {
    return true;
  }

  var idx = reqPath.indexOf(cookiePath);
  if (idx === 0) {
    // "o  The cookie-path is a prefix of the request-path, and the last
    // character of the cookie-path is %x2F ("/")."
    if (cookiePath.substr(-1) === "/") {
      return true;
    }

    // " o  The cookie-path is a prefix of the request-path, and the first
    // character of the request-path that is not included in the cookie- path
    // is a %x2F ("/") character."
    if (reqPath.substr(cookiePath.length, 1) === "/") {
      return true;
    }
  }

  return false;
}

exports.pathMatch = pathMatch;


/***/ }),

/***/ "./node_modules/tough-cookie/lib/permuteDomain.js":
/*!********************************************************!*\
  !*** ./node_modules/tough-cookie/lib/permuteDomain.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var pubsuffix = __webpack_require__(/*! ./pubsuffix-psl */ "./node_modules/tough-cookie/lib/pubsuffix-psl.js");

// Gives the permutation of all possible domainMatch()es of a given domain. The
// array is in shortest-to-longest order.  Handy for indexing.
function permuteDomain (domain) {
  var pubSuf = pubsuffix.getPublicSuffix(domain);
  if (!pubSuf) {
    return null;
  }
  if (pubSuf == domain) {
    return [domain];
  }

  var prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
  var parts = prefix.split('.').reverse();
  var cur = pubSuf;
  var permutations = [cur];
  while (parts.length) {
    cur = parts.shift() + '.' + cur;
    permutations.push(cur);
  }
  return permutations;
}

exports.permuteDomain = permuteDomain;


/***/ }),

/***/ "./node_modules/tough-cookie/lib/pubsuffix-psl.js":
/*!********************************************************!*\
  !*** ./node_modules/tough-cookie/lib/pubsuffix-psl.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2018, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var psl = __webpack_require__(/*! psl */ "./node_modules/psl/index.js");

function getPublicSuffix(domain) {
  return psl.get(domain);
}

exports.getPublicSuffix = getPublicSuffix;


/***/ }),

/***/ "./node_modules/tough-cookie/lib/store.js":
/*!************************************************!*\
  !*** ./node_modules/tough-cookie/lib/store.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*jshint unused:false */

function Store() {
}
exports.Store = Store;

// Stores may be synchronous, but are still required to use a
// Continuation-Passing Style API.  The CookieJar itself will expose a "*Sync"
// API that converts from synchronous-callbacks to imperative style.
Store.prototype.synchronous = false;

Store.prototype.findCookie = function(domain, path, key, cb) {
  throw new Error('findCookie is not implemented');
};

Store.prototype.findCookies = function(domain, path, cb) {
  throw new Error('findCookies is not implemented');
};

Store.prototype.putCookie = function(cookie, cb) {
  throw new Error('putCookie is not implemented');
};

Store.prototype.updateCookie = function(oldCookie, newCookie, cb) {
  // recommended default implementation:
  // return this.putCookie(newCookie, cb);
  throw new Error('updateCookie is not implemented');
};

Store.prototype.removeCookie = function(domain, path, key, cb) {
  throw new Error('removeCookie is not implemented');
};

Store.prototype.removeCookies = function(domain, path, cb) {
  throw new Error('removeCookies is not implemented');
};

Store.prototype.getAllCookies = function(cb) {
  throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');
};


/***/ }),

/***/ "./node_modules/tough-cookie/package.json":
/*!************************************************!*\
  !*** ./node_modules/tough-cookie/package.json ***!
  \************************************************/
/*! exports provided: author, contributors, license, name, description, keywords, version, homepage, repository, bugs, main, files, scripts, engines, devDependencies, dependencies, default */
/***/ (function(module) {

module.exports = {"author":{"name":"Jeremy Stashewsky","email":"jstash@gmail.com","website":"https://github.com/stash"},"contributors":[{"name":"Alexander Savin","website":"https://github.com/apsavin"},{"name":"Ian Livingstone","website":"https://github.com/ianlivingstone"},{"name":"Ivan Nikulin","website":"https://github.com/inikulin"},{"name":"Lalit Kapoor","website":"https://github.com/lalitkapoor"},{"name":"Sam Thompson","website":"https://github.com/sambthompson"},{"name":"Sebastian Mayr","website":"https://github.com/Sebmaster"}],"license":"BSD-3-Clause","name":"tough-cookie","description":"RFC6265 Cookies and Cookie Jar for node.js","keywords":["HTTP","cookie","cookies","set-cookie","cookiejar","jar","RFC6265","RFC2965"],"version":"2.4.3","homepage":"https://github.com/salesforce/tough-cookie","repository":{"type":"git","url":"git://github.com/salesforce/tough-cookie.git"},"bugs":{"url":"https://github.com/salesforce/tough-cookie/issues"},"main":"./lib/cookie","files":["lib"],"scripts":{"test":"vows test/*_test.js","cover":"nyc --reporter=lcov --reporter=html vows test/*_test.js"},"engines":{"node":">=0.8"},"devDependencies":{"async":"^1.4.2","nyc":"^11.6.0","string.prototype.repeat":"^0.2.0","vows":"^0.8.1"},"dependencies":{"psl":"^1.1.24","punycode":"^1.4.1"}};

/***/ }),

/***/ "./node_modules/tunnel-agent/index.js":
/*!********************************************!*\
  !*** ./node_modules/tunnel-agent/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var net = __webpack_require__(/*! net */ "net")
  , tls = __webpack_require__(/*! tls */ "tls")
  , http = __webpack_require__(/*! http */ "http")
  , https = __webpack_require__(/*! https */ "https")
  , events = __webpack_require__(/*! events */ "events")
  , assert = __webpack_require__(/*! assert */ "assert")
  , util = __webpack_require__(/*! util */ "util")
  , Buffer = __webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer
  ;

exports.httpOverHttp = httpOverHttp
exports.httpsOverHttp = httpsOverHttp
exports.httpOverHttps = httpOverHttps
exports.httpsOverHttps = httpsOverHttps


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  return agent
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  agent.createSocket = createSecureSocket
  agent.defaultPort = 443
  return agent
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  return agent
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  agent.createSocket = createSecureSocket
  agent.defaultPort = 443
  return agent
}


function TunnelingAgent(options) {
  var self = this
  self.options = options || {}
  self.proxyOptions = self.options.proxy || {}
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
  self.requests = []
  self.sockets = []

  self.on('free', function onFree(socket, host, port) {
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i]
      if (pending.host === host && pending.port === port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1)
        pending.request.onSocket(socket)
        return
      }
    }
    socket.destroy()
    self.removeSocket(socket)
  })
}
util.inherits(TunnelingAgent, events.EventEmitter)

TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
  var self = this

   // Legacy API: addRequest(req, host, port, path)
  if (typeof options === 'string') {
    options = {
      host: options,
      port: arguments[2],
      path: arguments[3]
    };
  }

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push({host: options.host, port: options.port, request: req})
    return
  }

  // If we are under maxSockets create a new one.
  self.createConnection({host: options.host, port: options.port, request: req})
}

TunnelingAgent.prototype.createConnection = function createConnection(pending) {
  var self = this

  self.createSocket(pending, function(socket) {
    socket.on('free', onFree)
    socket.on('close', onCloseOrRemove)
    socket.on('agentRemove', onCloseOrRemove)
    pending.request.onSocket(socket)

    function onFree() {
      self.emit('free', socket, pending.host, pending.port)
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket)
      socket.removeListener('free', onFree)
      socket.removeListener('close', onCloseOrRemove)
      socket.removeListener('agentRemove', onCloseOrRemove)
    }
  })
}

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this
  var placeholder = {}
  self.sockets.push(placeholder)

  var connectOptions = mergeOptions({}, self.proxyOptions,
    { method: 'CONNECT'
    , path: options.host + ':' + options.port
    , agent: false
    }
  )
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {}
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        Buffer.from(connectOptions.proxyAuth).toString('base64')
  }

  debug('making CONNECT request')
  var connectReq = self.request(connectOptions)
  connectReq.useChunkedEncodingByDefault = false // for v0.6
  connectReq.once('response', onResponse) // for v0.6
  connectReq.once('upgrade', onUpgrade)   // for v0.6
  connectReq.once('connect', onConnect)   // for v0.7 or later
  connectReq.once('error', onError)
  connectReq.end()

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head)
    })
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners()
    socket.removeAllListeners()

    if (res.statusCode === 200) {
      assert.equal(head.length, 0)
      debug('tunneling connection has established')
      self.sockets[self.sockets.indexOf(placeholder)] = socket
      cb(socket)
    } else {
      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
      error.code = 'ECONNRESET'
      options.request.emit('error', error)
      self.removeSocket(placeholder)
    }
  }

  function onError(cause) {
    connectReq.removeAllListeners()

    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
    error.code = 'ECONNRESET'
    options.request.emit('error', error)
    self.removeSocket(placeholder)
  }
}

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) return

  this.sockets.splice(pos, 1)

  var pending = this.requests.shift()
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createConnection(pending)
  }
}

function createSecureSocket(options, cb) {
  var self = this
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, mergeOptions({}, self.options,
      { servername: options.host
      , socket: socket
      }
    ))
    self.sockets[self.sockets.indexOf(socket)] = secureSocket
    cb(secureSocket)
  })
}


function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i]
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides)
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j]
        if (overrides[k] !== undefined) {
          target[k] = overrides[k]
        }
      }
    }
  }
  return target
}


var debug
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments)
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0]
    } else {
      args.unshift('TUNNEL:')
    }
    console.error.apply(console, args)
  }
} else {
  debug = function() {}
}
exports.debug = debug // for test


/***/ }),

/***/ "./node_modules/tweetnacl/nacl-fast.js":
/*!*********************************************!*\
  !*** ./node_modules/tweetnacl/nacl-fast.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = (x[j] + 128) >> 8;
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i, mlen;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  mlen = -1;
  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  mlen = n;
  return mlen;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  var t, i;
  for (i = 0; i < arguments.length; i++) {
     if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
       throw new TypeError('unexpected type ' + t + ', use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

// TODO: Completely remove this in v0.15.
if (!nacl.util) {
  nacl.util = {};
  nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
    throw new Error('nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js');
  };
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return false;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  if (arguments.length !== 2)
    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (true) {
    // Node.js.
    crypto = __webpack_require__(/*! crypto */ "crypto");
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})( true && module.exports ? module.exports : (self.nacl = self.nacl || {}));


/***/ }),

/***/ "./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
	 true ? factory(exports) :
	undefined;
}(this, (function (exports) { 'use strict';

function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {}
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        //normalize the default port
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

var O = {};
var isIRI = true;
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=uri.all.js.map


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng.js":
/*!**************************************!*\
  !*** ./node_modules/uuid/lib/rng.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.

var crypto = __webpack_require__(/*! crypto */ "crypto");

module.exports = function nodeRNG() {
  return crypto.randomBytes(16);
};


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),

/***/ "./node_modules/verror/lib/verror.js":
/*!*******************************************!*\
  !*** ./node_modules/verror/lib/verror.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * verror.js: richer JavaScript errors
 */

var mod_assertplus = __webpack_require__(/*! assert-plus */ "./node_modules/assert-plus/assert.js");
var mod_util = __webpack_require__(/*! util */ "util");

var mod_extsprintf = __webpack_require__(/*! extsprintf */ "./node_modules/verror/node_modules/extsprintf/lib/extsprintf.js");
var mod_isError = __webpack_require__(/*! core-util-is */ "./node_modules/core-util-is/lib/util.js").isError;
var sprintf = mod_extsprintf.sprintf;

/*
 * Public interface
 */

/* So you can 'var VError = require('verror')' */
module.exports = VError;
/* For compatibility */
VError.VError = VError;
/* Other exported classes */
VError.SError = SError;
VError.WError = WError;
VError.MultiError = MultiError;

/*
 * Common function used to parse constructor arguments for VError, WError, and
 * SError.  Named arguments to this function:
 *
 *     strict		force strict interpretation of sprintf arguments, even
 *     			if the options in "argv" don't say so
 *
 *     argv		error's constructor arguments, which are to be
 *     			interpreted as described in README.md.  For quick
 *     			reference, "argv" has one of the following forms:
 *
 *          [ sprintf_args... ]           (argv[0] is a string)
 *          [ cause, sprintf_args... ]    (argv[0] is an Error)
 *          [ options, sprintf_args... ]  (argv[0] is an object)
 *
 * This function normalizes these forms, producing an object with the following
 * properties:
 *
 *    options           equivalent to "options" in third form.  This will never
 *    			be a direct reference to what the caller passed in
 *    			(i.e., it may be a shallow copy), so it can be freely
 *    			modified.
 *
 *    shortmessage      result of sprintf(sprintf_args), taking options.strict
 *    			into account as described in README.md.
 */
function parseConstructorArguments(args)
{
	var argv, options, sprintf_args, shortmessage, k;

	mod_assertplus.object(args, 'args');
	mod_assertplus.bool(args.strict, 'args.strict');
	mod_assertplus.array(args.argv, 'args.argv');
	argv = args.argv;

	/*
	 * First, figure out which form of invocation we've been given.
	 */
	if (argv.length === 0) {
		options = {};
		sprintf_args = [];
	} else if (mod_isError(argv[0])) {
		options = { 'cause': argv[0] };
		sprintf_args = argv.slice(1);
	} else if (typeof (argv[0]) === 'object') {
		options = {};
		for (k in argv[0]) {
			options[k] = argv[0][k];
		}
		sprintf_args = argv.slice(1);
	} else {
		mod_assertplus.string(argv[0],
		    'first argument to VError, SError, or WError ' +
		    'constructor must be a string, object, or Error');
		options = {};
		sprintf_args = argv;
	}

	/*
	 * Now construct the error's message.
	 *
	 * extsprintf (which we invoke here with our caller's arguments in order
	 * to construct this Error's message) is strict in its interpretation of
	 * values to be processed by the "%s" specifier.  The value passed to
	 * extsprintf must actually be a string or something convertible to a
	 * String using .toString().  Passing other values (notably "null" and
	 * "undefined") is considered a programmer error.  The assumption is
	 * that if you actually want to print the string "null" or "undefined",
	 * then that's easy to do that when you're calling extsprintf; on the
	 * other hand, if you did NOT want that (i.e., there's actually a bug
	 * where the program assumes some variable is non-null and tries to
	 * print it, which might happen when constructing a packet or file in
	 * some specific format), then it's better to stop immediately than
	 * produce bogus output.
	 *
	 * However, sometimes the bug is only in the code calling VError, and a
	 * programmer might prefer to have the error message contain "null" or
	 * "undefined" rather than have the bug in the error path crash the
	 * program (making the first bug harder to identify).  For that reason,
	 * by default VError converts "null" or "undefined" arguments to their
	 * string representations and passes those to extsprintf.  Programmers
	 * desiring the strict behavior can use the SError class or pass the
	 * "strict" option to the VError constructor.
	 */
	mod_assertplus.object(options);
	if (!options.strict && !args.strict) {
		sprintf_args = sprintf_args.map(function (a) {
			return (a === null ? 'null' :
			    a === undefined ? 'undefined' : a);
		});
	}

	if (sprintf_args.length === 0) {
		shortmessage = '';
	} else {
		shortmessage = sprintf.apply(null, sprintf_args);
	}

	return ({
	    'options': options,
	    'shortmessage': shortmessage
	});
}

/*
 * See README.md for reference documentation.
 */
function VError()
{
	var args, obj, parsed, cause, ctor, message, k;

	args = Array.prototype.slice.call(arguments, 0);

	/*
	 * This is a regrettable pattern, but JavaScript's built-in Error class
	 * is defined to work this way, so we allow the constructor to be called
	 * without "new".
	 */
	if (!(this instanceof VError)) {
		obj = Object.create(VError.prototype);
		VError.apply(obj, arguments);
		return (obj);
	}

	/*
	 * For convenience and backwards compatibility, we support several
	 * different calling forms.  Normalize them here.
	 */
	parsed = parseConstructorArguments({
	    'argv': args,
	    'strict': false
	});

	/*
	 * If we've been given a name, apply it now.
	 */
	if (parsed.options.name) {
		mod_assertplus.string(parsed.options.name,
		    'error\'s "name" must be a string');
		this.name = parsed.options.name;
	}

	/*
	 * For debugging, we keep track of the original short message (attached
	 * this Error particularly) separately from the complete message (which
	 * includes the messages of our cause chain).
	 */
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;

	/*
	 * If we've been given a cause, record a reference to it and update our
	 * message appropriately.
	 */
	cause = parsed.options.cause;
	if (cause) {
		mod_assertplus.ok(mod_isError(cause), 'cause is not an Error');
		this.jse_cause = cause;

		if (!parsed.options.skipCauseMessage) {
			message += ': ' + cause.message;
		}
	}

	/*
	 * If we've been given an object with properties, shallow-copy that
	 * here.  We don't want to use a deep copy in case there are non-plain
	 * objects here, but we don't want to use the original object in case
	 * the caller modifies it later.
	 */
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}

	this.message = message;
	Error.call(this, message);

	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}

	return (this);
}

mod_util.inherits(VError, Error);
VError.prototype.name = 'VError';

VError.prototype.toString = function ve_toString()
{
	var str = (this.hasOwnProperty('name') && this.name ||
		this.constructor.name || this.constructor.prototype.name);
	if (this.message)
		str += ': ' + this.message;

	return (str);
};

/*
 * This method is provided for compatibility.  New callers should use
 * VError.cause() instead.  That method also uses the saner `null` return value
 * when there is no cause.
 */
VError.prototype.cause = function ve_cause()
{
	var cause = VError.cause(this);
	return (cause === null ? undefined : cause);
};

/*
 * Static methods
 *
 * These class-level methods are provided so that callers can use them on
 * instances of Errors that are not VErrors.  New interfaces should be provided
 * only using static methods to eliminate the class of programming mistake where
 * people fail to check whether the Error object has the corresponding methods.
 */

VError.cause = function (err)
{
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
};

VError.info = function (err)
{
	var rv, cause, k;

	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	cause = VError.cause(err);
	if (cause !== null) {
		rv = VError.info(cause);
	} else {
		rv = {};
	}

	if (typeof (err.jse_info) == 'object' && err.jse_info !== null) {
		for (k in err.jse_info) {
			rv[k] = err.jse_info[k];
		}
	}

	return (rv);
};

VError.findCauseByName = function (err, name)
{
	var cause;

	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	mod_assertplus.string(name, 'name');
	mod_assertplus.ok(name.length > 0, 'name cannot be empty');

	for (cause = err; cause !== null; cause = VError.cause(cause)) {
		mod_assertplus.ok(mod_isError(cause));
		if (cause.name == name) {
			return (cause);
		}
	}

	return (null);
};

VError.hasCauseWithName = function (err, name)
{
	return (VError.findCauseByName(err, name) !== null);
};

VError.fullStack = function (err)
{
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');

	var cause = VError.cause(err);

	if (cause) {
		return (err.stack + '\ncaused by: ' + VError.fullStack(cause));
	}

	return (err.stack);
};

VError.errorFromList = function (errors)
{
	mod_assertplus.arrayOfObject(errors, 'errors');

	if (errors.length === 0) {
		return (null);
	}

	errors.forEach(function (e) {
		mod_assertplus.ok(mod_isError(e));
	});

	if (errors.length == 1) {
		return (errors[0]);
	}

	return (new MultiError(errors));
};

VError.errorForEach = function (err, func)
{
	mod_assertplus.ok(mod_isError(err), 'err must be an Error');
	mod_assertplus.func(func, 'func');

	if (err instanceof MultiError) {
		err.errors().forEach(function iterError(e) { func(e); });
	} else {
		func(err);
	}
};


/*
 * SError is like VError, but stricter about types.  You cannot pass "null" or
 * "undefined" as string arguments to the formatter.
 */
function SError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof SError)) {
		obj = Object.create(SError.prototype);
		SError.apply(obj, arguments);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    'argv': args,
	    'strict': true
	});

	options = parsed.options;
	VError.call(this, options, '%s', parsed.shortmessage);

	return (this);
}

/*
 * We don't bother setting SError.prototype.name because once constructed,
 * SErrors are just like VErrors.
 */
mod_util.inherits(SError, VError);


/*
 * Represents a collection of errors for the purpose of consumers that generally
 * only deal with one error.  Callers can extract the individual errors
 * contained in this object, but may also just treat it as a normal single
 * error, in which case a summary message will be printed.
 */
function MultiError(errors)
{
	mod_assertplus.array(errors, 'list of errors');
	mod_assertplus.ok(errors.length > 0, 'must be at least one error');
	this.ase_errors = errors;

	VError.call(this, {
	    'cause': errors[0]
	}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
}

mod_util.inherits(MultiError, VError);
MultiError.prototype.name = 'MultiError';

MultiError.prototype.errors = function me_errors()
{
	return (this.ase_errors.slice(0));
};


/*
 * See README.md for reference details.
 */
function WError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof WError)) {
		obj = Object.create(WError.prototype);
		WError.apply(obj, args);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    'argv': args,
	    'strict': false
	});

	options = parsed.options;
	options['skipCauseMessage'] = true;
	VError.call(this, options, '%s', parsed.shortmessage);

	return (this);
}

mod_util.inherits(WError, VError);
WError.prototype.name = 'WError';

WError.prototype.toString = function we_toString()
{
	var str = (this.hasOwnProperty('name') && this.name ||
		this.constructor.name || this.constructor.prototype.name);
	if (this.message)
		str += ': ' + this.message;
	if (this.jse_cause && this.jse_cause.message)
		str += '; caused by ' + this.jse_cause.toString();

	return (str);
};

/*
 * For purely historical reasons, WError's cause() function allows you to set
 * the cause.
 */
WError.prototype.cause = function we_cause(c)
{
	if (mod_isError(c))
		this.jse_cause = c;

	return (this.jse_cause);
};


/***/ }),

/***/ "./node_modules/verror/node_modules/extsprintf/lib/extsprintf.js":
/*!***********************************************************************!*\
  !*** ./node_modules/verror/node_modules/extsprintf/lib/extsprintf.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * extsprintf.js: extended POSIX-style sprintf
 */

var mod_assert = __webpack_require__(/*! assert */ "assert");
var mod_util = __webpack_require__(/*! util */ "util");

/*
 * Public interface
 */
exports.sprintf = jsSprintf;
exports.printf = jsPrintf;
exports.fprintf = jsFprintf;

/*
 * Stripped down version of s[n]printf(3c).  We make a best effort to throw an
 * exception when given a format string we don't understand, rather than
 * ignoring it, so that we won't break existing programs if/when we go implement
 * the rest of this.
 *
 * This implementation currently supports specifying
 *	- field alignment ('-' flag),
 * 	- zero-pad ('0' flag)
 *	- always show numeric sign ('+' flag),
 *	- field width
 *	- conversions for strings, decimal integers, and floats (numbers).
 *	- argument size specifiers.  These are all accepted but ignored, since
 *	  Javascript has no notion of the physical size of an argument.
 *
 * Everything else is currently unsupported, most notably precision, unsigned
 * numbers, non-decimal numbers, and characters.
 */
function jsSprintf(ofmt)
{
	var regex = [
	    '([^%]*)',				/* normal text */
	    '%',				/* start of format */
	    '([\'\\-+ #0]*?)',			/* flags (optional) */
	    '([1-9]\\d*)?',			/* width (optional) */
	    '(\\.([1-9]\\d*))?',		/* precision (optional) */
	    '[lhjztL]*?',			/* length mods (ignored) */
	    '([diouxXfFeEgGaAcCsSp%jr])'	/* conversion */
	].join('');

	var re = new RegExp(regex);

	/* variadic arguments used to fill in conversion specifiers */
	var args = Array.prototype.slice.call(arguments, 1);
	/* remaining format string */
	var fmt = ofmt;

	/* components of the current conversion specifier */
	var flags, width, precision, conversion;
	var left, pad, sign, arg, match;

	/* return value */
	var ret = '';

	/* current variadic argument (1-based) */
	var argn = 1;
	/* 0-based position in the format string that we've read */
	var posn = 0;
	/* 1-based position in the format string of the current conversion */
	var convposn;
	/* current conversion specifier */
	var curconv;

	mod_assert.equal('string', typeof (fmt),
	    'first argument must be a format string');

	while ((match = re.exec(fmt)) !== null) {
		ret += match[1];
		fmt = fmt.substring(match[0].length);

		/*
		 * Update flags related to the current conversion specifier's
		 * position so that we can report clear error messages.
		 */
		curconv = match[0].substring(match[1].length);
		convposn = posn + match[1].length + 1;
		posn += match[0].length;

		flags = match[2] || '';
		width = match[3] || 0;
		precision = match[4] || '';
		conversion = match[6];
		left = false;
		sign = false;
		pad = ' ';

		if (conversion == '%') {
			ret += '%';
			continue;
		}

		if (args.length === 0) {
			throw (jsError(ofmt, convposn, curconv,
			    'has no matching argument ' +
			    '(too few arguments passed)'));
		}

		arg = args.shift();
		argn++;

		if (flags.match(/[\' #]/)) {
			throw (jsError(ofmt, convposn, curconv,
			    'uses unsupported flags'));
		}

		if (precision.length > 0) {
			throw (jsError(ofmt, convposn, curconv,
			    'uses non-zero precision (not supported)'));
		}

		if (flags.match(/-/))
			left = true;

		if (flags.match(/0/))
			pad = '0';

		if (flags.match(/\+/))
			sign = true;

		switch (conversion) {
		case 's':
			if (arg === undefined || arg === null) {
				throw (jsError(ofmt, convposn, curconv,
				    'attempted to print undefined or null ' +
				    'as a string (argument ' + argn + ' to ' +
				    'sprintf)'));
			}
			ret += doPad(pad, width, left, arg.toString());
			break;

		case 'd':
			arg = Math.floor(arg);
			/*jsl:fallthru*/
		case 'f':
			sign = sign && arg > 0 ? '+' : '';
			ret += sign + doPad(pad, width, left,
			    arg.toString());
			break;

		case 'x':
			ret += doPad(pad, width, left, arg.toString(16));
			break;

		case 'j': /* non-standard */
			if (width === 0)
				width = 10;
			ret += mod_util.inspect(arg, false, width);
			break;

		case 'r': /* non-standard */
			ret += dumpException(arg);
			break;

		default:
			throw (jsError(ofmt, convposn, curconv,
			    'is not supported'));
		}
	}

	ret += fmt;
	return (ret);
}

function jsError(fmtstr, convposn, curconv, reason) {
	mod_assert.equal(typeof (fmtstr), 'string');
	mod_assert.equal(typeof (curconv), 'string');
	mod_assert.equal(typeof (convposn), 'number');
	mod_assert.equal(typeof (reason), 'string');
	return (new Error('format string "' + fmtstr +
	    '": conversion specifier "' + curconv + '" at character ' +
	    convposn + ' ' + reason));
}

function jsPrintf() {
	var args = Array.prototype.slice.call(arguments);
	args.unshift(process.stdout);
	jsFprintf.apply(null, args);
}

function jsFprintf(stream) {
	var args = Array.prototype.slice.call(arguments, 1);
	return (stream.write(jsSprintf.apply(this, args)));
}

function doPad(chr, width, left, str)
{
	var ret = str;

	while (ret.length < width) {
		if (left)
			ret += chr;
		else
			ret = chr + ret;
	}

	return (ret);
}

/*
 * This function dumps long stack traces for exceptions having a cause() method.
 * See node-verror for an example.
 */
function dumpException(ex)
{
	var ret;

	if (!(ex instanceof Error))
		throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));

	/* Note that V8 prepends "ex.stack" with ex.toString(). */
	ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;

	if (ex.cause && typeof (ex.cause) === 'function') {
		var cex = ex.cause();
		if (cex) {
			ret += '\nCaused by: ' + dumpException(cex);
		}
	}

	return (ret);
}


/***/ }),

/***/ "./src/comment.js":
/*!************************!*\
  !*** ./src/comment.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! keybase-bot */ "./node_modules/keybase-bot/index.js");
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(keybase_bot__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _emoji__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emoji */ "./src/emoji.js");
/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./search */ "./src/search.js");




var reactNum = function reactNum(context, channel, id, num, until) {
  return num < until && context.bot.chat.react(channel, id, Object(_emoji__WEBPACK_IMPORTED_MODULE_1__["numToEmoji"])(num)).then(function () {
    return reactNum(context, channel, id, num + 1, until);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (function (context, channel, parsedMessage) {
  return Object(_search__WEBPACK_IMPORTED_MODULE_2__["getOrSearch"])(context, channel, parsedMessage, 'To confirm commenting, click on emojis below in the next 2 minutes:').then(function (_ref) {
    var count = _ref.count,
        id = _ref.id,
        issues = _ref.issues;
    context.comment.add(id, parsedMessage, issues);
    reactNum(context, channel, id, 0, count);
  });
});

/***/ }),

/***/ "./src/context.js":
/*!************************!*\
  !*** ./src/context.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! keybase-bot */ "./node_modules/keybase-bot/index.js");
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(keybase_bot__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_1__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var setTimeoutPromise = util__WEBPACK_IMPORTED_MODULE_1___default.a.promisify(setTimeout);

var CommentContext = function CommentContext() {
  var _this = this;

  _classCallCheck(this, CommentContext);

  _defineProperty(this, "_respMsgIDToCommentMessage", new Map());

  _defineProperty(this, "add", function (responseID, message, issues) {
    _this._respMsgIDToCommentMessage.set(responseID, {
      message: message,
      issues: issues
    });

    setTimeoutPromise(1000 * 120
    /* 2min */
    ).then(function () {
      return _this._respMsgIDToCommentMessage.delete(responseID);
    });
  });

  _defineProperty(this, "get", function (responseID) {
    return _this._respMsgIDToCommentMessage.get(responseID);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return {
    bot: new keybase_bot__WEBPACK_IMPORTED_MODULE_0___default.a(),
    comment: new CommentContext()
  };
});

/***/ }),

/***/ "./src/emoji.js":
/*!**********************!*\
  !*** ./src/emoji.js ***!
  \**********************/
/*! exports provided: emojiToNum, numToEmoji, statusToEmoji */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "emojiToNum", function() { return emojiToNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numToEmoji", function() { return numToEmoji; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "statusToEmoji", function() { return statusToEmoji; });
var emojiToNum = function emojiToNum(num) {
  switch (num) {
    case ':zero:':
      return 0;

    case ':one:':
      return 1;

    case ':two:':
      return 2;

    case ':three:':
      return 3;

    case ':four:':
      return 4;

    case ':five:':
      return 5;

    case ':six:':
      return 6;

    case ':seven:':
      return 7;

    case ':eight:':
      return 8;

    case ':nine:':
      return 9;

    case ':keycap_ten:':
      return 10;

    default:
      return null;
  }
};
var numToEmoji = function numToEmoji(num) {
  switch (num) {
    case 0:
      return ':zero:';

    case 1:
      return ':one:';

    case 2:
      return ':two:';

    case 3:
      return ':three:';

    case 4:
      return ':four:';

    case 5:
      return ':five:';

    case 6:
      return ':six:';

    case 7:
      return ':seven:';

    case 8:
      return ':eight:';

    case 9:
      return ':nine:';

    case 10:
      return ':keycap_ten:';

    default:
      return ':question:';
  }
};
var statusToEmoji = function statusToEmoji(status) {
  switch (status) {
    case 'Done':
      return ':white_check_mark:';

    case 'To Do':
      return ':statue_of_liberty:';

    default:
      return ':building_construction:';
  }
};

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _kira__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./kira */ "./src/kira.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context */ "./src/context.js");


Object(_kira__WEBPACK_IMPORTED_MODULE_0__["default"])(Object(_context__WEBPACK_IMPORTED_MODULE_1__["default"])());

/***/ }),

/***/ "./src/jira.js":
/*!*********************!*\
  !*** ./src/jira.js ***!
  \*********************/
/*! exports provided: getOrSearch, addComment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrSearch", function() { return getOrSearch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addComment", function() { return addComment; });
/* harmony import */ var jira_connector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jira-connector */ "./node_modules/jira-connector/index.js");
/* harmony import */ var jira_connector__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jira_connector__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./config.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



var jira = new jira_connector__WEBPACK_IMPORTED_MODULE_0___default.a({
  host: _config__WEBPACK_IMPORTED_MODULE_1__["jira"].host,
  basic_auth: {
    username: _config__WEBPACK_IMPORTED_MODULE_1__["jira"].username,
    password: _config__WEBPACK_IMPORTED_MODULE_1__["jira"].password
  }
});

var looksLikeIssueKey = function looksLikeIssueKey(str) {
  return !!str.match(/[A-Za-z]+-[0-9]+/);
};

var jiraRespMapper = function jiraRespMapper(issue) {
  return {
    key: issue.key,
    summary: issue.fields.summary,
    status: issue.fields.status.statusCategory.name,
    url: "https://".concat(_config__WEBPACK_IMPORTED_MODULE_1__["jira"].host, "/browse/").concat(issue.key)
  };
};

var getOrSearch = function getOrSearch(str) {
  return Promise.all([looksLikeIssueKey(str) ? jira.issue.getIssue({
    issueKey: str,
    fields: ['key', 'summary', 'status']
  }) : new Promise(function (r) {
    return r();
  }), jira.search.search({
    jql: "text ~ \"".concat(str, "\""),
    fields: 'key,summary,status',
    method: 'GET',
    maxResults: 11
  })]).then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        fromGet = _ref2[0],
        fromSearch = _ref2[1];

    return [].concat(_toConsumableArray(fromGet ? [fromGet] : []), _toConsumableArray(fromSearch ? fromSearch.issues : [])).map(jiraRespMapper);
  });
};
var addComment = function addComment(issueKey, comment) {
  return jira.issue.addComment({
    issueKey: issueKey,
    comment: {
      body: comment
    }
  }).then(function (_ref3) {
    var id = _ref3.id;
    return "https://".concat(_config__WEBPACK_IMPORTED_MODULE_1__["jira"].host, "/browse/").concat(issueKey, "?focusedCommentId=").concat(id);
  });
};

/***/ }),

/***/ "./src/kira.js":
/*!*********************!*\
  !*** ./src/kira.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! keybase-bot */ "./node_modules/keybase-bot/index.js");
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(keybase_bot__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./config.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./message */ "./src/message.js");
/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./search */ "./src/search.js");
/* harmony import */ var _comment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./comment */ "./src/comment.js");
/* harmony import */ var _reacji__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reacji */ "./src/reacji.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./context */ "./src/context.js");








var sendHelp = function sendHelp(context, channel) {
  return context.bot.chat.send(channel, {
    body: 'Usage: \n' + '  `!kira search <query>`\n' + '  `!kira comment <query> <your comment>`\n'
  });
};

var reactAck = function reactAck(context, channel, id) {
  return context.bot.chat.react(channel, id, ':eyes:');
};

var makeOnMessage = function makeOnMessage(context) {
  return function (kbMessage) {
    console.debug(kbMessage);
    var parsedMessage = _message__WEBPACK_IMPORTED_MODULE_2__["parseMessage"](kbMessage);
    console.debug({
      msg: 'got message',
      parsedMessage: parsedMessage
    });

    if (!parsedMessage) {
      // not a kira message
      return;
    }

    switch (parsedMessage.type) {
      case 'unknown':
      case 'help':
        sendHelp(context, kbMessage.channel);
        return;

      case 'search':
        reactAck(context, kbMessage.channel, kbMessage.id);
        Object(_search__WEBPACK_IMPORTED_MODULE_3__["default"])(context, kbMessage.channel, parsedMessage);
        return;

      case 'comment':
        reactAck(context, kbMessage.channel, kbMessage.id);
        Object(_comment__WEBPACK_IMPORTED_MODULE_4__["default"])(context, kbMessage.channel, parsedMessage);
        return;

      case 'reacji':
        Object(_reacji__WEBPACK_IMPORTED_MODULE_5__["default"])(context, kbMessage.channel, parsedMessage);
        return;

      default:
        console.error({
          error: 'how could this happen'
        });
        return;
    }
  };
};

/* harmony default export */ __webpack_exports__["default"] = (function (context) {
  return context.bot.init(_config__WEBPACK_IMPORTED_MODULE_1__["keybase"].username, _config__WEBPACK_IMPORTED_MODULE_1__["keybase"].paperkey, {
    verbose: true
  }).then(function () {
    return _config__WEBPACK_IMPORTED_MODULE_1__["keybase"].channels.forEach(function (channel) {
      return context.bot.chat.watchChannelForNewMessages(channel, makeOnMessage(context));
    });
  });
});

/***/ }),

/***/ "./src/message.js":
/*!************************!*\
  !*** ./src/message.js ***!
  \************************/
/*! exports provided: parseMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseMessage", function() { return parseMessage; });
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! keybase-bot */ "./node_modules/keybase-bot/index.js");
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(keybase_bot__WEBPACK_IMPORTED_MODULE_0__);

var cmdRE = new RegExp(/(?:!kira)\s+(\S+)(?:\s+(\S+))?(?:\s+(.*))?/);

var isKiraMessage = function isKiraMessage(message) {
  return message && message.content && message.content.type === 'text' && typeof message.content.text.body === 'string' && message.content.text.body.startsWith('!kira');
};

var isKiraReaction = function isKiraReaction(message) {
  return message && message.content && message.content.type === 'reaction';
};

var parseMessage = function parseMessage(message) {
  if (isKiraReaction(message)) {
    return {
      from: message.sender.username,
      type: 'reacji',
      reactToID: message.content.reaction.m,
      emoji: message.content.reaction.b
    };
  }

  if (!isKiraMessage(message)) {
    return null;
  }

  var matches = message.content.text.body.match(cmdRE);

  if (!matches || matches.length < 2) {
    return {
      type: 'unknown'
    };
  }

  switch (matches[1]) {
    case 'help':
      return {
        type: 'help'
      };

    case 'search':
      if (matches.length < 3) {
        return {
          type: 'unknown'
        };
      }

      return {
        from: message.sender.username,
        type: 'search',
        query: matches[2]
      };

    case 'comment':
      if (matches.length < 4) {
        return {
          type: 'unknown'
        };
      }

      return {
        from: message.sender.username,
        type: 'comment',
        query: matches[2],
        comment: matches[3]
      };

    default:
      return {
        type: 'unknown'
      };
  }
};

/***/ }),

/***/ "./src/reacji.js":
/*!***********************!*\
  !*** ./src/reacji.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _emoji__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./emoji */ "./src/emoji.js");
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! keybase-bot */ "./node_modules/keybase-bot/index.js");
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(keybase_bot__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jira__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jira */ "./src/jira.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config */ "./config.js");





var kb2jira = function kb2jira(kb) {
  return _config__WEBPACK_IMPORTED_MODULE_3__["jira"].usernameMapper[kb] || kb;
};

/* harmony default export */ __webpack_exports__["default"] = (function (context, channel, parsedMessage) {
  var item = context.comment.get(parsedMessage.reactToID);

  if (!item) {
    return;
  }

  if (parsedMessage.from === _config__WEBPACK_IMPORTED_MODULE_3__["keybase"].username) {
    // We never get our own reacji as of now, but just in case ...
    return;
  }

  var num = Object(_emoji__WEBPACK_IMPORTED_MODULE_0__["emojiToNum"])(parsedMessage.emoji);

  if (typeof num !== 'number') {
    return;
  }

  if (num >= item.issues.length) {
    return;
  }

  var issueKey = item.issues[num].key;
  var comment = "Comment by ".concat(kb2jira(item.message.from)) + (item.message.from === parsedMessage.from ? ': ' : " (confirmed by ".concat(kb2jira(parsedMessage.from), "): ")) + item.message.comment;
  return _jira__WEBPACK_IMPORTED_MODULE_2__["addComment"](issueKey, comment).then(function (url) {
    return context.bot.chat.send(channel, {
      body: "@".concat(parsedMessage.from, " Done! ").concat(url)
    });
  });
});

/***/ }),

/***/ "./src/search.js":
/*!***********************!*\
  !*** ./src/search.js ***!
  \***********************/
/*! exports provided: getOrSearch, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrSearch", function() { return getOrSearch; });
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! keybase-bot */ "./node_modules/keybase-bot/index.js");
/* harmony import */ var keybase_bot__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(keybase_bot__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jira__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jira */ "./src/jira.js");
/* harmony import */ var _emoji__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./emoji */ "./src/emoji.js");




var issueToLine = function issueToLine(issue, index) {
  return "".concat(Object(_emoji__WEBPACK_IMPORTED_MODULE_2__["numToEmoji"])(index), " *").concat(issue.key, "* ").concat(Object(_emoji__WEBPACK_IMPORTED_MODULE_2__["statusToEmoji"])(issue.status), " ").concat(issue.summary, " - ").concat(issue.url);
};

var buildSearchResultBody = function buildSearchResultBody(parsedMessage, issues, additional) {
  if (!issues.length) {
    return 'I got nothing from Jira.';
  }

  var firstIssues = issues.slice(0, 11);
  var head = "@".concat(parsedMessage.from, " I got ").concat(issues.length, " tickets from Jira") + (issues > 11 ? '. Here are the first 11:\n\n' : ':\n\n');
  var body = firstIssues.map(issueToLine).join('\n');
  return additional ? head + body + '\n\n' + additional : head + body;
};

var getOrSearch = function getOrSearch(context, channel, parsedMessage, additional) {
  return _jira__WEBPACK_IMPORTED_MODULE_1__["getOrSearch"](parsedMessage.query).then(function (issues) {
    return context.bot.chat.send(channel, {
      body: buildSearchResultBody(parsedMessage, issues, additional)
    }).then(function (_ref) {
      var id = _ref.id;
      return {
        count: issues.length > 11 ? 11 : issues.length,
        id: id,
        issues: issues
      };
    });
  });
};
/* harmony default export */ __webpack_exports__["default"] = (function (context, channel, parsedMessage) {
  return getOrSearch(context, channel, parsedMessage);
});

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("punycode");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),

/***/ "readline":
/*!***************************!*\
  !*** external "readline" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("readline");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2Fqdi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvZXJyb3JfY2xhc3Nlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2Zvcm1hdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3Jlc29sdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9ydWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3NjaGVtYV9vYmouanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS91Y3MybGVuZ3RoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL19saW1pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9fbGltaXRJdGVtcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9fbGltaXRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvX2xpbWl0UHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9hbGxPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9hbnlPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9jb21tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2NvbnN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2NvbnRhaW5zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2N1c3RvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9kZXBlbmRlbmNpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvZW51bS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvaWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvaXRlbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbXVsdGlwbGVPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9ub3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvb25lT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcGF0dGVybi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3Byb3BlcnR5TmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcmVmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3JlcXVpcmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3VuaXF1ZUl0ZW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3ZhbGlkYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hanYvbGliL2tleXdvcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS9saWIvYmVyL3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNuMS9saWIvYmVyL3R5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xL2xpYi9iZXIvd3JpdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc24xL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNzZXJ0LXBsdXMvYXNzZXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXN5bmNraXQvbGliL2Fib3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9saWIvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L2xpYi9kZWZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXN5bmNraXQvbGliL2l0ZXJhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L2xpYi9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXN5bmNraXQvbGliL3Rlcm1pbmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L3BhcmFsbGVsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3luY2tpdC9zZXJpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FzeW5ja2l0L3NlcmlhbE9yZGVyZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F3cy1zaWduMi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXdzNC9hd3M0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hd3M0L2xydS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmNyeXB0LXBia2RmL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jYXNlbGVzcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tYmluZWQtc3RyZWFtL2xpYi9jb21iaW5lZF9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbWJpbmVkLXN0cmVhbS9saWIvZGVmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVsYXllZC1zdHJlYW0vbGliL2RlbGF5ZWRfc3RyZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2MtanNibi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNjLWpzYm4vbGliL2VjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2MtanNibi9saWIvc2VjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9leHRlbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V4dHNwcmludGYvbGliL2V4dHNwcmludGYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZvcmV2ZXItYWdlbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zvcm0tZGF0YS9saWIvZm9ybV9kYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL3BvcHVsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXItc2NoZW1hL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFyLXZhbGlkYXRvci9saWIvZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhci12YWxpZGF0b3IvbGliL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3NpZ25lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9saWIvdmVyaWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pcy10eXBlZGFycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc3N0cmVhbS9pc3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL2FwcGxpY2F0aW9uLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9hdHRhY2htZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvYXVkaXRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9hdXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvYXZhdGFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvYm9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9jb21tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvY29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvY3VzdG9tRmllbGRPcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9kYXNoYm9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9maWVsZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL2dyb3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvZ3JvdXBVc2VyUGlja2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvZ3JvdXBzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvaXNzdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9pc3N1ZUxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9pc3N1ZUxpbmtUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvaXNzdWVUeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvanFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvbGljZW5zZVJvbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9saWNlbnNlVmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvbXlQZXJtaXNzaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL215UHJlZmVyZW5jZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9teXNlbGYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9wYXNzd29yZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL3Blcm1pc3Npb24tc2NoZW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvcGVybWlzc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9wcmlvcml0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL3Byb2plY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9wcm9qZWN0Q2F0ZWdvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9wcm9qZWN0VmFsaWRhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9yZWluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvcmVzb2x1dGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL3JvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvc2NyZWVucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL3NlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL3NlY3VyaXR5TGV2ZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9zZXJ2ZXJJbmZvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9zcHJpbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9zdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS9zdGF0dXNDYXRlZ29yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL3VzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS92ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvd2ViaG9vay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvYXBpL3dvcmtmbG93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9hcGkvd29ya2Zsb3dTY2hlbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ppcmEtY29ubmVjdG9yL2FwaS93b3JrbG9nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvamlyYS1jb25uZWN0b3IvbGliL2Vycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qaXJhLWNvbm5lY3Rvci9saWIvb2F1dGhfdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNibi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hL2xpYi92YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktc2FmZS9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcHJpbS9saWIvanNwcmltLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9rZXliYXNlLWJvdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLmNhbWVsY2FzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLmtlYmFiY2FzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLnNuYWtlY2FzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWltZS1kYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWltZS10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWtkaXJwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYXV0aC1zaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYXV0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2F1dGgvbGliL191dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2F1dGgvbGliL29hdXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYXV0aC9saWIvb2F1dGgyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYXV0aC9saWIvc2hhMS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BzbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3FzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3QvbGliL2F1dGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3QvbGliL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3QvbGliL2dldFByb3h5RnJvbVVSSS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvaGFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L2xpYi9oYXdrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L2xpYi9oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L2xpYi9tdWx0aXBhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3QvbGliL29hdXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXF1ZXN0L2xpYi9xdWVyeXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9saWIvcmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlcXVlc3QvbGliL3R1bm5lbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVxdWVzdC9yZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FmZXItYnVmZmVyL3NhZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvYWxncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2NlcnRpZmljYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZGhlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZWQtY29tcGF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZXJyb3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZmluZ2VycHJpbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL2F1dG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL2Ruc3NlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvb3BlbnNzaC1jZXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9wZW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL3BrY3MxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9wa2NzOC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2Zvcm1hdHMvcHV0dHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL3JmYzQyNTMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL3NzaC1wcml2YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy9zc2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9mb3JtYXRzL3g1MDktcGVtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvZm9ybWF0cy94NTA5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NzaHBrL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL2tleS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL3ByaXZhdGUta2V5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvc2lnbmF0dXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zc2hway9saWIvc3NoLWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3NocGsvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL2Nvb2tpZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9tZW1zdG9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9wYXRoTWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RvdWdoLWNvb2tpZS9saWIvcGVybXV0ZURvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdG91Z2gtY29va2llL2xpYi9wdWJzdWZmaXgtcHNsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b3VnaC1jb29raWUvbGliL3N0b3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dW5uZWwtYWdlbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3ZWV0bmFjbC9uYWNsLWZhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VyaS1qcy9kaXN0L2VzNS91cmkuYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL3Y0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92ZXJyb3IvbGliL3ZlcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmVycm9yL25vZGVfbW9kdWxlcy9leHRzcHJpbnRmL2xpYi9leHRzcHJpbnRmLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9jb250ZXh0LmpzIiwid2VicGFjazovLy8uL3NyYy9lbW9qaS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ppcmEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2tpcmEuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWNqaS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2VhcmNoLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImFzc2VydFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImJ1ZmZlclwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNoaWxkX3Byb2Nlc3NcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5ldFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm9zXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicGF0aFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInB1bnljb2RlXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicXVlcnlzdHJpbmdcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFkbGluZVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmVhbVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInRsc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInV0aWxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ6bGliXCIiXSwibmFtZXMiOlsia2V5YmFzZSIsInVzZXJuYW1lIiwicGFwZXJrZXkiLCJjaGFubmVscyIsIm5hbWUiLCJ0b3BpY05hbWUiLCJtZW1iZXJzVHlwZSIsInRvcGljX3R5cGUiLCJqaXJhIiwiaG9zdCIsInBhc3N3b3JkIiwidXNlcm5hbWVNYXBwZXIiLCJyZWFjdE51bSIsImNvbnRleHQiLCJjaGFubmVsIiwiaWQiLCJudW0iLCJ1bnRpbCIsImJvdCIsImNoYXQiLCJyZWFjdCIsIm51bVRvRW1vamkiLCJ0aGVuIiwicGFyc2VkTWVzc2FnZSIsImdldE9yU2VhcmNoIiwiY291bnQiLCJpc3N1ZXMiLCJjb21tZW50IiwiYWRkIiwic2V0VGltZW91dFByb21pc2UiLCJ1dGlsIiwicHJvbWlzaWZ5Iiwic2V0VGltZW91dCIsIkNvbW1lbnRDb250ZXh0IiwiTWFwIiwicmVzcG9uc2VJRCIsIm1lc3NhZ2UiLCJfcmVzcE1zZ0lEVG9Db21tZW50TWVzc2FnZSIsInNldCIsImRlbGV0ZSIsImdldCIsIkJvdCIsImVtb2ppVG9OdW0iLCJzdGF0dXNUb0Vtb2ppIiwic3RhdHVzIiwiS2lyYSIsIkNvbnRleHQiLCJKaXJhQ2xpZW50IiwiQ29uZmlnIiwiYmFzaWNfYXV0aCIsImxvb2tzTGlrZUlzc3VlS2V5Iiwic3RyIiwibWF0Y2giLCJqaXJhUmVzcE1hcHBlciIsImlzc3VlIiwia2V5Iiwic3VtbWFyeSIsImZpZWxkcyIsInN0YXR1c0NhdGVnb3J5IiwidXJsIiwiUHJvbWlzZSIsImFsbCIsImdldElzc3VlIiwiaXNzdWVLZXkiLCJyIiwic2VhcmNoIiwianFsIiwibWV0aG9kIiwibWF4UmVzdWx0cyIsImZyb21HZXQiLCJmcm9tU2VhcmNoIiwibWFwIiwiYWRkQ29tbWVudCIsImJvZHkiLCJzZW5kSGVscCIsInNlbmQiLCJyZWFjdEFjayIsIm1ha2VPbk1lc3NhZ2UiLCJrYk1lc3NhZ2UiLCJjb25zb2xlIiwiZGVidWciLCJNZXNzYWdlIiwibXNnIiwidHlwZSIsInJlYWNqaSIsImVycm9yIiwiaW5pdCIsInZlcmJvc2UiLCJmb3JFYWNoIiwid2F0Y2hDaGFubmVsRm9yTmV3TWVzc2FnZXMiLCJjbWRSRSIsIlJlZ0V4cCIsImlzS2lyYU1lc3NhZ2UiLCJjb250ZW50IiwidGV4dCIsInN0YXJ0c1dpdGgiLCJpc0tpcmFSZWFjdGlvbiIsInBhcnNlTWVzc2FnZSIsImZyb20iLCJzZW5kZXIiLCJyZWFjdFRvSUQiLCJyZWFjdGlvbiIsIm0iLCJlbW9qaSIsImIiLCJtYXRjaGVzIiwibGVuZ3RoIiwicXVlcnkiLCJrYjJqaXJhIiwia2IiLCJpdGVtIiwiSmlyYSIsImlzc3VlVG9MaW5lIiwiaW5kZXgiLCJidWlsZFNlYXJjaFJlc3VsdEJvZHkiLCJhZGRpdGlvbmFsIiwiZmlyc3RJc3N1ZXMiLCJzbGljZSIsImhlYWQiLCJqb2luIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakZBO0FBQUE7QUFBQTtBQUFPLElBQU1BLE9BQU8sR0FBRztBQUNyQkMsVUFBUSxFQUFFLFNBRFc7QUFFckJD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V0FBVyxFQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLElBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTywyRUFBMkU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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Q0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsR0FBRztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNUxBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDMUdBLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFHQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsMENBQU07QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsc0RBQWE7QUFDckMsYUFBYSxtQkFBTyxDQUFDLDBEQUFjO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLHdEQUFjOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHVFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMENBQU07QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7QUNoakJBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsMENBQU07QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsa0RBQVM7OztBQUdqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQiw4QkFBOEI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6S2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxZQUFZO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsa0RBQWtEOztBQUU3RTtBQUNBLE1BQU07QUFDTiwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwSEE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RMYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQjs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERhOztBQUViO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUM1TGE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ3REYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDdkVhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDckRhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxLQUFLLElBQUksZ0JBQWdCO0FBQ3RGLE9BQU8sRUFBRTs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVE7QUFDUjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQSxzQ0FBc0MsOERBQThELEVBQUUsa0VBQWtFLEVBQUU7QUFDMUs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLEdBQUc7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7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LHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhDQUE4QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pOYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQzFKVzs7QUFFWixlQUFlLG1CQUFPLENBQUMsa0RBQVU7QUFDakMsV0FBVyxtQkFBTyxDQUFDLDBDQUFTO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyx3REFBVzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1Qzs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3Q0FBd0MscUJBQXFCLDJDQUEyQztBQUN4Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRSxpQ0FBaUM7QUFDdkc7QUFDQTs7QUFFQTtBQUNBLDBFQUEwRSxpQ0FBaUM7QUFDM0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbURBQW1ELHNCQUFzQjtBQUN6RSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQkFBa0I7QUFDMUUsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCw2Q0FBNkMscUJBQXFCOztBQUVsRTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5Z0RBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0RBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3Qjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDNUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwREFBYzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdktBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5REFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsMERBQWM7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLGdEQUFRO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQyw4REFBZTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBYTtBQUNyQyxXQUFXLG1CQUFPLENBQUMsb0RBQVU7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxrREFBUztBQUM3QixVQUFVLG1CQUFPLENBQUMsOENBQU87QUFDekIsaUJBQWlCLG1CQUFPLENBQUMsOERBQWU7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLHdEQUFZOztBQUVuQztBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGdGQUF3QjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQW9COztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDelpB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OztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4QkFBOEI7QUFDdkQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDL1ZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5REFBYTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsOENBQU07QUFDekIsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQywwREFBYztBQUNuQyxXQUFXLG1CQUFPLENBQUMsaURBQVM7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLG1EQUFVO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQywrQ0FBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQywrREFBZ0I7O0FBRXpDLFlBQVksbUJBQU8sQ0FBQywwREFBUztBQUM3QixZQUFZLG1CQUFPLENBQUMsMERBQVM7QUFDN0IsY0FBYyxtQkFBTyxDQUFDLHNFQUFlO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyw4REFBVzs7QUFFakMsYUFBYSxtQkFBTyxDQUFDLHFEQUFXOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBZ0Q7QUFDcEQsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQWdEO0FBQ3BELElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFF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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTs7QUFFQSxpQkFBaUIs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QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDclNBOztBQUVBOztBQUVBLGFBQWEs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdDQUF3QztBQUN4QztBQUNBLEdBQUcsT0FBTztBQUNWLHVCQUF1QjtBQUN2QixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx3Q0FBd0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0JBQStCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUM7QUFDQSw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0Esc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pELHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsMkJBQTJCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsU0FBUyxFQUFFO0FBQ3pELEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsY0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9OQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUlBLElBQU1DLFFBQVEsR0FBRyxTQUFYQSxRQUFXLENBQUNDLE9BQUQsRUFBbUJDLE9BQW5CLEVBQTRCQyxF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QUFBLGFBQWE7QUFDakJVLGFBQUssRUFBRUMsTUFBTSxDQUFDZ0YsTUFBUCxHQUFnQixFQUFoQixHQUFxQixFQUFyQixHQUEwQmhGLE1BQU0sQ0FBQ2dGLE1BRHZCO0FBRWpCM0YsVUFBRSxFQUFGQSxFQUZpQjtBQUdqQlcsY0FBTSxFQUFOQTtBQUhpQixPQUFiO0FBQUEsS0FKUixDQUQrQztBQUFBLEdBQWpELENBTnlCO0FBQUEsQ0FBcEI7QUFrQlEseUVBQ2JiLE9BRGEsRUFFYkMsT0FGYSxFQUdiUyxhQUhhO0FBQUEsU0FJVkMsV0FBVyxDQUFDWCxPQUFELEVBQVVDLE9BQVYsRUFBbUJTLGFBQW5CLENBSkQ7QUFBQSxDQUFmLEU7Ozs7Ozs7Ozs7O0FDMUNBLG1DOzs7Ozs7Ozs7OztBQ0FBLG1DOzs7Ozs7Ozs7OztBQ0FBLDBDOzs7Ozs7Ozs7OztBQ0FBLG1DOzs7Ozs7Ozs7OztBQ0FBLG1DOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLGtDOzs7Ozs7Ozs7OztBQ0FBLGdDOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLHFDOzs7Ozs7Ozs7OztBQ0FBLHdDOzs7Ozs7Ozs7OztBQ0FBLHFDOzs7Ozs7Ozs7OztBQ0FBLG1DOzs7Ozs7Ozs7OztBQ0FBLGdDOzs7Ozs7Ozs7OztBQ0FBLGdDOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLGlDIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsIi8vIEBmbG93XG5leHBvcnQgY29uc3Qga2V5YmFzZSA9IHtcbiAgdXNlcm5hbWU6ICdibGFoYm90JyxcbiAgcGFwZXJrZXk6XG4gICAgJ2JsYWggYmxhaCBibHUgYmx1JyxcbiAgY2hhbm5lbHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiAnYmxhaC5ib3RzJyxcbiAgICAgIHRvcGljTmFtZTogJ3Rlc3QnLFxuICAgICAgbWVtYmVyc1R5cGU6ICd0ZWFtJyxcbiAgICAgIHRvcGljX3R5cGU6ICdjaGF0JyxcbiAgICB9LFxuICBdLFxufVxuXG5leHBvcnQgY29uc3QgamlyYSA9IHtcbiAgaG9zdDogJ2JsYWguYXRsYXNzaWFuLm5ldCcsXG4gIHVzZXJuYW1lOiAnYmxhaEBleGFtcGxlLmNvbScsXG4gIHBhc3N3b3JkOiAncGFzc3dvcmQnLFxuICB1c2VybmFtZU1hcHBlcjoge1xuICAgIFwiYmxhaFwiOiBcIlt+YmxhaGJsYWhdXCIsXG4gIH0sXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21waWxlU2NoZW1hID0gcmVxdWlyZSgnLi9jb21waWxlJylcbiAgLCByZXNvbHZlID0gcmVxdWlyZSgnLi9jb21waWxlL3Jlc29sdmUnKVxuICAsIENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpXG4gICwgU2NoZW1hT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21waWxlL3NjaGVtYV9vYmonKVxuICAsIHN0YWJsZVN0cmluZ2lmeSA9IHJlcXVpcmUoJ2Zhc3QtanNvbi1zdGFibGUtc3RyaW5naWZ5JylcbiAgLCBmb3JtYXRzID0gcmVxdWlyZSgnLi9jb21waWxlL2Zvcm1hdHMnKVxuICAsIHJ1bGVzID0gcmVxdWlyZSgnLi9jb21waWxlL3J1bGVzJylcbiAgLCAkZGF0YU1ldGFTY2hlbWEgPSByZXF1aXJlKCcuL2RhdGEnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuL2NvbXBpbGUvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFqdjtcblxuQWp2LnByb3RvdHlwZS52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuQWp2LnByb3RvdHlwZS5jb21waWxlID0gY29tcGlsZTtcbkFqdi5wcm90b3R5cGUuYWRkU2NoZW1hID0gYWRkU2NoZW1hO1xuQWp2LnByb3RvdHlwZS5hZGRNZXRhU2NoZW1hID0gYWRkTWV0YVNjaGVtYTtcbkFqdi5wcm90b3R5cGUudmFsaWRhdGVTY2hlbWEgPSB2YWxpZGF0ZVNjaGVtYTtcbkFqdi5wcm90b3R5cGUuZ2V0U2NoZW1hID0gZ2V0U2NoZW1hO1xuQWp2LnByb3RvdHlwZS5yZW1vdmVTY2hlbWEgPSByZW1vdmVTY2hlbWE7XG5BanYucHJvdG90eXBlLmFkZEZvcm1hdCA9IGFkZEZvcm1hdDtcbkFqdi5wcm90b3R5cGUuZXJyb3JzVGV4dCA9IGVycm9yc1RleHQ7XG5cbkFqdi5wcm90b3R5cGUuX2FkZFNjaGVtYSA9IF9hZGRTY2hlbWE7XG5BanYucHJvdG90eXBlLl9jb21waWxlID0gX2NvbXBpbGU7XG5cbkFqdi5wcm90b3R5cGUuY29tcGlsZUFzeW5jID0gcmVxdWlyZSgnLi9jb21waWxlL2FzeW5jJyk7XG52YXIgY3VzdG9tS2V5d29yZCA9IHJlcXVpcmUoJy4va2V5d29yZCcpO1xuQWp2LnByb3RvdHlwZS5hZGRLZXl3b3JkID0gY3VzdG9tS2V5d29yZC5hZGQ7XG5BanYucHJvdG90eXBlLmdldEtleXdvcmQgPSBjdXN0b21LZXl3b3JkLmdldDtcbkFqdi5wcm90b3R5cGUucmVtb3ZlS2V5d29yZCA9IGN1c3RvbUtleXdvcmQucmVtb3ZlO1xuXG52YXIgZXJyb3JDbGFzc2VzID0gcmVxdWlyZSgnLi9jb21waWxlL2Vycm9yX2NsYXNzZXMnKTtcbkFqdi5WYWxpZGF0aW9uRXJyb3IgPSBlcnJvckNsYXNzZXMuVmFsaWRhdGlvbjtcbkFqdi5NaXNzaW5nUmVmRXJyb3IgPSBlcnJvckNsYXNzZXMuTWlzc2luZ1JlZjtcbkFqdi4kZGF0YU1ldGFTY2hlbWEgPSAkZGF0YU1ldGFTY2hlbWE7XG5cbnZhciBNRVRBX1NDSEVNQV9JRCA9ICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSc7XG5cbnZhciBNRVRBX0lHTk9SRV9PUFRJT05TID0gWyAncmVtb3ZlQWRkaXRpb25hbCcsICd1c2VEZWZhdWx0cycsICdjb2VyY2VUeXBlcycgXTtcbnZhciBNRVRBX1NVUFBPUlRfREFUQSA9IFsnL3Byb3BlcnRpZXMnXTtcblxuLyoqXG4gKiBDcmVhdGVzIHZhbGlkYXRvciBpbnN0YW5jZS5cbiAqIFVzYWdlOiBgQWp2KG9wdHMpYFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgb3B0aW9uYWwgb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSBhanYgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQWp2KG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFqdikpIHJldHVybiBuZXcgQWp2KG9wdHMpO1xuICBvcHRzID0gdGhpcy5fb3B0cyA9IHV0aWwuY29weShvcHRzKSB8fCB7fTtcbiAgc2V0TG9nZ2VyKHRoaXMpO1xuICB0aGlzLl9zY2hlbWFzID0ge307XG4gIHRoaXMuX3JlZnMgPSB7fTtcbiAgdGhpcy5fZnJhZ21lbnRzID0ge307XG4gIHRoaXMuX2Zvcm1hdHMgPSBmb3JtYXRzKG9wdHMuZm9ybWF0KTtcblxuICB0aGlzLl9jYWNoZSA9IG9wdHMuY2FjaGUgfHwgbmV3IENhY2hlO1xuICB0aGlzLl9sb2FkaW5nU2NoZW1hcyA9IHt9O1xuICB0aGlzLl9jb21waWxhdGlvbnMgPSBbXTtcbiAgdGhpcy5SVUxFUyA9IHJ1bGVzKCk7XG4gIHRoaXMuX2dldElkID0gY2hvb3NlR2V0SWQob3B0cyk7XG5cbiAgb3B0cy5sb29wUmVxdWlyZWQgPSBvcHRzLmxvb3BSZXF1aXJlZCB8fCBJbmZpbml0eTtcbiAgaWYgKG9wdHMuZXJyb3JEYXRhUGF0aCA9PSAncHJvcGVydHknKSBvcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkgPSB0cnVlO1xuICBpZiAob3B0cy5zZXJpYWxpemUgPT09IHVuZGVmaW5lZCkgb3B0cy5zZXJpYWxpemUgPSBzdGFibGVTdHJpbmdpZnk7XG4gIHRoaXMuX21ldGFPcHRzID0gZ2V0TWV0YVNjaGVtYU9wdGlvbnModGhpcyk7XG5cbiAgaWYgKG9wdHMuZm9ybWF0cykgYWRkSW5pdGlhbEZvcm1hdHModGhpcyk7XG4gIGFkZERlZmF1bHRNZXRhU2NoZW1hKHRoaXMpO1xuICBpZiAodHlwZW9mIG9wdHMubWV0YSA9PSAnb2JqZWN0JykgdGhpcy5hZGRNZXRhU2NoZW1hKG9wdHMubWV0YSk7XG4gIGlmIChvcHRzLm51bGxhYmxlKSB0aGlzLmFkZEtleXdvcmQoJ251bGxhYmxlJywge21ldGFTY2hlbWE6IHtjb25zdDogdHJ1ZX19KTtcbiAgYWRkSW5pdGlhbFNjaGVtYXModGhpcyk7XG59XG5cblxuXG4vKipcbiAqIFZhbGlkYXRlIGRhdGEgdXNpbmcgc2NoZW1hXG4gKiBTY2hlbWEgd2lsbCBiZSBjb21waWxlZCBhbmQgY2FjaGVkICh1c2luZyBzZXJpYWxpemVkIEpTT04gYXMga2V5LiBbZmFzdC1qc29uLXN0YWJsZS1zdHJpbmdpZnldKGh0dHBzOi8vZ2l0aHViLmNvbS9lcG9iZXJlemtpbi9mYXN0LWpzb24tc3RhYmxlLXN0cmluZ2lmeSkgaXMgdXNlZCB0byBzZXJpYWxpemUuXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtICB7U3RyaW5nfE9iamVjdH0gc2NoZW1hS2V5UmVmIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAqIEBwYXJhbSAge0FueX0gZGF0YSB0byBiZSB2YWxpZGF0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHZhbGlkYXRpb24gcmVzdWx0LiBFcnJvcnMgZnJvbSB0aGUgbGFzdCB2YWxpZGF0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIGluIGBhanYuZXJyb3JzYCAoYW5kIGFsc28gaW4gY29tcGlsZWQgc2NoZW1hOiBgc2NoZW1hLmVycm9yc2ApLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZShzY2hlbWFLZXlSZWYsIGRhdGEpIHtcbiAgdmFyIHY7XG4gIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09ICdzdHJpbmcnKSB7XG4gICAgdiA9IHRoaXMuZ2V0U2NoZW1hKHNjaGVtYUtleVJlZik7XG4gICAgaWYgKCF2KSB0aHJvdyBuZXcgRXJyb3IoJ25vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCInICsgc2NoZW1hS2V5UmVmICsgJ1wiJyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjaGVtYU9iaiA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgIHYgPSBzY2hlbWFPYmoudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZShzY2hlbWFPYmopO1xuICB9XG5cbiAgdmFyIHZhbGlkID0gdihkYXRhKTtcbiAgaWYgKHYuJGFzeW5jICE9PSB0cnVlKSB0aGlzLmVycm9ycyA9IHYuZXJyb3JzO1xuICByZXR1cm4gdmFsaWQ7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgdmFsaWRhdGluZyBmdW5jdGlvbiBmb3IgcGFzc2VkIHNjaGVtYS5cbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtPYmplY3R9IHNjaGVtYSBzY2hlbWEgb2JqZWN0XG4gKiBAcGFyYW0gIHtCb29sZWFufSBfbWV0YSB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHkgdG8gY29tcGlsZSBtZXRhIHNjaGVtYXMgb2YgY3VzdG9tIGtleXdvcmRzLlxuICogQHJldHVybiB7RnVuY3Rpb259IHZhbGlkYXRpbmcgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gY29tcGlsZShzY2hlbWEsIF9tZXRhKSB7XG4gIHZhciBzY2hlbWFPYmogPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCB1bmRlZmluZWQsIF9tZXRhKTtcbiAgcmV0dXJuIHNjaGVtYU9iai52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlKHNjaGVtYU9iaik7XG59XG5cblxuLyoqXG4gKiBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2UuXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHNjaGVtYSBzY2hlbWEgb3IgYXJyYXkgb2Ygc2NoZW1hcy4gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCBhbmQgb3RoZXIgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IF9za2lwVmFsaWRhdGlvbiB0cnVlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24uIFVzZWQgaW50ZXJuYWxseSwgb3B0aW9uIHZhbGlkYXRlU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IF9tZXRhIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICogQHJldHVybiB7QWp2fSB0aGlzIGZvciBtZXRob2QgY2hhaW5pbmdcbiAqL1xuZnVuY3Rpb24gYWRkU2NoZW1hKHNjaGVtYSwga2V5LCBfc2tpcFZhbGlkYXRpb24sIF9tZXRhKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpe1xuICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspIHRoaXMuYWRkU2NoZW1hKHNjaGVtYVtpXSwgdW5kZWZpbmVkLCBfc2tpcFZhbGlkYXRpb24sIF9tZXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgaWQgPSB0aGlzLl9nZXRJZChzY2hlbWEpO1xuICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaWQgIT0gJ3N0cmluZycpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2hlbWEgaWQgbXVzdCBiZSBzdHJpbmcnKTtcbiAga2V5ID0gcmVzb2x2ZS5ub3JtYWxpemVJZChrZXkgfHwgaWQpO1xuICBjaGVja1VuaXF1ZSh0aGlzLCBrZXkpO1xuICB0aGlzLl9zY2hlbWFzW2tleV0gPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfc2tpcFZhbGlkYXRpb24sIF9tZXRhLCB0cnVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblxuLyoqXG4gKiBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAqIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYSBzY2hlbWEgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IG9wdGlvbmFsIHNjaGVtYSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcFZhbGlkYXRpb24gdHJ1ZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gKiBAcmV0dXJuIHtBanZ9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICovXG5mdW5jdGlvbiBhZGRNZXRhU2NoZW1hKHNjaGVtYSwga2V5LCBza2lwVmFsaWRhdGlvbikge1xuICB0aGlzLmFkZFNjaGVtYShzY2hlbWEsIGtleSwgc2tpcFZhbGlkYXRpb24sIHRydWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuXG4vKipcbiAqIFZhbGlkYXRlIHNjaGVtYVxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWEgc2NoZW1hIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRocm93T3JMb2dFcnJvciBwYXNzIHRydWUgdG8gdGhyb3cgKG9yIGxvZykgYW4gZXJyb3IgaWYgaW52YWxpZFxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzY2hlbWEgaXMgdmFsaWRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0aHJvd09yTG9nRXJyb3IpIHtcbiAgdmFyICRzY2hlbWEgPSBzY2hlbWEuJHNjaGVtYTtcbiAgaWYgKCRzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJHNjaGVtYSAhPSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyRzY2hlbWEgbXVzdCBiZSBhIHN0cmluZycpO1xuICAkc2NoZW1hID0gJHNjaGVtYSB8fCB0aGlzLl9vcHRzLmRlZmF1bHRNZXRhIHx8IGRlZmF1bHRNZXRhKHRoaXMpO1xuICBpZiAoISRzY2hlbWEpIHtcbiAgICB0aGlzLmxvZ2dlci53YXJuKCdtZXRhLXNjaGVtYSBub3QgYXZhaWxhYmxlJyk7XG4gICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKTtcbiAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdzY2hlbWEgaXMgaW52YWxpZDogJyArIHRoaXMuZXJyb3JzVGV4dCgpO1xuICAgIGlmICh0aGlzLl9vcHRzLnZhbGlkYXRlU2NoZW1hID09ICdsb2cnKSB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cblxuZnVuY3Rpb24gZGVmYXVsdE1ldGEoc2VsZikge1xuICB2YXIgbWV0YSA9IHNlbGYuX29wdHMubWV0YTtcbiAgc2VsZi5fb3B0cy5kZWZhdWx0TWV0YSA9IHR5cGVvZiBtZXRhID09ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLl9nZXRJZChtZXRhKSB8fCBtZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gTUVUQV9TQ0hFTUFfSURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICByZXR1cm4gc2VsZi5fb3B0cy5kZWZhdWx0TWV0YTtcbn1cblxuXG4vKipcbiAqIEdldCBjb21waWxlZCBzY2hlbWEgZnJvbSB0aGUgaW5zdGFuY2UgYnkgYGtleWAgb3IgYHJlZmAuXG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtICB7U3RyaW5nfSBrZXlSZWYgYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAoYHNjaGVtYS5pZGAgb3IgcmVzb2x2ZWQgaWQpLlxuICogQHJldHVybiB7RnVuY3Rpb259IHNjaGVtYSB2YWxpZGF0aW5nIGZ1bmN0aW9uICh3aXRoIHByb3BlcnR5IGBzY2hlbWFgKS5cbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1hKGtleVJlZikge1xuICB2YXIgc2NoZW1hT2JqID0gX2dldFNjaGVtYU9iaih0aGlzLCBrZXlSZWYpO1xuICBzd2l0Y2ggKHR5cGVvZiBzY2hlbWFPYmopIHtcbiAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gc2NoZW1hT2JqLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGUoc2NoZW1hT2JqKTtcbiAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gdGhpcy5nZXRTY2hlbWEoc2NoZW1hT2JqKTtcbiAgICBjYXNlICd1bmRlZmluZWQnOiByZXR1cm4gX2dldFNjaGVtYUZyYWdtZW50KHRoaXMsIGtleVJlZik7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBfZ2V0U2NoZW1hRnJhZ21lbnQoc2VsZiwgcmVmKSB7XG4gIHZhciByZXMgPSByZXNvbHZlLnNjaGVtYS5jYWxsKHNlbGYsIHsgc2NoZW1hOiB7fSB9LCByZWYpO1xuICBpZiAocmVzKSB7XG4gICAgdmFyIHNjaGVtYSA9IHJlcy5zY2hlbWFcbiAgICAgICwgcm9vdCA9IHJlcy5yb290XG4gICAgICAsIGJhc2VJZCA9IHJlcy5iYXNlSWQ7XG4gICAgdmFyIHYgPSBjb21waWxlU2NoZW1hLmNhbGwoc2VsZiwgc2NoZW1hLCByb290LCB1bmRlZmluZWQsIGJhc2VJZCk7XG4gICAgc2VsZi5fZnJhZ21lbnRzW3JlZl0gPSBuZXcgU2NoZW1hT2JqZWN0KHtcbiAgICAgIHJlZjogcmVmLFxuICAgICAgZnJhZ21lbnQ6IHRydWUsXG4gICAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICBiYXNlSWQ6IGJhc2VJZCxcbiAgICAgIHZhbGlkYXRlOiB2XG4gICAgfSk7XG4gICAgcmV0dXJuIHY7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBfZ2V0U2NoZW1hT2JqKHNlbGYsIGtleVJlZikge1xuICBrZXlSZWYgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGtleVJlZik7XG4gIHJldHVybiBzZWxmLl9zY2hlbWFzW2tleVJlZl0gfHwgc2VsZi5fcmVmc1trZXlSZWZdIHx8IHNlbGYuX2ZyYWdtZW50c1trZXlSZWZdO1xufVxuXG5cbi8qKlxuICogUmVtb3ZlIGNhY2hlZCBzY2hlbWEocykuXG4gKiBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gKiBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAqIEV2ZW4gaWYgc2NoZW1hIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgc2NoZW1hcyBpdCBzdGlsbCBjYW4gYmUgcmVtb3ZlZCBhcyBvdGhlciBzY2hlbWFzIGhhdmUgbG9jYWwgcmVmZXJlbmNlcy5cbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gc2NoZW1hS2V5UmVmIGtleSwgcmVmLCBwYXR0ZXJuIHRvIG1hdGNoIGtleS9yZWYgb3Igc2NoZW1hIG9iamVjdFxuICogQHJldHVybiB7QWp2fSB0aGlzIGZvciBtZXRob2QgY2hhaW5pbmdcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZikge1xuICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgX3JlbW92ZUFsbFNjaGVtYXModGhpcywgdGhpcy5fc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLCB0aGlzLl9yZWZzLCBzY2hlbWFLZXlSZWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICBfcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLCB0aGlzLl9zY2hlbWFzKTtcbiAgICAgIF9yZW1vdmVBbGxTY2hlbWFzKHRoaXMsIHRoaXMuX3JlZnMpO1xuICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICB2YXIgc2NoZW1hT2JqID0gX2dldFNjaGVtYU9iaih0aGlzLCBzY2hlbWFLZXlSZWYpO1xuICAgICAgaWYgKHNjaGVtYU9iaikgdGhpcy5fY2FjaGUuZGVsKHNjaGVtYU9iai5jYWNoZUtleSk7XG4gICAgICBkZWxldGUgdGhpcy5fc2NoZW1hc1tzY2hlbWFLZXlSZWZdO1xuICAgICAgZGVsZXRlIHRoaXMuX3JlZnNbc2NoZW1hS2V5UmVmXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB2YXIgc2VyaWFsaXplID0gdGhpcy5fb3B0cy5zZXJpYWxpemU7XG4gICAgICB2YXIgY2FjaGVLZXkgPSBzZXJpYWxpemUgPyBzZXJpYWxpemUoc2NoZW1hS2V5UmVmKSA6IHNjaGVtYUtleVJlZjtcbiAgICAgIHRoaXMuX2NhY2hlLmRlbChjYWNoZUtleSk7XG4gICAgICB2YXIgaWQgPSB0aGlzLl9nZXRJZChzY2hlbWFLZXlSZWYpO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGlkID0gcmVzb2x2ZS5ub3JtYWxpemVJZChpZCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zY2hlbWFzW2lkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlZnNbaWRdO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5cbmZ1bmN0aW9uIF9yZW1vdmVBbGxTY2hlbWFzKHNlbGYsIHNjaGVtYXMsIHJlZ2V4KSB7XG4gIGZvciAodmFyIGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgdmFyIHNjaGVtYU9iaiA9IHNjaGVtYXNba2V5UmVmXTtcbiAgICBpZiAoIXNjaGVtYU9iai5tZXRhICYmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSkge1xuICAgICAgc2VsZi5fY2FjaGUuZGVsKHNjaGVtYU9iai5jYWNoZUtleSk7XG4gICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qIEB0aGlzICAgQWp2ICovXG5mdW5jdGlvbiBfYWRkU2NoZW1hKHNjaGVtYSwgc2tpcFZhbGlkYXRpb24sIG1ldGEsIHNob3VsZEFkZFNjaGVtYSkge1xuICBpZiAodHlwZW9mIHNjaGVtYSAhPSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2NoZW1hICE9ICdib29sZWFuJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjaGVtYSBzaG91bGQgYmUgb2JqZWN0IG9yIGJvb2xlYW4nKTtcbiAgdmFyIHNlcmlhbGl6ZSA9IHRoaXMuX29wdHMuc2VyaWFsaXplO1xuICB2YXIgY2FjaGVLZXkgPSBzZXJpYWxpemUgPyBzZXJpYWxpemUoc2NoZW1hKSA6IHNjaGVtYTtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX2NhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG5cbiAgc2hvdWxkQWRkU2NoZW1hID0gc2hvdWxkQWRkU2NoZW1hIHx8IHRoaXMuX29wdHMuYWRkVXNlZFNjaGVtYSAhPT0gZmFsc2U7XG5cbiAgdmFyIGlkID0gcmVzb2x2ZS5ub3JtYWxpemVJZCh0aGlzLl9nZXRJZChzY2hlbWEpKTtcbiAgaWYgKGlkICYmIHNob3VsZEFkZFNjaGVtYSkgY2hlY2tVbmlxdWUodGhpcywgaWQpO1xuXG4gIHZhciB3aWxsVmFsaWRhdGUgPSB0aGlzLl9vcHRzLnZhbGlkYXRlU2NoZW1hICE9PSBmYWxzZSAmJiAhc2tpcFZhbGlkYXRpb247XG4gIHZhciByZWN1cnNpdmVNZXRhO1xuICBpZiAod2lsbFZhbGlkYXRlICYmICEocmVjdXJzaXZlTWV0YSA9IGlkICYmIGlkID09IHJlc29sdmUubm9ybWFsaXplSWQoc2NoZW1hLiRzY2hlbWEpKSlcbiAgICB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG5cbiAgdmFyIGxvY2FsUmVmcyA9IHJlc29sdmUuaWRzLmNhbGwodGhpcywgc2NoZW1hKTtcblxuICB2YXIgc2NoZW1hT2JqID0gbmV3IFNjaGVtYU9iamVjdCh7XG4gICAgaWQ6IGlkLFxuICAgIHNjaGVtYTogc2NoZW1hLFxuICAgIGxvY2FsUmVmczogbG9jYWxSZWZzLFxuICAgIGNhY2hlS2V5OiBjYWNoZUtleSxcbiAgICBtZXRhOiBtZXRhXG4gIH0pO1xuXG4gIGlmIChpZFswXSAhPSAnIycgJiYgc2hvdWxkQWRkU2NoZW1hKSB0aGlzLl9yZWZzW2lkXSA9IHNjaGVtYU9iajtcbiAgdGhpcy5fY2FjaGUucHV0KGNhY2hlS2V5LCBzY2hlbWFPYmopO1xuXG4gIGlmICh3aWxsVmFsaWRhdGUgJiYgcmVjdXJzaXZlTWV0YSkgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpO1xuXG4gIHJldHVybiBzY2hlbWFPYmo7XG59XG5cblxuLyogQHRoaXMgICBBanYgKi9cbmZ1bmN0aW9uIF9jb21waWxlKHNjaGVtYU9iaiwgcm9vdCkge1xuICBpZiAoc2NoZW1hT2JqLmNvbXBpbGluZykge1xuICAgIHNjaGVtYU9iai52YWxpZGF0ZSA9IGNhbGxWYWxpZGF0ZTtcbiAgICBjYWxsVmFsaWRhdGUuc2NoZW1hID0gc2NoZW1hT2JqLnNjaGVtYTtcbiAgICBjYWxsVmFsaWRhdGUuZXJyb3JzID0gbnVsbDtcbiAgICBjYWxsVmFsaWRhdGUucm9vdCA9IHJvb3QgPyByb290IDogY2FsbFZhbGlkYXRlO1xuICAgIGlmIChzY2hlbWFPYmouc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSlcbiAgICAgIGNhbGxWYWxpZGF0ZS4kYXN5bmMgPSB0cnVlO1xuICAgIHJldHVybiBjYWxsVmFsaWRhdGU7XG4gIH1cbiAgc2NoZW1hT2JqLmNvbXBpbGluZyA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRPcHRzO1xuICBpZiAoc2NoZW1hT2JqLm1ldGEpIHtcbiAgICBjdXJyZW50T3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdGhpcy5fb3B0cyA9IHRoaXMuX21ldGFPcHRzO1xuICB9XG5cbiAgdmFyIHY7XG4gIHRyeSB7IHYgPSBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoZW1hT2JqLnNjaGVtYSwgcm9vdCwgc2NoZW1hT2JqLmxvY2FsUmVmcyk7IH1cbiAgY2F0Y2goZSkge1xuICAgIGRlbGV0ZSBzY2hlbWFPYmoudmFsaWRhdGU7XG4gICAgdGhyb3cgZTtcbiAgfVxuICBmaW5hbGx5IHtcbiAgICBzY2hlbWFPYmouY29tcGlsaW5nID0gZmFsc2U7XG4gICAgaWYgKHNjaGVtYU9iai5tZXRhKSB0aGlzLl9vcHRzID0gY3VycmVudE9wdHM7XG4gIH1cblxuICBzY2hlbWFPYmoudmFsaWRhdGUgPSB2O1xuICBzY2hlbWFPYmoucmVmcyA9IHYucmVmcztcbiAgc2NoZW1hT2JqLnJlZlZhbCA9IHYucmVmVmFsO1xuICBzY2hlbWFPYmoucm9vdCA9IHYucm9vdDtcbiAgcmV0dXJuIHY7XG5cblxuICAvKiBAdGhpcyAgIHsqfSAtIGN1c3RvbSBjb250ZXh0LCBzZWUgcGFzc0NvbnRleHQgb3B0aW9uICovXG4gIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZSgpIHtcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gICAgdmFyIF92YWxpZGF0ZSA9IHNjaGVtYU9iai52YWxpZGF0ZTtcbiAgICB2YXIgcmVzdWx0ID0gX3ZhbGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgY2FsbFZhbGlkYXRlLmVycm9ycyA9IF92YWxpZGF0ZS5lcnJvcnM7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGNob29zZUdldElkKG9wdHMpIHtcbiAgc3dpdGNoIChvcHRzLnNjaGVtYUlkKSB7XG4gICAgY2FzZSAnYXV0byc6IHJldHVybiBfZ2V0JElkT3JJZDtcbiAgICBjYXNlICdpZCc6IHJldHVybiBfZ2V0SWQ7XG4gICAgZGVmYXVsdDogcmV0dXJuIF9nZXQkSWQ7XG4gIH1cbn1cblxuLyogQHRoaXMgICBBanYgKi9cbmZ1bmN0aW9uIF9nZXRJZChzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS4kaWQpIHRoaXMubG9nZ2VyLndhcm4oJ3NjaGVtYSAkaWQgaWdub3JlZCcsIHNjaGVtYS4kaWQpO1xuICByZXR1cm4gc2NoZW1hLmlkO1xufVxuXG4vKiBAdGhpcyAgIEFqdiAqL1xuZnVuY3Rpb24gX2dldCRJZChzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS5pZCkgdGhpcy5sb2dnZXIud2Fybignc2NoZW1hIGlkIGlnbm9yZWQnLCBzY2hlbWEuaWQpO1xuICByZXR1cm4gc2NoZW1hLiRpZDtcbn1cblxuXG5mdW5jdGlvbiBfZ2V0JElkT3JJZChzY2hlbWEpIHtcbiAgaWYgKHNjaGVtYS4kaWQgJiYgc2NoZW1hLmlkICYmIHNjaGVtYS4kaWQgIT0gc2NoZW1hLmlkKVxuICAgIHRocm93IG5ldyBFcnJvcignc2NoZW1hICRpZCBpcyBkaWZmZXJlbnQgZnJvbSBpZCcpO1xuICByZXR1cm4gc2NoZW1hLiRpZCB8fCBzY2hlbWEuaWQ7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIGVycm9yIG1lc3NhZ2Ugb2JqZWN0cyB0byBzdHJpbmdcbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtBcnJheTxPYmplY3Q+fSBlcnJvcnMgb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnMsIGlmIG5vdCBwYXNzZWQgZXJyb3JzIGZyb20gdGhlIGluc3RhbmNlIGFyZSB1c2VkLlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbmFsIG9wdGlvbnMgd2l0aCBwcm9wZXJ0aWVzIGBzZXBhcmF0b3JgIGFuZCBgZGF0YVZhcmAuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGh1bWFuIHJlYWRhYmxlIHN0cmluZyB3aXRoIGFsbCBlcnJvcnMgZGVzY3JpcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGVycm9yc1RleHQoZXJyb3JzLCBvcHRpb25zKSB7XG4gIGVycm9ycyA9IGVycm9ycyB8fCB0aGlzLmVycm9ycztcbiAgaWYgKCFlcnJvcnMpIHJldHVybiAnTm8gZXJyb3JzJztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gJywgJyA6IG9wdGlvbnMuc2VwYXJhdG9yO1xuICB2YXIgZGF0YVZhciA9IG9wdGlvbnMuZGF0YVZhciA9PT0gdW5kZWZpbmVkID8gJ2RhdGEnIDogb3B0aW9ucy5kYXRhVmFyO1xuXG4gIHZhciB0ZXh0ID0gJyc7XG4gIGZvciAodmFyIGk9MDsgaTxlcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZSA9IGVycm9yc1tpXTtcbiAgICBpZiAoZSkgdGV4dCArPSBkYXRhVmFyICsgZS5kYXRhUGF0aCArICcgJyArIGUubWVzc2FnZSArIHNlcGFyYXRvcjtcbiAgfVxuICByZXR1cm4gdGV4dC5zbGljZSgwLCAtc2VwYXJhdG9yLmxlbmd0aCk7XG59XG5cblxuLyoqXG4gKiBBZGQgY3VzdG9tIGZvcm1hdFxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGZvcm1hdCBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB8RnVuY3Rpb259IGZvcm1hdCBzdHJpbmcgaXMgY29udmVydGVkIHRvIFJlZ0V4cDsgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBib29sZWFuICh0cnVlIHdoZW4gdmFsaWQpXG4gKiBAcmV0dXJuIHtBanZ9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICovXG5mdW5jdGlvbiBhZGRGb3JtYXQobmFtZSwgZm9ybWF0KSB7XG4gIGlmICh0eXBlb2YgZm9ybWF0ID09ICdzdHJpbmcnKSBmb3JtYXQgPSBuZXcgUmVnRXhwKGZvcm1hdCk7XG4gIHRoaXMuX2Zvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gIHJldHVybiB0aGlzO1xufVxuXG5cbmZ1bmN0aW9uIGFkZERlZmF1bHRNZXRhU2NoZW1hKHNlbGYpIHtcbiAgdmFyICRkYXRhU2NoZW1hO1xuICBpZiAoc2VsZi5fb3B0cy4kZGF0YSkge1xuICAgICRkYXRhU2NoZW1hID0gcmVxdWlyZSgnLi9yZWZzL2RhdGEuanNvbicpO1xuICAgIHNlbGYuYWRkTWV0YVNjaGVtYSgkZGF0YVNjaGVtYSwgJGRhdGFTY2hlbWEuJGlkLCB0cnVlKTtcbiAgfVxuICBpZiAoc2VsZi5fb3B0cy5tZXRhID09PSBmYWxzZSkgcmV0dXJuO1xuICB2YXIgbWV0YVNjaGVtYSA9IHJlcXVpcmUoJy4vcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uJyk7XG4gIGlmIChzZWxmLl9vcHRzLiRkYXRhKSBtZXRhU2NoZW1hID0gJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU1VQUE9SVF9EQVRBKTtcbiAgc2VsZi5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCB0cnVlKTtcbiAgc2VsZi5fcmVmc1snaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWEnXSA9IE1FVEFfU0NIRU1BX0lEO1xufVxuXG5cbmZ1bmN0aW9uIGFkZEluaXRpYWxTY2hlbWFzKHNlbGYpIHtcbiAgdmFyIG9wdHNTY2hlbWFzID0gc2VsZi5fb3B0cy5zY2hlbWFzO1xuICBpZiAoIW9wdHNTY2hlbWFzKSByZXR1cm47XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHNTY2hlbWFzKSkgc2VsZi5hZGRTY2hlbWEob3B0c1NjaGVtYXMpO1xuICBlbHNlIGZvciAodmFyIGtleSBpbiBvcHRzU2NoZW1hcykgc2VsZi5hZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSwga2V5KTtcbn1cblxuXG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cyhzZWxmKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gc2VsZi5fb3B0cy5mb3JtYXRzKSB7XG4gICAgdmFyIGZvcm1hdCA9IHNlbGYuX29wdHMuZm9ybWF0c1tuYW1lXTtcbiAgICBzZWxmLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gY2hlY2tVbmlxdWUoc2VsZiwgaWQpIHtcbiAgaWYgKHNlbGYuX3NjaGVtYXNbaWRdIHx8IHNlbGYuX3JlZnNbaWRdKVxuICAgIHRocm93IG5ldyBFcnJvcignc2NoZW1hIHdpdGgga2V5IG9yIGlkIFwiJyArIGlkICsgJ1wiIGFscmVhZHkgZXhpc3RzJyk7XG59XG5cblxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoc2VsZikge1xuICB2YXIgbWV0YU9wdHMgPSB1dGlsLmNvcHkoc2VsZi5fb3B0cyk7XG4gIGZvciAodmFyIGk9MDsgaTxNRVRBX0lHTk9SRV9PUFRJT05TLmxlbmd0aDsgaSsrKVxuICAgIGRlbGV0ZSBtZXRhT3B0c1tNRVRBX0lHTk9SRV9PUFRJT05TW2ldXTtcbiAgcmV0dXJuIG1ldGFPcHRzO1xufVxuXG5cbmZ1bmN0aW9uIHNldExvZ2dlcihzZWxmKSB7XG4gIHZhciBsb2dnZXIgPSBzZWxmLl9vcHRzLmxvZ2dlcjtcbiAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpIHtcbiAgICBzZWxmLmxvZ2dlciA9IHtsb2c6IG5vb3AsIHdhcm46IG5vb3AsIGVycm9yOiBub29wfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpIGxvZ2dlciA9IGNvbnNvbGU7XG4gICAgaWYgKCEodHlwZW9mIGxvZ2dlciA9PSAnb2JqZWN0JyAmJiBsb2dnZXIubG9nICYmIGxvZ2dlci53YXJuICYmIGxvZ2dlci5lcnJvcikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHMnKTtcbiAgICBzZWxmLmxvZ2dlciA9IGxvZ2dlcjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBDYWNoZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ2FjaGUoKSB7XG4gIHRoaXMuX2NhY2hlID0ge307XG59O1xuXG5cbkNhY2hlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiBDYWNoZV9wdXQoa2V5LCB2YWx1ZSkge1xuICB0aGlzLl9jYWNoZVtrZXldID0gdmFsdWU7XG59O1xuXG5cbkNhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBDYWNoZV9nZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jYWNoZVtrZXldO1xufTtcblxuXG5DYWNoZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gQ2FjaGVfZGVsKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2FjaGVba2V5XTtcbn07XG5cblxuQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gQ2FjaGVfY2xlYXIoKSB7XG4gIHRoaXMuX2NhY2hlID0ge307XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWlzc2luZ1JlZkVycm9yID0gcmVxdWlyZSgnLi9lcnJvcl9jbGFzc2VzJykuTWlzc2luZ1JlZjtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQXN5bmM7XG5cblxuLyoqXG4gKiBDcmVhdGVzIHZhbGlkYXRpbmcgZnVuY3Rpb24gZm9yIHBhc3NlZCBzY2hlbWEgd2l0aCBhc3luY2hyb25vdXMgbG9hZGluZyBvZiBtaXNzaW5nIHNjaGVtYXMuXG4gKiBgbG9hZFNjaGVtYWAgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBzY2hlbWEgdXJpIGFuZCByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBzY2hlbWEuXG4gKiBAdGhpcyAgQWp2XG4gKiBAcGFyYW0ge09iamVjdH0gICBzY2hlbWEgc2NoZW1hIG9iamVjdFxuICogQHBhcmFtIHtCb29sZWFufSAgbWV0YSBvcHRpb25hbCB0cnVlIHRvIGNvbXBpbGUgbWV0YS1zY2hlbWE7IHRoaXMgcGFyYW1ldGVyIGNhbiBiZSBza2lwcGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhbiBvcHRpb25hbCBub2RlLXN0eWxlIGNhbGxiYWNrLCBpdCBpcyBjYWxsZWQgd2l0aCAyIHBhcmFtZXRlcnM6IGVycm9yIChvciBudWxsKSBhbmQgdmFsaWRhdGluZyBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgdmFsaWRhdGluZyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUFzeW5jKHNjaGVtYSwgbWV0YSwgY2FsbGJhY2spIHtcbiAgLyogZXNsaW50IG5vLXNoYWRvdzogMCAqL1xuICAvKiBnbG9iYWwgUHJvbWlzZSAqL1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHR5cGVvZiB0aGlzLl9vcHRzLmxvYWRTY2hlbWEgIT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMubG9hZFNjaGVtYSBzaG91bGQgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICh0eXBlb2YgbWV0YSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBtZXRhO1xuICAgIG1ldGEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgcCA9IGxvYWRNZXRhU2NoZW1hT2Yoc2NoZW1hKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NoZW1hT2JqID0gc2VsZi5fYWRkU2NoZW1hKHNjaGVtYSwgdW5kZWZpbmVkLCBtZXRhKTtcbiAgICByZXR1cm4gc2NoZW1hT2JqLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMoc2NoZW1hT2JqKTtcbiAgfSk7XG5cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgcC50aGVuKFxuICAgICAgZnVuY3Rpb24odikgeyBjYWxsYmFjayhudWxsLCB2KTsgfSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBwO1xuXG5cbiAgZnVuY3Rpb24gbG9hZE1ldGFTY2hlbWFPZihzY2gpIHtcbiAgICB2YXIgJHNjaGVtYSA9IHNjaC4kc2NoZW1hO1xuICAgIHJldHVybiAkc2NoZW1hICYmICFzZWxmLmdldFNjaGVtYSgkc2NoZW1hKVxuICAgICAgICAgICAgPyBjb21waWxlQXN5bmMuY2FsbChzZWxmLCB7ICRyZWY6ICRzY2hlbWEgfSwgdHJ1ZSlcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIF9jb21waWxlQXN5bmMoc2NoZW1hT2JqKSB7XG4gICAgdHJ5IHsgcmV0dXJuIHNlbGYuX2NvbXBpbGUoc2NoZW1hT2JqKTsgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgTWlzc2luZ1JlZkVycm9yKSByZXR1cm4gbG9hZE1pc3NpbmdTY2hlbWEoZSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEoZSkge1xuICAgICAgdmFyIHJlZiA9IGUubWlzc2luZ1NjaGVtYTtcbiAgICAgIGlmIChhZGRlZChyZWYpKSB0aHJvdyBuZXcgRXJyb3IoJ1NjaGVtYSAnICsgcmVmICsgJyBpcyBsb2FkZWQgYnV0ICcgKyBlLm1pc3NpbmdSZWYgKyAnIGNhbm5vdCBiZSByZXNvbHZlZCcpO1xuXG4gICAgICB2YXIgc2NoZW1hUHJvbWlzZSA9IHNlbGYuX2xvYWRpbmdTY2hlbWFzW3JlZl07XG4gICAgICBpZiAoIXNjaGVtYVByb21pc2UpIHtcbiAgICAgICAgc2NoZW1hUHJvbWlzZSA9IHNlbGYuX2xvYWRpbmdTY2hlbWFzW3JlZl0gPSBzZWxmLl9vcHRzLmxvYWRTY2hlbWEocmVmKTtcbiAgICAgICAgc2NoZW1hUHJvbWlzZS50aGVuKHJlbW92ZVByb21pc2UsIHJlbW92ZVByb21pc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NoZW1hUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzY2gpIHtcbiAgICAgICAgaWYgKCFhZGRlZChyZWYpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvYWRNZXRhU2NoZW1hT2Yoc2NoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghYWRkZWQocmVmKSkgc2VsZi5hZGRTY2hlbWEoc2NoLCByZWYsIHVuZGVmaW5lZCwgbWV0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfY29tcGlsZUFzeW5jKHNjaGVtYU9iaik7XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlUHJvbWlzZSgpIHtcbiAgICAgICAgZGVsZXRlIHNlbGYuX2xvYWRpbmdTY2hlbWFzW3JlZl07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZGVkKHJlZikge1xuICAgICAgICByZXR1cm4gc2VsZi5fcmVmc1tyZWZdIHx8IHNlbGYuX3NjaGVtYXNbcmVmXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlc29sdmUgPSByZXF1aXJlKCcuL3Jlc29sdmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFZhbGlkYXRpb246IGVycm9yU3ViY2xhc3MoVmFsaWRhdGlvbkVycm9yKSxcbiAgTWlzc2luZ1JlZjogZXJyb3JTdWJjbGFzcyhNaXNzaW5nUmVmRXJyb3IpXG59O1xuXG5cbmZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihlcnJvcnMpIHtcbiAgdGhpcy5tZXNzYWdlID0gJ3ZhbGlkYXRpb24gZmFpbGVkJztcbiAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gIHRoaXMuYWp2ID0gdGhpcy52YWxpZGF0aW9uID0gdHJ1ZTtcbn1cblxuXG5NaXNzaW5nUmVmRXJyb3IubWVzc2FnZSA9IGZ1bmN0aW9uIChiYXNlSWQsIHJlZikge1xuICByZXR1cm4gJ2NhblxcJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJyArIHJlZiArICcgZnJvbSBpZCAnICsgYmFzZUlkO1xufTtcblxuXG5mdW5jdGlvbiBNaXNzaW5nUmVmRXJyb3IoYmFzZUlkLCByZWYsIG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCBNaXNzaW5nUmVmRXJyb3IubWVzc2FnZShiYXNlSWQsIHJlZik7XG4gIHRoaXMubWlzc2luZ1JlZiA9IHJlc29sdmUudXJsKGJhc2VJZCwgcmVmKTtcbiAgdGhpcy5taXNzaW5nU2NoZW1hID0gcmVzb2x2ZS5ub3JtYWxpemVJZChyZXNvbHZlLmZ1bGxQYXRoKHRoaXMubWlzc2luZ1JlZikpO1xufVxuXG5cbmZ1bmN0aW9uIGVycm9yU3ViY2xhc3MoU3ViY2xhc3MpIHtcbiAgU3ViY2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBTdWJjbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWJjbGFzcztcbiAgcmV0dXJuIFN1YmNsYXNzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbnZhciBEQVlTID0gWzAsMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO1xudmFyIFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpKFxcLlxcZCspPyh6fFsrLV1cXGRcXGQ6XFxkXFxkKT8kL2k7XG52YXIgSE9TVE5BTUUgPSAvXlthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86Wy0wLTlhLXpdezAsNjF9WzAtOWEtel0pPykqJC9pO1xudmFyIFVSSSA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG52YXIgVVJJUkVGID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOik/KD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/KD86XFw/KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbi8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbnZhciBVUklURU1QTEFURSA9IC9eKD86KD86W15cXHgwMC1cXHgyMFwiJzw+JVxcXFxeYHt8fV18JVswLTlhLWZdezJ9KXxcXHtbKyMuLzs/Jj0sIUB8XT8oPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KD86LCg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8pKlxcfSkqJC9pO1xuLy8gRm9yIHRoZSBzb3VyY2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0XG4vLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4vLyBAdG9kbyBEZWxldGUgY3VycmVudCBVUkwgaW4gZmF2b3VyIG9mIHRoZSBjb21tZW50ZWQgb3V0IFVSTCBydWxlIHdoZW4gdGhpcyBpc3N1ZSBpcyBmaXhlZCBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNzk4My5cbi8vIHZhciBVUkwgPSAvXig/Oig/Omh0dHBzP3xmdHApOlxcL1xcLykoPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ITEwKD86XFwuXFxkezEsM30pezN9KSg/ITEyNyg/OlxcLlxcZHsxLDN9KXszfSkoPyExNjlcXC4yNTQoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTkyXFwuMTY4KD86XFwuXFxkezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyXFxkfDNbMC0xXSkoPzpcXC5cXGR7MSwzfSl7Mn0pKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswMV1cXGR8MjJbMC0zXSkoPzpcXC4oPzoxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVxcZD98MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC00XSkpfCg/Oig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9MC05XSstPykqW2EtelxcdXswMGExfS1cXHV7ZmZmZn0wLTldKykoPzpcXC4oPzpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfTAtOV0rLT8pKlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9MC05XSspKig/OlxcLig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9XXsyLH0pKSkoPzo6XFxkezIsNX0pPyg/OlxcL1teXFxzXSopPyQvaXU7XG52YXIgVVJMID0gL14oPzooPzpodHRwW3NcXHUwMTdGXT98ZnRwKTpcXC9cXC8pKD86KD86W1xcMC1cXHgwOFxceDBFLVxceDFGIS1cXHg5RlxceEExLVxcdTE2N0ZcXHUxNjgxLVxcdTFGRkZcXHUyMDBCLVxcdTIwMjdcXHUyMDJBLVxcdTIwMkVcXHUyMDMwLVxcdTIwNUVcXHUyMDYwLVxcdTJGRkZcXHUzMDAxLVxcdUQ3RkZcXHVFMDAwLVxcdUZFRkVcXHVGRjAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKyg/OjooPzpbXFwwLVxceDA4XFx4MEUtXFx4MUYhLVxceDlGXFx4QTEtXFx1MTY3RlxcdTE2ODEtXFx1MUZGRlxcdTIwMEItXFx1MjAyN1xcdTIwMkEtXFx1MjAyRVxcdTIwMzAtXFx1MjA1RVxcdTIwNjAtXFx1MkZGRlxcdTMwMDEtXFx1RDdGRlxcdUUwMDAtXFx1RkVGRVxcdUZGMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkqKT9AKT8oPzooPyExMCg/OlxcLlswLTldezEsM30pezN9KSg/ITEyNyg/OlxcLlswLTldezEsM30pezN9KSg/ITE2OVxcLjI1NCg/OlxcLlswLTldezEsM30pezJ9KSg/ITE5MlxcLjE2OCg/OlxcLlswLTldezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyWzAtOV18M1swMV0pKD86XFwuWzAtOV17MSwzfSl7Mn0pKD86WzEtOV1bMC05XT98MVswLTldWzAtOV18MlswMV1bMC05XXwyMlswLTNdKSg/OlxcLig/OjE/WzAtOV17MSwyfXwyWzAtNF1bMC05XXwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVswLTldP3wxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTRdKSl8KD86KD86KD86WzAtOUtTYS16XFx4QTEtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKy0/KSooPzpbMC05S1NhLXpcXHhBMS1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkrKSg/OlxcLig/Oig/OlswLTlLU2EtelxceEExLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKSstPykqKD86WzAtOUtTYS16XFx4QTEtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKykqKD86XFwuKD86KD86W0tTYS16XFx4QTEtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pezIsfSkpKSg/OjpbMC05XXsyLDV9KT8oPzpcXC8oPzpbXFwwLVxceDA4XFx4MEUtXFx4MUYhLVxceDlGXFx4QTEtXFx1MTY3RlxcdTE2ODEtXFx1MUZGRlxcdTIwMEItXFx1MjAyN1xcdTIwMkEtXFx1MjAyRVxcdTIwMzAtXFx1MjA1RVxcdTIwNjAtXFx1MkZGRlxcdTMwMDEtXFx1RDdGRlxcdUUwMDAtXFx1RkVGRVxcdUZGMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkqKT8kL2k7XG52YXIgVVVJRCA9IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pO1xudmFyIEpTT05fUE9JTlRFUiA9IC9eKD86XFwvKD86W15+L118fjB8fjEpKikqJC87XG52YXIgSlNPTl9QT0lOVEVSX1VSSV9GUkFHTUVOVCA9IC9eIyg/OlxcLyg/OlthLXowLTlfXFwtLiEkJicoKSorLDs6PUBdfCVbMC05YS1mXXsyfXx+MHx+MSkqKSokL2k7XG52YXIgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZm9ybWF0cztcblxuZnVuY3Rpb24gZm9ybWF0cyhtb2RlKSB7XG4gIG1vZGUgPSBtb2RlID09ICdmdWxsJyA/ICdmdWxsJyA6ICdmYXN0JztcbiAgcmV0dXJuIHV0aWwuY29weShmb3JtYXRzW21vZGVdKTtcbn1cblxuXG5mb3JtYXRzLmZhc3QgPSB7XG4gIC8vIGRhdGU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgZGF0ZTogL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLyxcbiAgLy8gZGF0ZS10aW1lOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gIHRpbWU6IC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkOlxcZFxcZCk/JC9pLFxuICAnZGF0ZS10aW1lJzogL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGRbdFxcc10oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQ6XFxkXFxkKSQvaSxcbiAgLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuICB1cmk6IC9eKD86W2Etel1bYS16MC05Ky0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2ksXG4gICd1cmktcmVmZXJlbmNlJzogL14oPzooPzpbYS16XVthLXowLTkrLS5dKjopP1xcLz9cXC8pPyg/OlteXFxcXFxccyNdW15cXHMjXSopPyg/OiNbXlxcXFxcXHNdKik/JC9pLFxuICAndXJpLXRlbXBsYXRlJzogVVJJVEVNUExBVEUsXG4gIHVybDogVVJMLFxuICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDEzMjMvdXNpbmctYS1yZWd1bGFyLWV4cHJlc3Npb24tdG8tdmFsaWRhdGUtYW4tZW1haWwtYWRkcmVzcyNhbnN3ZXItODgyOTM2M1xuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxsZnVsIHZpb2xhdGlvbicpXG4gIGVtYWlsOiAvXlthLXowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rQFthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPykqJC9pLFxuICBob3N0bmFtZTogSE9TVE5BTUUsXG4gIC8vIG9wdGltaXplZCBodHRwczovL3d3dy5zYWZhcmlib29rc29ubGluZS5jb20vbGlicmFyeS92aWV3L3JlZ3VsYXItZXhwcmVzc2lvbnMtY29va2Jvb2svOTc4MDU5NjgwMjgzNy9jaDA3czE2Lmh0bWxcbiAgaXB2NDogL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykkLyxcbiAgLy8gb3B0aW1pemVkIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTM0OTcvcmVndWxhci1leHByZXNzaW9uLXRoYXQtbWF0Y2hlcy12YWxpZC1pcHY2LWFkZHJlc3Nlc1xuICBpcHY2OiAvXlxccyooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7N30oPzpbMC05YS1mXXsxLDR9fDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Nn0oPzo6WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezV9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsMn0pfDooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezR9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsM30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KT86KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7M30oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw0fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsMn06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Mn0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw1fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsM306KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw2fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNH06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzo6KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsN30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDV9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpKD86JS4rKT9cXHMqJC9pLFxuICByZWdleDogcmVnZXgsXG4gIC8vIHV1aWQ6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQxMjJcbiAgdXVpZDogVVVJRCxcbiAgLy8gSlNPTi1wb2ludGVyOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMVxuICAvLyB1cmkgZnJhZ21lbnQ6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I2FwcGVuZGl4LUFcbiAgJ2pzb24tcG9pbnRlcic6IEpTT05fUE9JTlRFUixcbiAgJ2pzb24tcG9pbnRlci11cmktZnJhZ21lbnQnOiBKU09OX1BPSU5URVJfVVJJX0ZSQUdNRU5ULFxuICAvLyByZWxhdGl2ZSBKU09OLXBvaW50ZXI6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWx1ZmYtcmVsYXRpdmUtanNvbi1wb2ludGVyLTAwXG4gICdyZWxhdGl2ZS1qc29uLXBvaW50ZXInOiBSRUxBVElWRV9KU09OX1BPSU5URVJcbn07XG5cblxuZm9ybWF0cy5mdWxsID0ge1xuICBkYXRlOiBkYXRlLFxuICB0aW1lOiB0aW1lLFxuICAnZGF0ZS10aW1lJzogZGF0ZV90aW1lLFxuICB1cmk6IHVyaSxcbiAgJ3VyaS1yZWZlcmVuY2UnOiBVUklSRUYsXG4gICd1cmktdGVtcGxhdGUnOiBVUklURU1QTEFURSxcbiAgdXJsOiBVUkwsXG4gIGVtYWlsOiAvXlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSpAKD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pPyQvaSxcbiAgaG9zdG5hbWU6IGhvc3RuYW1lLFxuICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvLFxuICBpcHY2OiAvXlxccyooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7N30oPzpbMC05YS1mXXsxLDR9fDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Nn0oPzo6WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezV9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsMn0pfDooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezR9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsM30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KT86KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7M30oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw0fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsMn06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Mn0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw1fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsM306KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw2fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNH06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzo6KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsN30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDV9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpKD86JS4rKT9cXHMqJC9pLFxuICByZWdleDogcmVnZXgsXG4gIHV1aWQ6IFVVSUQsXG4gICdqc29uLXBvaW50ZXInOiBKU09OX1BPSU5URVIsXG4gICdqc29uLXBvaW50ZXItdXJpLWZyYWdtZW50JzogSlNPTl9QT0lOVEVSX1VSSV9GUkFHTUVOVCxcbiAgJ3JlbGF0aXZlLWpzb24tcG9pbnRlcic6IFJFTEFUSVZFX0pTT05fUE9JTlRFUlxufTtcblxuXG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG59XG5cblxuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgLy8gZnVsbC1kYXRlIGZyb20gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICB2YXIgbWF0Y2hlcyA9IHN0ci5tYXRjaChEQVRFKTtcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHllYXIgPSArbWF0Y2hlc1sxXTtcbiAgdmFyIG1vbnRoID0gK21hdGNoZXNbMl07XG4gIHZhciBkYXkgPSArbWF0Y2hlc1szXTtcblxuICByZXR1cm4gbW9udGggPj0gMSAmJiBtb250aCA8PSAxMiAmJiBkYXkgPj0gMSAmJlxuICAgICAgICAgIGRheSA8PSAobW9udGggPT0gMiAmJiBpc0xlYXBZZWFyKHllYXIpID8gMjkgOiBEQVlTW21vbnRoXSk7XG59XG5cblxuZnVuY3Rpb24gdGltZShzdHIsIGZ1bGwpIHtcbiAgdmFyIG1hdGNoZXMgPSBzdHIubWF0Y2goVElNRSk7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBob3VyID0gbWF0Y2hlc1sxXTtcbiAgdmFyIG1pbnV0ZSA9IG1hdGNoZXNbMl07XG4gIHZhciBzZWNvbmQgPSBtYXRjaGVzWzNdO1xuICB2YXIgdGltZVpvbmUgPSBtYXRjaGVzWzVdO1xuICByZXR1cm4gKChob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTkpIHx8XG4gICAgICAgICAgKGhvdXIgPT0gMjMgJiYgbWludXRlID09IDU5ICYmIHNlY29uZCA9PSA2MCkpICYmXG4gICAgICAgICAoIWZ1bGwgfHwgdGltZVpvbmUpO1xufVxuXG5cbnZhciBEQVRFX1RJTUVfU0VQQVJBVE9SID0gL3R8XFxzL2k7XG5mdW5jdGlvbiBkYXRlX3RpbWUoc3RyKSB7XG4gIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgdmFyIGRhdGVUaW1lID0gc3RyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICByZXR1cm4gZGF0ZVRpbWUubGVuZ3RoID09IDIgJiYgZGF0ZShkYXRlVGltZVswXSkgJiYgdGltZShkYXRlVGltZVsxXSwgdHJ1ZSk7XG59XG5cblxuZnVuY3Rpb24gaG9zdG5hbWUoc3RyKSB7XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxMDM0I3NlY3Rpb24tMy41XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxMTIzI3NlY3Rpb24tMlxuICByZXR1cm4gc3RyLmxlbmd0aCA8PSAyNTUgJiYgSE9TVE5BTUUudGVzdChzdHIpO1xufVxuXG5cbnZhciBOT1RfVVJJX0ZSQUdNRU5UID0gL1xcL3w6LztcbmZ1bmN0aW9uIHVyaShzdHIpIHtcbiAgLy8gaHR0cDovL2ptcndhcmUuY29tL2FydGljbGVzLzIwMDkvdXJpX3JlZ2V4cC9VUklfcmVnZXguaHRtbCArIG9wdGlvbmFsIHByb3RvY29sICsgcmVxdWlyZWQgXCIuXCJcbiAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG59XG5cblxudmFyIFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi87XG5mdW5jdGlvbiByZWdleChzdHIpIHtcbiAgaWYgKFpfQU5DSE9SLnRlc3Qoc3RyKSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIG5ldyBSZWdFeHAoc3RyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXNvbHZlID0gcmVxdWlyZSgnLi9yZXNvbHZlJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbiAgLCBlcnJvckNsYXNzZXMgPSByZXF1aXJlKCcuL2Vycm9yX2NsYXNzZXMnKVxuICAsIHN0YWJsZVN0cmluZ2lmeSA9IHJlcXVpcmUoJ2Zhc3QtanNvbi1zdGFibGUtc3RyaW5naWZ5Jyk7XG5cbnZhciB2YWxpZGF0ZUdlbmVyYXRvciA9IHJlcXVpcmUoJy4uL2RvdGpzL3ZhbGlkYXRlJyk7XG5cbi8qKlxuICogRnVuY3Rpb25zIGJlbG93IGFyZSB1c2VkIGluc2lkZSBjb21waWxlZCB2YWxpZGF0aW9ucyBmdW5jdGlvblxuICovXG5cbnZhciB1Y3MybGVuZ3RoID0gdXRpbC51Y3MybGVuZ3RoO1xudmFyIGVxdWFsID0gcmVxdWlyZSgnZmFzdC1kZWVwLWVxdWFsJyk7XG5cbi8vIHRoaXMgZXJyb3IgaXMgdGhyb3duIGJ5IGFzeW5jIHNjaGVtYXMgdG8gcmV0dXJuIHZhbGlkYXRpb24gZXJyb3JzIHZpYSBleGNlcHRpb25cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSBlcnJvckNsYXNzZXMuVmFsaWRhdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlO1xuXG5cbi8qKlxuICogQ29tcGlsZXMgc2NoZW1hIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtPYmplY3R9IHNjaGVtYSBzY2hlbWEgb2JqZWN0XG4gKiBAcGFyYW0gIHtPYmplY3R9IHJvb3Qgb2JqZWN0IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb3Qgc2NoZW1hIGZvciB0aGlzIHNjaGVtYVxuICogQHBhcmFtICB7T2JqZWN0fSBsb2NhbFJlZnMgdGhlIGhhc2ggb2YgbG9jYWwgcmVmZXJlbmNlcyBpbnNpZGUgdGhlIHNjaGVtYSAoY3JlYXRlZCBieSByZXNvbHZlLmlkKSwgdXNlZCBmb3IgaW5saW5lIHJlc29sdXRpb25cbiAqIEBwYXJhbSAge1N0cmluZ30gYmFzZUlkIGJhc2UgSUQgZm9yIElEcyBpbiB0aGUgc2NoZW1hXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdmFsaWRhdGlvbiBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBjb21waWxlKHNjaGVtYSwgcm9vdCwgbG9jYWxSZWZzLCBiYXNlSWQpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSwgZXZpbDogdHJ1ZSAqL1xuICAvKiBlc2xpbnQgbm8tc2hhZG93OiAwICovXG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgb3B0cyA9IHRoaXMuX29wdHNcbiAgICAsIHJlZlZhbCA9IFsgdW5kZWZpbmVkIF1cbiAgICAsIHJlZnMgPSB7fVxuICAgICwgcGF0dGVybnMgPSBbXVxuICAgICwgcGF0dGVybnNIYXNoID0ge31cbiAgICAsIGRlZmF1bHRzID0gW11cbiAgICAsIGRlZmF1bHRzSGFzaCA9IHt9XG4gICAgLCBjdXN0b21SdWxlcyA9IFtdO1xuXG4gIHJvb3QgPSByb290IHx8IHsgc2NoZW1hOiBzY2hlbWEsIHJlZlZhbDogcmVmVmFsLCByZWZzOiByZWZzIH07XG5cbiAgdmFyIGMgPSBjaGVja0NvbXBpbGluZy5jYWxsKHRoaXMsIHNjaGVtYSwgcm9vdCwgYmFzZUlkKTtcbiAgdmFyIGNvbXBpbGF0aW9uID0gdGhpcy5fY29tcGlsYXRpb25zW2MuaW5kZXhdO1xuICBpZiAoYy5jb21waWxpbmcpIHJldHVybiAoY29tcGlsYXRpb24uY2FsbFZhbGlkYXRlID0gY2FsbFZhbGlkYXRlKTtcblxuICB2YXIgZm9ybWF0cyA9IHRoaXMuX2Zvcm1hdHM7XG4gIHZhciBSVUxFUyA9IHRoaXMuUlVMRVM7XG5cbiAgdHJ5IHtcbiAgICB2YXIgdiA9IGxvY2FsQ29tcGlsZShzY2hlbWEsIHJvb3QsIGxvY2FsUmVmcywgYmFzZUlkKTtcbiAgICBjb21waWxhdGlvbi52YWxpZGF0ZSA9IHY7XG4gICAgdmFyIGN2ID0gY29tcGlsYXRpb24uY2FsbFZhbGlkYXRlO1xuICAgIGlmIChjdikge1xuICAgICAgY3Yuc2NoZW1hID0gdi5zY2hlbWE7XG4gICAgICBjdi5lcnJvcnMgPSBudWxsO1xuICAgICAgY3YucmVmcyA9IHYucmVmcztcbiAgICAgIGN2LnJlZlZhbCA9IHYucmVmVmFsO1xuICAgICAgY3Yucm9vdCA9IHYucm9vdDtcbiAgICAgIGN2LiRhc3luYyA9IHYuJGFzeW5jO1xuICAgICAgaWYgKG9wdHMuc291cmNlQ29kZSkgY3Yuc291cmNlID0gdi5zb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9IGZpbmFsbHkge1xuICAgIGVuZENvbXBpbGluZy5jYWxsKHRoaXMsIHNjaGVtYSwgcm9vdCwgYmFzZUlkKTtcbiAgfVxuXG4gIC8qIEB0aGlzICAgeyp9IC0gY3VzdG9tIGNvbnRleHQsIHNlZSBwYXNzQ29udGV4dCBvcHRpb24gKi9cbiAgZnVuY3Rpb24gY2FsbFZhbGlkYXRlKCkge1xuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgICB2YXIgdmFsaWRhdGUgPSBjb21waWxhdGlvbi52YWxpZGF0ZTtcbiAgICB2YXIgcmVzdWx0ID0gdmFsaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBjYWxsVmFsaWRhdGUuZXJyb3JzID0gdmFsaWRhdGUuZXJyb3JzO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhbENvbXBpbGUoX3NjaGVtYSwgX3Jvb3QsIGxvY2FsUmVmcywgYmFzZUlkKSB7XG4gICAgdmFyIGlzUm9vdCA9ICFfcm9vdCB8fCAoX3Jvb3QgJiYgX3Jvb3Quc2NoZW1hID09IF9zY2hlbWEpO1xuICAgIGlmIChfcm9vdC5zY2hlbWEgIT0gcm9vdC5zY2hlbWEpXG4gICAgICByZXR1cm4gY29tcGlsZS5jYWxsKHNlbGYsIF9zY2hlbWEsIF9yb290LCBsb2NhbFJlZnMsIGJhc2VJZCk7XG5cbiAgICB2YXIgJGFzeW5jID0gX3NjaGVtYS4kYXN5bmMgPT09IHRydWU7XG5cbiAgICB2YXIgc291cmNlQ29kZSA9IHZhbGlkYXRlR2VuZXJhdG9yKHtcbiAgICAgIGlzVG9wOiB0cnVlLFxuICAgICAgc2NoZW1hOiBfc2NoZW1hLFxuICAgICAgaXNSb290OiBpc1Jvb3QsXG4gICAgICBiYXNlSWQ6IGJhc2VJZCxcbiAgICAgIHJvb3Q6IF9yb290LFxuICAgICAgc2NoZW1hUGF0aDogJycsXG4gICAgICBlcnJTY2hlbWFQYXRoOiAnIycsXG4gICAgICBlcnJvclBhdGg6ICdcIlwiJyxcbiAgICAgIE1pc3NpbmdSZWZFcnJvcjogZXJyb3JDbGFzc2VzLk1pc3NpbmdSZWYsXG4gICAgICBSVUxFUzogUlVMRVMsXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGVHZW5lcmF0b3IsXG4gICAgICB1dGlsOiB1dGlsLFxuICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgIHJlc29sdmVSZWY6IHJlc29sdmVSZWYsXG4gICAgICB1c2VQYXR0ZXJuOiB1c2VQYXR0ZXJuLFxuICAgICAgdXNlRGVmYXVsdDogdXNlRGVmYXVsdCxcbiAgICAgIHVzZUN1c3RvbVJ1bGU6IHVzZUN1c3RvbVJ1bGUsXG4gICAgICBvcHRzOiBvcHRzLFxuICAgICAgZm9ybWF0czogZm9ybWF0cyxcbiAgICAgIGxvZ2dlcjogc2VsZi5sb2dnZXIsXG4gICAgICBzZWxmOiBzZWxmXG4gICAgfSk7XG5cbiAgICBzb3VyY2VDb2RlID0gdmFycyhyZWZWYWwsIHJlZlZhbENvZGUpICsgdmFycyhwYXR0ZXJucywgcGF0dGVybkNvZGUpXG4gICAgICAgICAgICAgICAgICAgKyB2YXJzKGRlZmF1bHRzLCBkZWZhdWx0Q29kZSkgKyB2YXJzKGN1c3RvbVJ1bGVzLCBjdXN0b21SdWxlQ29kZSlcbiAgICAgICAgICAgICAgICAgICArIHNvdXJjZUNvZGU7XG5cbiAgICBpZiAob3B0cy5wcm9jZXNzQ29kZSkgc291cmNlQ29kZSA9IG9wdHMucHJvY2Vzc0NvZGUoc291cmNlQ29kZSk7XG4gICAgLy8gY29uc29sZS5sb2coJ1xcblxcblxcbiAqKiogXFxuJywgSlNPTi5zdHJpbmdpZnkoc291cmNlQ29kZSkpO1xuICAgIHZhciB2YWxpZGF0ZTtcbiAgICB0cnkge1xuICAgICAgdmFyIG1ha2VWYWxpZGF0ZSA9IG5ldyBGdW5jdGlvbihcbiAgICAgICAgJ3NlbGYnLFxuICAgICAgICAnUlVMRVMnLFxuICAgICAgICAnZm9ybWF0cycsXG4gICAgICAgICdyb290JyxcbiAgICAgICAgJ3JlZlZhbCcsXG4gICAgICAgICdkZWZhdWx0cycsXG4gICAgICAgICdjdXN0b21SdWxlcycsXG4gICAgICAgICdlcXVhbCcsXG4gICAgICAgICd1Y3MybGVuZ3RoJyxcbiAgICAgICAgJ1ZhbGlkYXRpb25FcnJvcicsXG4gICAgICAgIHNvdXJjZUNvZGVcbiAgICAgICk7XG5cbiAgICAgIHZhbGlkYXRlID0gbWFrZVZhbGlkYXRlKFxuICAgICAgICBzZWxmLFxuICAgICAgICBSVUxFUyxcbiAgICAgICAgZm9ybWF0cyxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcmVmVmFsLFxuICAgICAgICBkZWZhdWx0cyxcbiAgICAgICAgY3VzdG9tUnVsZXMsXG4gICAgICAgIGVxdWFsLFxuICAgICAgICB1Y3MybGVuZ3RoLFxuICAgICAgICBWYWxpZGF0aW9uRXJyb3JcbiAgICAgICk7XG5cbiAgICAgIHJlZlZhbFswXSA9IHZhbGlkYXRlO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoJ0Vycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6Jywgc291cmNlQ29kZSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhbGlkYXRlLnNjaGVtYSA9IF9zY2hlbWE7XG4gICAgdmFsaWRhdGUuZXJyb3JzID0gbnVsbDtcbiAgICB2YWxpZGF0ZS5yZWZzID0gcmVmcztcbiAgICB2YWxpZGF0ZS5yZWZWYWwgPSByZWZWYWw7XG4gICAgdmFsaWRhdGUucm9vdCA9IGlzUm9vdCA/IHZhbGlkYXRlIDogX3Jvb3Q7XG4gICAgaWYgKCRhc3luYykgdmFsaWRhdGUuJGFzeW5jID0gdHJ1ZTtcbiAgICBpZiAob3B0cy5zb3VyY2VDb2RlID09PSB0cnVlKSB7XG4gICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7XG4gICAgICAgIGNvZGU6IHNvdXJjZUNvZGUsXG4gICAgICAgIHBhdHRlcm5zOiBwYXR0ZXJucyxcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVSZWYoYmFzZUlkLCByZWYsIGlzUm9vdCkge1xuICAgIHJlZiA9IHJlc29sdmUudXJsKGJhc2VJZCwgcmVmKTtcbiAgICB2YXIgcmVmSW5kZXggPSByZWZzW3JlZl07XG4gICAgdmFyIF9yZWZWYWwsIHJlZkNvZGU7XG4gICAgaWYgKHJlZkluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIF9yZWZWYWwgPSByZWZWYWxbcmVmSW5kZXhdO1xuICAgICAgcmVmQ29kZSA9ICdyZWZWYWxbJyArIHJlZkluZGV4ICsgJ10nO1xuICAgICAgcmV0dXJuIHJlc29sdmVkUmVmKF9yZWZWYWwsIHJlZkNvZGUpO1xuICAgIH1cbiAgICBpZiAoIWlzUm9vdCAmJiByb290LnJlZnMpIHtcbiAgICAgIHZhciByb290UmVmSWQgPSByb290LnJlZnNbcmVmXTtcbiAgICAgIGlmIChyb290UmVmSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfcmVmVmFsID0gcm9vdC5yZWZWYWxbcm9vdFJlZklkXTtcbiAgICAgICAgcmVmQ29kZSA9IGFkZExvY2FsUmVmKHJlZiwgX3JlZlZhbCk7XG4gICAgICAgIHJldHVybiByZXNvbHZlZFJlZihfcmVmVmFsLCByZWZDb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWZDb2RlID0gYWRkTG9jYWxSZWYocmVmKTtcbiAgICB2YXIgdiA9IHJlc29sdmUuY2FsbChzZWxmLCBsb2NhbENvbXBpbGUsIHJvb3QsIHJlZik7XG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGxvY2FsU2NoZW1hID0gbG9jYWxSZWZzICYmIGxvY2FsUmVmc1tyZWZdO1xuICAgICAgaWYgKGxvY2FsU2NoZW1hKSB7XG4gICAgICAgIHYgPSByZXNvbHZlLmlubGluZVJlZihsb2NhbFNjaGVtYSwgb3B0cy5pbmxpbmVSZWZzKVxuICAgICAgICAgICAgPyBsb2NhbFNjaGVtYVxuICAgICAgICAgICAgOiBjb21waWxlLmNhbGwoc2VsZiwgbG9jYWxTY2hlbWEsIHJvb3QsIGxvY2FsUmVmcywgYmFzZUlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW1vdmVMb2NhbFJlZihyZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlTG9jYWxSZWYocmVmLCB2KTtcbiAgICAgIHJldHVybiByZXNvbHZlZFJlZih2LCByZWZDb2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMb2NhbFJlZihyZWYsIHYpIHtcbiAgICB2YXIgcmVmSWQgPSByZWZWYWwubGVuZ3RoO1xuICAgIHJlZlZhbFtyZWZJZF0gPSB2O1xuICAgIHJlZnNbcmVmXSA9IHJlZklkO1xuICAgIHJldHVybiAncmVmVmFsJyArIHJlZklkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTG9jYWxSZWYocmVmKSB7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VMb2NhbFJlZihyZWYsIHYpIHtcbiAgICB2YXIgcmVmSWQgPSByZWZzW3JlZl07XG4gICAgcmVmVmFsW3JlZklkXSA9IHY7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlZFJlZihyZWZWYWwsIGNvZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHJlZlZhbCA9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVmVmFsID09ICdib29sZWFuJ1xuICAgICAgICAgICAgPyB7IGNvZGU6IGNvZGUsIHNjaGVtYTogcmVmVmFsLCBpbmxpbmU6IHRydWUgfVxuICAgICAgICAgICAgOiB7IGNvZGU6IGNvZGUsICRhc3luYzogcmVmVmFsICYmICEhcmVmVmFsLiRhc3luYyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlUGF0dGVybihyZWdleFN0cikge1xuICAgIHZhciBpbmRleCA9IHBhdHRlcm5zSGFzaFtyZWdleFN0cl07XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZGV4ID0gcGF0dGVybnNIYXNoW3JlZ2V4U3RyXSA9IHBhdHRlcm5zLmxlbmd0aDtcbiAgICAgIHBhdHRlcm5zW2luZGV4XSA9IHJlZ2V4U3RyO1xuICAgIH1cbiAgICByZXR1cm4gJ3BhdHRlcm4nICsgaW5kZXg7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VEZWZhdWx0KHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWU7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gdXRpbC50b1F1b3RlZFN0cmluZyh2YWx1ZSk7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gICAgICAgIHZhciB2YWx1ZVN0ciA9IHN0YWJsZVN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIHZhciBpbmRleCA9IGRlZmF1bHRzSGFzaFt2YWx1ZVN0cl07XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5kZXggPSBkZWZhdWx0c0hhc2hbdmFsdWVTdHJdID0gZGVmYXVsdHMubGVuZ3RoO1xuICAgICAgICAgIGRlZmF1bHRzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCcgKyBpbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VDdXN0b21SdWxlKHJ1bGUsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkge1xuICAgIHZhciB2YWxpZGF0ZVNjaGVtYSA9IHJ1bGUuZGVmaW5pdGlvbi52YWxpZGF0ZVNjaGVtYTtcbiAgICBpZiAodmFsaWRhdGVTY2hlbWEgJiYgc2VsZi5fb3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciB2YWxpZCA9IHZhbGlkYXRlU2NoZW1hKHNjaGVtYSk7XG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ2tleXdvcmQgc2NoZW1hIGlzIGludmFsaWQ6ICcgKyBzZWxmLmVycm9yc1RleHQodmFsaWRhdGVTY2hlbWEuZXJyb3JzKTtcbiAgICAgICAgaWYgKHNlbGYuX29wdHMudmFsaWRhdGVTY2hlbWEgPT0gJ2xvZycpIHNlbGYubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29tcGlsZSA9IHJ1bGUuZGVmaW5pdGlvbi5jb21waWxlXG4gICAgICAsIGlubGluZSA9IHJ1bGUuZGVmaW5pdGlvbi5pbmxpbmVcbiAgICAgICwgbWFjcm8gPSBydWxlLmRlZmluaXRpb24ubWFjcm87XG5cbiAgICB2YXIgdmFsaWRhdGU7XG4gICAgaWYgKGNvbXBpbGUpIHtcbiAgICAgIHZhbGlkYXRlID0gY29tcGlsZS5jYWxsKHNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCk7XG4gICAgfSBlbHNlIGlmIChtYWNybykge1xuICAgICAgdmFsaWRhdGUgPSBtYWNyby5jYWxsKHNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCk7XG4gICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpIHNlbGYudmFsaWRhdGVTY2hlbWEodmFsaWRhdGUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoaW5saW5lKSB7XG4gICAgICB2YWxpZGF0ZSA9IGlubGluZS5jYWxsKHNlbGYsIGl0LCBydWxlLmtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGUgPSBydWxlLmRlZmluaXRpb24udmFsaWRhdGU7XG4gICAgICBpZiAoIXZhbGlkYXRlKSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZhbGlkYXRlID09PSB1bmRlZmluZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1c3RvbSBrZXl3b3JkIFwiJyArIHJ1bGUua2V5d29yZCArICdcImZhaWxlZCB0byBjb21waWxlJyk7XG5cbiAgICB2YXIgaW5kZXggPSBjdXN0b21SdWxlcy5sZW5ndGg7XG4gICAgY3VzdG9tUnVsZXNbaW5kZXhdID0gdmFsaWRhdGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogJ2N1c3RvbVJ1bGUnICsgaW5kZXgsXG4gICAgICB2YWxpZGF0ZTogdmFsaWRhdGVcbiAgICB9O1xuICB9XG59XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNjaGVtYSBpcyBjdXJyZW50bHkgY29tcGlsZWRcbiAqIEB0aGlzICAgQWp2XG4gKiBAcGFyYW0gIHtPYmplY3R9IHNjaGVtYSBzY2hlbWEgdG8gY29tcGlsZVxuICogQHBhcmFtICB7T2JqZWN0fSByb290IHJvb3Qgb2JqZWN0XG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJhc2VJZCBiYXNlIHNjaGVtYSBJRFxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIFwiaW5kZXhcIiAoY29tcGlsYXRpb24gaW5kZXgpIGFuZCBcImNvbXBpbGluZ1wiIChib29sZWFuKVxuICovXG5mdW5jdGlvbiBjaGVja0NvbXBpbGluZyhzY2hlbWEsIHJvb3QsIGJhc2VJZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBpbmRleCA9IGNvbXBJbmRleC5jYWxsKHRoaXMsIHNjaGVtYSwgcm9vdCwgYmFzZUlkKTtcbiAgaWYgKGluZGV4ID49IDApIHJldHVybiB7IGluZGV4OiBpbmRleCwgY29tcGlsaW5nOiB0cnVlIH07XG4gIGluZGV4ID0gdGhpcy5fY29tcGlsYXRpb25zLmxlbmd0aDtcbiAgdGhpcy5fY29tcGlsYXRpb25zW2luZGV4XSA9IHtcbiAgICBzY2hlbWE6IHNjaGVtYSxcbiAgICByb290OiByb290LFxuICAgIGJhc2VJZDogYmFzZUlkXG4gIH07XG4gIHJldHVybiB7IGluZGV4OiBpbmRleCwgY29tcGlsaW5nOiBmYWxzZSB9O1xufVxuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgc2NoZW1hIGZyb20gdGhlIGN1cnJlbnRseSBjb21waWxlZCBsaXN0XG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWEgc2NoZW1hIHRvIGNvbXBpbGVcbiAqIEBwYXJhbSAge09iamVjdH0gcm9vdCByb290IG9iamVjdFxuICogQHBhcmFtICB7U3RyaW5nfSBiYXNlSWQgYmFzZSBzY2hlbWEgSURcbiAqL1xuZnVuY3Rpb24gZW5kQ29tcGlsaW5nKHNjaGVtYSwgcm9vdCwgYmFzZUlkKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgdmFyIGkgPSBjb21wSW5kZXguY2FsbCh0aGlzLCBzY2hlbWEsIHJvb3QsIGJhc2VJZCk7XG4gIGlmIChpID49IDApIHRoaXMuX2NvbXBpbGF0aW9ucy5zcGxpY2UoaSwgMSk7XG59XG5cblxuLyoqXG4gKiBJbmRleCBvZiBzY2hlbWEgY29tcGlsYXRpb24gaW4gdGhlIGN1cnJlbnRseSBjb21waWxlZCBsaXN0XG4gKiBAdGhpcyAgIEFqdlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWEgc2NoZW1hIHRvIGNvbXBpbGVcbiAqIEBwYXJhbSAge09iamVjdH0gcm9vdCByb290IG9iamVjdFxuICogQHBhcmFtICB7U3RyaW5nfSBiYXNlSWQgYmFzZSBzY2hlbWEgSURcbiAqIEByZXR1cm4ge0ludGVnZXJ9IGNvbXBpbGF0aW9uIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGNvbXBJbmRleChzY2hlbWEsIHJvb3QsIGJhc2VJZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIGZvciAodmFyIGk9MDsgaTx0aGlzLl9jb21waWxhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IHRoaXMuX2NvbXBpbGF0aW9uc1tpXTtcbiAgICBpZiAoYy5zY2hlbWEgPT0gc2NoZW1hICYmIGMucm9vdCA9PSByb290ICYmIGMuYmFzZUlkID09IGJhc2VJZCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5cbmZ1bmN0aW9uIHBhdHRlcm5Db2RlKGksIHBhdHRlcm5zKSB7XG4gIHJldHVybiAndmFyIHBhdHRlcm4nICsgaSArICcgPSBuZXcgUmVnRXhwKCcgKyB1dGlsLnRvUXVvdGVkU3RyaW5nKHBhdHRlcm5zW2ldKSArICcpOyc7XG59XG5cblxuZnVuY3Rpb24gZGVmYXVsdENvZGUoaSkge1xuICByZXR1cm4gJ3ZhciBkZWZhdWx0JyArIGkgKyAnID0gZGVmYXVsdHNbJyArIGkgKyAnXTsnO1xufVxuXG5cbmZ1bmN0aW9uIHJlZlZhbENvZGUoaSwgcmVmVmFsKSB7XG4gIHJldHVybiByZWZWYWxbaV0gPT09IHVuZGVmaW5lZCA/ICcnIDogJ3ZhciByZWZWYWwnICsgaSArICcgPSByZWZWYWxbJyArIGkgKyAnXTsnO1xufVxuXG5cbmZ1bmN0aW9uIGN1c3RvbVJ1bGVDb2RlKGkpIHtcbiAgcmV0dXJuICd2YXIgY3VzdG9tUnVsZScgKyBpICsgJyA9IGN1c3RvbVJ1bGVzWycgKyBpICsgJ107Jztcbn1cblxuXG5mdW5jdGlvbiB2YXJzKGFyciwgc3RhdGVtZW50KSB7XG4gIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuICcnO1xuICB2YXIgY29kZSA9ICcnO1xuICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKVxuICAgIGNvZGUgKz0gc3RhdGVtZW50KGksIGFycik7XG4gIHJldHVybiBjb2RlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVVJJID0gcmVxdWlyZSgndXJpLWpzJylcbiAgLCBlcXVhbCA9IHJlcXVpcmUoJ2Zhc3QtZGVlcC1lcXVhbCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG4gICwgU2NoZW1hT2JqZWN0ID0gcmVxdWlyZSgnLi9zY2hlbWFfb2JqJylcbiAgLCB0cmF2ZXJzZSA9IHJlcXVpcmUoJ2pzb24tc2NoZW1hLXRyYXZlcnNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZTtcblxucmVzb2x2ZS5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xucmVzb2x2ZS5mdWxsUGF0aCA9IGdldEZ1bGxQYXRoO1xucmVzb2x2ZS51cmwgPSByZXNvbHZlVXJsO1xucmVzb2x2ZS5pZHMgPSByZXNvbHZlSWRzO1xucmVzb2x2ZS5pbmxpbmVSZWYgPSBpbmxpbmVSZWY7XG5yZXNvbHZlLnNjaGVtYSA9IHJlc29sdmVTY2hlbWE7XG5cbi8qKlxuICogW3Jlc29sdmUgYW5kIGNvbXBpbGUgdGhlIHJlZmVyZW5jZXMgKCRyZWYpXVxuICogQHRoaXMgICBBanZcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjb21waWxlIHJlZmVyZW5jZSB0byBzY2hlbWEgY29tcGlsYXRpb24gZnVuY2l0b24gKGxvY2FsQ29tcGlsZSlcbiAqIEBwYXJhbSAge09iamVjdH0gcm9vdCBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxuICogQHBhcmFtICB7U3RyaW5nfSByZWYgcmVmZXJlbmNlIHRvIHJlc29sdmVcbiAqIEByZXR1cm4ge09iamVjdHxGdW5jdGlvbn0gc2NoZW1hIG9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuICovXG5mdW5jdGlvbiByZXNvbHZlKGNvbXBpbGUsIHJvb3QsIHJlZikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciByZWZWYWwgPSB0aGlzLl9yZWZzW3JlZl07XG4gIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHRoaXMuX3JlZnNbcmVmVmFsXSkgcmVmVmFsID0gdGhpcy5fcmVmc1tyZWZWYWxdO1xuICAgIGVsc2UgcmV0dXJuIHJlc29sdmUuY2FsbCh0aGlzLCBjb21waWxlLCByb290LCByZWZWYWwpO1xuICB9XG5cbiAgcmVmVmFsID0gcmVmVmFsIHx8IHRoaXMuX3NjaGVtYXNbcmVmXTtcbiAgaWYgKHJlZlZhbCBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdCkge1xuICAgIHJldHVybiBpbmxpbmVSZWYocmVmVmFsLnNjaGVtYSwgdGhpcy5fb3B0cy5pbmxpbmVSZWZzKVxuICAgICAgICAgICAgPyByZWZWYWwuc2NoZW1hXG4gICAgICAgICAgICA6IHJlZlZhbC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlKHJlZlZhbCk7XG4gIH1cblxuICB2YXIgcmVzID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHJlZik7XG4gIHZhciBzY2hlbWEsIHYsIGJhc2VJZDtcbiAgaWYgKHJlcykge1xuICAgIHNjaGVtYSA9IHJlcy5zY2hlbWE7XG4gICAgcm9vdCA9IHJlcy5yb290O1xuICAgIGJhc2VJZCA9IHJlcy5iYXNlSWQ7XG4gIH1cblxuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hT2JqZWN0KSB7XG4gICAgdiA9IHNjaGVtYS52YWxpZGF0ZSB8fCBjb21waWxlLmNhbGwodGhpcywgc2NoZW1hLnNjaGVtYSwgcm9vdCwgdW5kZWZpbmVkLCBiYXNlSWQpO1xuICB9IGVsc2UgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdiA9IGlubGluZVJlZihzY2hlbWEsIHRoaXMuX29wdHMuaW5saW5lUmVmcylcbiAgICAgICAgPyBzY2hlbWFcbiAgICAgICAgOiBjb21waWxlLmNhbGwodGhpcywgc2NoZW1hLCByb290LCB1bmRlZmluZWQsIGJhc2VJZCk7XG4gIH1cblxuICByZXR1cm4gdjtcbn1cblxuXG4vKipcbiAqIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG4gKiBAdGhpcyBBanZcbiAqIEBwYXJhbSAge09iamVjdH0gcm9vdCByb290IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc2NoZW1hLCByZWZWYWwsIHJlZnNcbiAqIEBwYXJhbSAge1N0cmluZ30gcmVmICByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNjaGVtYSwgcm9vdCwgYmFzZUlkXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTY2hlbWEocm9vdCwgcmVmKSB7XG4gIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cbiAgdmFyIHAgPSBVUkkucGFyc2UocmVmKVxuICAgICwgcmVmUGF0aCA9IF9nZXRGdWxsUGF0aChwKVxuICAgICwgYmFzZUlkID0gZ2V0RnVsbFBhdGgodGhpcy5fZ2V0SWQocm9vdC5zY2hlbWEpKTtcbiAgaWYgKE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPT09IDAgfHwgcmVmUGF0aCAhPT0gYmFzZUlkKSB7XG4gICAgdmFyIGlkID0gbm9ybWFsaXplSWQocmVmUGF0aCk7XG4gICAgdmFyIHJlZlZhbCA9IHRoaXMuX3JlZnNbaWRdO1xuICAgIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVJlY3Vyc2l2ZS5jYWxsKHRoaXMsIHJvb3QsIHJlZlZhbCwgcCk7XG4gICAgfSBlbHNlIGlmIChyZWZWYWwgaW5zdGFuY2VvZiBTY2hlbWFPYmplY3QpIHtcbiAgICAgIGlmICghcmVmVmFsLnZhbGlkYXRlKSB0aGlzLl9jb21waWxlKHJlZlZhbCk7XG4gICAgICByb290ID0gcmVmVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZWYWwgPSB0aGlzLl9zY2hlbWFzW2lkXTtcbiAgICAgIGlmIChyZWZWYWwgaW5zdGFuY2VvZiBTY2hlbWFPYmplY3QpIHtcbiAgICAgICAgaWYgKCFyZWZWYWwudmFsaWRhdGUpIHRoaXMuX2NvbXBpbGUocmVmVmFsKTtcbiAgICAgICAgaWYgKGlkID09IG5vcm1hbGl6ZUlkKHJlZikpXG4gICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiByZWZWYWwsIHJvb3Q6IHJvb3QsIGJhc2VJZDogYmFzZUlkIH07XG4gICAgICAgIHJvb3QgPSByZWZWYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcm9vdC5zY2hlbWEpIHJldHVybjtcbiAgICBiYXNlSWQgPSBnZXRGdWxsUGF0aCh0aGlzLl9nZXRJZChyb290LnNjaGVtYSkpO1xuICB9XG4gIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIGJhc2VJZCwgcm9vdC5zY2hlbWEsIHJvb3QpO1xufVxuXG5cbi8qIEB0aGlzIEFqdiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVJlY3Vyc2l2ZShyb290LCByZWYsIHBhcnNlZFJlZikge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciByZXMgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbiAgaWYgKHJlcykge1xuICAgIHZhciBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgIHZhciBiYXNlSWQgPSByZXMuYmFzZUlkO1xuICAgIHJvb3QgPSByZXMucm9vdDtcbiAgICB2YXIgaWQgPSB0aGlzLl9nZXRJZChzY2hlbWEpO1xuICAgIGlmIChpZCkgYmFzZUlkID0gcmVzb2x2ZVVybChiYXNlSWQsIGlkKTtcbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwYXJzZWRSZWYsIGJhc2VJZCwgc2NoZW1hLCByb290KTtcbiAgfVxufVxuXG5cbnZhciBQUkVWRU5UX1NDT1BFX0NIQU5HRSA9IHV0aWwudG9IYXNoKFsncHJvcGVydGllcycsICdwYXR0ZXJuUHJvcGVydGllcycsICdlbnVtJywgJ2RlcGVuZGVuY2llcycsICdkZWZpbml0aW9ucyddKTtcbi8qIEB0aGlzIEFqdiAqL1xuZnVuY3Rpb24gZ2V0SnNvblBvaW50ZXIocGFyc2VkUmVmLCBiYXNlSWQsIHNjaGVtYSwgcm9vdCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHBhcnNlZFJlZi5mcmFnbWVudCA9IHBhcnNlZFJlZi5mcmFnbWVudCB8fCAnJztcbiAgaWYgKHBhcnNlZFJlZi5mcmFnbWVudC5zbGljZSgwLDEpICE9ICcvJykgcmV0dXJuO1xuICB2YXIgcGFydHMgPSBwYXJzZWRSZWYuZnJhZ21lbnQuc3BsaXQoJy8nKTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCkge1xuICAgICAgcGFydCA9IHV0aWwudW5lc2NhcGVGcmFnbWVudChwYXJ0KTtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYVtwYXJ0XTtcbiAgICAgIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICB2YXIgaWQ7XG4gICAgICBpZiAoIVBSRVZFTlRfU0NPUEVfQ0hBTkdFW3BhcnRdKSB7XG4gICAgICAgIGlkID0gdGhpcy5fZ2V0SWQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGlkKSBiYXNlSWQgPSByZXNvbHZlVXJsKGJhc2VJZCwgaWQpO1xuICAgICAgICBpZiAoc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgICB2YXIgJHJlZiA9IHJlc29sdmVVcmwoYmFzZUlkLCBzY2hlbWEuJHJlZik7XG4gICAgICAgICAgdmFyIHJlcyA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCAkcmVmKTtcbiAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgICAgICAgICAgcm9vdCA9IHJlcy5yb290O1xuICAgICAgICAgICAgYmFzZUlkID0gcmVzLmJhc2VJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYSAhPT0gcm9vdC5zY2hlbWEpXG4gICAgcmV0dXJuIHsgc2NoZW1hOiBzY2hlbWEsIHJvb3Q6IHJvb3QsIGJhc2VJZDogYmFzZUlkIH07XG59XG5cblxudmFyIFNJTVBMRV9JTkxJTkVEID0gdXRpbC50b0hhc2goW1xuICAndHlwZScsICdmb3JtYXQnLCAncGF0dGVybicsXG4gICdtYXhMZW5ndGgnLCAnbWluTGVuZ3RoJyxcbiAgJ21heFByb3BlcnRpZXMnLCAnbWluUHJvcGVydGllcycsXG4gICdtYXhJdGVtcycsICdtaW5JdGVtcycsXG4gICdtYXhpbXVtJywgJ21pbmltdW0nLFxuICAndW5pcXVlSXRlbXMnLCAnbXVsdGlwbGVPZicsXG4gICdyZXF1aXJlZCcsICdlbnVtJ1xuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCkge1xuICBpZiAobGltaXQgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkIHx8IGxpbWl0ID09PSB0cnVlKSByZXR1cm4gY2hlY2tOb1JlZihzY2hlbWEpO1xuICBlbHNlIGlmIChsaW1pdCkgcmV0dXJuIGNvdW50S2V5cyhzY2hlbWEpIDw9IGxpbWl0O1xufVxuXG5cbmZ1bmN0aW9uIGNoZWNrTm9SZWYoc2NoZW1hKSB7XG4gIHZhciBpdGVtO1xuICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPHNjaGVtYS5sZW5ndGg7IGkrKykge1xuICAgICAgaXRlbSA9IHNjaGVtYVtpXTtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSAnb2JqZWN0JyAmJiAhY2hlY2tOb1JlZihpdGVtKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAoa2V5ID09ICckcmVmJykgcmV0dXJuIGZhbHNlO1xuICAgICAgaXRlbSA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdvYmplY3QnICYmICFjaGVja05vUmVmKGl0ZW0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIGNvdW50S2V5cyhzY2hlbWEpIHtcbiAgdmFyIGNvdW50ID0gMCwgaXRlbTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIGZvciAodmFyIGk9MDsgaTxzY2hlbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGl0ZW0gPSBzY2hlbWFbaV07XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gJ29iamVjdCcpIGNvdW50ICs9IGNvdW50S2V5cyhpdGVtKTtcbiAgICAgIGlmIChjb3VudCA9PSBJbmZpbml0eSkgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICBpZiAoa2V5ID09ICckcmVmJykgcmV0dXJuIEluZmluaXR5O1xuICAgICAgaWYgKFNJTVBMRV9JTkxJTkVEW2tleV0pIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0gPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09ICdvYmplY3QnKSBjb3VudCArPSBjb3VudEtleXMoaXRlbSkgKyAxO1xuICAgICAgICBpZiAoY291bnQgPT0gSW5maW5pdHkpIHJldHVybiBJbmZpbml0eTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoKGlkLCBub3JtYWxpemUpIHtcbiAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICB2YXIgcCA9IFVSSS5wYXJzZShpZCk7XG4gIHJldHVybiBfZ2V0RnVsbFBhdGgocCk7XG59XG5cblxuZnVuY3Rpb24gX2dldEZ1bGxQYXRoKHApIHtcbiAgcmV0dXJuIFVSSS5zZXJpYWxpemUocCkuc3BsaXQoJyMnKVswXSArICcjJztcbn1cblxuXG52YXIgVFJBSUxJTkdfU0xBU0hfSEFTSCA9IC8jXFwvPyQvO1xuZnVuY3Rpb24gbm9ybWFsaXplSWQoaWQpIHtcbiAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCAnJykgOiAnJztcbn1cblxuXG5mdW5jdGlvbiByZXNvbHZlVXJsKGJhc2VJZCwgaWQpIHtcbiAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gIHJldHVybiBVUkkucmVzb2x2ZShiYXNlSWQsIGlkKTtcbn1cblxuXG4vKiBAdGhpcyBBanYgKi9cbmZ1bmN0aW9uIHJlc29sdmVJZHMoc2NoZW1hKSB7XG4gIHZhciBzY2hlbWFJZCA9IG5vcm1hbGl6ZUlkKHRoaXMuX2dldElkKHNjaGVtYSkpO1xuICB2YXIgYmFzZUlkcyA9IHsnJzogc2NoZW1hSWR9O1xuICB2YXIgZnVsbFBhdGhzID0geycnOiBnZXRGdWxsUGF0aChzY2hlbWFJZCwgZmFsc2UpfTtcbiAgdmFyIGxvY2FsUmVmcyA9IHt9O1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJhdmVyc2Uoc2NoZW1hLCB7YWxsS2V5czogdHJ1ZX0sIGZ1bmN0aW9uKHNjaCwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICAgIGlmIChqc29uUHRyID09PSAnJykgcmV0dXJuO1xuICAgIHZhciBpZCA9IHNlbGYuX2dldElkKHNjaCk7XG4gICAgdmFyIGJhc2VJZCA9IGJhc2VJZHNbcGFyZW50SnNvblB0cl07XG4gICAgdmFyIGZ1bGxQYXRoID0gZnVsbFBhdGhzW3BhcmVudEpzb25QdHJdICsgJy8nICsgcGFyZW50S2V5d29yZDtcbiAgICBpZiAoa2V5SW5kZXggIT09IHVuZGVmaW5lZClcbiAgICAgIGZ1bGxQYXRoICs9ICcvJyArICh0eXBlb2Yga2V5SW5kZXggPT0gJ251bWJlcicgPyBrZXlJbmRleCA6IHV0aWwuZXNjYXBlRnJhZ21lbnQoa2V5SW5kZXgpKTtcblxuICAgIGlmICh0eXBlb2YgaWQgPT0gJ3N0cmluZycpIHtcbiAgICAgIGlkID0gYmFzZUlkID0gbm9ybWFsaXplSWQoYmFzZUlkID8gVVJJLnJlc29sdmUoYmFzZUlkLCBpZCkgOiBpZCk7XG5cbiAgICAgIHZhciByZWZWYWwgPSBzZWxmLl9yZWZzW2lkXTtcbiAgICAgIGlmICh0eXBlb2YgcmVmVmFsID09ICdzdHJpbmcnKSByZWZWYWwgPSBzZWxmLl9yZWZzW3JlZlZhbF07XG4gICAgICBpZiAocmVmVmFsICYmIHJlZlZhbC5zY2hlbWEpIHtcbiAgICAgICAgaWYgKCFlcXVhbChzY2gsIHJlZlZhbC5zY2hlbWEpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWQgXCInICsgaWQgKyAnXCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWEnKTtcbiAgICAgIH0gZWxzZSBpZiAoaWQgIT0gbm9ybWFsaXplSWQoZnVsbFBhdGgpKSB7XG4gICAgICAgIGlmIChpZFswXSA9PSAnIycpIHtcbiAgICAgICAgICBpZiAobG9jYWxSZWZzW2lkXSAmJiAhZXF1YWwoc2NoLCBsb2NhbFJlZnNbaWRdKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWQgXCInICsgaWQgKyAnXCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWEnKTtcbiAgICAgICAgICBsb2NhbFJlZnNbaWRdID0gc2NoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuX3JlZnNbaWRdID0gZnVsbFBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYmFzZUlkc1tqc29uUHRyXSA9IGJhc2VJZDtcbiAgICBmdWxsUGF0aHNbanNvblB0cl0gPSBmdWxsUGF0aDtcbiAgfSk7XG5cbiAgcmV0dXJuIGxvY2FsUmVmcztcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJ1bGVNb2R1bGVzID0gcmVxdWlyZSgnLi4vZG90anMnKVxuICAsIHRvSGFzaCA9IHJlcXVpcmUoJy4vdXRpbCcpLnRvSGFzaDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBydWxlcygpIHtcbiAgdmFyIFJVTEVTID0gW1xuICAgIHsgdHlwZTogJ251bWJlcicsXG4gICAgICBydWxlczogWyB7ICdtYXhpbXVtJzogWydleGNsdXNpdmVNYXhpbXVtJ10gfSxcbiAgICAgICAgICAgICAgIHsgJ21pbmltdW0nOiBbJ2V4Y2x1c2l2ZU1pbmltdW0nXSB9LCAnbXVsdGlwbGVPZicsICdmb3JtYXQnXSB9LFxuICAgIHsgdHlwZTogJ3N0cmluZycsXG4gICAgICBydWxlczogWyAnbWF4TGVuZ3RoJywgJ21pbkxlbmd0aCcsICdwYXR0ZXJuJywgJ2Zvcm1hdCcgXSB9LFxuICAgIHsgdHlwZTogJ2FycmF5JyxcbiAgICAgIHJ1bGVzOiBbICdtYXhJdGVtcycsICdtaW5JdGVtcycsICdpdGVtcycsICdjb250YWlucycsICd1bmlxdWVJdGVtcycgXSB9LFxuICAgIHsgdHlwZTogJ29iamVjdCcsXG4gICAgICBydWxlczogWyAnbWF4UHJvcGVydGllcycsICdtaW5Qcm9wZXJ0aWVzJywgJ3JlcXVpcmVkJywgJ2RlcGVuZGVuY2llcycsICdwcm9wZXJ0eU5hbWVzJyxcbiAgICAgICAgICAgICAgIHsgJ3Byb3BlcnRpZXMnOiBbJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJywgJ3BhdHRlcm5Qcm9wZXJ0aWVzJ10gfSBdIH0sXG4gICAgeyBydWxlczogWyAnJHJlZicsICdjb25zdCcsICdlbnVtJywgJ25vdCcsICdhbnlPZicsICdvbmVPZicsICdhbGxPZicsICdpZicgXSB9XG4gIF07XG5cbiAgdmFyIEFMTCA9IFsgJ3R5cGUnLCAnJGNvbW1lbnQnIF07XG4gIHZhciBLRVlXT1JEUyA9IFtcbiAgICAnJHNjaGVtYScsICckaWQnLCAnaWQnLCAnJGRhdGEnLCAndGl0bGUnLFxuICAgICdkZXNjcmlwdGlvbicsICdkZWZhdWx0JywgJ2RlZmluaXRpb25zJyxcbiAgICAnZXhhbXBsZXMnLCAncmVhZE9ubHknLCAnd3JpdGVPbmx5JyxcbiAgICAnY29udGVudE1lZGlhVHlwZScsICdjb250ZW50RW5jb2RpbmcnLFxuICAgICdhZGRpdGlvbmFsSXRlbXMnLCAndGhlbicsICdlbHNlJ1xuICBdO1xuICB2YXIgVFlQRVMgPSBbICdudW1iZXInLCAnaW50ZWdlcicsICdzdHJpbmcnLCAnYXJyYXknLCAnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVsbCcgXTtcbiAgUlVMRVMuYWxsID0gdG9IYXNoKEFMTCk7XG4gIFJVTEVTLnR5cGVzID0gdG9IYXNoKFRZUEVTKTtcblxuICBSVUxFUy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgIGdyb3VwLnJ1bGVzID0gZ3JvdXAucnVsZXMubWFwKGZ1bmN0aW9uIChrZXl3b3JkKSB7XG4gICAgICB2YXIgaW1wbEtleXdvcmRzO1xuICAgICAgaWYgKHR5cGVvZiBrZXl3b3JkID09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyhrZXl3b3JkKVswXTtcbiAgICAgICAgaW1wbEtleXdvcmRzID0ga2V5d29yZFtrZXldO1xuICAgICAgICBrZXl3b3JkID0ga2V5O1xuICAgICAgICBpbXBsS2V5d29yZHMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIEFMTC5wdXNoKGspO1xuICAgICAgICAgIFJVTEVTLmFsbFtrXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgQUxMLnB1c2goa2V5d29yZCk7XG4gICAgICB2YXIgcnVsZSA9IFJVTEVTLmFsbFtrZXl3b3JkXSA9IHtcbiAgICAgICAga2V5d29yZDoga2V5d29yZCxcbiAgICAgICAgY29kZTogcnVsZU1vZHVsZXNba2V5d29yZF0sXG4gICAgICAgIGltcGxlbWVudHM6IGltcGxLZXl3b3Jkc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0pO1xuXG4gICAgUlVMRVMuYWxsLiRjb21tZW50ID0ge1xuICAgICAga2V5d29yZDogJyRjb21tZW50JyxcbiAgICAgIGNvZGU6IHJ1bGVNb2R1bGVzLiRjb21tZW50XG4gICAgfTtcblxuICAgIGlmIChncm91cC50eXBlKSBSVUxFUy50eXBlc1tncm91cC50eXBlXSA9IGdyb3VwO1xuICB9KTtcblxuICBSVUxFUy5rZXl3b3JkcyA9IHRvSGFzaChBTEwuY29uY2F0KEtFWVdPUkRTKSk7XG4gIFJVTEVTLmN1c3RvbSA9IHt9O1xuXG4gIHJldHVybiBSVUxFUztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hT2JqZWN0O1xuXG5mdW5jdGlvbiBTY2hlbWFPYmplY3Qob2JqKSB7XG4gIHV0aWwuY29weShvYmosIHRoaXMpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgdmFyIGxlbmd0aCA9IDBcbiAgICAsIGxlbiA9IHN0ci5sZW5ndGhcbiAgICAsIHBvcyA9IDBcbiAgICAsIHZhbHVlO1xuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgbGVuZ3RoKys7XG4gICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICgodmFsdWUgJiAweEZDMDApID09IDB4REMwMCkgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcHk6IGNvcHksXG4gIGNoZWNrRGF0YVR5cGU6IGNoZWNrRGF0YVR5cGUsXG4gIGNoZWNrRGF0YVR5cGVzOiBjaGVja0RhdGFUeXBlcyxcbiAgY29lcmNlVG9UeXBlczogY29lcmNlVG9UeXBlcyxcbiAgdG9IYXNoOiB0b0hhc2gsXG4gIGdldFByb3BlcnR5OiBnZXRQcm9wZXJ0eSxcbiAgZXNjYXBlUXVvdGVzOiBlc2NhcGVRdW90ZXMsXG4gIGVxdWFsOiByZXF1aXJlKCdmYXN0LWRlZXAtZXF1YWwnKSxcbiAgdWNzMmxlbmd0aDogcmVxdWlyZSgnLi91Y3MybGVuZ3RoJyksXG4gIHZhck9jY3VyZW5jZXM6IHZhck9jY3VyZW5jZXMsXG4gIHZhclJlcGxhY2U6IHZhclJlcGxhY2UsXG4gIGNsZWFuVXBDb2RlOiBjbGVhblVwQ29kZSxcbiAgZmluYWxDbGVhblVwQ29kZTogZmluYWxDbGVhblVwQ29kZSxcbiAgc2NoZW1hSGFzUnVsZXM6IHNjaGVtYUhhc1J1bGVzLFxuICBzY2hlbWFIYXNSdWxlc0V4Y2VwdDogc2NoZW1hSGFzUnVsZXNFeGNlcHQsXG4gIHRvUXVvdGVkU3RyaW5nOiB0b1F1b3RlZFN0cmluZyxcbiAgZ2V0UGF0aEV4cHI6IGdldFBhdGhFeHByLFxuICBnZXRQYXRoOiBnZXRQYXRoLFxuICBnZXREYXRhOiBnZXREYXRhLFxuICB1bmVzY2FwZUZyYWdtZW50OiB1bmVzY2FwZUZyYWdtZW50LFxuICB1bmVzY2FwZUpzb25Qb2ludGVyOiB1bmVzY2FwZUpzb25Qb2ludGVyLFxuICBlc2NhcGVGcmFnbWVudDogZXNjYXBlRnJhZ21lbnQsXG4gIGVzY2FwZUpzb25Qb2ludGVyOiBlc2NhcGVKc29uUG9pbnRlclxufTtcblxuXG5mdW5jdGlvbiBjb3B5KG8sIHRvKSB7XG4gIHRvID0gdG8gfHwge307XG4gIGZvciAodmFyIGtleSBpbiBvKSB0b1trZXldID0gb1trZXldO1xuICByZXR1cm4gdG87XG59XG5cblxuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZShkYXRhVHlwZSwgZGF0YSwgbmVnYXRlKSB7XG4gIHZhciBFUVVBTCA9IG5lZ2F0ZSA/ICcgIT09ICcgOiAnID09PSAnXG4gICAgLCBBTkQgPSBuZWdhdGUgPyAnIHx8ICcgOiAnICYmICdcbiAgICAsIE9LID0gbmVnYXRlID8gJyEnIDogJydcbiAgICAsIE5PVCA9IG5lZ2F0ZSA/ICcnIDogJyEnO1xuICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgY2FzZSAnbnVsbCc6IHJldHVybiBkYXRhICsgRVFVQUwgKyAnbnVsbCc7XG4gICAgY2FzZSAnYXJyYXknOiByZXR1cm4gT0sgKyAnQXJyYXkuaXNBcnJheSgnICsgZGF0YSArICcpJztcbiAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gJygnICsgT0sgKyBkYXRhICsgQU5EICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGVvZiAnICsgZGF0YSArIEVRVUFMICsgJ1wib2JqZWN0XCInICsgQU5EICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgTk9UICsgJ0FycmF5LmlzQXJyYXkoJyArIGRhdGEgKyAnKSknO1xuICAgIGNhc2UgJ2ludGVnZXInOiByZXR1cm4gJyh0eXBlb2YgJyArIGRhdGEgKyBFUVVBTCArICdcIm51bWJlclwiJyArIEFORCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBOT1QgKyAnKCcgKyBkYXRhICsgJyAlIDEpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBTkQgKyBkYXRhICsgRVFVQUwgKyBkYXRhICsgJyknO1xuICAgIGRlZmF1bHQ6IHJldHVybiAndHlwZW9mICcgKyBkYXRhICsgRVFVQUwgKyAnXCInICsgZGF0YVR5cGUgKyAnXCInO1xuICB9XG59XG5cblxuZnVuY3Rpb24gY2hlY2tEYXRhVHlwZXMoZGF0YVR5cGVzLCBkYXRhKSB7XG4gIHN3aXRjaCAoZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCB0cnVlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGNvZGUgPSAnJztcbiAgICAgIHZhciB0eXBlcyA9IHRvSGFzaChkYXRhVHlwZXMpO1xuICAgICAgaWYgKHR5cGVzLmFycmF5ICYmIHR5cGVzLm9iamVjdCkge1xuICAgICAgICBjb2RlID0gdHlwZXMubnVsbCA/ICcoJzogJyghJyArIGRhdGEgKyAnIHx8ICc7XG4gICAgICAgIGNvZGUgKz0gJ3R5cGVvZiAnICsgZGF0YSArICcgIT09IFwib2JqZWN0XCIpJztcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlcy5udW1iZXIpIGRlbGV0ZSB0eXBlcy5pbnRlZ2VyO1xuICAgICAgZm9yICh2YXIgdCBpbiB0eXBlcylcbiAgICAgICAgY29kZSArPSAoY29kZSA/ICcgJiYgJyA6ICcnICkgKyBjaGVja0RhdGFUeXBlKHQsIGRhdGEsIHRydWUpO1xuXG4gICAgICByZXR1cm4gY29kZTtcbiAgfVxufVxuXG5cbnZhciBDT0VSQ0VfVE9fVFlQRVMgPSB0b0hhc2goWyAnc3RyaW5nJywgJ251bWJlcicsICdpbnRlZ2VyJywgJ2Jvb2xlYW4nLCAnbnVsbCcgXSk7XG5mdW5jdGlvbiBjb2VyY2VUb1R5cGVzKG9wdGlvbkNvZXJjZVR5cGVzLCBkYXRhVHlwZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVR5cGVzKSkge1xuICAgIHZhciB0eXBlcyA9IFtdO1xuICAgIGZvciAodmFyIGk9MDsgaTxkYXRhVHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0ID0gZGF0YVR5cGVzW2ldO1xuICAgICAgaWYgKENPRVJDRV9UT19UWVBFU1t0XSkgdHlwZXNbdHlwZXMubGVuZ3RoXSA9IHQ7XG4gICAgICBlbHNlIGlmIChvcHRpb25Db2VyY2VUeXBlcyA9PT0gJ2FycmF5JyAmJiB0ID09PSAnYXJyYXknKSB0eXBlc1t0eXBlcy5sZW5ndGhdID0gdDtcbiAgICB9XG4gICAgaWYgKHR5cGVzLmxlbmd0aCkgcmV0dXJuIHR5cGVzO1xuICB9IGVsc2UgaWYgKENPRVJDRV9UT19UWVBFU1tkYXRhVHlwZXNdKSB7XG4gICAgcmV0dXJuIFtkYXRhVHlwZXNdO1xuICB9IGVsc2UgaWYgKG9wdGlvbkNvZXJjZVR5cGVzID09PSAnYXJyYXknICYmIGRhdGFUeXBlcyA9PT0gJ2FycmF5Jykge1xuICAgIHJldHVybiBbJ2FycmF5J107XG4gIH1cbn1cblxuXG5mdW5jdGlvbiB0b0hhc2goYXJyKSB7XG4gIHZhciBoYXNoID0ge307XG4gIGZvciAodmFyIGk9MDsgaTxhcnIubGVuZ3RoOyBpKyspIGhhc2hbYXJyW2ldXSA9IHRydWU7XG4gIHJldHVybiBoYXNoO1xufVxuXG5cbnZhciBJREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2k7XG52YXIgU0lOR0xFX1FVT1RFID0gLyd8XFxcXC9nO1xuZnVuY3Rpb24gZ2V0UHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09ICdudW1iZXInXG4gICAgICAgICAgPyAnWycgKyBrZXkgKyAnXSdcbiAgICAgICAgICA6IElERU5USUZJRVIudGVzdChrZXkpXG4gICAgICAgICAgICA/ICcuJyArIGtleVxuICAgICAgICAgICAgOiBcIlsnXCIgKyBlc2NhcGVRdW90ZXMoa2V5KSArIFwiJ11cIjtcbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVRdW90ZXMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShTSU5HTEVfUVVPVEUsICdcXFxcJCYnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAnXFxcXGYnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKTtcbn1cblxuXG5mdW5jdGlvbiB2YXJPY2N1cmVuY2VzKHN0ciwgZGF0YVZhcikge1xuICBkYXRhVmFyICs9ICdbXjAtOV0nO1xuICB2YXIgbWF0Y2hlcyA9IHN0ci5tYXRjaChuZXcgUmVnRXhwKGRhdGFWYXIsICdnJykpO1xuICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXMubGVuZ3RoIDogMDtcbn1cblxuXG5mdW5jdGlvbiB2YXJSZXBsYWNlKHN0ciwgZGF0YVZhciwgZXhwcikge1xuICBkYXRhVmFyICs9ICcoW14wLTldKSc7XG4gIGV4cHIgPSBleHByLnJlcGxhY2UoL1xcJC9nLCAnJCQkJCcpO1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChkYXRhVmFyLCAnZycpLCBleHByICsgJyQxJyk7XG59XG5cblxudmFyIEVNUFRZX0VMU0UgPSAvZWxzZVxccyp7XFxzKn0vZ1xuICAsIEVNUFRZX0lGX05PX0VMU0UgPSAvaWZcXHMqXFwoW14pXStcXClcXHMqXFx7XFxzKlxcfSg/IVxccyplbHNlKS9nXG4gICwgRU1QVFlfSUZfV0lUSF9FTFNFID0gL2lmXFxzKlxcKChbXildKylcXClcXHMqXFx7XFxzKlxcfVxccyplbHNlKD8hXFxzKmlmKS9nO1xuZnVuY3Rpb24gY2xlYW5VcENvZGUob3V0KSB7XG4gIHJldHVybiBvdXQucmVwbGFjZShFTVBUWV9FTFNFLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKEVNUFRZX0lGX05PX0VMU0UsICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoRU1QVFlfSUZfV0lUSF9FTFNFLCAnaWYgKCEoJDEpKScpO1xufVxuXG5cbnZhciBFUlJPUlNfUkVHRVhQID0gL1tedi5dZXJyb3JzL2dcbiAgLCBSRU1PVkVfRVJST1JTID0gL3ZhciBlcnJvcnMgPSAwO3x2YXIgdkVycm9ycyA9IG51bGw7fHZhbGlkYXRlLmVycm9ycyA9IHZFcnJvcnM7L2dcbiAgLCBSRU1PVkVfRVJST1JTX0FTWU5DID0gL3ZhciBlcnJvcnMgPSAwO3x2YXIgdkVycm9ycyA9IG51bGw7L2dcbiAgLCBSRVRVUk5fVkFMSUQgPSAncmV0dXJuIGVycm9ycyA9PT0gMDsnXG4gICwgUkVUVVJOX1RSVUUgPSAndmFsaWRhdGUuZXJyb3JzID0gbnVsbDsgcmV0dXJuIHRydWU7J1xuICAsIFJFVFVSTl9BU1lOQyA9IC9pZiBcXChlcnJvcnMgPT09IDBcXCkgcmV0dXJuIGRhdGE7XFxzKmVsc2UgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvclxcKHZFcnJvcnNcXCk7L1xuICAsIFJFVFVSTl9EQVRBX0FTWU5DID0gJ3JldHVybiBkYXRhOydcbiAgLCBST09UREFUQV9SRUdFWFAgPSAvW15BLVphLXpfJF1yb290RGF0YVteQS1aYS16MC05XyRdL2dcbiAgLCBSRU1PVkVfUk9PVERBVEEgPSAvaWYgXFwocm9vdERhdGEgPT09IHVuZGVmaW5lZFxcKSByb290RGF0YSA9IGRhdGE7LztcblxuZnVuY3Rpb24gZmluYWxDbGVhblVwQ29kZShvdXQsIGFzeW5jKSB7XG4gIHZhciBtYXRjaGVzID0gb3V0Lm1hdGNoKEVSUk9SU19SRUdFWFApO1xuICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA9PSAyKSB7XG4gICAgb3V0ID0gYXN5bmNcbiAgICAgICAgICA/IG91dC5yZXBsYWNlKFJFTU9WRV9FUlJPUlNfQVNZTkMsICcnKVxuICAgICAgICAgICAgICAgLnJlcGxhY2UoUkVUVVJOX0FTWU5DLCBSRVRVUk5fREFUQV9BU1lOQylcbiAgICAgICAgICA6IG91dC5yZXBsYWNlKFJFTU9WRV9FUlJPUlMsICcnKVxuICAgICAgICAgICAgICAgLnJlcGxhY2UoUkVUVVJOX1ZBTElELCBSRVRVUk5fVFJVRSk7XG4gIH1cblxuICBtYXRjaGVzID0gb3V0Lm1hdGNoKFJPT1REQVRBX1JFR0VYUCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCAhPT0gMykgcmV0dXJuIG91dDtcbiAgcmV0dXJuIG91dC5yZXBsYWNlKFJFTU9WRV9ST09UREFUQSwgJycpO1xufVxuXG5cbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgcnVsZXMpIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gJ2Jvb2xlYW4nKSByZXR1cm4gIXNjaGVtYTtcbiAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkgaWYgKHJ1bGVzW2tleV0pIHJldHVybiB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzRXhjZXB0KHNjaGVtYSwgcnVsZXMsIGV4Y2VwdEtleXdvcmQpIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gJ2Jvb2xlYW4nKSByZXR1cm4gIXNjaGVtYSAmJiBleGNlcHRLZXl3b3JkICE9ICdub3QnO1xuICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSBpZiAoa2V5ICE9IGV4Y2VwdEtleXdvcmQgJiYgcnVsZXNba2V5XSkgcmV0dXJuIHRydWU7XG59XG5cblxuZnVuY3Rpb24gdG9RdW90ZWRTdHJpbmcoc3RyKSB7XG4gIHJldHVybiAnXFwnJyArIGVzY2FwZVF1b3RlcyhzdHIpICsgJ1xcJyc7XG59XG5cblxuZnVuY3Rpb24gZ2V0UGF0aEV4cHIoY3VycmVudFBhdGgsIGV4cHIsIGpzb25Qb2ludGVycywgaXNOdW1iZXIpIHtcbiAgdmFyIHBhdGggPSBqc29uUG9pbnRlcnMgLy8gZmFsc2UgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICA/ICdcXCcvXFwnICsgJyArIGV4cHIgKyAoaXNOdW1iZXIgPyAnJyA6ICcucmVwbGFjZSgvfi9nLCBcXCd+MFxcJykucmVwbGFjZSgvXFxcXC8vZywgXFwnfjFcXCcpJylcbiAgICAgICAgICAgICAgOiAoaXNOdW1iZXIgPyAnXFwnW1xcJyArICcgKyBleHByICsgJyArIFxcJ11cXCcnIDogJ1xcJ1tcXFxcXFwnXFwnICsgJyArIGV4cHIgKyAnICsgXFwnXFxcXFxcJ11cXCcnKTtcbiAgcmV0dXJuIGpvaW5QYXRocyhjdXJyZW50UGF0aCwgcGF0aCk7XG59XG5cblxuZnVuY3Rpb24gZ2V0UGF0aChjdXJyZW50UGF0aCwgcHJvcCwganNvblBvaW50ZXJzKSB7XG4gIHZhciBwYXRoID0ganNvblBvaW50ZXJzIC8vIGZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgPyB0b1F1b3RlZFN0cmluZygnLycgKyBlc2NhcGVKc29uUG9pbnRlcihwcm9wKSlcbiAgICAgICAgICAgICAgOiB0b1F1b3RlZFN0cmluZyhnZXRQcm9wZXJ0eShwcm9wKSk7XG4gIHJldHVybiBqb2luUGF0aHMoY3VycmVudFBhdGgsIHBhdGgpO1xufVxuXG5cbnZhciBKU09OX1BPSU5URVIgPSAvXlxcLyg/Oltefl18fjB8fjEpKiQvO1xudmFyIFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvO1xuZnVuY3Rpb24gZ2V0RGF0YSgkZGF0YSwgbHZsLCBwYXRocykge1xuICB2YXIgdXAsIGpzb25Qb2ludGVyLCBkYXRhLCBtYXRjaGVzO1xuICBpZiAoJGRhdGEgPT09ICcnKSByZXR1cm4gJ3Jvb3REYXRhJztcbiAgaWYgKCRkYXRhWzBdID09ICcvJykge1xuICAgIGlmICghSlNPTl9QT0lOVEVSLnRlc3QoJGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTi1wb2ludGVyOiAnICsgJGRhdGEpO1xuICAgIGpzb25Qb2ludGVyID0gJGRhdGE7XG4gICAgZGF0YSA9ICdyb290RGF0YSc7XG4gIH0gZWxzZSB7XG4gICAgbWF0Y2hlcyA9ICRkYXRhLm1hdGNoKFJFTEFUSVZFX0pTT05fUE9JTlRFUik7XG4gICAgaWYgKCFtYXRjaGVzKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTi1wb2ludGVyOiAnICsgJGRhdGEpO1xuICAgIHVwID0gK21hdGNoZXNbMV07XG4gICAganNvblBvaW50ZXIgPSBtYXRjaGVzWzJdO1xuICAgIGlmIChqc29uUG9pbnRlciA9PSAnIycpIHtcbiAgICAgIGlmICh1cCA+PSBsdmwpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFjY2VzcyBwcm9wZXJ0eS9pbmRleCAnICsgdXAgKyAnIGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyAnICsgbHZsKTtcbiAgICAgIHJldHVybiBwYXRoc1tsdmwgLSB1cF07XG4gICAgfVxuXG4gICAgaWYgKHVwID4gbHZsKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhY2Nlc3MgZGF0YSAnICsgdXAgKyAnIGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyAnICsgbHZsKTtcbiAgICBkYXRhID0gJ2RhdGEnICsgKChsdmwgLSB1cCkgfHwgJycpO1xuICAgIGlmICghanNvblBvaW50ZXIpIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGV4cHIgPSBkYXRhO1xuICB2YXIgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdCgnLycpO1xuICBmb3IgKHZhciBpPTA7IGk8c2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICBkYXRhICs9IGdldFByb3BlcnR5KHVuZXNjYXBlSnNvblBvaW50ZXIoc2VnbWVudCkpO1xuICAgICAgZXhwciArPSAnICYmICcgKyBkYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwcjtcbn1cblxuXG5mdW5jdGlvbiBqb2luUGF0aHMgKGEsIGIpIHtcbiAgaWYgKGEgPT0gJ1wiXCInKSByZXR1cm4gYjtcbiAgcmV0dXJuIChhICsgJyArICcgKyBiKS5yZXBsYWNlKC8nIFxcKyAnL2csICcnKTtcbn1cblxuXG5mdW5jdGlvbiB1bmVzY2FwZUZyYWdtZW50KHN0cikge1xuICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlSnNvblBvaW50ZXIoc3RyKSk7XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG59XG5cblxuZnVuY3Rpb24gdW5lc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBLRVlXT1JEUyA9IFtcbiAgJ211bHRpcGxlT2YnLFxuICAnbWF4aW11bScsXG4gICdleGNsdXNpdmVNYXhpbXVtJyxcbiAgJ21pbmltdW0nLFxuICAnZXhjbHVzaXZlTWluaW11bScsXG4gICdtYXhMZW5ndGgnLFxuICAnbWluTGVuZ3RoJyxcbiAgJ3BhdHRlcm4nLFxuICAnYWRkaXRpb25hbEl0ZW1zJyxcbiAgJ21heEl0ZW1zJyxcbiAgJ21pbkl0ZW1zJyxcbiAgJ3VuaXF1ZUl0ZW1zJyxcbiAgJ21heFByb3BlcnRpZXMnLFxuICAnbWluUHJvcGVydGllcycsXG4gICdyZXF1aXJlZCcsXG4gICdhZGRpdGlvbmFsUHJvcGVydGllcycsXG4gICdlbnVtJyxcbiAgJ2Zvcm1hdCcsXG4gICdjb25zdCdcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gIGZvciAodmFyIGk9MDsgaTxrZXl3b3Jkc0pzb25Qb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICB2YXIgc2VnbWVudHMgPSBrZXl3b3Jkc0pzb25Qb2ludGVyc1tpXS5zcGxpdCgnLycpO1xuICAgIHZhciBrZXl3b3JkcyA9IG1ldGFTY2hlbWE7XG4gICAgdmFyIGo7XG4gICAgZm9yIChqPTE7IGo8c2VnbWVudHMubGVuZ3RoOyBqKyspXG4gICAgICBrZXl3b3JkcyA9IGtleXdvcmRzW3NlZ21lbnRzW2pdXTtcblxuICAgIGZvciAoaj0wOyBqPEtFWVdPUkRTLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIga2V5ID0gS0VZV09SRFNbal07XG4gICAgICB2YXIgc2NoZW1hID0ga2V5d29yZHNba2V5XTtcbiAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAga2V5d29yZHNba2V5XSA9IHtcbiAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgeyAkcmVmOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Vwb2JlcmV6a2luL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uIycgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWV0YVNjaGVtYTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX19saW1pdChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGVycm9yS2V5d29yZDtcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIHZhciAkaXNNYXggPSAka2V5d29yZCA9PSAnbWF4aW11bScsXG4gICAgJGV4Y2x1c2l2ZUtleXdvcmQgPSAkaXNNYXggPyAnZXhjbHVzaXZlTWF4aW11bScgOiAnZXhjbHVzaXZlTWluaW11bScsXG4gICAgJHNjaGVtYUV4Y2wgPSBpdC5zY2hlbWFbJGV4Y2x1c2l2ZUtleXdvcmRdLFxuICAgICRpc0RhdGFFeGNsID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hRXhjbCAmJiAkc2NoZW1hRXhjbC4kZGF0YSxcbiAgICAkb3AgPSAkaXNNYXggPyAnPCcgOiAnPicsXG4gICAgJG5vdE9wID0gJGlzTWF4ID8gJz4nIDogJzwnLFxuICAgICRlcnJvcktleXdvcmQgPSB1bmRlZmluZWQ7XG4gIGlmICgkaXNEYXRhRXhjbCkge1xuICAgIHZhciAkc2NoZW1hVmFsdWVFeGNsID0gaXQudXRpbC5nZXREYXRhKCRzY2hlbWFFeGNsLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpLFxuICAgICAgJGV4Y2x1c2l2ZSA9ICdleGNsdXNpdmUnICsgJGx2bCxcbiAgICAgICRleGNsVHlwZSA9ICdleGNsVHlwZScgKyAkbHZsLFxuICAgICAgJGV4Y2xJc051bWJlciA9ICdleGNsSXNOdW1iZXInICsgJGx2bCxcbiAgICAgICRvcEV4cHIgPSAnb3AnICsgJGx2bCxcbiAgICAgICRvcFN0ciA9ICdcXCcgKyAnICsgJG9wRXhwciArICcgKyBcXCcnO1xuICAgIG91dCArPSAnIHZhciBzY2hlbWFFeGNsJyArICgkbHZsKSArICcgPSAnICsgKCRzY2hlbWFWYWx1ZUV4Y2wpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWVFeGNsID0gJ3NjaGVtYUV4Y2wnICsgJGx2bDtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkZXhjbHVzaXZlKSArICc7IHZhciAnICsgKCRleGNsVHlwZSkgKyAnID0gdHlwZW9mICcgKyAoJHNjaGVtYVZhbHVlRXhjbCkgKyAnOyBpZiAoJyArICgkZXhjbFR5cGUpICsgJyAhPSBcXCdib29sZWFuXFwnICYmICcgKyAoJGV4Y2xUeXBlKSArICcgIT0gXFwndW5kZWZpbmVkXFwnICYmICcgKyAoJGV4Y2xUeXBlKSArICcgIT0gXFwnbnVtYmVyXFwnKSB7ICc7XG4gICAgdmFyICRlcnJvcktleXdvcmQgPSAkZXhjbHVzaXZlS2V5d29yZDtcbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICdfZXhjbHVzaXZlTGltaXQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7fSAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJyArICgkZXhjbHVzaXZlS2V5d29yZCkgKyAnIHNob3VsZCBiZSBib29sZWFuXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgfVxuICAgIHZhciBfX2VyciA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSBlbHNlIGlmICggJztcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHx8ICc7XG4gICAgfVxuICAgIG91dCArPSAnICcgKyAoJGV4Y2xUeXBlKSArICcgPT0gXFwnbnVtYmVyXFwnID8gKCAoJyArICgkZXhjbHVzaXZlKSArICcgPSAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnID09PSB1bmRlZmluZWQgfHwgJyArICgkc2NoZW1hVmFsdWVFeGNsKSArICcgJyArICgkb3ApICsgJz0gJyArICgkc2NoZW1hVmFsdWUpICsgJykgPyAnICsgKCRkYXRhKSArICcgJyArICgkbm90T3ApICsgJz0gJyArICgkc2NoZW1hVmFsdWVFeGNsKSArICcgOiAnICsgKCRkYXRhKSArICcgJyArICgkbm90T3ApICsgJyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICkgOiAoICgnICsgKCRleGNsdXNpdmUpICsgJyA9ICcgKyAoJHNjaGVtYVZhbHVlRXhjbCkgKyAnID09PSB0cnVlKSA/ICcgKyAoJGRhdGEpICsgJyAnICsgKCRub3RPcCkgKyAnPSAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnIDogJyArICgkZGF0YSkgKyAnICcgKyAoJG5vdE9wKSArICcgJyArICgkc2NoZW1hVmFsdWUpICsgJyApIHx8ICcgKyAoJGRhdGEpICsgJyAhPT0gJyArICgkZGF0YSkgKyAnKSB7IHZhciBvcCcgKyAoJGx2bCkgKyAnID0gJyArICgkZXhjbHVzaXZlKSArICcgPyBcXCcnICsgKCRvcCkgKyAnXFwnIDogXFwnJyArICgkb3ApICsgJz1cXCc7ICc7XG4gICAgaWYgKCRzY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgJGVycm9yS2V5d29yZCA9ICRleGNsdXNpdmVLZXl3b3JkO1xuICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGV4Y2x1c2l2ZUtleXdvcmQ7XG4gICAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hVmFsdWVFeGNsO1xuICAgICAgJGlzRGF0YSA9ICRpc0RhdGFFeGNsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgJGV4Y2xJc051bWJlciA9IHR5cGVvZiAkc2NoZW1hRXhjbCA9PSAnbnVtYmVyJyxcbiAgICAgICRvcFN0ciA9ICRvcDtcbiAgICBpZiAoJGV4Y2xJc051bWJlciAmJiAkaXNEYXRhKSB7XG4gICAgICB2YXIgJG9wRXhwciA9ICdcXCcnICsgJG9wU3RyICsgJ1xcJyc7XG4gICAgICBvdXQgKz0gJyBpZiAoICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJyAoJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ251bWJlclxcJykgfHwgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICggJyArICgkc2NoZW1hVmFsdWUpICsgJyA9PT0gdW5kZWZpbmVkIHx8ICcgKyAoJHNjaGVtYUV4Y2wpICsgJyAnICsgKCRvcCkgKyAnPSAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnID8gJyArICgkZGF0YSkgKyAnICcgKyAoJG5vdE9wKSArICc9ICcgKyAoJHNjaGVtYUV4Y2wpICsgJyA6ICcgKyAoJGRhdGEpICsgJyAnICsgKCRub3RPcCkgKyAnICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKSB8fCAnICsgKCRkYXRhKSArICcgIT09ICcgKyAoJGRhdGEpICsgJykgeyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJGV4Y2xJc051bWJlciAmJiAkc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgJGV4Y2x1c2l2ZSA9IHRydWU7XG4gICAgICAgICRlcnJvcktleXdvcmQgPSAkZXhjbHVzaXZlS2V5d29yZDtcbiAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGV4Y2x1c2l2ZUtleXdvcmQ7XG4gICAgICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWFFeGNsO1xuICAgICAgICAkbm90T3AgKz0gJz0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCRleGNsSXNOdW1iZXIpICRzY2hlbWFWYWx1ZSA9IE1hdGhbJGlzTWF4ID8gJ21pbicgOiAnbWF4J10oJHNjaGVtYUV4Y2wsICRzY2hlbWEpO1xuICAgICAgICBpZiAoJHNjaGVtYUV4Y2wgPT09ICgkZXhjbElzTnVtYmVyID8gJHNjaGVtYVZhbHVlIDogdHJ1ZSkpIHtcbiAgICAgICAgICAkZXhjbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAkZXJyb3JLZXl3b3JkID0gJGV4Y2x1c2l2ZUtleXdvcmQ7XG4gICAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGV4Y2x1c2l2ZUtleXdvcmQ7XG4gICAgICAgICAgJG5vdE9wICs9ICc9JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZXhjbHVzaXZlID0gZmFsc2U7XG4gICAgICAgICAgJG9wU3RyICs9ICc9JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyICRvcEV4cHIgPSAnXFwnJyArICRvcFN0ciArICdcXCcnO1xuICAgICAgb3V0ICs9ICcgaWYgKCAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHx8ICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcgJyArICgkbm90T3ApICsgJyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnIHx8ICcgKyAoJGRhdGEpICsgJyAhPT0gJyArICgkZGF0YSkgKyAnKSB7ICc7XG4gICAgfVxuICB9XG4gICRlcnJvcktleXdvcmQgPSAkZXJyb3JLZXl3b3JkIHx8ICRrZXl3b3JkO1xuICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJGVycm9yS2V5d29yZCB8fCAnX2xpbWl0JykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBjb21wYXJpc29uOiAnICsgKCRvcEV4cHIpICsgJywgbGltaXQ6ICcgKyAoJHNjaGVtYVZhbHVlKSArICcsIGV4Y2x1c2l2ZTogJyArICgkZXhjbHVzaXZlKSArICcgfSAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJyArICgkb3BTdHIpICsgJyAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICdcXCcgKyAnICsgKCRzY2hlbWFWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYVZhbHVlKSArICdcXCcnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ3ZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgICAgICAgICAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHt9ICc7XG4gIH1cbiAgdmFyIF9fZXJyID0gb3V0O1xuICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJyB9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfX2xpbWl0SXRlbXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRlcnJvcktleXdvcmQ7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICB2YXIgJG9wID0gJGtleXdvcmQgPT0gJ21heEl0ZW1zJyA/ICc+JyA6ICc8JztcbiAgb3V0ICs9ICdpZiAoICc7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHx8ICc7XG4gIH1cbiAgb3V0ICs9ICcgJyArICgkZGF0YSkgKyAnLmxlbmd0aCAnICsgKCRvcCkgKyAnICcgKyAoJHNjaGVtYVZhbHVlKSArICcpIHsgJztcbiAgdmFyICRlcnJvcktleXdvcmQgPSAka2V5d29yZDtcbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ19saW1pdEl0ZW1zJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBsaW1pdDogJyArICgkc2NoZW1hVmFsdWUpICsgJyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSAnO1xuICAgICAgaWYgKCRrZXl3b3JkID09ICdtYXhJdGVtcycpIHtcbiAgICAgICAgb3V0ICs9ICdtb3JlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnZmV3ZXInO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgdGhhbiAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICdcXCcgKyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICsgXFwnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArICgkc2NoZW1hKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIGl0ZW1zXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAgJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAndmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoJHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX19saW1pdExlbmd0aChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGVycm9yS2V5d29yZDtcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIHZhciAkb3AgPSAka2V5d29yZCA9PSAnbWF4TGVuZ3RoJyA/ICc+JyA6ICc8JztcbiAgb3V0ICs9ICdpZiAoICc7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHx8ICc7XG4gIH1cbiAgaWYgKGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcubGVuZ3RoICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdWNzMmxlbmd0aCgnICsgKCRkYXRhKSArICcpICc7XG4gIH1cbiAgb3V0ICs9ICcgJyArICgkb3ApICsgJyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnKSB7ICc7XG4gIHZhciAkZXJyb3JLZXl3b3JkID0gJGtleXdvcmQ7XG4gIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICdfbGltaXRMZW5ndGgnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGxpbWl0OiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnIH0gJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIE5PVCBiZSAnO1xuICAgICAgaWYgKCRrZXl3b3JkID09ICdtYXhMZW5ndGgnKSB7XG4gICAgICAgIG91dCArPSAnbG9uZ2VyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnc2hvcnRlcic7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB0aGFuICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ1xcJyArICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKyBcXCcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgY2hhcmFjdGVyc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ3ZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgICAgICAgICAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHt9ICc7XG4gIH1cbiAgdmFyIF9fZXJyID0gb3V0O1xuICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9fbGltaXRQcm9wZXJ0aWVzKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZXJyb3JLZXl3b3JkO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgdmFyICRvcCA9ICRrZXl3b3JkID09ICdtYXhQcm9wZXJ0aWVzJyA/ICc+JyA6ICc8JztcbiAgb3V0ICs9ICdpZiAoICc7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJyArICgkc2NoZW1hVmFsdWUpICsgJyAhPSBcXCdudW1iZXJcXCcpIHx8ICc7XG4gIH1cbiAgb3V0ICs9ICcgT2JqZWN0LmtleXMoJyArICgkZGF0YSkgKyAnKS5sZW5ndGggJyArICgkb3ApICsgJyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnKSB7ICc7XG4gIHZhciAkZXJyb3JLZXl3b3JkID0gJGtleXdvcmQ7XG4gIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICdfbGltaXRQcm9wZXJ0aWVzJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBsaW1pdDogJyArICgkc2NoZW1hVmFsdWUpICsgJyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgaGF2ZSAnO1xuICAgICAgaWYgKCRrZXl3b3JkID09ICdtYXhQcm9wZXJ0aWVzJykge1xuICAgICAgICBvdXQgKz0gJ21vcmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICdmZXdlcic7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB0aGFuICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ1xcJyArICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKyBcXCcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgcHJvcGVydGllc1xcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogICc7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ3ZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgICAgICAgICAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHt9ICc7XG4gIH1cbiAgdmFyIF9fZXJyID0gb3V0O1xuICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgfVxuICBvdXQgKz0gJ30gJztcbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9hbGxPZihpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gIHZhciAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRuZXh0VmFsaWQgPSAndmFsaWQnICsgJGl0LmxldmVsO1xuICB2YXIgJGN1cnJlbnRCYXNlSWQgPSAkaXQuYmFzZUlkLFxuICAgICRhbGxTY2hlbWFzRW1wdHkgPSB0cnVlO1xuICB2YXIgYXJyMSA9ICRzY2hlbWE7XG4gIGlmIChhcnIxKSB7XG4gICAgdmFyICRzY2gsICRpID0gLTEsXG4gICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgJHNjaCA9IGFycjFbJGkgKz0gMV07XG4gICAgICBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgICAgICRhbGxTY2hlbWFzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArICcvJyArICRpO1xuICAgICAgICBvdXQgKz0gJyAgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnO1xuICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIGlmICgkYWxsU2NoZW1hc0VtcHR5KSB7XG4gICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzLnNsaWNlKDAsIC0xKSkgKyAnICc7XG4gICAgfVxuICB9XG4gIG91dCA9IGl0LnV0aWwuY2xlYW5VcENvZGUob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfYW55T2YoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsO1xuICB2YXIgJGVycnMgPSAnZXJyc19fJyArICRsdmw7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICB2YXIgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgdmFyICRub0VtcHR5U2NoZW1hID0gJHNjaGVtYS5ldmVyeShmdW5jdGlvbigkc2NoKSB7XG4gICAgcmV0dXJuIGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKTtcbiAgfSk7XG4gIGlmICgkbm9FbXB0eVNjaGVtYSkge1xuICAgIHZhciAkY3VycmVudEJhc2VJZCA9ICRpdC5iYXNlSWQ7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsgdmFyICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZTsgICc7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgdmFyIGFycjEgPSAkc2NoZW1hO1xuICAgIGlmIChhcnIxKSB7XG4gICAgICB2YXIgJHNjaCwgJGkgPSAtMSxcbiAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArICcvJyArICRpO1xuICAgICAgICBvdXQgKz0gJyAgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICBvdXQgKz0gJyAnICsgKCR2YWxpZCkgKyAnID0gJyArICgkdmFsaWQpICsgJyB8fCAnICsgKCRuZXh0VmFsaWQpICsgJzsgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICB9XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAgdmFyIGVyciA9ICAgJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdhbnlPZicpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHt9ICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgbWF0Y2ggc29tZSBzY2hlbWEgaW4gYW55T2ZcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcge30gJztcbiAgICB9XG4gICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IHZFcnJvcnM7IHJldHVybiBmYWxzZTsgJztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9ICcgfSBlbHNlIHsgIGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKCcgKyAoJGVycnMpICsgJykgdkVycm9ycy5sZW5ndGggPSAnICsgKCRlcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0gJztcbiAgICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9XG4gICAgb3V0ID0gaXQudXRpbC5jbGVhblVwQ29kZShvdXQpO1xuICB9IGVsc2Uge1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9jb21tZW50KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRjb21tZW50ID0gaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKTtcbiAgaWYgKGl0Lm9wdHMuJGNvbW1lbnQgPT09IHRydWUpIHtcbiAgICBvdXQgKz0gJyBjb25zb2xlLmxvZygnICsgKCRjb21tZW50KSArICcpOyc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGl0Lm9wdHMuJGNvbW1lbnQgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG91dCArPSAnIHNlbGYuX29wdHMuJGNvbW1lbnQoJyArICgkY29tbWVudCkgKyAnLCAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcsIHZhbGlkYXRlLnJvb3Quc2NoZW1hKTsnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2NvbnN0KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIGlmICghJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJzsnO1xuICB9XG4gIG91dCArPSAndmFyICcgKyAoJHZhbGlkKSArICcgPSBlcXVhbCgnICsgKCRkYXRhKSArICcsIHNjaGVtYScgKyAoJGx2bCkgKyAnKTsgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAgJztcbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdjb25zdCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgYWxsb3dlZFZhbHVlOiBzY2hlbWEnICsgKCRsdmwpICsgJyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSBlcXVhbCB0byBjb25zdGFudFxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnIH0nO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2NvbnRhaW5zKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIHZhciAkaWR4ID0gJ2knICsgJGx2bCxcbiAgICAkZGF0YU54dCA9ICRpdC5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxLFxuICAgICRuZXh0RGF0YSA9ICdkYXRhJyArICRkYXRhTnh0LFxuICAgICRjdXJyZW50QmFzZUlkID0gaXQuYmFzZUlkLFxuICAgICRub25FbXB0eVNjaGVtYSA9IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaGVtYSwgaXQuUlVMRVMuYWxsKTtcbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzO3ZhciAnICsgKCR2YWxpZCkgKyAnOyc7XG4gIGlmICgkbm9uRW1wdHlTY2hlbWEpIHtcbiAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoO1xuICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHRWYWxpZCkgKyAnID0gZmFsc2U7IGZvciAodmFyICcgKyAoJGlkeCkgKyAnID0gMDsgJyArICgkaWR4KSArICcgPCAnICsgKCRkYXRhKSArICcubGVuZ3RoOyAnICsgKCRpZHgpICsgJysrKSB7ICc7XG4gICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAkaWR4LCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGlkeCArICddJztcbiAgICAkaXQuZGF0YVBhdGhBcnJbJGRhdGFOeHRdID0gJGlkeDtcbiAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgYnJlYWs7IH0gICc7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCEnICsgKCRuZXh0VmFsaWQpICsgJykgeyc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPT0gMCkgeyc7XG4gIH1cbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdjb250YWlucycpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHt9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBjb250YWluIGEgdmFsaWQgaXRlbVxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnIH0gZWxzZSB7ICc7XG4gIGlmICgkbm9uRW1wdHlTY2hlbWEpIHtcbiAgICBvdXQgKz0gJyAgZXJyb3JzID0gJyArICgkZXJycykgKyAnOyBpZiAodkVycm9ycyAhPT0gbnVsbCkgeyBpZiAoJyArICgkZXJycykgKyAnKSB2RXJyb3JzLmxlbmd0aCA9ICcgKyAoJGVycnMpICsgJzsgZWxzZSB2RXJyb3JzID0gbnVsbDsgfSAnO1xuICB9XG4gIGlmIChpdC5vcHRzLmFsbEVycm9ycykge1xuICAgIG91dCArPSAnIH0gJztcbiAgfVxuICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2N1c3RvbShpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGVycm9yS2V5d29yZDtcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsO1xuICB2YXIgJGVycnMgPSAnZXJyc19fJyArICRsdmw7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICB2YXIgJHJ1bGUgPSB0aGlzLFxuICAgICRkZWZpbml0aW9uID0gJ2RlZmluaXRpb24nICsgJGx2bCxcbiAgICAkckRlZiA9ICRydWxlLmRlZmluaXRpb24sXG4gICAgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgdmFyICRjb21waWxlLCAkaW5saW5lLCAkbWFjcm8sICRydWxlVmFsaWRhdGUsICR2YWxpZGF0ZUNvZGU7XG4gIGlmICgkaXNEYXRhICYmICRyRGVmLiRkYXRhKSB7XG4gICAgJHZhbGlkYXRlQ29kZSA9ICdrZXl3b3JkVmFsaWRhdGUnICsgJGx2bDtcbiAgICB2YXIgJHZhbGlkYXRlU2NoZW1hID0gJHJEZWYudmFsaWRhdGVTY2hlbWE7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJGRlZmluaXRpb24pICsgJyA9IFJVTEVTLmN1c3RvbVtcXCcnICsgKCRrZXl3b3JkKSArICdcXCddLmRlZmluaXRpb247IHZhciAnICsgKCR2YWxpZGF0ZUNvZGUpICsgJyA9ICcgKyAoJGRlZmluaXRpb24pICsgJy52YWxpZGF0ZTsnO1xuICB9IGVsc2Uge1xuICAgICRydWxlVmFsaWRhdGUgPSBpdC51c2VDdXN0b21SdWxlKCRydWxlLCAkc2NoZW1hLCBpdC5zY2hlbWEsIGl0KTtcbiAgICBpZiAoISRydWxlVmFsaWRhdGUpIHJldHVybjtcbiAgICAkc2NoZW1hVmFsdWUgPSAndmFsaWRhdGUuc2NoZW1hJyArICRzY2hlbWFQYXRoO1xuICAgICR2YWxpZGF0ZUNvZGUgPSAkcnVsZVZhbGlkYXRlLmNvZGU7XG4gICAgJGNvbXBpbGUgPSAkckRlZi5jb21waWxlO1xuICAgICRpbmxpbmUgPSAkckRlZi5pbmxpbmU7XG4gICAgJG1hY3JvID0gJHJEZWYubWFjcm87XG4gIH1cbiAgdmFyICRydWxlRXJycyA9ICR2YWxpZGF0ZUNvZGUgKyAnLmVycm9ycycsXG4gICAgJGkgPSAnaScgKyAkbHZsLFxuICAgICRydWxlRXJyID0gJ3J1bGVFcnInICsgJGx2bCxcbiAgICAkYXN5bmNLZXl3b3JkID0gJHJEZWYuYXN5bmM7XG4gIGlmICgkYXN5bmNLZXl3b3JkICYmICFpdC5hc3luYykgdGhyb3cgbmV3IEVycm9yKCdhc3luYyBrZXl3b3JkIGluIHN5bmMgc2NoZW1hJyk7XG4gIGlmICghKCRpbmxpbmUgfHwgJG1hY3JvKSkge1xuICAgIG91dCArPSAnJyArICgkcnVsZUVycnMpICsgJyA9IG51bGw7JztcbiAgfVxuICBvdXQgKz0gJ3ZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7dmFyICcgKyAoJHZhbGlkKSArICc7JztcbiAgaWYgKCRpc0RhdGEgJiYgJHJEZWYuJGRhdGEpIHtcbiAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgb3V0ICs9ICcgaWYgKCcgKyAoJHNjaGVtYVZhbHVlKSArICcgPT09IHVuZGVmaW5lZCkgeyAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgfSBlbHNlIHsgJztcbiAgICBpZiAoJHZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICBvdXQgKz0gJyAnICsgKCR2YWxpZCkgKyAnID0gJyArICgkZGVmaW5pdGlvbikgKyAnLnZhbGlkYXRlU2NoZW1hKCcgKyAoJHNjaGVtYVZhbHVlKSArICcpOyBpZiAoJyArICgkdmFsaWQpICsgJykgeyAnO1xuICAgIH1cbiAgfVxuICBpZiAoJGlubGluZSkge1xuICAgIGlmICgkckRlZi5zdGF0ZW1lbnRzKSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRydWxlVmFsaWRhdGUudmFsaWRhdGUpICsgJyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCR2YWxpZCkgKyAnID0gJyArICgkcnVsZVZhbGlkYXRlLnZhbGlkYXRlKSArICc7ICc7XG4gICAgfVxuICB9IGVsc2UgaWYgKCRtYWNybykge1xuICAgIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICAgIHZhciAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAgICRpdC5sZXZlbCsrO1xuICAgIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgICAkaXQuc2NoZW1hID0gJHJ1bGVWYWxpZGF0ZS52YWxpZGF0ZTtcbiAgICAkaXQuc2NoZW1hUGF0aCA9ICcnO1xuICAgIHZhciAkd2FzQ29tcG9zaXRlID0gaXQuY29tcG9zaXRlUnVsZTtcbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSB0cnVlO1xuICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCkucmVwbGFjZSgvdmFsaWRhdGVcXC5zY2hlbWEvZywgJHZhbGlkYXRlQ29kZSk7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICBvdXQgKz0gJyAnICsgKCRjb2RlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gJyc7XG4gICAgb3V0ICs9ICcgICcgKyAoJHZhbGlkYXRlQ29kZSkgKyAnLmNhbGwoICc7XG4gICAgaWYgKGl0Lm9wdHMucGFzc0NvbnRleHQpIHtcbiAgICAgIG91dCArPSAndGhpcyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnc2VsZic7XG4gICAgfVxuICAgIGlmICgkY29tcGlsZSB8fCAkckRlZi5zY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAsICcgKyAoJHNjaGVtYVZhbHVlKSArICcgLCAnICsgKCRkYXRhKSArICcgLCB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAsIChkYXRhUGF0aCB8fCBcXCdcXCcpJztcbiAgICBpZiAoaXQuZXJyb3JQYXRoICE9ICdcIlwiJykge1xuICAgICAgb3V0ICs9ICcgKyAnICsgKGl0LmVycm9yUGF0aCk7XG4gICAgfVxuICAgIHZhciAkcGFyZW50RGF0YSA9ICRkYXRhTHZsID8gJ2RhdGEnICsgKCgkZGF0YUx2bCAtIDEpIHx8ICcnKSA6ICdwYXJlbnREYXRhJyxcbiAgICAgICRwYXJlbnREYXRhUHJvcGVydHkgPSAkZGF0YUx2bCA/IGl0LmRhdGFQYXRoQXJyWyRkYXRhTHZsXSA6ICdwYXJlbnREYXRhUHJvcGVydHknO1xuICAgIG91dCArPSAnICwgJyArICgkcGFyZW50RGF0YSkgKyAnICwgJyArICgkcGFyZW50RGF0YVByb3BlcnR5KSArICcgLCByb290RGF0YSApICAnO1xuICAgIHZhciBkZWZfY2FsbFJ1bGVWYWxpZGF0ZSA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICgkckRlZi5lcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCR2YWxpZCkgKyAnID0gJztcbiAgICAgIGlmICgkYXN5bmNLZXl3b3JkKSB7XG4gICAgICAgIG91dCArPSAnYXdhaXQgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnJyArIChkZWZfY2FsbFJ1bGVWYWxpZGF0ZSkgKyAnOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJGFzeW5jS2V5d29yZCkge1xuICAgICAgICAkcnVsZUVycnMgPSAnY3VzdG9tRXJyb3JzJyArICRsdmw7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCRydWxlRXJycykgKyAnID0gbnVsbDsgdHJ5IHsgJyArICgkdmFsaWQpICsgJyA9IGF3YWl0ICcgKyAoZGVmX2NhbGxSdWxlVmFsaWRhdGUpICsgJzsgfSBjYXRjaCAoZSkgeyAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7IGlmIChlIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSAnICsgKCRydWxlRXJycykgKyAnID0gZS5lcnJvcnM7IGVsc2UgdGhyb3cgZTsgfSAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkcnVsZUVycnMpICsgJyA9IG51bGw7ICcgKyAoJHZhbGlkKSArICcgPSAnICsgKGRlZl9jYWxsUnVsZVZhbGlkYXRlKSArICc7ICc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgkckRlZi5tb2RpZnlpbmcpIHtcbiAgICBvdXQgKz0gJyBpZiAoJyArICgkcGFyZW50RGF0YSkgKyAnKSAnICsgKCRkYXRhKSArICcgPSAnICsgKCRwYXJlbnREYXRhKSArICdbJyArICgkcGFyZW50RGF0YVByb3BlcnR5KSArICddOyc7XG4gIH1cbiAgb3V0ICs9ICcnICsgKCRjbG9zaW5nQnJhY2VzKTtcbiAgaWYgKCRyRGVmLnZhbGlkKSB7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCArPSAnIGlmICggJztcbiAgICBpZiAoJHJEZWYudmFsaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3V0ICs9ICcgISc7XG4gICAgICBpZiAoJG1hY3JvKSB7XG4gICAgICAgIG91dCArPSAnJyArICgkbmV4dFZhbGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArICgkdmFsaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCEkckRlZi52YWxpZCkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnKSB7ICc7XG4gICAgJGVycm9yS2V5d29yZCA9ICRydWxlLmtleXdvcmQ7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9ICcnO1xuICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ2N1c3RvbScpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsga2V5d29yZDogXFwnJyArICgkcnVsZS5rZXl3b3JkKSArICdcXCcgfSAnO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIHBhc3MgXCInICsgKCRydWxlLmtleXdvcmQpICsgJ1wiIGtleXdvcmQgdmFsaWRhdGlvblxcJyAnO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB7fSAnO1xuICAgIH1cbiAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgfVxuICAgIHZhciBkZWZfY3VzdG9tRXJyb3IgPSBvdXQ7XG4gICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICBpZiAoJGlubGluZSkge1xuICAgICAgaWYgKCRyRGVmLmVycm9ycykge1xuICAgICAgICBpZiAoJHJEZWYuZXJyb3JzICE9ICdmdWxsJykge1xuICAgICAgICAgIG91dCArPSAnICBmb3IgKHZhciAnICsgKCRpKSArICc9JyArICgkZXJycykgKyAnOyAnICsgKCRpKSArICc8ZXJyb3JzOyAnICsgKCRpKSArICcrKykgeyB2YXIgJyArICgkcnVsZUVycikgKyAnID0gdkVycm9yc1snICsgKCRpKSArICddOyBpZiAoJyArICgkcnVsZUVycikgKyAnLmRhdGFQYXRoID09PSB1bmRlZmluZWQpICcgKyAoJHJ1bGVFcnIpICsgJy5kYXRhUGF0aCA9IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJzsgaWYgKCcgKyAoJHJ1bGVFcnIpICsgJy5zY2hlbWFQYXRoID09PSB1bmRlZmluZWQpIHsgJyArICgkcnVsZUVycikgKyAnLnNjaGVtYVBhdGggPSBcIicgKyAoJGVyclNjaGVtYVBhdGgpICsgJ1wiOyB9ICc7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArICgkcnVsZUVycikgKyAnLnNjaGVtYSA9ICcgKyAoJHNjaGVtYVZhbHVlKSArICc7ICcgKyAoJHJ1bGVFcnIpICsgJy5kYXRhID0gJyArICgkZGF0YSkgKyAnOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgkckRlZi5lcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgJyArIChkZWZfY3VzdG9tRXJyb3IpICsgJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRlcnJzKSArICcgPT0gZXJyb3JzKSB7ICcgKyAoZGVmX2N1c3RvbUVycm9yKSArICcgfSBlbHNlIHsgIGZvciAodmFyICcgKyAoJGkpICsgJz0nICsgKCRlcnJzKSArICc7ICcgKyAoJGkpICsgJzxlcnJvcnM7ICcgKyAoJGkpICsgJysrKSB7IHZhciAnICsgKCRydWxlRXJyKSArICcgPSB2RXJyb3JzWycgKyAoJGkpICsgJ107IGlmICgnICsgKCRydWxlRXJyKSArICcuZGF0YVBhdGggPT09IHVuZGVmaW5lZCkgJyArICgkcnVsZUVycikgKyAnLmRhdGFQYXRoID0gKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnOyBpZiAoJyArICgkcnVsZUVycikgKyAnLnNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCkgeyAnICsgKCRydWxlRXJyKSArICcuc2NoZW1hUGF0aCA9IFwiJyArICgkZXJyU2NoZW1hUGF0aCkgKyAnXCI7IH0gJztcbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKCRydWxlRXJyKSArICcuc2NoZW1hID0gJyArICgkc2NoZW1hVmFsdWUpICsgJzsgJyArICgkcnVsZUVycikgKyAnLmRhdGEgPSAnICsgKCRkYXRhKSArICc7ICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gfSAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkbWFjcm8pIHtcbiAgICAgIG91dCArPSAnICAgdmFyIGVyciA9ICAgJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICdjdXN0b20nKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGtleXdvcmQ6IFxcJycgKyAoJHJ1bGUua2V5d29yZCkgKyAnXFwnIH0gJztcbiAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgcGFzcyBcIicgKyAoJHJ1bGUua2V5d29yZCkgKyAnXCIga2V5d29yZCB2YWxpZGF0aW9uXFwnICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRyRGVmLmVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgJyArIChkZWZfY3VzdG9tRXJyb3IpICsgJyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKEFycmF5LmlzQXJyYXkoJyArICgkcnVsZUVycnMpICsgJykpIHsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSAnICsgKCRydWxlRXJycykgKyAnOyBlbHNlIHZFcnJvcnMgPSB2RXJyb3JzLmNvbmNhdCgnICsgKCRydWxlRXJycykgKyAnKTsgZXJyb3JzID0gdkVycm9ycy5sZW5ndGg7ICBmb3IgKHZhciAnICsgKCRpKSArICc9JyArICgkZXJycykgKyAnOyAnICsgKCRpKSArICc8ZXJyb3JzOyAnICsgKCRpKSArICcrKykgeyB2YXIgJyArICgkcnVsZUVycikgKyAnID0gdkVycm9yc1snICsgKCRpKSArICddOyBpZiAoJyArICgkcnVsZUVycikgKyAnLmRhdGFQYXRoID09PSB1bmRlZmluZWQpICcgKyAoJHJ1bGVFcnIpICsgJy5kYXRhUGF0aCA9IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJzsgICcgKyAoJHJ1bGVFcnIpICsgJy5zY2hlbWFQYXRoID0gXCInICsgKCRlcnJTY2hlbWFQYXRoKSArICdcIjsgICc7XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAnICsgKCRydWxlRXJyKSArICcuc2NoZW1hID0gJyArICgkc2NoZW1hVmFsdWUpICsgJzsgJyArICgkcnVsZUVycikgKyAnLmRhdGEgPSAnICsgKCRkYXRhKSArICc7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSB9IGVsc2UgeyAnICsgKGRlZl9jdXN0b21FcnJvcikgKyAnIH0gJztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9ICcgfSAnO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZGVwZW5kZW5jaWVzKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkZXJycyA9ICdlcnJzX18nICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gIHZhciAkY2xvc2luZ0JyYWNlcyA9ICcnO1xuICAkaXQubGV2ZWwrKztcbiAgdmFyICRuZXh0VmFsaWQgPSAndmFsaWQnICsgJGl0LmxldmVsO1xuICB2YXIgJHNjaGVtYURlcHMgPSB7fSxcbiAgICAkcHJvcGVydHlEZXBzID0ge30sXG4gICAgJG93blByb3BlcnRpZXMgPSBpdC5vcHRzLm93blByb3BlcnRpZXM7XG4gIGZvciAoJHByb3BlcnR5IGluICRzY2hlbWEpIHtcbiAgICB2YXIgJHNjaCA9ICRzY2hlbWFbJHByb3BlcnR5XTtcbiAgICB2YXIgJGRlcHMgPSBBcnJheS5pc0FycmF5KCRzY2gpID8gJHByb3BlcnR5RGVwcyA6ICRzY2hlbWFEZXBzO1xuICAgICRkZXBzWyRwcm9wZXJ0eV0gPSAkc2NoO1xuICB9XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsnO1xuICB2YXIgJGN1cnJlbnRFcnJvclBhdGggPSBpdC5lcnJvclBhdGg7XG4gIG91dCArPSAndmFyIG1pc3NpbmcnICsgKCRsdmwpICsgJzsnO1xuICBmb3IgKHZhciAkcHJvcGVydHkgaW4gJHByb3BlcnR5RGVwcykge1xuICAgICRkZXBzID0gJHByb3BlcnR5RGVwc1skcHJvcGVydHldO1xuICAgIGlmICgkZGVwcy5sZW5ndGgpIHtcbiAgICAgIG91dCArPSAnIGlmICggJyArICgkZGF0YSkgKyAoaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpKSArICcgIT09IHVuZGVmaW5lZCAnO1xuICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgIG91dCArPSAnICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsIFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnXFwnKSAnO1xuICAgICAgfVxuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgJiYgKCAnO1xuICAgICAgICB2YXIgYXJyMSA9ICRkZXBzO1xuICAgICAgICBpZiAoYXJyMSkge1xuICAgICAgICAgIHZhciAkcHJvcGVydHlLZXksICRpID0gLTEsXG4gICAgICAgICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAgICAgJHByb3BlcnR5S2V5ID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgICAgIGlmICgkaSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgICAkdXNlRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgICBvdXQgKz0gJyAoICggJyArICgkdXNlRGF0YSkgKyAnID09PSB1bmRlZmluZWQgJztcbiAgICAgICAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsIFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KSkgKyAnXFwnKSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcpICYmIChtaXNzaW5nJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoaXQub3B0cy5qc29uUG9pbnRlcnMgPyAkcHJvcGVydHlLZXkgOiAkcHJvcCkpICsgJykgKSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJykpIHsgICc7XG4gICAgICAgIHZhciAkcHJvcGVydHlQYXRoID0gJ21pc3NpbmcnICsgJGx2bCxcbiAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gJ1xcJyArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFxcJyc7XG4gICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC5vcHRzLmpzb25Qb2ludGVycyA/IGl0LnV0aWwuZ2V0UGF0aEV4cHIoJGN1cnJlbnRFcnJvclBhdGgsICRwcm9wZXJ0eVBhdGgsIHRydWUpIDogJGN1cnJlbnRFcnJvclBhdGggKyAnICsgJyArICRwcm9wZXJ0eVBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdkZXBlbmRlbmNpZXMnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHByb3BlcnR5OiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eSkpICsgJ1xcJywgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJywgZGVwc0NvdW50OiAnICsgKCRkZXBzLmxlbmd0aCkgKyAnLCBkZXBzOiBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmxlbmd0aCA9PSAxID8gJGRlcHNbMF0gOiAkZGVwcy5qb2luKFwiLCBcIikpKSArICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgaGF2ZSAnO1xuICAgICAgICAgICAgaWYgKCRkZXBzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgIG91dCArPSAncHJvcGVydHkgJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwc1swXSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdwcm9wZXJ0aWVzICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHMuam9pbihcIiwgXCIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJyB3aGVuIHByb3BlcnR5ICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnIGlzIHByZXNlbnRcXCcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgKSB7ICc7XG4gICAgICAgIHZhciBhcnIyID0gJGRlcHM7XG4gICAgICAgIGlmIChhcnIyKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTIgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlIChpMiA8IGwyKSB7XG4gICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIyW2kyICs9IDFdO1xuICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KSxcbiAgICAgICAgICAgICAgJHVzZURhdGEgPSAkZGF0YSArICRwcm9wO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGgoJGN1cnJlbnRFcnJvclBhdGgsICRwcm9wZXJ0eUtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCAnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICEgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpKSArICdcXCcpICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJykgeyAgdmFyIGVyciA9ICAgJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnZGVwZW5kZW5jaWVzJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBwcm9wZXJ0eTogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICdcXCcsIG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcsIGRlcHNDb3VudDogJyArICgkZGVwcy5sZW5ndGgpICsgJywgZGVwczogXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwcy5sZW5ndGggPT0gMSA/ICRkZXBzWzBdIDogJGRlcHMuam9pbihcIiwgXCIpKSkgKyAnXFwnIH0gJztcbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgaGF2ZSAnO1xuICAgICAgICAgICAgICAgIGlmICgkZGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICdwcm9wZXJ0eSAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzWzBdKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAncHJvcGVydGllcyAnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmpvaW4oXCIsIFwiKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB3aGVuIHByb3BlcnR5ICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSkgKyAnIGlzIHByZXNlbnRcXCcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgfSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAgICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpdC5lcnJvclBhdGggPSAkY3VycmVudEVycm9yUGF0aDtcbiAgdmFyICRjdXJyZW50QmFzZUlkID0gJGl0LmJhc2VJZDtcbiAgZm9yICh2YXIgJHByb3BlcnR5IGluICRzY2hlbWFEZXBzKSB7XG4gICAgdmFyICRzY2ggPSAkc2NoZW1hRGVwc1skcHJvcGVydHldO1xuICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJG5leHRWYWxpZCkgKyAnID0gdHJ1ZTsgaWYgKCAnICsgKCRkYXRhKSArIChpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eSkpICsgJyAhPT0gdW5kZWZpbmVkICc7XG4gICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgb3V0ICs9ICcgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHkpKSArICdcXCcpICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJykgeyAnO1xuICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpO1xuICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArICcvJyArIGl0LnV0aWwuZXNjYXBlRnJhZ21lbnQoJHByb3BlcnR5KTtcbiAgICAgIG91dCArPSAnICAnICsgKGl0LnZhbGlkYXRlKCRpdCkpICsgJyAnO1xuICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgb3V0ICs9ICcgfSAgJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnO1xuICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgICAnICsgKCRjbG9zaW5nQnJhY2VzKSArICcgaWYgKCcgKyAoJGVycnMpICsgJyA9PSBlcnJvcnMpIHsnO1xuICB9XG4gIG91dCA9IGl0LnV0aWwuY2xlYW5VcENvZGUob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZW51bShpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICB2YXIgJGkgPSAnaScgKyAkbHZsLFxuICAgICR2U2NoZW1hID0gJ3NjaGVtYScgKyAkbHZsO1xuICBpZiAoISRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkdlNjaGVtYSkgKyAnID0gdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnOyc7XG4gIH1cbiAgb3V0ICs9ICd2YXIgJyArICgkdmFsaWQpICsgJzsnO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIGlmIChzY2hlbWEnICsgKCRsdmwpICsgJyA9PT0gdW5kZWZpbmVkKSAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hJyArICgkbHZsKSArICcpKSAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7IGVsc2Ugeyc7XG4gIH1cbiAgb3V0ICs9ICcnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7Zm9yICh2YXIgJyArICgkaSkgKyAnPTA7ICcgKyAoJGkpICsgJzwnICsgKCR2U2NoZW1hKSArICcubGVuZ3RoOyAnICsgKCRpKSArICcrKykgaWYgKGVxdWFsKCcgKyAoJGRhdGEpICsgJywgJyArICgkdlNjaGVtYSkgKyAnWycgKyAoJGkpICsgJ10pKSB7ICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyBicmVhazsgfSc7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgIH0gICc7XG4gIH1cbiAgb3V0ICs9ICcgaWYgKCEnICsgKCR2YWxpZCkgKyAnKSB7ICAgJztcbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdlbnVtJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBhbGxvd2VkVmFsdWVzOiBzY2hlbWEnICsgKCRsdmwpICsgJyB9ICc7XG4gICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB7fSAnO1xuICB9XG4gIHZhciBfX2VyciA9IG91dDtcbiAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICcgfSc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZm9ybWF0KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIGlmIChpdC5vcHRzLmZvcm1hdCA9PT0gZmFsc2UpIHtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgdmFyICR1bmtub3duRm9ybWF0cyA9IGl0Lm9wdHMudW5rbm93bkZvcm1hdHMsXG4gICAgJGFsbG93VW5rbm93biA9IEFycmF5LmlzQXJyYXkoJHVua25vd25Gb3JtYXRzKTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICB2YXIgJGZvcm1hdCA9ICdmb3JtYXQnICsgJGx2bCxcbiAgICAgICRpc09iamVjdCA9ICdpc09iamVjdCcgKyAkbHZsLFxuICAgICAgJGZvcm1hdFR5cGUgPSAnZm9ybWF0VHlwZScgKyAkbHZsO1xuICAgIG91dCArPSAnIHZhciAnICsgKCRmb3JtYXQpICsgJyA9IGZvcm1hdHNbJyArICgkc2NoZW1hVmFsdWUpICsgJ107IHZhciAnICsgKCRpc09iamVjdCkgKyAnID0gdHlwZW9mICcgKyAoJGZvcm1hdCkgKyAnID09IFxcJ29iamVjdFxcJyAmJiAhKCcgKyAoJGZvcm1hdCkgKyAnIGluc3RhbmNlb2YgUmVnRXhwKSAmJiAnICsgKCRmb3JtYXQpICsgJy52YWxpZGF0ZTsgdmFyICcgKyAoJGZvcm1hdFR5cGUpICsgJyA9ICcgKyAoJGlzT2JqZWN0KSArICcgJiYgJyArICgkZm9ybWF0KSArICcudHlwZSB8fCBcXCdzdHJpbmdcXCc7IGlmICgnICsgKCRpc09iamVjdCkgKyAnKSB7ICc7XG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB2YXIgYXN5bmMnICsgKCRsdmwpICsgJyA9ICcgKyAoJGZvcm1hdCkgKyAnLmFzeW5jOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAnICsgKCRmb3JtYXQpICsgJyA9ICcgKyAoJGZvcm1hdCkgKyAnLnZhbGlkYXRlOyB9IGlmICggICc7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSAnICgnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT0gXFwnc3RyaW5nXFwnKSB8fCAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyAoJztcbiAgICBpZiAoJHVua25vd25Gb3JtYXRzICE9ICdpZ25vcmUnKSB7XG4gICAgICBvdXQgKz0gJyAoJyArICgkc2NoZW1hVmFsdWUpICsgJyAmJiAhJyArICgkZm9ybWF0KSArICcgJztcbiAgICAgIGlmICgkYWxsb3dVbmtub3duKSB7XG4gICAgICAgIG91dCArPSAnICYmIHNlbGYuX29wdHMudW5rbm93bkZvcm1hdHMuaW5kZXhPZignICsgKCRzY2hlbWFWYWx1ZSkgKyAnKSA9PSAtMSAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcpIHx8ICc7XG4gICAgfVxuICAgIG91dCArPSAnICgnICsgKCRmb3JtYXQpICsgJyAmJiAnICsgKCRmb3JtYXRUeXBlKSArICcgPT0gXFwnJyArICgkcnVsZVR5cGUpICsgJ1xcJyAmJiAhKHR5cGVvZiAnICsgKCRmb3JtYXQpICsgJyA9PSBcXCdmdW5jdGlvblxcJyA/ICc7XG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyAoYXN5bmMnICsgKCRsdmwpICsgJyA/IGF3YWl0ICcgKyAoJGZvcm1hdCkgKyAnKCcgKyAoJGRhdGEpICsgJykgOiAnICsgKCRmb3JtYXQpICsgJygnICsgKCRkYXRhKSArICcpKSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRmb3JtYXQpICsgJygnICsgKCRkYXRhKSArICcpICc7XG4gICAgfVxuICAgIG91dCArPSAnIDogJyArICgkZm9ybWF0KSArICcudGVzdCgnICsgKCRkYXRhKSArICcpKSkpKSB7JztcbiAgfSBlbHNlIHtcbiAgICB2YXIgJGZvcm1hdCA9IGl0LmZvcm1hdHNbJHNjaGVtYV07XG4gICAgaWYgKCEkZm9ybWF0KSB7XG4gICAgICBpZiAoJHVua25vd25Gb3JtYXRzID09ICdpZ25vcmUnKSB7XG4gICAgICAgIGl0LmxvZ2dlci53YXJuKCd1bmtub3duIGZvcm1hdCBcIicgKyAkc2NoZW1hICsgJ1wiIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCInICsgaXQuZXJyU2NoZW1hUGF0aCArICdcIicpO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH0gZWxzZSBpZiAoJGFsbG93VW5rbm93biAmJiAkdW5rbm93bkZvcm1hdHMuaW5kZXhPZigkc2NoZW1hKSA+PSAwKSB7XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGZvcm1hdCBcIicgKyAkc2NoZW1hICsgJ1wiIGlzIHVzZWQgaW4gc2NoZW1hIGF0IHBhdGggXCInICsgaXQuZXJyU2NoZW1hUGF0aCArICdcIicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgJGlzT2JqZWN0ID0gdHlwZW9mICRmb3JtYXQgPT0gJ29iamVjdCcgJiYgISgkZm9ybWF0IGluc3RhbmNlb2YgUmVnRXhwKSAmJiAkZm9ybWF0LnZhbGlkYXRlO1xuICAgIHZhciAkZm9ybWF0VHlwZSA9ICRpc09iamVjdCAmJiAkZm9ybWF0LnR5cGUgfHwgJ3N0cmluZyc7XG4gICAgaWYgKCRpc09iamVjdCkge1xuICAgICAgdmFyICRhc3luYyA9ICRmb3JtYXQuYXN5bmMgPT09IHRydWU7XG4gICAgICAkZm9ybWF0ID0gJGZvcm1hdC52YWxpZGF0ZTtcbiAgICB9XG4gICAgaWYgKCRmb3JtYXRUeXBlICE9ICRydWxlVHlwZSkge1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKHRydWUpIHsgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGlmICgkYXN5bmMpIHtcbiAgICAgIGlmICghaXQuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMgZm9ybWF0IGluIHN5bmMgc2NoZW1hJyk7XG4gICAgICB2YXIgJGZvcm1hdFJlZiA9ICdmb3JtYXRzJyArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHNjaGVtYSkgKyAnLnZhbGlkYXRlJztcbiAgICAgIG91dCArPSAnIGlmICghKGF3YWl0ICcgKyAoJGZvcm1hdFJlZikgKyAnKCcgKyAoJGRhdGEpICsgJykpKSB7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIGlmICghICc7XG4gICAgICB2YXIgJGZvcm1hdFJlZiA9ICdmb3JtYXRzJyArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHNjaGVtYSk7XG4gICAgICBpZiAoJGlzT2JqZWN0KSAkZm9ybWF0UmVmICs9ICcudmFsaWRhdGUnO1xuICAgICAgaWYgKHR5cGVvZiAkZm9ybWF0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkZm9ybWF0UmVmKSArICcoJyArICgkZGF0YSkgKyAnKSAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkZm9ybWF0UmVmKSArICcudGVzdCgnICsgKCRkYXRhKSArICcpICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJykgeyAnO1xuICAgIH1cbiAgfVxuICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ2Zvcm1hdCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgZm9ybWF0OiAgJztcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWFWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKTtcbiAgICB9XG4gICAgb3V0ICs9ICcgIH0gJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIGZvcm1hdCBcIic7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gJ1xcJyArICcgKyAoJHNjaGVtYVZhbHVlKSArICcgKyBcXCcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnXCJcXCcgJztcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICd2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB7fSAnO1xuICB9XG4gIHZhciBfX2VyciA9IG91dDtcbiAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICcgfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX2lmKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgdmFyICR0aGVuU2NoID0gaXQuc2NoZW1hWyd0aGVuJ10sXG4gICAgJGVsc2VTY2ggPSBpdC5zY2hlbWFbJ2Vsc2UnXSxcbiAgICAkdGhlblByZXNlbnQgPSAkdGhlblNjaCAhPT0gdW5kZWZpbmVkICYmIGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHRoZW5TY2gsIGl0LlJVTEVTLmFsbCksXG4gICAgJGVsc2VQcmVzZW50ID0gJGVsc2VTY2ggIT09IHVuZGVmaW5lZCAmJiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRlbHNlU2NoLCBpdC5SVUxFUy5hbGwpLFxuICAgICRjdXJyZW50QmFzZUlkID0gJGl0LmJhc2VJZDtcbiAgaWYgKCR0aGVuUHJlc2VudCB8fCAkZWxzZVByZXNlbnQpIHtcbiAgICB2YXIgJGlmQ2xhdXNlO1xuICAgICRpdC5jcmVhdGVFcnJvcnMgPSBmYWxzZTtcbiAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoO1xuICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsgdmFyICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyAgJztcbiAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICBvdXQgKz0gJyAgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgJGl0LmNyZWF0ZUVycm9ycyA9IHRydWU7XG4gICAgb3V0ICs9ICcgIGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKCcgKyAoJGVycnMpICsgJykgdkVycm9ycy5sZW5ndGggPSAnICsgKCRlcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0gICc7XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICBpZiAoJHRoZW5QcmVzZW50KSB7XG4gICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcpIHsgICc7XG4gICAgICAkaXQuc2NoZW1hID0gaXQuc2NoZW1hWyd0aGVuJ107XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLnRoZW4nO1xuICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy90aGVuJztcbiAgICAgIG91dCArPSAnICAnICsgKGl0LnZhbGlkYXRlKCRpdCkpICsgJyAnO1xuICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgb3V0ICs9ICcgJyArICgkdmFsaWQpICsgJyA9ICcgKyAoJG5leHRWYWxpZCkgKyAnOyAnO1xuICAgICAgaWYgKCR0aGVuUHJlc2VudCAmJiAkZWxzZVByZXNlbnQpIHtcbiAgICAgICAgJGlmQ2xhdXNlID0gJ2lmQ2xhdXNlJyArICRsdmw7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCRpZkNsYXVzZSkgKyAnID0gXFwndGhlblxcJzsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRpZkNsYXVzZSA9ICdcXCd0aGVuXFwnJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICAgIGlmICgkZWxzZVByZXNlbnQpIHtcbiAgICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIHsgJztcbiAgICB9XG4gICAgaWYgKCRlbHNlUHJlc2VudCkge1xuICAgICAgJGl0LnNjaGVtYSA9IGl0LnNjaGVtYVsnZWxzZSddO1xuICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy5lbHNlJztcbiAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvZWxzZSc7XG4gICAgICBvdXQgKz0gJyAgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRuZXh0VmFsaWQpICsgJzsgJztcbiAgICAgIGlmICgkdGhlblByZXNlbnQgJiYgJGVsc2VQcmVzZW50KSB7XG4gICAgICAgICRpZkNsYXVzZSA9ICdpZkNsYXVzZScgKyAkbHZsO1xuICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkaWZDbGF1c2UpICsgJyA9IFxcJ2Vsc2VcXCc7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkaWZDbGF1c2UgPSAnXFwnZWxzZVxcJyc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfVxuICAgIG91dCArPSAnIGlmICghJyArICgkdmFsaWQpICsgJykgeyAgIHZhciBlcnIgPSAgICc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnaWYnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGZhaWxpbmdLZXl3b3JkOiAnICsgKCRpZkNsYXVzZSkgKyAnIH0gJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBtYXRjaCBcIlxcJyArICcgKyAoJGlmQ2xhdXNlKSArICcgKyBcXCdcIiBzY2hlbWFcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcge30gJztcbiAgICB9XG4gICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IHZFcnJvcnM7IHJldHVybiBmYWxzZTsgJztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9ICcgfSAgICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgIH1cbiAgICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICh0cnVlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vYWxsIHJlcXVpcmVzIG11c3QgYmUgZXhwbGljaXQgYmVjYXVzZSBicm93c2VyaWZ5IHdvbid0IHdvcmsgd2l0aCBkeW5hbWljIHJlcXVpcmVzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgJyRyZWYnOiByZXF1aXJlKCcuL3JlZicpLFxuICBhbGxPZjogcmVxdWlyZSgnLi9hbGxPZicpLFxuICBhbnlPZjogcmVxdWlyZSgnLi9hbnlPZicpLFxuICAnJGNvbW1lbnQnOiByZXF1aXJlKCcuL2NvbW1lbnQnKSxcbiAgY29uc3Q6IHJlcXVpcmUoJy4vY29uc3QnKSxcbiAgY29udGFpbnM6IHJlcXVpcmUoJy4vY29udGFpbnMnKSxcbiAgZGVwZW5kZW5jaWVzOiByZXF1aXJlKCcuL2RlcGVuZGVuY2llcycpLFxuICAnZW51bSc6IHJlcXVpcmUoJy4vZW51bScpLFxuICBmb3JtYXQ6IHJlcXVpcmUoJy4vZm9ybWF0JyksXG4gICdpZic6IHJlcXVpcmUoJy4vaWYnKSxcbiAgaXRlbXM6IHJlcXVpcmUoJy4vaXRlbXMnKSxcbiAgbWF4aW11bTogcmVxdWlyZSgnLi9fbGltaXQnKSxcbiAgbWluaW11bTogcmVxdWlyZSgnLi9fbGltaXQnKSxcbiAgbWF4SXRlbXM6IHJlcXVpcmUoJy4vX2xpbWl0SXRlbXMnKSxcbiAgbWluSXRlbXM6IHJlcXVpcmUoJy4vX2xpbWl0SXRlbXMnKSxcbiAgbWF4TGVuZ3RoOiByZXF1aXJlKCcuL19saW1pdExlbmd0aCcpLFxuICBtaW5MZW5ndGg6IHJlcXVpcmUoJy4vX2xpbWl0TGVuZ3RoJyksXG4gIG1heFByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX2xpbWl0UHJvcGVydGllcycpLFxuICBtaW5Qcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19saW1pdFByb3BlcnRpZXMnKSxcbiAgbXVsdGlwbGVPZjogcmVxdWlyZSgnLi9tdWx0aXBsZU9mJyksXG4gIG5vdDogcmVxdWlyZSgnLi9ub3QnKSxcbiAgb25lT2Y6IHJlcXVpcmUoJy4vb25lT2YnKSxcbiAgcGF0dGVybjogcmVxdWlyZSgnLi9wYXR0ZXJuJyksXG4gIHByb3BlcnRpZXM6IHJlcXVpcmUoJy4vcHJvcGVydGllcycpLFxuICBwcm9wZXJ0eU5hbWVzOiByZXF1aXJlKCcuL3Byb3BlcnR5TmFtZXMnKSxcbiAgcmVxdWlyZWQ6IHJlcXVpcmUoJy4vcmVxdWlyZWQnKSxcbiAgdW5pcXVlSXRlbXM6IHJlcXVpcmUoJy4vdW5pcXVlSXRlbXMnKSxcbiAgdmFsaWRhdGU6IHJlcXVpcmUoJy4vdmFsaWRhdGUnKVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfaXRlbXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsO1xuICB2YXIgJGVycnMgPSAnZXJyc19fJyArICRsdmw7XG4gIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICB2YXIgJGNsb3NpbmdCcmFjZXMgPSAnJztcbiAgJGl0LmxldmVsKys7XG4gIHZhciAkbmV4dFZhbGlkID0gJ3ZhbGlkJyArICRpdC5sZXZlbDtcbiAgdmFyICRpZHggPSAnaScgKyAkbHZsLFxuICAgICRkYXRhTnh0ID0gJGl0LmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDEsXG4gICAgJG5leHREYXRhID0gJ2RhdGEnICsgJGRhdGFOeHQsXG4gICAgJGN1cnJlbnRCYXNlSWQgPSBpdC5iYXNlSWQ7XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczt2YXIgJyArICgkdmFsaWQpICsgJzsnO1xuICBpZiAoQXJyYXkuaXNBcnJheSgkc2NoZW1hKSkge1xuICAgIHZhciAkYWRkaXRpb25hbEl0ZW1zID0gaXQuc2NoZW1hLmFkZGl0aW9uYWxJdGVtcztcbiAgICBpZiAoJGFkZGl0aW9uYWxJdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJHZhbGlkKSArICcgPSAnICsgKCRkYXRhKSArICcubGVuZ3RoIDw9ICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJzsgJztcbiAgICAgIHZhciAkY3VyckVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aDtcbiAgICAgICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvYWRkaXRpb25hbEl0ZW1zJztcbiAgICAgIG91dCArPSAnICBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICAnO1xuICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnYWRkaXRpb25hbEl0ZW1zJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBsaW1pdDogJyArICgkc2NoZW1hLmxlbmd0aCkgKyAnIH0gJztcbiAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgbW9yZSB0aGFuICcgKyAoJHNjaGVtYS5sZW5ndGgpICsgJyBpdGVtc1xcJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogZmFsc2UgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgIH1cbiAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgJGVyclNjaGVtYVBhdGggPSAkY3VyckVyclNjaGVtYVBhdGg7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYXJyMSA9ICRzY2hlbWE7XG4gICAgaWYgKGFycjEpIHtcbiAgICAgIHZhciAkc2NoLCAkaSA9IC0xLFxuICAgICAgICBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAgICRzY2ggPSBhcnIxWyRpICs9IDFdO1xuICAgICAgICBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgICAgICAgb3V0ICs9ICcgJyArICgkbmV4dFZhbGlkKSArICcgPSB0cnVlOyBpZiAoJyArICgkZGF0YSkgKyAnLmxlbmd0aCA+ICcgKyAoJGkpICsgJykgeyAnO1xuICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArICdbJyArICRpICsgJ10nO1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoICsgJy8nICsgJGk7XG4gICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAkaSwgaXQub3B0cy5qc29uUG9pbnRlcnMsIHRydWUpO1xuICAgICAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAkaTtcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gICc7XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnO1xuICAgICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mICRhZGRpdGlvbmFsSXRlbXMgPT0gJ29iamVjdCcgJiYgaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkYWRkaXRpb25hbEl0ZW1zLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgICAkaXQuc2NoZW1hID0gJGFkZGl0aW9uYWxJdGVtcztcbiAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcuYWRkaXRpb25hbEl0ZW1zJztcbiAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvYWRkaXRpb25hbEl0ZW1zJztcbiAgICAgIG91dCArPSAnICcgKyAoJG5leHRWYWxpZCkgKyAnID0gdHJ1ZTsgaWYgKCcgKyAoJGRhdGEpICsgJy5sZW5ndGggPiAnICsgKCRzY2hlbWEubGVuZ3RoKSArICcpIHsgIGZvciAodmFyICcgKyAoJGlkeCkgKyAnID0gJyArICgkc2NoZW1hLmxlbmd0aCkgKyAnOyAnICsgKCRpZHgpICsgJyA8ICcgKyAoJGRhdGEpICsgJy5sZW5ndGg7ICcgKyAoJGlkeCkgKyAnKyspIHsgJztcbiAgICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGlkeCwgaXQub3B0cy5qc29uUG9pbnRlcnMsIHRydWUpO1xuICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGlkeCArICddJztcbiAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAkaWR4O1xuICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgIH1cbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIGJyZWFrOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSB9ICAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoZW1hLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgJGl0LnNjaGVtYSA9ICRzY2hlbWE7XG4gICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoO1xuICAgIG91dCArPSAnICBmb3IgKHZhciAnICsgKCRpZHgpICsgJyA9ICcgKyAoMCkgKyAnOyAnICsgKCRpZHgpICsgJyA8ICcgKyAoJGRhdGEpICsgJy5sZW5ndGg7ICcgKyAoJGlkeCkgKyAnKyspIHsgJztcbiAgICAkaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICRpZHgsIGl0Lm9wdHMuanNvblBvaW50ZXJzLCB0cnVlKTtcbiAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyAnWycgKyAkaWR4ICsgJ10nO1xuICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAkaWR4O1xuICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICBvdXQgKz0gJyAnICsgKGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpKSArICcgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHREYXRhKSArICcgPSAnICsgKCRwYXNzRGF0YSkgKyAnOyAnICsgKCRjb2RlKSArICcgJztcbiAgICB9XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIGJyZWFrOyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9JztcbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMpICsgJyBpZiAoJyArICgkZXJycykgKyAnID09IGVycm9ycykgeyc7XG4gIH1cbiAgb3V0ID0gaXQudXRpbC5jbGVhblVwQ29kZShvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9tdWx0aXBsZU9mKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICBvdXQgKz0gJ3ZhciBkaXZpc2lvbicgKyAoJGx2bCkgKyAnO2lmICgnO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnICcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT09IHVuZGVmaW5lZCAmJiAoIHR5cGVvZiAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9IFxcJ251bWJlclxcJyB8fCAnO1xuICB9XG4gIG91dCArPSAnIChkaXZpc2lvbicgKyAoJGx2bCkgKyAnID0gJyArICgkZGF0YSkgKyAnIC8gJyArICgkc2NoZW1hVmFsdWUpICsgJywgJztcbiAgaWYgKGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvbikge1xuICAgIG91dCArPSAnIE1hdGguYWJzKE1hdGgucm91bmQoZGl2aXNpb24nICsgKCRsdmwpICsgJykgLSBkaXZpc2lvbicgKyAoJGx2bCkgKyAnKSA+IDFlLScgKyAoaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uKSArICcgJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyBkaXZpc2lvbicgKyAoJGx2bCkgKyAnICE9PSBwYXJzZUludChkaXZpc2lvbicgKyAoJGx2bCkgKyAnKSAnO1xuICB9XG4gIG91dCArPSAnICkgJztcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyAgKSAgJztcbiAgfVxuICBvdXQgKz0gJyApIHsgICAnO1xuICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ211bHRpcGxlT2YnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG11bHRpcGxlT2Y6ICcgKyAoJHNjaGVtYVZhbHVlKSArICcgfSAnO1xuICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgbXVsdGlwbGUgb2YgJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAnXFwnICsgJyArICgkc2NoZW1hVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWFWYWx1ZSkgKyAnXFwnJztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6ICAnO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICd2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArICgkc2NoZW1hKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB7fSAnO1xuICB9XG4gIHZhciBfX2VyciA9IG91dDtcbiAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gIH1cbiAgb3V0ICs9ICd9ICc7XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfbm90KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkZXJycyA9ICdlcnJzX18nICsgJGx2bDtcbiAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2hlbWEsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoO1xuICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgb3V0ICs9ICcgdmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsgICc7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgJGl0LmNyZWF0ZUVycm9ycyA9IGZhbHNlO1xuICAgIHZhciAkYWxsRXJyb3JzT3B0aW9uO1xuICAgIGlmICgkaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICAgICRhbGxFcnJvcnNPcHRpb24gPSAkaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgICAkaXQub3B0cy5hbGxFcnJvcnMgPSBmYWxzZTtcbiAgICB9XG4gICAgb3V0ICs9ICcgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAkaXQuY3JlYXRlRXJyb3JzID0gdHJ1ZTtcbiAgICBpZiAoJGFsbEVycm9yc09wdGlvbikgJGl0Lm9wdHMuYWxsRXJyb3JzID0gJGFsbEVycm9yc09wdGlvbjtcbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAgICc7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ25vdCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHt9ICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGJlIHZhbGlkXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgfVxuICAgIHZhciBfX2VyciA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSBlbHNlIHsgIGVycm9ycyA9ICcgKyAoJGVycnMpICsgJzsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKCcgKyAoJGVycnMpICsgJykgdkVycm9ycy5sZW5ndGggPSAnICsgKCRlcnJzKSArICc7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0gJztcbiAgICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgIHZhciBlcnIgPSAgICc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnbm90JykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczoge30gJztcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ3Nob3VsZCBOT1QgYmUgdmFsaWRcXCcgJztcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIH0gJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcge30gJztcbiAgICB9XG4gICAgb3V0ICs9ICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgaWYgKGZhbHNlKSB7ICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX29uZU9mKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gIHZhciBvdXQgPSAnICc7XG4gIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIHZhciAkY3VycmVudEJhc2VJZCA9ICRpdC5iYXNlSWQsXG4gICAgJHByZXZWYWxpZCA9ICdwcmV2VmFsaWQnICsgJGx2bCxcbiAgICAkcGFzc2luZ1NjaGVtYXMgPSAncGFzc2luZ1NjaGVtYXMnICsgJGx2bDtcbiAgb3V0ICs9ICd2YXIgJyArICgkZXJycykgKyAnID0gZXJyb3JzICwgJyArICgkcHJldlZhbGlkKSArICcgPSBmYWxzZSAsICcgKyAoJHZhbGlkKSArICcgPSBmYWxzZSAsICcgKyAoJHBhc3NpbmdTY2hlbWFzKSArICcgPSBudWxsOyAnO1xuICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgaWYgKGFycjEpIHtcbiAgICB2YXIgJHNjaCwgJGkgPSAtMSxcbiAgICAgIGwxID0gYXJyMS5sZW5ndGggLSAxO1xuICAgIHdoaWxlICgkaSA8IGwxKSB7XG4gICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyAnWycgKyAkaSArICddJztcbiAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArICcvJyArICRpO1xuICAgICAgICBvdXQgKz0gJyAgJyArIChpdC52YWxpZGF0ZSgkaXQpKSArICcgJztcbiAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJG5leHRWYWxpZCkgKyAnID0gdHJ1ZTsgJztcbiAgICAgIH1cbiAgICAgIGlmICgkaSkge1xuICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcgJiYgJyArICgkcHJldlZhbGlkKSArICcpIHsgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyAnICsgKCRwYXNzaW5nU2NoZW1hcykgKyAnID0gWycgKyAoJHBhc3NpbmdTY2hlbWFzKSArICcsICcgKyAoJGkpICsgJ107IH0gZWxzZSB7ICc7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9ICd9JztcbiAgICAgIH1cbiAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnICsgKCR2YWxpZCkgKyAnID0gJyArICgkcHJldlZhbGlkKSArICcgPSB0cnVlOyAnICsgKCRwYXNzaW5nU2NoZW1hcykgKyAnID0gJyArICgkaSkgKyAnOyB9JztcbiAgICB9XG4gIH1cbiAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgb3V0ICs9ICcnICsgKCRjbG9zaW5nQnJhY2VzKSArICdpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnb25lT2YnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHBhc3NpbmdTY2hlbWFzOiAnICsgKCRwYXNzaW5nU2NoZW1hcykgKyAnIH0gJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlxcJyAnO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpdC5hc3luYykge1xuICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gdkVycm9yczsgcmV0dXJuIGZhbHNlOyAnO1xuICAgIH1cbiAgfVxuICBvdXQgKz0gJ30gZWxzZSB7ICBlcnJvcnMgPSAnICsgKCRlcnJzKSArICc7IGlmICh2RXJyb3JzICE9PSBudWxsKSB7IGlmICgnICsgKCRlcnJzKSArICcpIHZFcnJvcnMubGVuZ3RoID0gJyArICgkZXJycykgKyAnOyBlbHNlIHZFcnJvcnMgPSBudWxsOyB9JztcbiAgaWYgKGl0Lm9wdHMuYWxsRXJyb3JzKSB7XG4gICAgb3V0ICs9ICcgfSAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3BhdHRlcm4oaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSxcbiAgICAkc2NoZW1hVmFsdWU7XG4gIGlmICgkaXNEYXRhKSB7XG4gICAgb3V0ICs9ICcgdmFyIHNjaGVtYScgKyAoJGx2bCkgKyAnID0gJyArIChpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSkgKyAnOyAnO1xuICAgICRzY2hlbWFWYWx1ZSA9ICdzY2hlbWEnICsgJGx2bDtcbiAgfSBlbHNlIHtcbiAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICB9XG4gIHZhciAkcmVnZXhwID0gJGlzRGF0YSA/ICcobmV3IFJlZ0V4cCgnICsgJHNjaGVtYVZhbHVlICsgJykpJyA6IGl0LnVzZVBhdHRlcm4oJHNjaGVtYSk7XG4gIG91dCArPSAnaWYgKCAnO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnICgnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT0gXFwnc3RyaW5nXFwnKSB8fCAnO1xuICB9XG4gIG91dCArPSAnICEnICsgKCRyZWdleHApICsgJy50ZXN0KCcgKyAoJGRhdGEpICsgJykgKSB7ICAgJztcbiAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdwYXR0ZXJuJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBwYXR0ZXJuOiAgJztcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9ICcnICsgKCRzY2hlbWFWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKTtcbiAgICB9XG4gICAgb3V0ICs9ICcgIH0gJztcbiAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIG1hdGNoIHBhdHRlcm4gXCInO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9ICdcXCcgKyAnICsgKCRzY2hlbWFWYWx1ZSkgKyAnICsgXFwnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnJyArIChpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJ1wiXFwnICc7XG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIG91dCArPSAnICwgc2NoZW1hOiAgJztcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSAndmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJycgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSk7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcge30gJztcbiAgfVxuICB2YXIgX19lcnIgPSBvdXQ7XG4gIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICB9XG4gIG91dCArPSAnfSAnO1xuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3Byb3BlcnRpZXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIHZhciAka2V5ID0gJ2tleScgKyAkbHZsLFxuICAgICRpZHggPSAnaWR4JyArICRsdmwsXG4gICAgJGRhdGFOeHQgPSAkaXQuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMSxcbiAgICAkbmV4dERhdGEgPSAnZGF0YScgKyAkZGF0YU54dCxcbiAgICAkZGF0YVByb3BlcnRpZXMgPSAnZGF0YVByb3BlcnRpZXMnICsgJGx2bDtcbiAgdmFyICRzY2hlbWFLZXlzID0gT2JqZWN0LmtleXMoJHNjaGVtYSB8fCB7fSksXG4gICAgJHBQcm9wZXJ0aWVzID0gaXQuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzIHx8IHt9LFxuICAgICRwUHJvcGVydHlLZXlzID0gT2JqZWN0LmtleXMoJHBQcm9wZXJ0aWVzKSxcbiAgICAkYVByb3BlcnRpZXMgPSBpdC5zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsXG4gICAgJHNvbWVQcm9wZXJ0aWVzID0gJHNjaGVtYUtleXMubGVuZ3RoIHx8ICRwUHJvcGVydHlLZXlzLmxlbmd0aCxcbiAgICAkbm9BZGRpdGlvbmFsID0gJGFQcm9wZXJ0aWVzID09PSBmYWxzZSxcbiAgICAkYWRkaXRpb25hbElzU2NoZW1hID0gdHlwZW9mICRhUHJvcGVydGllcyA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cygkYVByb3BlcnRpZXMpLmxlbmd0aCxcbiAgICAkcmVtb3ZlQWRkaXRpb25hbCA9IGl0Lm9wdHMucmVtb3ZlQWRkaXRpb25hbCxcbiAgICAkY2hlY2tBZGRpdGlvbmFsID0gJG5vQWRkaXRpb25hbCB8fCAkYWRkaXRpb25hbElzU2NoZW1hIHx8ICRyZW1vdmVBZGRpdGlvbmFsLFxuICAgICRvd25Qcm9wZXJ0aWVzID0gaXQub3B0cy5vd25Qcm9wZXJ0aWVzLFxuICAgICRjdXJyZW50QmFzZUlkID0gaXQuYmFzZUlkO1xuICB2YXIgJHJlcXVpcmVkID0gaXQuc2NoZW1hLnJlcXVpcmVkO1xuICBpZiAoJHJlcXVpcmVkICYmICEoaXQub3B0cy4kZGF0YSAmJiAkcmVxdWlyZWQuJGRhdGEpICYmICRyZXF1aXJlZC5sZW5ndGggPCBpdC5vcHRzLmxvb3BSZXF1aXJlZCkgdmFyICRyZXF1aXJlZEhhc2ggPSBpdC51dGlsLnRvSGFzaCgkcmVxdWlyZWQpO1xuICBvdXQgKz0gJ3ZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7dmFyICcgKyAoJG5leHRWYWxpZCkgKyAnID0gdHJ1ZTsnO1xuICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkZGF0YVByb3BlcnRpZXMpICsgJyA9IHVuZGVmaW5lZDsnO1xuICB9XG4gIGlmICgkY2hlY2tBZGRpdGlvbmFsKSB7XG4gICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRkYXRhUHJvcGVydGllcykgKyAnID0gJyArICgkZGF0YVByb3BlcnRpZXMpICsgJyB8fCBPYmplY3Qua2V5cygnICsgKCRkYXRhKSArICcpOyBmb3IgKHZhciAnICsgKCRpZHgpICsgJz0wOyAnICsgKCRpZHgpICsgJzwnICsgKCRkYXRhUHJvcGVydGllcykgKyAnLmxlbmd0aDsgJyArICgkaWR4KSArICcrKykgeyB2YXIgJyArICgka2V5KSArICcgPSAnICsgKCRkYXRhUHJvcGVydGllcykgKyAnWycgKyAoJGlkeCkgKyAnXTsgJztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgZm9yICh2YXIgJyArICgka2V5KSArICcgaW4gJyArICgkZGF0YSkgKyAnKSB7ICc7XG4gICAgfVxuICAgIGlmICgkc29tZVByb3BlcnRpZXMpIHtcbiAgICAgIG91dCArPSAnIHZhciBpc0FkZGl0aW9uYWwnICsgKCRsdmwpICsgJyA9ICEoZmFsc2UgJztcbiAgICAgIGlmICgkc2NoZW1hS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCRzY2hlbWFLZXlzLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgICBvdXQgKz0gJyB8fCB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcuaGFzT3duUHJvcGVydHkoJyArICgka2V5KSArICcpICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFycjEgPSAkc2NoZW1hS2V5cztcbiAgICAgICAgICBpZiAoYXJyMSkge1xuICAgICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTEgPSAtMSxcbiAgICAgICAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoaTEgPCBsMSkge1xuICAgICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIxW2kxICs9IDFdO1xuICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAnICsgKCRrZXkpICsgJyA9PSAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJHByb3BlcnR5S2V5KSkgKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoJHBQcm9wZXJ0eUtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnIyID0gJHBQcm9wZXJ0eUtleXM7XG4gICAgICAgIGlmIChhcnIyKSB7XG4gICAgICAgICAgdmFyICRwUHJvcGVydHksICRpID0gLTEsXG4gICAgICAgICAgICBsMiA9IGFycjIubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoJGkgPCBsMikge1xuICAgICAgICAgICAgJHBQcm9wZXJ0eSA9IGFycjJbJGkgKz0gMV07XG4gICAgICAgICAgICBvdXQgKz0gJyB8fCAnICsgKGl0LnVzZVBhdHRlcm4oJHBQcm9wZXJ0eSkpICsgJy50ZXN0KCcgKyAoJGtleSkgKyAnKSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0ICs9ICcgKTsgaWYgKGlzQWRkaXRpb25hbCcgKyAoJGx2bCkgKyAnKSB7ICc7XG4gICAgfVxuICAgIGlmICgkcmVtb3ZlQWRkaXRpb25hbCA9PSAnYWxsJykge1xuICAgICAgb3V0ICs9ICcgZGVsZXRlICcgKyAoJGRhdGEpICsgJ1snICsgKCRrZXkpICsgJ107ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciAkY3VycmVudEVycm9yUGF0aCA9IGl0LmVycm9yUGF0aDtcbiAgICAgIHZhciAkYWRkaXRpb25hbFByb3BlcnR5ID0gJ1xcJyArICcgKyAka2V5ICsgJyArIFxcJyc7XG4gICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgIGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAka2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICB9XG4gICAgICBpZiAoJG5vQWRkaXRpb25hbCkge1xuICAgICAgICBpZiAoJHJlbW92ZUFkZGl0aW9uYWwpIHtcbiAgICAgICAgICBvdXQgKz0gJyBkZWxldGUgJyArICgkZGF0YSkgKyAnWycgKyAoJGtleSkgKyAnXTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyAnICsgKCRuZXh0VmFsaWQpICsgJyA9IGZhbHNlOyAnO1xuICAgICAgICAgIHZhciAkY3VyckVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aDtcbiAgICAgICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnL2FkZGl0aW9uYWxQcm9wZXJ0aWVzJztcbiAgICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgnYWRkaXRpb25hbFByb3BlcnRpZXMnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IGFkZGl0aW9uYWxQcm9wZXJ0eTogXFwnJyArICgkYWRkaXRpb25hbFByb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJztcbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnaXMgYW4gaW52YWxpZCBhZGRpdGlvbmFsIHByb3BlcnR5JztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJ3Nob3VsZCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiBmYWxzZSAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkZXJyU2NoZW1hUGF0aCA9ICRjdXJyRXJyU2NoZW1hUGF0aDtcbiAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9ICcgYnJlYWs7ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCRhZGRpdGlvbmFsSXNTY2hlbWEpIHtcbiAgICAgICAgaWYgKCRyZW1vdmVBZGRpdGlvbmFsID09ICdmYWlsaW5nJykge1xuICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRlcnJzKSArICcgPSBlcnJvcnM7ICAnO1xuICAgICAgICAgIHZhciAkd2FzQ29tcG9zaXRlID0gaXQuY29tcG9zaXRlUnVsZTtcbiAgICAgICAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSB0cnVlO1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkYVByb3BlcnRpZXM7XG4gICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy5hZGRpdGlvbmFsUHJvcGVydGllcyc7XG4gICAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy9hZGRpdGlvbmFsUHJvcGVydGllcyc7XG4gICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSA/IGl0LmVycm9yUGF0aCA6IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAka2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGtleSArICddJztcbiAgICAgICAgICAkaXQuZGF0YVBhdGhBcnJbJGRhdGFOeHRdID0gJGtleTtcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIHsgZXJyb3JzID0gJyArICgkZXJycykgKyAnOyBpZiAodmFsaWRhdGUuZXJyb3JzICE9PSBudWxsKSB7IGlmIChlcnJvcnMpIHZhbGlkYXRlLmVycm9ycy5sZW5ndGggPSBlcnJvcnM7IGVsc2UgdmFsaWRhdGUuZXJyb3JzID0gbnVsbDsgfSBkZWxldGUgJyArICgkZGF0YSkgKyAnWycgKyAoJGtleSkgKyAnXTsgfSAgJztcbiAgICAgICAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRpdC5zY2hlbWEgPSAkYVByb3BlcnRpZXM7XG4gICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy5hZGRpdGlvbmFsUHJvcGVydGllcyc7XG4gICAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy9hZGRpdGlvbmFsUHJvcGVydGllcyc7XG4gICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSA/IGl0LmVycm9yUGF0aCA6IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAka2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGtleSArICddJztcbiAgICAgICAgICAkaXQuZGF0YVBhdGhBcnJbJGRhdGFOeHRdID0gJGtleTtcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoIScgKyAoJG5leHRWYWxpZCkgKyAnKSBicmVhazsgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGl0LmVycm9yUGF0aCA9ICRjdXJyZW50RXJyb3JQYXRoO1xuICAgIH1cbiAgICBpZiAoJHNvbWVQcm9wZXJ0aWVzKSB7XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIGlmICgnICsgKCRuZXh0VmFsaWQpICsgJykgeyAnO1xuICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgIH1cbiAgfVxuICB2YXIgJHVzZURlZmF1bHRzID0gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZTtcbiAgaWYgKCRzY2hlbWFLZXlzLmxlbmd0aCkge1xuICAgIHZhciBhcnIzID0gJHNjaGVtYUtleXM7XG4gICAgaWYgKGFycjMpIHtcbiAgICAgIHZhciAkcHJvcGVydHlLZXksIGkzID0gLTEsXG4gICAgICAgIGwzID0gYXJyMy5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkzIDwgbDMpIHtcbiAgICAgICAgJHByb3BlcnR5S2V5ID0gYXJyM1tpMyArPSAxXTtcbiAgICAgICAgdmFyICRzY2ggPSAkc2NoZW1hWyRwcm9wZXJ0eUtleV07XG4gICAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eUtleSksXG4gICAgICAgICAgICAkcGFzc0RhdGEgPSAkZGF0YSArICRwcm9wLFxuICAgICAgICAgICAgJGhhc0RlZmF1bHQgPSAkdXNlRGVmYXVsdHMgJiYgJHNjaC5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArICRwcm9wO1xuICAgICAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGggKyAnLycgKyBpdC51dGlsLmVzY2FwZUZyYWdtZW50KCRwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aChpdC5lcnJvclBhdGgsICRwcm9wZXJ0eUtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICAgICRjb2RlID0gaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSk7XG4gICAgICAgICAgICB2YXIgJHVzZURhdGEgPSAkcGFzc0RhdGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciAkdXNlRGF0YSA9ICRuZXh0RGF0YTtcbiAgICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRoYXNEZWZhdWx0KSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAnICsgKCRjb2RlKSArICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCRyZXF1aXJlZEhhc2ggJiYgJHJlcXVpcmVkSGFzaFskcHJvcGVydHlLZXldKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIGlmICggJyArICgkdXNlRGF0YSkgKyAnID09PSB1bmRlZmluZWQgJztcbiAgICAgICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgfHwgISBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJyArICgkZGF0YSkgKyAnLCBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkpICsgJ1xcJykgJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJykgeyAnICsgKCRuZXh0VmFsaWQpICsgJyA9IGZhbHNlOyAnO1xuICAgICAgICAgICAgICB2YXIgJGN1cnJlbnRFcnJvclBhdGggPSBpdC5lcnJvclBhdGgsXG4gICAgICAgICAgICAgICAgJGN1cnJFcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGgsXG4gICAgICAgICAgICAgICAgJG1pc3NpbmdQcm9wZXJ0eSA9IGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGgoJGN1cnJlbnRFcnJvclBhdGgsICRwcm9wZXJ0eUtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvcmVxdWlyZWQnO1xuICAgICAgICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICAgICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgICAgICAgICAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ3JlcXVpcmVkJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6IFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFwnIH0gJztcbiAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJztcbiAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICdpcyBhIHJlcXVpcmVkIHByb3BlcnR5JztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnc2hvdWxkIGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgXFxcXFxcJycgKyAoJG1pc3NpbmdQcm9wZXJ0eSkgKyAnXFxcXFxcJyc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgICAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRlcnJTY2hlbWFQYXRoID0gJGN1cnJFcnJTY2hlbWFQYXRoO1xuICAgICAgICAgICAgICBpdC5lcnJvclBhdGggPSAkY3VycmVudEVycm9yUGF0aDtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgfSBlbHNlIHsgJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCAnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgfHwgISBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJyArICgkZGF0YSkgKyAnLCBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkpICsgJ1xcJykgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcpIHsgJyArICgkbmV4dFZhbGlkKSArICcgPSB0cnVlOyB9IGVsc2UgeyAnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCR1c2VEYXRhKSArICcgIT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJiYgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJyArICgkZGF0YSkgKyAnLCBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkpICsgJ1xcJykgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgKSB7ICc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoJGNvZGUpICsgJyB9ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICc7XG4gICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gJ30nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgkcFByb3BlcnR5S2V5cy5sZW5ndGgpIHtcbiAgICB2YXIgYXJyNCA9ICRwUHJvcGVydHlLZXlzO1xuICAgIGlmIChhcnI0KSB7XG4gICAgICB2YXIgJHBQcm9wZXJ0eSwgaTQgPSAtMSxcbiAgICAgICAgbDQgPSBhcnI0Lmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaTQgPCBsNCkge1xuICAgICAgICAkcFByb3BlcnR5ID0gYXJyNFtpNCArPSAxXTtcbiAgICAgICAgdmFyICRzY2ggPSAkcFByb3BlcnRpZXNbJHBQcm9wZXJ0eV07XG4gICAgICAgIGlmIChpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyAnLnBhdHRlcm5Qcm9wZXJ0aWVzJyArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHBQcm9wZXJ0eSk7XG4gICAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy9wYXR0ZXJuUHJvcGVydGllcy8nICsgaXQudXRpbC5lc2NhcGVGcmFnbWVudCgkcFByb3BlcnR5KTtcbiAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcgPSAnICsgKCRkYXRhUHJvcGVydGllcykgKyAnIHx8IE9iamVjdC5rZXlzKCcgKyAoJGRhdGEpICsgJyk7IGZvciAodmFyICcgKyAoJGlkeCkgKyAnPTA7ICcgKyAoJGlkeCkgKyAnPCcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcubGVuZ3RoOyAnICsgKCRpZHgpICsgJysrKSB7IHZhciAnICsgKCRrZXkpICsgJyA9ICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICdbJyArICgkaWR4KSArICddOyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBmb3IgKHZhciAnICsgKCRrZXkpICsgJyBpbiAnICsgKCRkYXRhKSArICcpIHsgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoaXQudXNlUGF0dGVybigkcFByb3BlcnR5KSkgKyAnLnRlc3QoJyArICgka2V5KSArICcpKSB7ICc7XG4gICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAka2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGtleSArICddJztcbiAgICAgICAgICAkaXQuZGF0YVBhdGhBcnJbJGRhdGFOeHRdID0gJGtleTtcbiAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSkgKyAnICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhciAnICsgKCRuZXh0RGF0YSkgKyAnID0gJyArICgkcGFzc0RhdGEpICsgJzsgJyArICgkY29kZSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoIScgKyAoJG5leHRWYWxpZCkgKyAnKSBicmVhazsgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBlbHNlICcgKyAoJG5leHRWYWxpZCkgKyAnID0gdHJ1ZTsgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfSAgJztcbiAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJG5leHRWYWxpZCkgKyAnKSB7ICc7XG4gICAgICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSAnfSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgb3V0ICs9ICcgJyArICgkY2xvc2luZ0JyYWNlcykgKyAnIGlmICgnICsgKCRlcnJzKSArICcgPT0gZXJyb3JzKSB7JztcbiAgfVxuICBvdXQgPSBpdC51dGlsLmNsZWFuVXBDb2RlKG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3Byb3BlcnR5TmFtZXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICRlcnJzID0gJ2VycnNfXycgKyAkbHZsO1xuICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgdmFyICRjbG9zaW5nQnJhY2VzID0gJyc7XG4gICRpdC5sZXZlbCsrO1xuICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gIG91dCArPSAndmFyICcgKyAoJGVycnMpICsgJyA9IGVycm9yczsnO1xuICBpZiAoaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoZW1hLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgJGl0LnNjaGVtYSA9ICRzY2hlbWE7XG4gICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoO1xuICAgIHZhciAka2V5ID0gJ2tleScgKyAkbHZsLFxuICAgICAgJGlkeCA9ICdpZHgnICsgJGx2bCxcbiAgICAgICRpID0gJ2knICsgJGx2bCxcbiAgICAgICRpbnZhbGlkTmFtZSA9ICdcXCcgKyAnICsgJGtleSArICcgKyBcXCcnLFxuICAgICAgJGRhdGFOeHQgPSAkaXQuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMSxcbiAgICAgICRuZXh0RGF0YSA9ICdkYXRhJyArICRkYXRhTnh0LFxuICAgICAgJGRhdGFQcm9wZXJ0aWVzID0gJ2RhdGFQcm9wZXJ0aWVzJyArICRsdmwsXG4gICAgICAkb3duUHJvcGVydGllcyA9IGl0Lm9wdHMub3duUHJvcGVydGllcyxcbiAgICAgICRjdXJyZW50QmFzZUlkID0gaXQuYmFzZUlkO1xuICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcgPSB1bmRlZmluZWQ7ICc7XG4gICAgfVxuICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgb3V0ICs9ICcgJyArICgkZGF0YVByb3BlcnRpZXMpICsgJyA9ICcgKyAoJGRhdGFQcm9wZXJ0aWVzKSArICcgfHwgT2JqZWN0LmtleXMoJyArICgkZGF0YSkgKyAnKTsgZm9yICh2YXIgJyArICgkaWR4KSArICc9MDsgJyArICgkaWR4KSArICc8JyArICgkZGF0YVByb3BlcnRpZXMpICsgJy5sZW5ndGg7ICcgKyAoJGlkeCkgKyAnKyspIHsgdmFyICcgKyAoJGtleSkgKyAnID0gJyArICgkZGF0YVByb3BlcnRpZXMpICsgJ1snICsgKCRpZHgpICsgJ107ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIGZvciAodmFyICcgKyAoJGtleSkgKyAnIGluICcgKyAoJGRhdGEpICsgJykgeyAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB2YXIgc3RhcnRFcnJzJyArICgkbHZsKSArICcgPSBlcnJvcnM7ICc7XG4gICAgdmFyICRwYXNzRGF0YSA9ICRrZXk7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgIG91dCArPSAnICcgKyAoaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkpICsgJyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YXIgJyArICgkbmV4dERhdGEpICsgJyA9ICcgKyAoJHBhc3NEYXRhKSArICc7ICcgKyAoJGNvZGUpICsgJyAnO1xuICAgIH1cbiAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgIG91dCArPSAnIGlmICghJyArICgkbmV4dFZhbGlkKSArICcpIHsgZm9yICh2YXIgJyArICgkaSkgKyAnPXN0YXJ0RXJycycgKyAoJGx2bCkgKyAnOyAnICsgKCRpKSArICc8ZXJyb3JzOyAnICsgKCRpKSArICcrKykgeyB2RXJyb3JzWycgKyAoJGkpICsgJ10ucHJvcGVydHlOYW1lID0gJyArICgka2V5KSArICc7IH0gICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gJyB7IGtleXdvcmQ6IFxcJycgKyAoJ3Byb3BlcnR5TmFtZXMnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHByb3BlcnR5TmFtZTogXFwnJyArICgkaW52YWxpZE5hbWUpICsgJ1xcJyB9ICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdwcm9wZXJ0eSBuYW1lIFxcXFxcXCcnICsgKCRpbnZhbGlkTmFtZSkgKyAnXFxcXFxcJyBpcyBpbnZhbGlkXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgfVxuICAgIG91dCArPSAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IodkVycm9ycyk7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBicmVhazsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgfSB9JztcbiAgfVxuICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMpICsgJyBpZiAoJyArICgkZXJycykgKyAnID09IGVycm9ycykgeyc7XG4gIH1cbiAgb3V0ID0gaXQudXRpbC5jbGVhblVwQ29kZShvdXQpO1xuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9yZWYoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyAnLycgKyAka2V5d29yZDtcbiAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gIHZhciAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gIHZhciAkdmFsaWQgPSAndmFsaWQnICsgJGx2bDtcbiAgdmFyICRhc3luYywgJHJlZkNvZGU7XG4gIGlmICgkc2NoZW1hID09ICcjJyB8fCAkc2NoZW1hID09ICcjLycpIHtcbiAgICBpZiAoaXQuaXNSb290KSB7XG4gICAgICAkYXN5bmMgPSBpdC5hc3luYztcbiAgICAgICRyZWZDb2RlID0gJ3ZhbGlkYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgJGFzeW5jID0gaXQucm9vdC5zY2hlbWEuJGFzeW5jID09PSB0cnVlO1xuICAgICAgJHJlZkNvZGUgPSAncm9vdC5yZWZWYWxbMF0nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgJHJlZlZhbCA9IGl0LnJlc29sdmVSZWYoaXQuYmFzZUlkLCAkc2NoZW1hLCBpdC5pc1Jvb3QpO1xuICAgIGlmICgkcmVmVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciAkbWVzc2FnZSA9IGl0Lk1pc3NpbmdSZWZFcnJvci5tZXNzYWdlKGl0LmJhc2VJZCwgJHNjaGVtYSk7XG4gICAgICBpZiAoaXQub3B0cy5taXNzaW5nUmVmcyA9PSAnZmFpbCcpIHtcbiAgICAgICAgaXQubG9nZ2VyLmVycm9yKCRtZXNzYWdlKTtcbiAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCckcmVmJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyByZWY6IFxcJycgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyB9ICc7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIG1lc3NhZ2U6IFxcJ2NhblxcXFxcXCd0IHJlc29sdmUgcmVmZXJlbmNlICcgKyAoaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSkpICsgJ1xcJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoZmFsc2UpIHsgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpdC5vcHRzLm1pc3NpbmdSZWZzID09ICdpZ25vcmUnKSB7XG4gICAgICAgIGl0LmxvZ2dlci53YXJuKCRtZXNzYWdlKTtcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgaXQuTWlzc2luZ1JlZkVycm9yKGl0LmJhc2VJZCwgJHNjaGVtYSwgJG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJHJlZlZhbC5pbmxpbmUpIHtcbiAgICAgIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICAgICAgJGl0LmxldmVsKys7XG4gICAgICB2YXIgJG5leHRWYWxpZCA9ICd2YWxpZCcgKyAkaXQubGV2ZWw7XG4gICAgICAkaXQuc2NoZW1hID0gJHJlZlZhbC5zY2hlbWE7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9ICcnO1xuICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkc2NoZW1hO1xuICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KS5yZXBsYWNlKC92YWxpZGF0ZVxcLnNjaGVtYS9nLCAkcmVmVmFsLmNvZGUpO1xuICAgICAgb3V0ICs9ICcgJyArICgkY29kZSkgKyAnICc7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkbmV4dFZhbGlkKSArICcpIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgJGFzeW5jID0gJHJlZlZhbC4kYXN5bmMgPT09IHRydWUgfHwgKGl0LmFzeW5jICYmICRyZWZWYWwuJGFzeW5jICE9PSBmYWxzZSk7XG4gICAgICAkcmVmQ29kZSA9ICRyZWZWYWwuY29kZTtcbiAgICB9XG4gIH1cbiAgaWYgKCRyZWZDb2RlKSB7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9ICcnO1xuICAgIGlmIChpdC5vcHRzLnBhc3NDb250ZXh0KSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRyZWZDb2RlKSArICcuY2FsbCh0aGlzLCAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyAnICsgKCRyZWZDb2RlKSArICcoICc7XG4gICAgfVxuICAgIG91dCArPSAnICcgKyAoJGRhdGEpICsgJywgKGRhdGFQYXRoIHx8IFxcJ1xcJyknO1xuICAgIGlmIChpdC5lcnJvclBhdGggIT0gJ1wiXCInKSB7XG4gICAgICBvdXQgKz0gJyArICcgKyAoaXQuZXJyb3JQYXRoKTtcbiAgICB9XG4gICAgdmFyICRwYXJlbnREYXRhID0gJGRhdGFMdmwgPyAnZGF0YScgKyAoKCRkYXRhTHZsIC0gMSkgfHwgJycpIDogJ3BhcmVudERhdGEnLFxuICAgICAgJHBhcmVudERhdGFQcm9wZXJ0eSA9ICRkYXRhTHZsID8gaXQuZGF0YVBhdGhBcnJbJGRhdGFMdmxdIDogJ3BhcmVudERhdGFQcm9wZXJ0eSc7XG4gICAgb3V0ICs9ICcgLCAnICsgKCRwYXJlbnREYXRhKSArICcgLCAnICsgKCRwYXJlbnREYXRhUHJvcGVydHkpICsgJywgcm9vdERhdGEpICAnO1xuICAgIHZhciBfX2NhbGxWYWxpZGF0ZSA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICgkYXN5bmMpIHtcbiAgICAgIGlmICghaXQuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWEnKTtcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgdHJ5IHsgYXdhaXQgJyArIChfX2NhbGxWYWxpZGF0ZSkgKyAnOyAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkdmFsaWQpICsgJyA9IHRydWU7ICc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gJyB9IGNhdGNoIChlKSB7IGlmICghKGUgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpKSB0aHJvdyBlOyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IGUuZXJyb3JzOyBlbHNlIHZFcnJvcnMgPSB2RXJyb3JzLmNvbmNhdChlLmVycm9ycyk7IGVycm9ycyA9IHZFcnJvcnMubGVuZ3RoOyAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJHZhbGlkKSArICcpIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICcgaWYgKCEnICsgKF9fY2FsbFZhbGlkYXRlKSArICcpIHsgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSAnICsgKCRyZWZDb2RlKSArICcuZXJyb3JzOyBlbHNlIHZFcnJvcnMgPSB2RXJyb3JzLmNvbmNhdCgnICsgKCRyZWZDb2RlKSArICcuZXJyb3JzKTsgZXJyb3JzID0gdkVycm9ycy5sZW5ndGg7IH0gJztcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSAnIGVsc2UgeyAnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9yZXF1aXJlZChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyAnO1xuICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICB2YXIgJGRhdGEgPSAnZGF0YScgKyAoJGRhdGFMdmwgfHwgJycpO1xuICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsXG4gICAgJHNjaGVtYVZhbHVlO1xuICBpZiAoJGlzRGF0YSkge1xuICAgIG91dCArPSAnIHZhciBzY2hlbWEnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikpICsgJzsgJztcbiAgICAkc2NoZW1hVmFsdWUgPSAnc2NoZW1hJyArICRsdmw7XG4gIH0gZWxzZSB7XG4gICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgfVxuICB2YXIgJHZTY2hlbWEgPSAnc2NoZW1hJyArICRsdmw7XG4gIGlmICghJGlzRGF0YSkge1xuICAgIGlmICgkc2NoZW1hLmxlbmd0aCA8IGl0Lm9wdHMubG9vcFJlcXVpcmVkICYmIGl0LnNjaGVtYS5wcm9wZXJ0aWVzICYmIE9iamVjdC5rZXlzKGl0LnNjaGVtYS5wcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgIHZhciAkcmVxdWlyZWQgPSBbXTtcbiAgICAgIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgIHZhciAkcHJvcGVydHksIGkxID0gLTEsXG4gICAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpMSA8IGwxKSB7XG4gICAgICAgICAgJHByb3BlcnR5ID0gYXJyMVtpMSArPSAxXTtcbiAgICAgICAgICB2YXIgJHByb3BlcnR5U2NoID0gaXQuc2NoZW1hLnByb3BlcnRpZXNbJHByb3BlcnR5XTtcbiAgICAgICAgICBpZiAoISgkcHJvcGVydHlTY2ggJiYgaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkcHJvcGVydHlTY2gsIGl0LlJVTEVTLmFsbCkpKSB7XG4gICAgICAgICAgICAkcmVxdWlyZWRbJHJlcXVpcmVkLmxlbmd0aF0gPSAkcHJvcGVydHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciAkcmVxdWlyZWQgPSAkc2NoZW1hO1xuICAgIH1cbiAgfVxuICBpZiAoJGlzRGF0YSB8fCAkcmVxdWlyZWQubGVuZ3RoKSB7XG4gICAgdmFyICRjdXJyZW50RXJyb3JQYXRoID0gaXQuZXJyb3JQYXRoLFxuICAgICAgJGxvb3BSZXF1aXJlZCA9ICRpc0RhdGEgfHwgJHJlcXVpcmVkLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BSZXF1aXJlZCxcbiAgICAgICRvd25Qcm9wZXJ0aWVzID0gaXQub3B0cy5vd25Qcm9wZXJ0aWVzO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyB2YXIgbWlzc2luZycgKyAoJGx2bCkgKyAnOyAnO1xuICAgICAgaWYgKCRsb29wUmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKCEkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJHZTY2hlbWEpICsgJyA9IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJzsgJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgJGkgPSAnaScgKyAkbHZsLFxuICAgICAgICAgICRwcm9wZXJ0eVBhdGggPSAnc2NoZW1hJyArICRsdmwgKyAnWycgKyAkaSArICddJyxcbiAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gJ1xcJyArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFxcJyc7XG4gICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyAnO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSAnIGlmIChzY2hlbWEnICsgKCRsdmwpICsgJyA9PT0gdW5kZWZpbmVkKSAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hJyArICgkbHZsKSArICcpKSAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7IGVsc2Ugeyc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgZm9yICh2YXIgJyArICgkaSkgKyAnID0gMDsgJyArICgkaSkgKyAnIDwgJyArICgkdlNjaGVtYSkgKyAnLmxlbmd0aDsgJyArICgkaSkgKyAnKyspIHsgJyArICgkdmFsaWQpICsgJyA9ICcgKyAoJGRhdGEpICsgJ1snICsgKCR2U2NoZW1hKSArICdbJyArICgkaSkgKyAnXV0gIT09IHVuZGVmaW5lZCAnO1xuICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICBvdXQgKz0gJyAmJiAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsICcgKyAoJHZTY2hlbWEpICsgJ1snICsgKCRpKSArICddKSAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnOyBpZiAoIScgKyAoJHZhbGlkKSArICcpIGJyZWFrOyB9ICc7XG4gICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9ICcgIH0gICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgIGlmICghJyArICgkdmFsaWQpICsgJykgeyAgICc7XG4gICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCcnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXFxcXFwnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSBlbHNlIHsgJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIGlmICggJztcbiAgICAgICAgdmFyIGFycjIgPSAkcmVxdWlyZWQ7XG4gICAgICAgIGlmIChhcnIyKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgJGkgPSAtMSxcbiAgICAgICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlICgkaSA8IGwyKSB7XG4gICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIyWyRpICs9IDFdO1xuICAgICAgICAgICAgaWYgKCRpKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eUtleSksXG4gICAgICAgICAgICAgICR1c2VEYXRhID0gJGRhdGEgKyAkcHJvcDtcbiAgICAgICAgICAgIG91dCArPSAnICggKCAnICsgKCR1c2VEYXRhKSArICcgPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHx8ICEgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCcgKyAoJGRhdGEpICsgJywgXFwnJyArIChpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpKSArICdcXCcpICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJykgJiYgKG1pc3NpbmcnICsgKCRsdmwpICsgJyA9ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZyhpdC5vcHRzLmpzb25Qb2ludGVycyA/ICRwcm9wZXJ0eUtleSA6ICRwcm9wKSkgKyAnKSApICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnKSB7ICAnO1xuICAgICAgICB2YXIgJHByb3BlcnR5UGF0aCA9ICdtaXNzaW5nJyArICRsdmwsXG4gICAgICAgICAgJG1pc3NpbmdQcm9wZXJ0eSA9ICdcXCcgKyAnICsgJHByb3BlcnR5UGF0aCArICcgKyBcXCcnO1xuICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQub3B0cy5qc29uUG9pbnRlcnMgPyBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCB0cnVlKSA6ICRjdXJyZW50RXJyb3JQYXRoICsgJyArICcgKyAkcHJvcGVydHlQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCcnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXFxcXFwnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgfSBlbHNlIHsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRsb29wUmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKCEkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJHZTY2hlbWEpICsgJyA9IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJzsgJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgJGkgPSAnaScgKyAkbHZsLFxuICAgICAgICAgICRwcm9wZXJ0eVBhdGggPSAnc2NoZW1hJyArICRsdmwgKyAnWycgKyAkaSArICddJyxcbiAgICAgICAgICAkbWlzc2luZ1Byb3BlcnR5ID0gJ1xcJyArICcgKyAkcHJvcGVydHlQYXRoICsgJyArIFxcJyc7XG4gICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkdlNjaGVtYSkgKyAnICYmICFBcnJheS5pc0FycmF5KCcgKyAoJHZTY2hlbWEpICsgJykpIHsgIHZhciBlcnIgPSAgICc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJztcbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnaXMgYSByZXF1aXJlZCBwcm9wZXJ0eSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXFxcXFwnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyB9IGVsc2UgaWYgKCcgKyAoJHZTY2hlbWEpICsgJyAhPT0gdW5kZWZpbmVkKSB7ICc7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgZm9yICh2YXIgJyArICgkaSkgKyAnID0gMDsgJyArICgkaSkgKyAnIDwgJyArICgkdlNjaGVtYSkgKyAnLmxlbmd0aDsgJyArICgkaSkgKyAnKyspIHsgaWYgKCcgKyAoJGRhdGEpICsgJ1snICsgKCR2U2NoZW1hKSArICdbJyArICgkaSkgKyAnXV0gPT09IHVuZGVmaW5lZCAnO1xuICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICBvdXQgKz0gJyB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgnICsgKCRkYXRhKSArICcsICcgKyAoJHZTY2hlbWEpICsgJ1snICsgKCRpKSArICddKSAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnKSB7ICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgncmVxdWlyZWQnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXCcgfSAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCcnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcXFwnJyArICgkbWlzc2luZ1Byb3BlcnR5KSArICdcXFxcXFwnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnXFwnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKCRzY2hlbWFQYXRoKSArICcgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoaXQuc2NoZW1hUGF0aCkgKyAnICwgZGF0YTogJyArICgkZGF0YSkgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB7fSAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IH0gfSAnO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSAnICB9ICAnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXJyMyA9ICRyZXF1aXJlZDtcbiAgICAgICAgaWYgKGFycjMpIHtcbiAgICAgICAgICB2YXIgJHByb3BlcnR5S2V5LCBpMyA9IC0xLFxuICAgICAgICAgICAgbDMgPSBhcnIzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGkzIDwgbDMpIHtcbiAgICAgICAgICAgICRwcm9wZXJ0eUtleSA9IGFycjNbaTMgKz0gMV07XG4gICAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eUtleSksXG4gICAgICAgICAgICAgICRtaXNzaW5nUHJvcGVydHkgPSBpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpLFxuICAgICAgICAgICAgICAkdXNlRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aCgkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5S2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoICcgKyAoJHVzZURhdGEpICsgJyA9PT0gdW5kZWZpbmVkICc7XG4gICAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgfHwgISBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoJyArICgkZGF0YSkgKyAnLCBcXCcnICsgKGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkpICsgJ1xcJykgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSAnKSB7ICB2YXIgZXJyID0gICAnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCdyZXF1aXJlZCcpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiBcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcJyB9ICc7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnJztcbiAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ2lzIGEgcmVxdWlyZWQgcHJvcGVydHknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ3Nob3VsZCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5IFxcXFxcXCcnICsgKCRtaXNzaW5nUHJvcGVydHkpICsgJ1xcXFxcXCcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyB9ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGl0LmVycm9yUGF0aCA9ICRjdXJyZW50RXJyb3JQYXRoO1xuICB9IGVsc2UgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyc7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfdW5pcXVlSXRlbXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgdmFyIG91dCA9ICcgJztcbiAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvJyArICRrZXl3b3JkO1xuICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsO1xuICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLFxuICAgICRzY2hlbWFWYWx1ZTtcbiAgaWYgKCRpc0RhdGEpIHtcbiAgICBvdXQgKz0gJyB2YXIgc2NoZW1hJyArICgkbHZsKSArICcgPSAnICsgKGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpKSArICc7ICc7XG4gICAgJHNjaGVtYVZhbHVlID0gJ3NjaGVtYScgKyAkbHZsO1xuICB9IGVsc2Uge1xuICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gIH1cbiAgaWYgKCgkc2NoZW1hIHx8ICRpc0RhdGEpICYmIGl0Lm9wdHMudW5pcXVlSXRlbXMgIT09IGZhbHNlKSB7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnOyBpZiAoJyArICgkc2NoZW1hVmFsdWUpICsgJyA9PT0gZmFsc2UgfHwgJyArICgkc2NoZW1hVmFsdWUpICsgJyA9PT0gdW5kZWZpbmVkKSAnICsgKCR2YWxpZCkgKyAnID0gdHJ1ZTsgZWxzZSBpZiAodHlwZW9mICcgKyAoJHNjaGVtYVZhbHVlKSArICcgIT0gXFwnYm9vbGVhblxcJykgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyBlbHNlIHsgJztcbiAgICB9XG4gICAgb3V0ICs9ICcgdmFyIGkgPSAnICsgKCRkYXRhKSArICcubGVuZ3RoICwgJyArICgkdmFsaWQpICsgJyA9IHRydWUgLCBqOyBpZiAoaSA+IDEpIHsgJztcbiAgICB2YXIgJGl0ZW1UeXBlID0gaXQuc2NoZW1hLml0ZW1zICYmIGl0LnNjaGVtYS5pdGVtcy50eXBlLFxuICAgICAgJHR5cGVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSgkaXRlbVR5cGUpO1xuICAgIGlmICghJGl0ZW1UeXBlIHx8ICRpdGVtVHlwZSA9PSAnb2JqZWN0JyB8fCAkaXRlbVR5cGUgPT0gJ2FycmF5JyB8fCAoJHR5cGVJc0FycmF5ICYmICgkaXRlbVR5cGUuaW5kZXhPZignb2JqZWN0JykgPj0gMCB8fCAkaXRlbVR5cGUuaW5kZXhPZignYXJyYXknKSA+PSAwKSkpIHtcbiAgICAgIG91dCArPSAnIG91dGVyOiBmb3IgKDtpLS07KSB7IGZvciAoaiA9IGk7IGotLTspIHsgaWYgKGVxdWFsKCcgKyAoJGRhdGEpICsgJ1tpXSwgJyArICgkZGF0YSkgKyAnW2pdKSkgeyAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7IGJyZWFrIG91dGVyOyB9IH0gfSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YXIgaXRlbUluZGljZXMgPSB7fSwgaXRlbTsgZm9yICg7aS0tOykgeyB2YXIgaXRlbSA9ICcgKyAoJGRhdGEpICsgJ1tpXTsgJztcbiAgICAgIHZhciAkbWV0aG9kID0gJ2NoZWNrRGF0YVR5cGUnICsgKCR0eXBlSXNBcnJheSA/ICdzJyA6ICcnKTtcbiAgICAgIG91dCArPSAnIGlmICgnICsgKGl0LnV0aWxbJG1ldGhvZF0oJGl0ZW1UeXBlLCAnaXRlbScsIHRydWUpKSArICcpIGNvbnRpbnVlOyAnO1xuICAgICAgaWYgKCR0eXBlSXNBcnJheSkge1xuICAgICAgICBvdXQgKz0gJyBpZiAodHlwZW9mIGl0ZW0gPT0gXFwnc3RyaW5nXFwnKSBpdGVtID0gXFwnXCJcXCcgKyBpdGVtOyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgaWYgKHR5cGVvZiBpdGVtSW5kaWNlc1tpdGVtXSA9PSBcXCdudW1iZXJcXCcpIHsgJyArICgkdmFsaWQpICsgJyA9IGZhbHNlOyBqID0gaXRlbUluZGljZXNbaXRlbV07IGJyZWFrOyB9IGl0ZW1JbmRpY2VzW2l0ZW1dID0gaTsgfSAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9ICc7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSAnICB9ICAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyBpZiAoIScgKyAoJHZhbGlkKSArICcpIHsgICAnO1xuICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICBvdXQgPSAnJzsgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCd1bmlxdWVJdGVtcycpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHsgaTogaSwgajogaiB9ICc7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgTk9UIGhhdmUgZHVwbGljYXRlIGl0ZW1zIChpdGVtcyAjIyBcXCcgKyBqICsgXFwnIGFuZCBcXCcgKyBpICsgXFwnIGFyZSBpZGVudGljYWwpXFwnICc7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSAnICwgc2NoZW1hOiAgJztcbiAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICBvdXQgKz0gJ3ZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnJyArICgkc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB7fSAnO1xuICAgIH1cbiAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBbJyArIChfX2VycikgKyAnXTsgcmV0dXJuIGZhbHNlOyAnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gJyB2YXIgZXJyID0gJyArIChfX2VycikgKyAnOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7ICc7XG4gICAgfVxuICAgIG91dCArPSAnIH0gJztcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9ICcgZWxzZSB7ICc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gJyBpZiAodHJ1ZSkgeyAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV92YWxpZGF0ZShpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICB2YXIgb3V0ID0gJyc7XG4gIHZhciAkYXN5bmMgPSBpdC5zY2hlbWEuJGFzeW5jID09PSB0cnVlLFxuICAgICRyZWZLZXl3b3JkcyA9IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXNFeGNlcHQoaXQuc2NoZW1hLCBpdC5SVUxFUy5hbGwsICckcmVmJyksXG4gICAgJGlkID0gaXQuc2VsZi5fZ2V0SWQoaXQuc2NoZW1hKTtcbiAgaWYgKGl0LmlzVG9wKSB7XG4gICAgb3V0ICs9ICcgdmFyIHZhbGlkYXRlID0gJztcbiAgICBpZiAoJGFzeW5jKSB7XG4gICAgICBpdC5hc3luYyA9IHRydWU7XG4gICAgICBvdXQgKz0gJ2FzeW5jICc7XG4gICAgfVxuICAgIG91dCArPSAnZnVuY3Rpb24oZGF0YSwgZGF0YVBhdGgsIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eSwgcm9vdERhdGEpIHsgXFwndXNlIHN0cmljdFxcJzsgJztcbiAgICBpZiAoJGlkICYmIChpdC5vcHRzLnNvdXJjZUNvZGUgfHwgaXQub3B0cy5wcm9jZXNzQ29kZSkpIHtcbiAgICAgIG91dCArPSAnICcgKyAoJy9cXCojIHNvdXJjZVVSTD0nICsgJGlkICsgJyAqLycpICsgJyAnO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGl0LnNjaGVtYSA9PSAnYm9vbGVhbicgfHwgISgkcmVmS2V5d29yZHMgfHwgaXQuc2NoZW1hLiRyZWYpKSB7XG4gICAgdmFyICRrZXl3b3JkID0gJ2ZhbHNlIHNjaGVtYSc7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gICAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy8nICsgJGtleXdvcmQ7XG4gICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgdmFyICRlcnJvcktleXdvcmQ7XG4gICAgdmFyICRkYXRhID0gJ2RhdGEnICsgKCRkYXRhTHZsIHx8ICcnKTtcbiAgICB2YXIgJHZhbGlkID0gJ3ZhbGlkJyArICRsdmw7XG4gICAgaWYgKGl0LnNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChpdC5pc1RvcCkge1xuICAgICAgICAkYnJlYWtPbkVycm9yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCR2YWxpZCkgKyAnID0gZmFsc2U7ICc7XG4gICAgICB9XG4gICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ2ZhbHNlIHNjaGVtYScpICsgJ1xcJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgXFwnXFwnKSArICcgKyAoaXQuZXJyb3JQYXRoKSArICcgLCBzY2hlbWFQYXRoOiAnICsgKGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpKSArICcgLCBwYXJhbXM6IHt9ICc7XG4gICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2VcXCcgJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IGZhbHNlICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICB9XG4gICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgIG91dCArPSAnIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoWycgKyAoX19lcnIpICsgJ10pOyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGl0LmlzVG9wKSB7XG4gICAgICAgIGlmICgkYXN5bmMpIHtcbiAgICAgICAgICBvdXQgKz0gJyByZXR1cm4gZGF0YTsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gJyB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsOyByZXR1cm4gdHJ1ZTsgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9ICcgdmFyICcgKyAoJHZhbGlkKSArICcgPSB0cnVlOyAnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXQuaXNUb3ApIHtcbiAgICAgIG91dCArPSAnIH07IHJldHVybiB2YWxpZGF0ZTsgJztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBpZiAoaXQuaXNUb3ApIHtcbiAgICB2YXIgJHRvcCA9IGl0LmlzVG9wLFxuICAgICAgJGx2bCA9IGl0LmxldmVsID0gMCxcbiAgICAgICRkYXRhTHZsID0gaXQuZGF0YUxldmVsID0gMCxcbiAgICAgICRkYXRhID0gJ2RhdGEnO1xuICAgIGl0LnJvb3RJZCA9IGl0LnJlc29sdmUuZnVsbFBhdGgoaXQuc2VsZi5fZ2V0SWQoaXQucm9vdC5zY2hlbWEpKTtcbiAgICBpdC5iYXNlSWQgPSBpdC5iYXNlSWQgfHwgaXQucm9vdElkO1xuICAgIGRlbGV0ZSBpdC5pc1RvcDtcbiAgICBpdC5kYXRhUGF0aEFyciA9IFt1bmRlZmluZWRdO1xuICAgIG91dCArPSAnIHZhciB2RXJyb3JzID0gbnVsbDsgJztcbiAgICBvdXQgKz0gJyB2YXIgZXJyb3JzID0gMDsgICAgICc7XG4gICAgb3V0ICs9ICcgaWYgKHJvb3REYXRhID09PSB1bmRlZmluZWQpIHJvb3REYXRhID0gZGF0YTsgJztcbiAgfSBlbHNlIHtcbiAgICB2YXIgJGx2bCA9IGl0LmxldmVsLFxuICAgICAgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWwsXG4gICAgICAkZGF0YSA9ICdkYXRhJyArICgkZGF0YUx2bCB8fCAnJyk7XG4gICAgaWYgKCRpZCkgaXQuYmFzZUlkID0gaXQucmVzb2x2ZS51cmwoaXQuYmFzZUlkLCAkaWQpO1xuICAgIGlmICgkYXN5bmMgJiYgIWl0LmFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYScpO1xuICAgIG91dCArPSAnIHZhciBlcnJzXycgKyAoJGx2bCkgKyAnID0gZXJyb3JzOyc7XG4gIH1cbiAgdmFyICR2YWxpZCA9ICd2YWxpZCcgKyAkbHZsLFxuICAgICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnMsXG4gICAgJGNsb3NpbmdCcmFjZXMxID0gJycsXG4gICAgJGNsb3NpbmdCcmFjZXMyID0gJyc7XG4gIHZhciAkZXJyb3JLZXl3b3JkO1xuICB2YXIgJHR5cGVTY2hlbWEgPSBpdC5zY2hlbWEudHlwZSxcbiAgICAkdHlwZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCR0eXBlU2NoZW1hKTtcbiAgaWYgKCR0eXBlU2NoZW1hICYmIGl0Lm9wdHMubnVsbGFibGUgJiYgaXQuc2NoZW1hLm51bGxhYmxlID09PSB0cnVlKSB7XG4gICAgaWYgKCR0eXBlSXNBcnJheSkge1xuICAgICAgaWYgKCR0eXBlU2NoZW1hLmluZGV4T2YoJ251bGwnKSA9PSAtMSkgJHR5cGVTY2hlbWEgPSAkdHlwZVNjaGVtYS5jb25jYXQoJ251bGwnKTtcbiAgICB9IGVsc2UgaWYgKCR0eXBlU2NoZW1hICE9ICdudWxsJykge1xuICAgICAgJHR5cGVTY2hlbWEgPSBbJHR5cGVTY2hlbWEsICdudWxsJ107XG4gICAgICAkdHlwZUlzQXJyYXkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoJHR5cGVJc0FycmF5ICYmICR0eXBlU2NoZW1hLmxlbmd0aCA9PSAxKSB7XG4gICAgJHR5cGVTY2hlbWEgPSAkdHlwZVNjaGVtYVswXTtcbiAgICAkdHlwZUlzQXJyYXkgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXQuc2NoZW1hLiRyZWYgJiYgJHJlZktleXdvcmRzKSB7XG4gICAgaWYgKGl0Lm9wdHMuZXh0ZW5kUmVmcyA9PSAnZmFpbCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignJHJlZjogdmFsaWRhdGlvbiBrZXl3b3JkcyB1c2VkIGluIHNjaGVtYSBhdCBwYXRoIFwiJyArIGl0LmVyclNjaGVtYVBhdGggKyAnXCIgKHNlZSBvcHRpb24gZXh0ZW5kUmVmcyknKTtcbiAgICB9IGVsc2UgaWYgKGl0Lm9wdHMuZXh0ZW5kUmVmcyAhPT0gdHJ1ZSkge1xuICAgICAgJHJlZktleXdvcmRzID0gZmFsc2U7XG4gICAgICBpdC5sb2dnZXIud2FybignJHJlZjoga2V5d29yZHMgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIicgKyBpdC5lcnJTY2hlbWFQYXRoICsgJ1wiJyk7XG4gICAgfVxuICB9XG4gIGlmIChpdC5zY2hlbWEuJGNvbW1lbnQgJiYgaXQub3B0cy4kY29tbWVudCkge1xuICAgIG91dCArPSAnICcgKyAoaXQuUlVMRVMuYWxsLiRjb21tZW50LmNvZGUoaXQsICckY29tbWVudCcpKTtcbiAgfVxuICBpZiAoJHR5cGVTY2hlbWEpIHtcbiAgICBpZiAoaXQub3B0cy5jb2VyY2VUeXBlcykge1xuICAgICAgdmFyICRjb2VyY2VUb1R5cGVzID0gaXQudXRpbC5jb2VyY2VUb1R5cGVzKGl0Lm9wdHMuY29lcmNlVHlwZXMsICR0eXBlU2NoZW1hKTtcbiAgICB9XG4gICAgdmFyICRydWxlc0dyb3VwID0gaXQuUlVMRVMudHlwZXNbJHR5cGVTY2hlbWFdO1xuICAgIGlmICgkY29lcmNlVG9UeXBlcyB8fCAkdHlwZUlzQXJyYXkgfHwgJHJ1bGVzR3JvdXAgPT09IHRydWUgfHwgKCRydWxlc0dyb3VwICYmICEkc2hvdWxkVXNlR3JvdXAoJHJ1bGVzR3JvdXApKSkge1xuICAgICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcudHlwZScsXG4gICAgICAgICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArICcvdHlwZSc7XG4gICAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgJy50eXBlJyxcbiAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy90eXBlJyxcbiAgICAgICAgJG1ldGhvZCA9ICR0eXBlSXNBcnJheSA/ICdjaGVja0RhdGFUeXBlcycgOiAnY2hlY2tEYXRhVHlwZSc7XG4gICAgICBvdXQgKz0gJyBpZiAoJyArIChpdC51dGlsWyRtZXRob2RdKCR0eXBlU2NoZW1hLCAkZGF0YSwgdHJ1ZSkpICsgJykgeyAnO1xuICAgICAgaWYgKCRjb2VyY2VUb1R5cGVzKSB7XG4gICAgICAgIHZhciAkZGF0YVR5cGUgPSAnZGF0YVR5cGUnICsgJGx2bCxcbiAgICAgICAgICAkY29lcmNlZCA9ICdjb2VyY2VkJyArICRsdmw7XG4gICAgICAgIG91dCArPSAnIHZhciAnICsgKCRkYXRhVHlwZSkgKyAnID0gdHlwZW9mICcgKyAoJGRhdGEpICsgJzsgJztcbiAgICAgICAgaWYgKGl0Lm9wdHMuY29lcmNlVHlwZXMgPT0gJ2FycmF5Jykge1xuICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRkYXRhVHlwZSkgKyAnID09IFxcJ29iamVjdFxcJyAmJiBBcnJheS5pc0FycmF5KCcgKyAoJGRhdGEpICsgJykpICcgKyAoJGRhdGFUeXBlKSArICcgPSBcXCdhcnJheVxcJzsgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyB2YXIgJyArICgkY29lcmNlZCkgKyAnID0gdW5kZWZpbmVkOyAnO1xuICAgICAgICB2YXIgJGJyYWNlc0NvZXJjaW9uID0gJyc7XG4gICAgICAgIHZhciBhcnIxID0gJGNvZXJjZVRvVHlwZXM7XG4gICAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgICAgdmFyICR0eXBlLCAkaSA9IC0xLFxuICAgICAgICAgICAgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICAgICAgICR0eXBlID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgICAgIGlmICgkaSkge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkY29lcmNlZCkgKyAnID09PSB1bmRlZmluZWQpIHsgJztcbiAgICAgICAgICAgICAgJGJyYWNlc0NvZXJjaW9uICs9ICd9JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLmNvZXJjZVR5cGVzID09ICdhcnJheScgJiYgJHR5cGUgIT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdhcnJheVxcJyAmJiAnICsgKCRkYXRhKSArICcubGVuZ3RoID09IDEpIHsgJyArICgkY29lcmNlZCkgKyAnID0gJyArICgkZGF0YSkgKyAnID0gJyArICgkZGF0YSkgKyAnWzBdOyAnICsgKCRkYXRhVHlwZSkgKyAnID0gdHlwZW9mICcgKyAoJGRhdGEpICsgJzsgIH0gJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkdHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdudW1iZXJcXCcgfHwgJyArICgkZGF0YVR5cGUpICsgJyA9PSBcXCdib29sZWFuXFwnKSAnICsgKCRjb2VyY2VkKSArICcgPSBcXCdcXCcgKyAnICsgKCRkYXRhKSArICc7IGVsc2UgaWYgKCcgKyAoJGRhdGEpICsgJyA9PT0gbnVsbCkgJyArICgkY29lcmNlZCkgKyAnID0gXFwnXFwnOyAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkdHlwZSA9PSAnbnVtYmVyJyB8fCAkdHlwZSA9PSAnaW50ZWdlcicpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJGRhdGFUeXBlKSArICcgPT0gXFwnYm9vbGVhblxcJyB8fCAnICsgKCRkYXRhKSArICcgPT09IG51bGwgfHwgKCcgKyAoJGRhdGFUeXBlKSArICcgPT0gXFwnc3RyaW5nXFwnICYmICcgKyAoJGRhdGEpICsgJyAmJiAnICsgKCRkYXRhKSArICcgPT0gKycgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICBpZiAoJHR5cGUgPT0gJ2ludGVnZXInKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgJiYgISgnICsgKCRkYXRhKSArICcgJSAxKSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9ICcpKSAnICsgKCRjb2VyY2VkKSArICcgPSArJyArICgkZGF0YSkgKyAnOyAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkdHlwZSA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICcgaWYgKCcgKyAoJGRhdGEpICsgJyA9PT0gXFwnZmFsc2VcXCcgfHwgJyArICgkZGF0YSkgKyAnID09PSAwIHx8ICcgKyAoJGRhdGEpICsgJyA9PT0gbnVsbCkgJyArICgkY29lcmNlZCkgKyAnID0gZmFsc2U7IGVsc2UgaWYgKCcgKyAoJGRhdGEpICsgJyA9PT0gXFwndHJ1ZVxcJyB8fCAnICsgKCRkYXRhKSArICcgPT09IDEpICcgKyAoJGNvZXJjZWQpICsgJyA9IHRydWU7ICc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCR0eXBlID09ICdudWxsJykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArICgkZGF0YSkgKyAnID09PSBcXCdcXCcgfHwgJyArICgkZGF0YSkgKyAnID09PSAwIHx8ICcgKyAoJGRhdGEpICsgJyA9PT0gZmFsc2UpICcgKyAoJGNvZXJjZWQpICsgJyA9IG51bGw7ICc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0Lm9wdHMuY29lcmNlVHlwZXMgPT0gJ2FycmF5JyAmJiAkdHlwZSA9PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgIG91dCArPSAnIGlmICgnICsgKCRkYXRhVHlwZSkgKyAnID09IFxcJ3N0cmluZ1xcJyB8fCAnICsgKCRkYXRhVHlwZSkgKyAnID09IFxcJ251bWJlclxcJyB8fCAnICsgKCRkYXRhVHlwZSkgKyAnID09IFxcJ2Jvb2xlYW5cXCcgfHwgJyArICgkZGF0YSkgKyAnID09IG51bGwpICcgKyAoJGNvZXJjZWQpICsgJyA9IFsnICsgKCRkYXRhKSArICddOyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyAnICsgKCRicmFjZXNDb2VyY2lvbikgKyAnIGlmICgnICsgKCRjb2VyY2VkKSArICcgPT09IHVuZGVmaW5lZCkgeyAgICc7XG4gICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICd0eXBlJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnXFwnIH0gJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICc7XG4gICAgICAgICAgICBpZiAoJHR5cGVJc0FycmF5KSB7XG4gICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyB9IGVsc2UgeyAgJztcbiAgICAgICAgdmFyICRwYXJlbnREYXRhID0gJGRhdGFMdmwgPyAnZGF0YScgKyAoKCRkYXRhTHZsIC0gMSkgfHwgJycpIDogJ3BhcmVudERhdGEnLFxuICAgICAgICAgICRwYXJlbnREYXRhUHJvcGVydHkgPSAkZGF0YUx2bCA/IGl0LmRhdGFQYXRoQXJyWyRkYXRhTHZsXSA6ICdwYXJlbnREYXRhUHJvcGVydHknO1xuICAgICAgICBvdXQgKz0gJyAnICsgKCRkYXRhKSArICcgPSAnICsgKCRjb2VyY2VkKSArICc7ICc7XG4gICAgICAgIGlmICghJGRhdGFMdmwpIHtcbiAgICAgICAgICBvdXQgKz0gJ2lmICgnICsgKCRwYXJlbnREYXRhKSArICcgIT09IHVuZGVmaW5lZCknO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnICcgKyAoJHBhcmVudERhdGEpICsgJ1snICsgKCRwYXJlbnREYXRhUHJvcGVydHkpICsgJ10gPSAnICsgKCRjb2VyY2VkKSArICc7IH0gJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgIG91dCA9ICcnOyAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSAnIHsga2V5d29yZDogXFwnJyArICgkZXJyb3JLZXl3b3JkIHx8ICd0eXBlJykgKyAnXFwnICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCBcXCdcXCcpICsgJyArIChpdC5lcnJvclBhdGgpICsgJyAsIHNjaGVtYVBhdGg6ICcgKyAoaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkpICsgJyAsIHBhcmFtczogeyB0eXBlOiBcXCcnO1xuICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSAnXFwnIH0gJztcbiAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG91dCArPSAnICwgbWVzc2FnZTogXFwnc2hvdWxkIGJlICc7XG4gICAgICAgICAgICBpZiAoJHR5cGVJc0FycmF5KSB7XG4gICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gJycgKyAoJHR5cGVTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9ICdcXCcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYScgKyAoJHNjaGVtYVBhdGgpICsgJyAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArIChpdC5zY2hlbWFQYXRoKSArICcgLCBkYXRhOiAnICsgKCRkYXRhKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHt9ICc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgICAgb3V0ICs9ICcgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbJyArIChfX2VycikgKyAnXSk7ICc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IFsnICsgKF9fZXJyKSArICddOyByZXR1cm4gZmFsc2U7ICc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSAnIHZhciBlcnIgPSAnICsgKF9fZXJyKSArICc7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0ICs9ICcgfSAnO1xuICAgIH1cbiAgfVxuICBpZiAoaXQuc2NoZW1hLiRyZWYgJiYgISRyZWZLZXl3b3Jkcykge1xuICAgIG91dCArPSAnICcgKyAoaXQuUlVMRVMuYWxsLiRyZWYuY29kZShpdCwgJyRyZWYnKSkgKyAnICc7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSAnIH0gaWYgKGVycm9ycyA9PT0gJztcbiAgICAgIGlmICgkdG9wKSB7XG4gICAgICAgIG91dCArPSAnMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gJ2VycnNfJyArICgkbHZsKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSAnKSB7ICc7XG4gICAgICAkY2xvc2luZ0JyYWNlczIgKz0gJ30nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYXJyMiA9IGl0LlJVTEVTO1xuICAgIGlmIChhcnIyKSB7XG4gICAgICB2YXIgJHJ1bGVzR3JvdXAsIGkyID0gLTEsXG4gICAgICAgIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkyIDwgbDIpIHtcbiAgICAgICAgJHJ1bGVzR3JvdXAgPSBhcnIyW2kyICs9IDFdO1xuICAgICAgICBpZiAoJHNob3VsZFVzZUdyb3VwKCRydWxlc0dyb3VwKSkge1xuICAgICAgICAgIGlmICgkcnVsZXNHcm91cC50eXBlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyBpZiAoJyArIChpdC51dGlsLmNoZWNrRGF0YVR5cGUoJHJ1bGVzR3JvdXAudHlwZSwgJGRhdGEpKSArICcpIHsgJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0Lm9wdHMudXNlRGVmYXVsdHMgJiYgIWl0LmNvbXBvc2l0ZVJ1bGUpIHtcbiAgICAgICAgICAgIGlmICgkcnVsZXNHcm91cC50eXBlID09ICdvYmplY3QnICYmIGl0LnNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgJHNjaGVtYUtleXMgPSBPYmplY3Qua2V5cygkc2NoZW1hKTtcbiAgICAgICAgICAgICAgdmFyIGFycjMgPSAkc2NoZW1hS2V5cztcbiAgICAgICAgICAgICAgaWYgKGFycjMpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHByb3BlcnR5S2V5LCBpMyA9IC0xLFxuICAgICAgICAgICAgICAgICAgbDMgPSBhcnIzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkzIDwgbDMpIHtcbiAgICAgICAgICAgICAgICAgICRwcm9wZXJ0eUtleSA9IGFycjNbaTMgKz0gMV07XG4gICAgICAgICAgICAgICAgICB2YXIgJHNjaCA9ICRzY2hlbWFbJHByb3BlcnR5S2V5XTtcbiAgICAgICAgICAgICAgICAgIGlmICgkc2NoLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnICBpZiAoJyArICgkcGFzc0RhdGEpICsgJyA9PT0gdW5kZWZpbmVkICc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnVzZURlZmF1bHRzID09ICdlbXB0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAnICsgKCRwYXNzRGF0YSkgKyAnID09PSBudWxsIHx8ICcgKyAoJHBhc3NEYXRhKSArICcgPT09IFxcJ1xcJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnICkgJyArICgkcGFzc0RhdGEpICsgJyA9ICc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnVzZURlZmF1bHRzID09ICdzaGFyZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51c2VEZWZhdWx0KCRzY2guZGVmYXVsdCkpICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnICcgKyAoSlNPTi5zdHJpbmdpZnkoJHNjaC5kZWZhdWx0KSkgKyAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICc7ICc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRydWxlc0dyb3VwLnR5cGUgPT0gJ2FycmF5JyAmJiBBcnJheS5pc0FycmF5KGl0LnNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgICAgdmFyIGFycjQgPSBpdC5zY2hlbWEuaXRlbXM7XG4gICAgICAgICAgICAgIGlmIChhcnI0KSB7XG4gICAgICAgICAgICAgICAgdmFyICRzY2gsICRpID0gLTEsXG4gICAgICAgICAgICAgICAgICBsNCA9IGFycjQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoJGkgPCBsNCkge1xuICAgICAgICAgICAgICAgICAgJHNjaCA9IGFycjRbJGkgKz0gMV07XG4gICAgICAgICAgICAgICAgICBpZiAoJHNjaC5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgJ1snICsgJGkgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnICBpZiAoJyArICgkcGFzc0RhdGEpICsgJyA9PT0gdW5kZWZpbmVkICc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnVzZURlZmF1bHRzID09ICdlbXB0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJyB8fCAnICsgKCRwYXNzRGF0YSkgKyAnID09PSBudWxsIHx8ICcgKyAoJHBhc3NEYXRhKSArICcgPT09IFxcJ1xcJyAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnICkgJyArICgkcGFzc0RhdGEpICsgJyA9ICc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnVzZURlZmF1bHRzID09ICdzaGFyZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArIChpdC51c2VEZWZhdWx0KCRzY2guZGVmYXVsdCkpICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnICcgKyAoSlNPTi5zdHJpbmdpZnkoJHNjaC5kZWZhdWx0KSkgKyAnICc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICc7ICc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhcnI1ID0gJHJ1bGVzR3JvdXAucnVsZXM7XG4gICAgICAgICAgaWYgKGFycjUpIHtcbiAgICAgICAgICAgIHZhciAkcnVsZSwgaTUgPSAtMSxcbiAgICAgICAgICAgICAgbDUgPSBhcnI1Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoaTUgPCBsNSkge1xuICAgICAgICAgICAgICAkcnVsZSA9IGFycjVbaTUgKz0gMV07XG4gICAgICAgICAgICAgIGlmICgkc2hvdWxkVXNlUnVsZSgkcnVsZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGNvZGUgPSAkcnVsZS5jb2RlKGl0LCAkcnVsZS5rZXl3b3JkLCAkcnVsZXNHcm91cC50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoJGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSAnICcgKyAoJGNvZGUpICsgJyAnO1xuICAgICAgICAgICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgJGNsb3NpbmdCcmFjZXMxICs9ICd9JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnICcgKyAoJGNsb3NpbmdCcmFjZXMxKSArICcgJztcbiAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzMSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJHJ1bGVzR3JvdXAudHlwZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgfSAnO1xuICAgICAgICAgICAgaWYgKCR0eXBlU2NoZW1hICYmICR0eXBlU2NoZW1hID09PSAkcnVsZXNHcm91cC50eXBlICYmICEkY29lcmNlVG9UeXBlcykge1xuICAgICAgICAgICAgICBvdXQgKz0gJyBlbHNlIHsgJztcbiAgICAgICAgICAgICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArICcudHlwZScsXG4gICAgICAgICAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgJy90eXBlJztcbiAgICAgICAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgICAgICAgb3V0ID0gJyc7IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgeyBrZXl3b3JkOiBcXCcnICsgKCRlcnJvcktleXdvcmQgfHwgJ3R5cGUnKSArICdcXCcgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8IFxcJ1xcJykgKyAnICsgKGl0LmVycm9yUGF0aCkgKyAnICwgc2NoZW1hUGF0aDogJyArIChpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSkgKyAnICwgcGFyYW1zOiB7IHR5cGU6IFxcJyc7XG4gICAgICAgICAgICAgICAgaWYgKCR0eXBlSXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdcXCcgfSAnO1xuICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgLCBtZXNzYWdlOiBcXCdzaG91bGQgYmUgJztcbiAgICAgICAgICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcnICsgKCR0eXBlU2NoZW1hLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSAnJyArICgkdHlwZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJ1xcJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hJyArICgkc2NoZW1hUGF0aCkgKyAnICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWEnICsgKGl0LnNjaGVtYVBhdGgpICsgJyAsIGRhdGE6ICcgKyAoJGRhdGEpICsgJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gJyB9ICc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcge30gJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgICAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gJyB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFsnICsgKF9fZXJyKSArICddKTsgJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgdmFsaWRhdGUuZXJyb3JzID0gWycgKyAoX19lcnIpICsgJ107IHJldHVybiBmYWxzZTsgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgdmFyIGVyciA9ICcgKyAoX19lcnIpICsgJzsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyAnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSAnIH0gJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSAnIGlmIChlcnJvcnMgPT09ICc7XG4gICAgICAgICAgICBpZiAoJHRvcCkge1xuICAgICAgICAgICAgICBvdXQgKz0gJzAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICdlcnJzXycgKyAoJGx2bCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJykgeyAnO1xuICAgICAgICAgICAgJGNsb3NpbmdCcmFjZXMyICs9ICd9JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICBvdXQgKz0gJyAnICsgKCRjbG9zaW5nQnJhY2VzMikgKyAnICc7XG4gIH1cbiAgaWYgKCR0b3ApIHtcbiAgICBpZiAoJGFzeW5jKSB7XG4gICAgICBvdXQgKz0gJyBpZiAoZXJyb3JzID09PSAwKSByZXR1cm4gZGF0YTsgICAgICAgICAgICc7XG4gICAgICBvdXQgKz0gJyBlbHNlIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IodkVycm9ycyk7ICc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnIHZhbGlkYXRlLmVycm9ycyA9IHZFcnJvcnM7ICc7XG4gICAgICBvdXQgKz0gJyByZXR1cm4gZXJyb3JzID09PSAwOyAgICAgICAnO1xuICAgIH1cbiAgICBvdXQgKz0gJyB9OyByZXR1cm4gdmFsaWRhdGU7JztcbiAgfSBlbHNlIHtcbiAgICBvdXQgKz0gJyB2YXIgJyArICgkdmFsaWQpICsgJyA9IGVycm9ycyA9PT0gZXJyc18nICsgKCRsdmwpICsgJzsnO1xuICB9XG4gIG91dCA9IGl0LnV0aWwuY2xlYW5VcENvZGUob3V0KTtcbiAgaWYgKCR0b3ApIHtcbiAgICBvdXQgPSBpdC51dGlsLmZpbmFsQ2xlYW5VcENvZGUob3V0LCAkYXN5bmMpO1xuICB9XG5cbiAgZnVuY3Rpb24gJHNob3VsZFVzZUdyb3VwKCRydWxlc0dyb3VwKSB7XG4gICAgdmFyIHJ1bGVzID0gJHJ1bGVzR3JvdXAucnVsZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKylcbiAgICAgIGlmICgkc2hvdWxkVXNlUnVsZShydWxlc1tpXSkpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gJHNob3VsZFVzZVJ1bGUoJHJ1bGUpIHtcbiAgICByZXR1cm4gaXQuc2NoZW1hWyRydWxlLmtleXdvcmRdICE9PSB1bmRlZmluZWQgfHwgKCRydWxlLmltcGxlbWVudHMgJiYgJHJ1bGVJbXBsZW1lbnRzU29tZUtleXdvcmQoJHJ1bGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uICRydWxlSW1wbGVtZW50c1NvbWVLZXl3b3JkKCRydWxlKSB7XG4gICAgdmFyIGltcGwgPSAkcnVsZS5pbXBsZW1lbnRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1wbC5sZW5ndGg7IGkrKylcbiAgICAgIGlmIChpdC5zY2hlbWFbaW1wbFtpXV0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIElERU5USUZJRVIgPSAvXlthLXpfJF1bYS16MC05XyQtXSokL2k7XG52YXIgY3VzdG9tUnVsZUNvZGUgPSByZXF1aXJlKCcuL2RvdGpzL2N1c3RvbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkOiBhZGRLZXl3b3JkLFxuICBnZXQ6IGdldEtleXdvcmQsXG4gIHJlbW92ZTogcmVtb3ZlS2V5d29yZFxufTtcblxuLyoqXG4gKiBEZWZpbmUgY3VzdG9tIGtleXdvcmRcbiAqIEB0aGlzICBBanZcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXl3b3JkIGN1c3RvbSBrZXl3b3JkLCBzaG91bGQgYmUgdW5pcXVlIChpbmNsdWRpbmcgZGlmZmVyZW50IGZyb20gYWxsIHN0YW5kYXJkLCBjdXN0b20gYW5kIG1hY3JvIGtleXdvcmRzKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIGtleXdvcmQgZGVmaW5pdGlvbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGB0eXBlYCAodHlwZShzKSB3aGljaCB0aGUga2V5d29yZCBhcHBsaWVzIHRvKSwgYHZhbGlkYXRlYCBvciBgY29tcGlsZWAuXG4gKiBAcmV0dXJuIHtBanZ9IHRoaXMgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICovXG5mdW5jdGlvbiBhZGRLZXl3b3JkKGtleXdvcmQsIGRlZmluaXRpb24pIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuICAvKiBlc2xpbnQgbm8tc2hhZG93OiAwICovXG4gIHZhciBSVUxFUyA9IHRoaXMuUlVMRVM7XG5cbiAgaWYgKFJVTEVTLmtleXdvcmRzW2tleXdvcmRdKVxuICAgIHRocm93IG5ldyBFcnJvcignS2V5d29yZCAnICsga2V5d29yZCArICcgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG5cbiAgaWYgKCFJREVOVElGSUVSLnRlc3Qoa2V5d29yZCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXl3b3JkICcgKyBrZXl3b3JkICsgJyBpcyBub3QgYSB2YWxpZCBpZGVudGlmaWVyJyk7XG5cbiAgaWYgKGRlZmluaXRpb24pIHtcbiAgICBpZiAoZGVmaW5pdGlvbi5tYWNybyAmJiBkZWZpbml0aW9uLnZhbGlkICE9PSB1bmRlZmluZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widmFsaWRcIiBvcHRpb24gY2Fubm90IGJlIHVzZWQgd2l0aCBtYWNybyBrZXl3b3JkcycpO1xuXG4gICAgdmFyIGRhdGFUeXBlID0gZGVmaW5pdGlvbi50eXBlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFUeXBlKSkge1xuICAgICAgdmFyIGksIGxlbiA9IGRhdGFUeXBlLmxlbmd0aDtcbiAgICAgIGZvciAoaT0wOyBpPGxlbjsgaSsrKSBjaGVja0RhdGFUeXBlKGRhdGFUeXBlW2ldKTtcbiAgICAgIGZvciAoaT0wOyBpPGxlbjsgaSsrKSBfYWRkUnVsZShrZXl3b3JkLCBkYXRhVHlwZVtpXSwgZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhVHlwZSkgY2hlY2tEYXRhVHlwZShkYXRhVHlwZSk7XG4gICAgICBfYWRkUnVsZShrZXl3b3JkLCBkYXRhVHlwZSwgZGVmaW5pdGlvbik7XG4gICAgfVxuXG4gICAgdmFyICRkYXRhID0gZGVmaW5pdGlvbi4kZGF0YSA9PT0gdHJ1ZSAmJiB0aGlzLl9vcHRzLiRkYXRhO1xuICAgIGlmICgkZGF0YSAmJiAhZGVmaW5pdGlvbi52YWxpZGF0ZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignJGRhdGEgc3VwcG9ydDogXCJ2YWxpZGF0ZVwiIGZ1bmN0aW9uIGlzIG5vdCBkZWZpbmVkJyk7XG5cbiAgICB2YXIgbWV0YVNjaGVtYSA9IGRlZmluaXRpb24ubWV0YVNjaGVtYTtcbiAgICBpZiAobWV0YVNjaGVtYSkge1xuICAgICAgaWYgKCRkYXRhKSB7XG4gICAgICAgIG1ldGFTY2hlbWEgPSB7XG4gICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgIG1ldGFTY2hlbWEsXG4gICAgICAgICAgICB7ICckcmVmJzogJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lcG9iZXJlemtpbi9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiMnIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBkZWZpbml0aW9uLnZhbGlkYXRlU2NoZW1hID0gdGhpcy5jb21waWxlKG1ldGFTY2hlbWEsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gUlVMRVMuYWxsW2tleXdvcmRdID0gdHJ1ZTtcblxuXG4gIGZ1bmN0aW9uIF9hZGRSdWxlKGtleXdvcmQsIGRhdGFUeXBlLCBkZWZpbml0aW9uKSB7XG4gICAgdmFyIHJ1bGVHcm91cDtcbiAgICBmb3IgKHZhciBpPTA7IGk8UlVMRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZyA9IFJVTEVTW2ldO1xuICAgICAgaWYgKHJnLnR5cGUgPT0gZGF0YVR5cGUpIHtcbiAgICAgICAgcnVsZUdyb3VwID0gcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcnVsZUdyb3VwKSB7XG4gICAgICBydWxlR3JvdXAgPSB7IHR5cGU6IGRhdGFUeXBlLCBydWxlczogW10gfTtcbiAgICAgIFJVTEVTLnB1c2gocnVsZUdyb3VwKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZSA9IHtcbiAgICAgIGtleXdvcmQ6IGtleXdvcmQsXG4gICAgICBkZWZpbml0aW9uOiBkZWZpbml0aW9uLFxuICAgICAgY3VzdG9tOiB0cnVlLFxuICAgICAgY29kZTogY3VzdG9tUnVsZUNvZGUsXG4gICAgICBpbXBsZW1lbnRzOiBkZWZpbml0aW9uLmltcGxlbWVudHNcbiAgICB9O1xuICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpO1xuICAgIFJVTEVTLmN1c3RvbVtrZXl3b3JkXSA9IHJ1bGU7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGUpIHtcbiAgICBpZiAoIVJVTEVTLnR5cGVzW2RhdGFUeXBlXSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgJyArIGRhdGFUeXBlKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5cbi8qKlxuICogR2V0IGtleXdvcmRcbiAqIEB0aGlzICBBanZcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXl3b3JkIHByZS1kZWZpbmVkIG9yIGN1c3RvbSBrZXl3b3JkLlxuICogQHJldHVybiB7T2JqZWN0fEJvb2xlYW59IGN1c3RvbSBrZXl3b3JkIGRlZmluaXRpb24sIGB0cnVlYCBpZiBpdCBpcyBhIHByZWRlZmluZWQga2V5d29yZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGdldEtleXdvcmQoa2V5d29yZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBydWxlID0gdGhpcy5SVUxFUy5jdXN0b21ba2V5d29yZF07XG4gIHJldHVybiBydWxlID8gcnVsZS5kZWZpbml0aW9uIDogdGhpcy5SVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSB8fCBmYWxzZTtcbn1cblxuXG4vKipcbiAqIFJlbW92ZSBrZXl3b3JkXG4gKiBAdGhpcyAgQWp2XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5d29yZCBwcmUtZGVmaW5lZCBvciBjdXN0b20ga2V5d29yZC5cbiAqIEByZXR1cm4ge0Fqdn0gdGhpcyBmb3IgbWV0aG9kIGNoYWluaW5nXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUtleXdvcmQoa2V5d29yZCkge1xuICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG4gIHZhciBSVUxFUyA9IHRoaXMuUlVMRVM7XG4gIGRlbGV0ZSBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXTtcbiAgZGVsZXRlIFJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgZGVsZXRlIFJVTEVTLmN1c3RvbVtrZXl3b3JkXTtcbiAgZm9yICh2YXIgaT0wOyBpPFJVTEVTLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJ1bGVzID0gUlVMRVNbaV0ucnVsZXM7XG4gICAgZm9yICh2YXIgaj0wOyBqPHJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAocnVsZXNbal0ua2V5d29yZCA9PSBrZXl3b3JkKSB7XG4gICAgICAgIHJ1bGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTEgTWFyayBDYXZhZ2UgPG1jYXZhZ2VAZ21haWwuY29tPiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIG5ld0ludmFsaWRBc24xRXJyb3I6IGZ1bmN0aW9uIChtc2cpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcigpO1xuICAgIGUubmFtZSA9ICdJbnZhbGlkQXNuMUVycm9yJztcbiAgICBlLm1lc3NhZ2UgPSBtc2cgfHwgJyc7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxufTtcbiIsIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbnZhciBSZWFkZXIgPSByZXF1aXJlKCcuL3JlYWRlcicpO1xudmFyIFdyaXRlciA9IHJlcXVpcmUoJy4vd3JpdGVyJyk7XG5cblxuLy8gLS0tIEV4cG9ydHNcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgUmVhZGVyOiBSZWFkZXIsXG5cbiAgV3JpdGVyOiBXcml0ZXJcblxufTtcblxuZm9yICh2YXIgdCBpbiB0eXBlcykge1xuICBpZiAodHlwZXMuaGFzT3duUHJvcGVydHkodCkpXG4gICAgbW9kdWxlLmV4cG9ydHNbdF0gPSB0eXBlc1t0XTtcbn1cbmZvciAodmFyIGUgaW4gZXJyb3JzKSB7XG4gIGlmIChlcnJvcnMuaGFzT3duUHJvcGVydHkoZSkpXG4gICAgbW9kdWxlLmV4cG9ydHNbZV0gPSBlcnJvcnNbZV07XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG5cbnZhciBBU04xID0gcmVxdWlyZSgnLi90eXBlcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cblxuLy8gLS0tIEdsb2JhbHNcblxudmFyIG5ld0ludmFsaWRBc24xRXJyb3IgPSBlcnJvcnMubmV3SW52YWxpZEFzbjFFcnJvcjtcblxuXG5cbi8vIC0tLSBBUElcblxuZnVuY3Rpb24gUmVhZGVyKGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8ICFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSBtdXN0IGJlIGEgbm9kZSBCdWZmZXInKTtcblxuICB0aGlzLl9idWYgPSBkYXRhO1xuICB0aGlzLl9zaXplID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gVGhlc2UgaG9sZCB0aGUgXCJjdXJyZW50XCIgc3RhdGVcbiAgdGhpcy5fbGVuID0gMDtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRlci5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuX2xlbik7IH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5fb2Zmc2V0KTsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkZXIucHJvdG90eXBlLCAncmVtYWluJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLl9zaXplIC0gdGhpcy5fb2Zmc2V0KTsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkZXIucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLl9idWYuc2xpY2UodGhpcy5fb2Zmc2V0KSk7IH1cbn0pO1xuXG5cbi8qKlxuICogUmVhZHMgYSBzaW5nbGUgYnl0ZSBhbmQgYWR2YW5jZXMgb2Zmc2V0OyB5b3UgY2FuIHBhc3MgaW4gYHRydWVgIHRvIG1ha2UgdGhpc1xuICogYSBcInBlZWtcIiBvcGVyYXRpb24gKGkuZS4sIGdldCB0aGUgYnl0ZSwgYnV0IGRvbid0IGFkdmFuY2UgdGhlIG9mZnNldCkuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBwZWVrIHRydWUgbWVhbnMgZG9uJ3QgbW92ZSBvZmZzZXQuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBuZXh0IGJ5dGUsIG51bGwgaWYgbm90IGVub3VnaCBkYXRhLlxuICovXG5SZWFkZXIucHJvdG90eXBlLnJlYWRCeXRlID0gZnVuY3Rpb24gKHBlZWspIHtcbiAgaWYgKHRoaXMuX3NpemUgLSB0aGlzLl9vZmZzZXQgPCAxKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBiID0gdGhpcy5fYnVmW3RoaXMuX29mZnNldF0gJiAweGZmO1xuXG4gIGlmICghcGVlaylcbiAgICB0aGlzLl9vZmZzZXQgKz0gMTtcblxuICByZXR1cm4gYjtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWFkQnl0ZSh0cnVlKTtcbn07XG5cblxuLyoqXG4gKiBSZWFkcyBhIChwb3RlbnRpYWxseSkgdmFyaWFibGUgbGVuZ3RoIG9mZiB0aGUgQkVSIGJ1ZmZlci4gIFRoaXMgY2FsbCBpc1xuICogbm90IHJlYWxseSBtZWFudCB0byBiZSBjYWxsZWQgZGlyZWN0bHksIGFzIGNhbGxlcnMgaGF2ZSB0byBtYW5pcHVsYXRlXG4gKiB0aGUgaW50ZXJuYWwgYnVmZmVyIGFmdGVyd2FyZHMuXG4gKlxuICogQXMgYSByZXN1bHQgb2YgdGhpcyBjYWxsLCB5b3UgY2FuIGNhbGwgYFJlYWRlci5sZW5ndGhgLCB1bnRpbCB0aGVcbiAqIG5leHQgdGhpbmcgY2FsbGVkIHRoYXQgZG9lcyBhIHJlYWRMZW5ndGguXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgYW1vdW50IG9mIG9mZnNldCB0byBhZHZhbmNlIHRoZSBidWZmZXIuXG4gKiBAdGhyb3dzIHtJbnZhbGlkQXNuMUVycm9yfSBvbiBiYWQgQVNOLjFcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5yZWFkTGVuZ3RoID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG4gICAgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5fc2l6ZSlcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgbGVuQiA9IHRoaXMuX2J1ZltvZmZzZXQrK10gJiAweGZmO1xuICBpZiAobGVuQiA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAoKGxlbkIgJiAweDgwKSA9PT0gMHg4MCkge1xuICAgIGxlbkIgJj0gMHg3ZjtcblxuICAgIGlmIChsZW5CID09PSAwKVxuICAgICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignSW5kZWZpbml0ZSBsZW5ndGggbm90IHN1cHBvcnRlZCcpO1xuXG4gICAgaWYgKGxlbkIgPiA0KVxuICAgICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignZW5jb2RpbmcgdG9vIGxvbmcnKTtcblxuICAgIGlmICh0aGlzLl9zaXplIC0gb2Zmc2V0IDwgbGVuQilcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgdGhpcy5fbGVuID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbkI7IGkrKylcbiAgICAgIHRoaXMuX2xlbiA9ICh0aGlzLl9sZW4gPDwgOCkgKyAodGhpcy5fYnVmW29mZnNldCsrXSAmIDB4ZmYpO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gV2Fzbid0IGEgdmFyaWFibGUgbGVuZ3RoXG4gICAgdGhpcy5fbGVuID0gbGVuQjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59O1xuXG5cbi8qKlxuICogUGFyc2VzIHRoZSBuZXh0IHNlcXVlbmNlIGluIHRoaXMgQkVSIGJ1ZmZlci5cbiAqXG4gKiBUbyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgc2VxdWVuY2UsIGNhbGwgYFJlYWRlci5sZW5ndGhgLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIHNlcXVlbmNlJ3MgdGFnLlxuICovXG5SZWFkZXIucHJvdG90eXBlLnJlYWRTZXF1ZW5jZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHNlcSA9IHRoaXMucGVlaygpO1xuICBpZiAoc2VxID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAodGFnICE9PSB1bmRlZmluZWQgJiYgdGFnICE9PSBzZXEpXG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignRXhwZWN0ZWQgMHgnICsgdGFnLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiBnb3QgMHgnICsgc2VxLnRvU3RyaW5nKDE2KSk7XG5cbiAgdmFyIG8gPSB0aGlzLnJlYWRMZW5ndGgodGhpcy5fb2Zmc2V0ICsgMSk7IC8vIHN0b3JlZCBpbiBgbGVuZ3RoYFxuICBpZiAobyA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICB0aGlzLl9vZmZzZXQgPSBvO1xuICByZXR1cm4gc2VxO1xufTtcblxuXG5SZWFkZXIucHJvdG90eXBlLnJlYWRJbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkVGFnKEFTTjEuSW50ZWdlcik7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUucmVhZEJvb2xlYW4gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5fcmVhZFRhZyhBU04xLkJvb2xlYW4pID09PSAwID8gZmFsc2UgOiB0cnVlKTtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkRW51bWVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkVGFnKEFTTjEuRW51bWVyYXRpb24pO1xufTtcblxuXG5SZWFkZXIucHJvdG90eXBlLnJlYWRTdHJpbmcgPSBmdW5jdGlvbiAodGFnLCByZXRidWYpIHtcbiAgaWYgKCF0YWcpXG4gICAgdGFnID0gQVNOMS5PY3RldFN0cmluZztcblxuICB2YXIgYiA9IHRoaXMucGVlaygpO1xuICBpZiAoYiA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAoYiAhPT0gdGFnKVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0V4cGVjdGVkIDB4JyArIHRhZy50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogZ290IDB4JyArIGIudG9TdHJpbmcoMTYpKTtcblxuICB2YXIgbyA9IHRoaXMucmVhZExlbmd0aCh0aGlzLl9vZmZzZXQgKyAxKTsgLy8gc3RvcmVkIGluIGBsZW5ndGhgXG5cbiAgaWYgKG8gPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gdGhpcy5fc2l6ZSAtIG8pXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdGhpcy5fb2Zmc2V0ID0gbztcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIHJldGJ1ZiA/IEJ1ZmZlci5hbGxvYygwKSA6ICcnO1xuXG4gIHZhciBzdHIgPSB0aGlzLl9idWYuc2xpY2UodGhpcy5fb2Zmc2V0LCB0aGlzLl9vZmZzZXQgKyB0aGlzLmxlbmd0aCk7XG4gIHRoaXMuX29mZnNldCArPSB0aGlzLmxlbmd0aDtcblxuICByZXR1cm4gcmV0YnVmID8gc3RyIDogc3RyLnRvU3RyaW5nKCd1dGY4Jyk7XG59O1xuXG5SZWFkZXIucHJvdG90eXBlLnJlYWRPSUQgPSBmdW5jdGlvbiAodGFnKSB7XG4gIGlmICghdGFnKVxuICAgIHRhZyA9IEFTTjEuT0lEO1xuXG4gIHZhciBiID0gdGhpcy5yZWFkU3RyaW5nKHRhZywgdHJ1ZSk7XG4gIGlmIChiID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIHZhbHVlID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IGJbaV0gJiAweGZmO1xuXG4gICAgdmFsdWUgPDw9IDc7XG4gICAgdmFsdWUgKz0gYnl0ZSAmIDB4N2Y7XG4gICAgaWYgKChieXRlICYgMHg4MCkgPT09IDApIHtcbiAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIHZhbHVlID0gMDtcbiAgICB9XG4gIH1cblxuICB2YWx1ZSA9IHZhbHVlcy5zaGlmdCgpO1xuICB2YWx1ZXMudW5zaGlmdCh2YWx1ZSAlIDQwKTtcbiAgdmFsdWVzLnVuc2hpZnQoKHZhbHVlIC8gNDApID4+IDApO1xuXG4gIHJldHVybiB2YWx1ZXMuam9pbignLicpO1xufTtcblxuXG5SZWFkZXIucHJvdG90eXBlLl9yZWFkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICBhc3NlcnQub2sodGFnICE9PSB1bmRlZmluZWQpO1xuXG4gIHZhciBiID0gdGhpcy5wZWVrKCk7XG5cbiAgaWYgKGIgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGIgIT09IHRhZylcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdFeHBlY3RlZCAweCcgKyB0YWcudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6IGdvdCAweCcgKyBiLnRvU3RyaW5nKDE2KSk7XG5cbiAgdmFyIG8gPSB0aGlzLnJlYWRMZW5ndGgodGhpcy5fb2Zmc2V0ICsgMSk7IC8vIHN0b3JlZCBpbiBgbGVuZ3RoYFxuICBpZiAobyA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAodGhpcy5sZW5ndGggPiA0KVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0ludGVnZXIgdG9vIGxvbmc6ICcgKyB0aGlzLmxlbmd0aCk7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gdGhpcy5fc2l6ZSAtIG8pXG4gICAgcmV0dXJuIG51bGw7XG4gIHRoaXMuX29mZnNldCA9IG87XG5cbiAgdmFyIGZiID0gdGhpcy5fYnVmW3RoaXMuX29mZnNldF07XG4gIHZhciB2YWx1ZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPDw9IDg7XG4gICAgdmFsdWUgfD0gKHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gJiAweGZmKTtcbiAgfVxuXG4gIGlmICgoZmIgJiAweDgwKSA9PT0gMHg4MCAmJiBpICE9PSA0KVxuICAgIHZhbHVlIC09ICgxIDw8IChpICogOCkpO1xuXG4gIHJldHVybiB2YWx1ZSA+PiAwO1xufTtcblxuXG5cbi8vIC0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XG4iLCIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVPQzogMCxcbiAgQm9vbGVhbjogMSxcbiAgSW50ZWdlcjogMixcbiAgQml0U3RyaW5nOiAzLFxuICBPY3RldFN0cmluZzogNCxcbiAgTnVsbDogNSxcbiAgT0lEOiA2LFxuICBPYmplY3REZXNjcmlwdG9yOiA3LFxuICBFeHRlcm5hbDogOCxcbiAgUmVhbDogOSwgLy8gZmxvYXRcbiAgRW51bWVyYXRpb246IDEwLFxuICBQRFY6IDExLFxuICBVdGY4U3RyaW5nOiAxMixcbiAgUmVsYXRpdmVPSUQ6IDEzLFxuICBTZXF1ZW5jZTogMTYsXG4gIFNldDogMTcsXG4gIE51bWVyaWNTdHJpbmc6IDE4LFxuICBQcmludGFibGVTdHJpbmc6IDE5LFxuICBUNjFTdHJpbmc6IDIwLFxuICBWaWRlb3RleFN0cmluZzogMjEsXG4gIElBNVN0cmluZzogMjIsXG4gIFVUQ1RpbWU6IDIzLFxuICBHZW5lcmFsaXplZFRpbWU6IDI0LFxuICBHcmFwaGljU3RyaW5nOiAyNSxcbiAgVmlzaWJsZVN0cmluZzogMjYsXG4gIEdlbmVyYWxTdHJpbmc6IDI4LFxuICBVbml2ZXJzYWxTdHJpbmc6IDI5LFxuICBDaGFyYWN0ZXJTdHJpbmc6IDMwLFxuICBCTVBTdHJpbmc6IDMxLFxuICBDb25zdHJ1Y3RvcjogMzIsXG4gIENvbnRleHQ6IDEyOFxufTtcbiIsIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBBU04xID0gcmVxdWlyZSgnLi90eXBlcycpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cblxuLy8gLS0tIEdsb2JhbHNcblxudmFyIG5ld0ludmFsaWRBc24xRXJyb3IgPSBlcnJvcnMubmV3SW52YWxpZEFzbjFFcnJvcjtcblxudmFyIERFRkFVTFRfT1BUUyA9IHtcbiAgc2l6ZTogMTAyNCxcbiAgZ3Jvd3RoRmFjdG9yOiA4XG59O1xuXG5cbi8vIC0tLSBIZWxwZXJzXG5cbmZ1bmN0aW9uIG1lcmdlKGZyb20sIHRvKSB7XG4gIGFzc2VydC5vayhmcm9tKTtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiAoZnJvbSksICdvYmplY3QnKTtcbiAgYXNzZXJ0Lm9rKHRvKTtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiAodG8pLCAnb2JqZWN0Jyk7XG5cbiAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhmcm9tKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAodG9ba2V5XSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwga2V5KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIGtleSwgdmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gdG87XG59XG5cblxuXG4vLyAtLS0gQVBJXG5cbmZ1bmN0aW9uIFdyaXRlcihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBtZXJnZShERUZBVUxUX09QVFMsIG9wdGlvbnMgfHwge30pO1xuXG4gIHRoaXMuX2J1ZiA9IEJ1ZmZlci5hbGxvYyhvcHRpb25zLnNpemUgfHwgMTAyNCk7XG4gIHRoaXMuX3NpemUgPSB0aGlzLl9idWYubGVuZ3RoO1xuICB0aGlzLl9vZmZzZXQgPSAwO1xuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblxuICAvLyBBIGxpc3Qgb2Ygb2Zmc2V0cyBpbiB0aGUgYnVmZmVyIHdoZXJlIHdlIG5lZWQgdG8gaW5zZXJ0XG4gIC8vIHNlcXVlbmNlIHRhZy9sZW4gcGFpcnMuXG4gIHRoaXMuX3NlcSA9IFtdO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGVyLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3NlcS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKHRoaXMuX3NlcS5sZW5ndGggKyAnIHVuZW5kZWQgc2VxdWVuY2UocyknKTtcblxuICAgIHJldHVybiAodGhpcy5fYnVmLnNsaWNlKDAsIHRoaXMuX29mZnNldCkpO1xuICB9XG59KTtcblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICBpZiAodHlwZW9mIChiKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpO1xuXG4gIHRoaXMuX2Vuc3VyZSgxKTtcbiAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGI7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVJbnQgPSBmdW5jdGlvbiAoaSwgdGFnKSB7XG4gIGlmICh0eXBlb2YgKGkpICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gIGlmICh0eXBlb2YgKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRhZyA9IEFTTjEuSW50ZWdlcjtcblxuICB2YXIgc3ogPSA0O1xuXG4gIHdoaWxlICgoKChpICYgMHhmZjgwMDAwMCkgPT09IDApIHx8ICgoaSAmIDB4ZmY4MDAwMDApID09PSAweGZmODAwMDAwID4+IDApKSAmJlxuICAgICAgICAoc3ogPiAxKSkge1xuICAgIHN6LS07XG4gICAgaSA8PD0gODtcbiAgfVxuXG4gIGlmIChzeiA+IDQpXG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignQkVSIGludHMgY2Fubm90IGJlID4gMHhmZmZmZmZmZicpO1xuXG4gIHRoaXMuX2Vuc3VyZSgyICsgc3opO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gdGFnO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gc3o7XG5cbiAgd2hpbGUgKHN6LS0gPiAwKSB7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9ICgoaSAmIDB4ZmYwMDAwMDApID4+PiAyNCk7XG4gICAgaSA8PD0gODtcbiAgfVxuXG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVOdWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndyaXRlQnl0ZShBU04xLk51bGwpO1xuICB0aGlzLndyaXRlQnl0ZSgweDAwKTtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZUVudW1lcmF0aW9uID0gZnVuY3Rpb24gKGksIHRhZykge1xuICBpZiAodHlwZW9mIChpKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICBpZiAodHlwZW9mICh0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLkVudW1lcmF0aW9uO1xuXG4gIHJldHVybiB0aGlzLndyaXRlSW50KGksIHRhZyk7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVCb29sZWFuID0gZnVuY3Rpb24gKGIsIHRhZykge1xuICBpZiAodHlwZW9mIChiKSAhPT0gJ2Jvb2xlYW4nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYSBCb29sZWFuJyk7XG4gIGlmICh0eXBlb2YgKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRhZyA9IEFTTjEuQm9vbGVhbjtcblxuICB0aGlzLl9lbnN1cmUoMyk7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSB0YWc7XG4gIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSAweDAxO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gYiA/IDB4ZmYgOiAweDAwO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24gKHMsIHRhZykge1xuICBpZiAodHlwZW9mIChzKSAhPT0gJ3N0cmluZycpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZyAod2FzOiAnICsgdHlwZW9mIChzKSArICcpJyk7XG4gIGlmICh0eXBlb2YgKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRhZyA9IEFTTjEuT2N0ZXRTdHJpbmc7XG5cbiAgdmFyIGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHMpO1xuICB0aGlzLndyaXRlQnl0ZSh0YWcpO1xuICB0aGlzLndyaXRlTGVuZ3RoKGxlbik7XG4gIGlmIChsZW4pIHtcbiAgICB0aGlzLl9lbnN1cmUobGVuKTtcbiAgICB0aGlzLl9idWYud3JpdGUocywgdGhpcy5fb2Zmc2V0KTtcbiAgICB0aGlzLl9vZmZzZXQgKz0gbGVuO1xuICB9XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbiAoYnVmLCB0YWcpIHtcbiAgaWYgKHR5cGVvZiAodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFnIG11c3QgYmUgYSBudW1iZXInKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgYnVmZmVyJyk7XG5cbiAgdGhpcy53cml0ZUJ5dGUodGFnKTtcbiAgdGhpcy53cml0ZUxlbmd0aChidWYubGVuZ3RoKTtcbiAgdGhpcy5fZW5zdXJlKGJ1Zi5sZW5ndGgpO1xuICBidWYuY29weSh0aGlzLl9idWYsIHRoaXMuX29mZnNldCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMuX29mZnNldCArPSBidWYubGVuZ3RoO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlU3RyaW5nQXJyYXkgPSBmdW5jdGlvbiAoc3RyaW5ncykge1xuICBpZiAoKCFzdHJpbmdzIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXlbU3RyaW5nXScpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgc2VsZi53cml0ZVN0cmluZyhzKTtcbiAgfSk7XG59O1xuXG4vLyBUaGlzIGlzIHJlYWxseSB0byBzb2x2ZSBERVIgY2FzZXMsIGJ1dCB3aGF0ZXZlciBmb3Igbm93XG5Xcml0ZXIucHJvdG90eXBlLndyaXRlT0lEID0gZnVuY3Rpb24gKHMsIHRhZykge1xuICBpZiAodHlwZW9mIChzKSAhPT0gJ3N0cmluZycpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICBpZiAodHlwZW9mICh0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLk9JRDtcblxuICBpZiAoIS9eKFswLTldK1xcLil7Myx9WzAtOV0rJC8udGVzdChzKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyZ3VtZW50IGlzIG5vdCBhIHZhbGlkIE9JRCBzdHJpbmcnKTtcblxuICBmdW5jdGlvbiBlbmNvZGVPY3RldChieXRlcywgb2N0ZXQpIHtcbiAgICBpZiAob2N0ZXQgPCAxMjgpIHtcbiAgICAgICAgYnl0ZXMucHVzaChvY3RldCk7XG4gICAgfSBlbHNlIGlmIChvY3RldCA8IDE2Mzg0KSB7XG4gICAgICAgIGJ5dGVzLnB1c2goKG9jdGV0ID4+PiA3KSB8IDB4ODApO1xuICAgICAgICBieXRlcy5wdXNoKG9jdGV0ICYgMHg3Rik7XG4gICAgfSBlbHNlIGlmIChvY3RldCA8IDIwOTcxNTIpIHtcbiAgICAgIGJ5dGVzLnB1c2goKG9jdGV0ID4+PiAxNCkgfCAweDgwKTtcbiAgICAgIGJ5dGVzLnB1c2goKChvY3RldCA+Pj4gNykgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaChvY3RldCAmIDB4N0YpO1xuICAgIH0gZWxzZSBpZiAob2N0ZXQgPCAyNjg0MzU0NTYpIHtcbiAgICAgIGJ5dGVzLnB1c2goKG9jdGV0ID4+PiAyMSkgfCAweDgwKTtcbiAgICAgIGJ5dGVzLnB1c2goKChvY3RldCA+Pj4gMTQpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2goKChvY3RldCA+Pj4gNykgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaChvY3RldCAmIDB4N0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDI4KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDIxKSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDE0KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKCgob2N0ZXQgPj4+IDcpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2gob2N0ZXQgJiAweDdGKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdG1wID0gcy5zcGxpdCgnLicpO1xuICB2YXIgYnl0ZXMgPSBbXTtcbiAgYnl0ZXMucHVzaChwYXJzZUludCh0bXBbMF0sIDEwKSAqIDQwICsgcGFyc2VJbnQodG1wWzFdLCAxMCkpO1xuICB0bXAuc2xpY2UoMikuZm9yRWFjaChmdW5jdGlvbiAoYikge1xuICAgIGVuY29kZU9jdGV0KGJ5dGVzLCBwYXJzZUludChiLCAxMCkpO1xuICB9KTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2Vuc3VyZSgyICsgYnl0ZXMubGVuZ3RoKTtcbiAgdGhpcy53cml0ZUJ5dGUodGFnKTtcbiAgdGhpcy53cml0ZUxlbmd0aChieXRlcy5sZW5ndGgpO1xuICBieXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgc2VsZi53cml0ZUJ5dGUoYik7XG4gIH0pO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICBpZiAodHlwZW9mIChsZW4pICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgTnVtYmVyJyk7XG5cbiAgdGhpcy5fZW5zdXJlKDQpO1xuXG4gIGlmIChsZW4gPD0gMHg3Zikge1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmYpIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHg4MTtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmZmYpIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHg4MjtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuID4+IDg7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPD0gMHhmZmZmZmYpIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHg4MztcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuID4+IDE2O1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBsZW4gPj4gODtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0xlbmd0aCB0b28gbG9uZyAoPiA0IGJ5dGVzKScpO1xuICB9XG59O1xuXG5Xcml0ZXIucHJvdG90eXBlLnN0YXJ0U2VxdWVuY2UgPSBmdW5jdGlvbiAodGFnKSB7XG4gIGlmICh0eXBlb2YgKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRhZyA9IEFTTjEuU2VxdWVuY2UgfCBBU04xLkNvbnN0cnVjdG9yO1xuXG4gIHRoaXMud3JpdGVCeXRlKHRhZyk7XG4gIHRoaXMuX3NlcS5wdXNoKHRoaXMuX29mZnNldCk7XG4gIHRoaXMuX2Vuc3VyZSgzKTtcbiAgdGhpcy5fb2Zmc2V0ICs9IDM7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUuZW5kU2VxdWVuY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZXEgPSB0aGlzLl9zZXEucG9wKCk7XG4gIHZhciBzdGFydCA9IHNlcSArIDM7XG4gIHZhciBsZW4gPSB0aGlzLl9vZmZzZXQgLSBzdGFydDtcblxuICBpZiAobGVuIDw9IDB4N2YpIHtcbiAgICB0aGlzLl9zaGlmdChzdGFydCwgbGVuLCAtMik7XG4gICAgdGhpcy5fYnVmW3NlcV0gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmYpIHtcbiAgICB0aGlzLl9zaGlmdChzdGFydCwgbGVuLCAtMSk7XG4gICAgdGhpcy5fYnVmW3NlcV0gPSAweDgxO1xuICAgIHRoaXMuX2J1ZltzZXEgKyAxXSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPD0gMHhmZmZmKSB7XG4gICAgdGhpcy5fYnVmW3NlcV0gPSAweDgyO1xuICAgIHRoaXMuX2J1ZltzZXEgKyAxXSA9IGxlbiA+PiA4O1xuICAgIHRoaXMuX2J1ZltzZXEgKyAyXSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPD0gMHhmZmZmZmYpIHtcbiAgICB0aGlzLl9zaGlmdChzdGFydCwgbGVuLCAxKTtcbiAgICB0aGlzLl9idWZbc2VxXSA9IDB4ODM7XG4gICAgdGhpcy5fYnVmW3NlcSArIDFdID0gbGVuID4+IDE2O1xuICAgIHRoaXMuX2J1ZltzZXEgKyAyXSA9IGxlbiA+PiA4O1xuICAgIHRoaXMuX2J1ZltzZXEgKyAzXSA9IGxlbjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdTZXF1ZW5jZSB0b28gbG9uZycpO1xuICB9XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUuX3NoaWZ0ID0gZnVuY3Rpb24gKHN0YXJ0LCBsZW4sIHNoaWZ0KSB7XG4gIGFzc2VydC5vayhzdGFydCAhPT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0Lm9rKGxlbiAhPT0gdW5kZWZpbmVkKTtcbiAgYXNzZXJ0Lm9rKHNoaWZ0KTtcblxuICB0aGlzLl9idWYuY29weSh0aGlzLl9idWYsIHN0YXJ0ICsgc2hpZnQsIHN0YXJ0LCBzdGFydCArIGxlbik7XG4gIHRoaXMuX29mZnNldCArPSBzaGlmdDtcbn07XG5cbldyaXRlci5wcm90b3R5cGUuX2Vuc3VyZSA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgYXNzZXJ0Lm9rKGxlbik7XG5cbiAgaWYgKHRoaXMuX3NpemUgLSB0aGlzLl9vZmZzZXQgPCBsZW4pIHtcbiAgICB2YXIgc3ogPSB0aGlzLl9zaXplICogdGhpcy5fb3B0aW9ucy5ncm93dGhGYWN0b3I7XG4gICAgaWYgKHN6IC0gdGhpcy5fb2Zmc2V0IDwgbGVuKVxuICAgICAgc3ogKz0gbGVuO1xuXG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhzeik7XG5cbiAgICB0aGlzLl9idWYuY29weShidWYsIDAsIDAsIHRoaXMuX29mZnNldCk7XG4gICAgdGhpcy5fYnVmID0gYnVmO1xuICAgIHRoaXMuX3NpemUgPSBzejtcbiAgfVxufTtcblxuXG5cbi8vIC0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XG4iLCIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbi8vIElmIHlvdSBoYXZlIG5vIGlkZWEgd2hhdCBBU04uMSBvciBCRVIgaXMsIHNlZSB0aGlzOlxuLy8gZnRwOi8vZnRwLnJzYS5jb20vcHViL3BrY3MvYXNjaWkvbGF5bWFuLmFzY1xuXG52YXIgQmVyID0gcmVxdWlyZSgnLi9iZXIvaW5kZXgnKTtcblxuXG5cbi8vIC0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgQmVyOiBCZXIsXG5cbiAgQmVyUmVhZGVyOiBCZXIuUmVhZGVyLFxuXG4gIEJlcldyaXRlcjogQmVyLldyaXRlclxuXG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDEyLCBNYXJrIENhdmFnZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cblxuLy8vLS0tIEdsb2JhbHNcblxuLyogSlNTVFlMRUQgKi9cbnZhciBVVUlEX1JFR0VYUCA9IC9eW2EtZkEtRjAtOV17OH0tW2EtZkEtRjAtOV17NH0tW2EtZkEtRjAtOV17NH0tW2EtZkEtRjAtOV17NH0tW2EtZkEtRjAtOV17MTJ9JC87XG5cblxuLy8vLS0tIEludGVybmFsXG5cbmZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICAgIHJldHVybiAoc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcbn1cblxuZnVuY3Rpb24gX3Rvc3MobmFtZSwgZXhwZWN0ZWQsIG9wZXIsIGFyZywgYWN0dWFsKSB7XG4gICAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IHV0aWwuZm9ybWF0KCclcyAoJXMpIGlzIHJlcXVpcmVkJywgbmFtZSwgZXhwZWN0ZWQpLFxuICAgICAgICBhY3R1YWw6IChhY3R1YWwgPT09IHVuZGVmaW5lZCkgPyB0eXBlb2YgKGFyZykgOiBhY3R1YWwoYXJnKSxcbiAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgICBvcGVyYXRvcjogb3BlciB8fCAnPT09JyxcbiAgICAgICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBfdG9zcy5jYWxsZXJcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2dldENsYXNzKGFyZykge1xuICAgIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykuc2xpY2UoOCwgLTEpKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBXaHkgZXZlbiBib3RoZXIgd2l0aCBhc3NlcnRzP1xufVxuXG5cbi8vLy0tLSBFeHBvcnRzXG5cbnZhciB0eXBlcyA9IHtcbiAgICBib29sOiB7XG4gICAgICAgIGNoZWNrOiBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0eXBlb2YgKGFyZykgPT09ICdib29sZWFuJzsgfVxuICAgIH0sXG4gICAgZnVuYzoge1xuICAgICAgICBjaGVjazogZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdHlwZW9mIChhcmcpID09PSAnZnVuY3Rpb24nOyB9XG4gICAgfSxcbiAgICBzdHJpbmc6IHtcbiAgICAgICAgY2hlY2s6IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHR5cGVvZiAoYXJnKSA9PT0gJ3N0cmluZyc7IH1cbiAgICB9LFxuICAgIG9iamVjdDoge1xuICAgICAgICBjaGVjazogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiAoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgICAgY2hlY2s6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgKGFyZykgPT09ICdudW1iZXInICYmICFpc05hTihhcmcpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBmaW5pdGU6IHtcbiAgICAgICAgY2hlY2s6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgKGFyZykgPT09ICdudW1iZXInICYmICFpc05hTihhcmcpICYmIGlzRmluaXRlKGFyZyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJ1ZmZlcjoge1xuICAgICAgICBjaGVjazogZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGFyZyk7IH0sXG4gICAgICAgIG9wZXJhdG9yOiAnQnVmZmVyLmlzQnVmZmVyJ1xuICAgIH0sXG4gICAgYXJyYXk6IHtcbiAgICAgICAgY2hlY2s6IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTsgfSxcbiAgICAgICAgb3BlcmF0b3I6ICdBcnJheS5pc0FycmF5J1xuICAgIH0sXG4gICAgc3RyZWFtOiB7XG4gICAgICAgIGNoZWNrOiBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBhcmcgaW5zdGFuY2VvZiBTdHJlYW07IH0sXG4gICAgICAgIG9wZXJhdG9yOiAnaW5zdGFuY2VvZicsXG4gICAgICAgIGFjdHVhbDogX2dldENsYXNzXG4gICAgfSxcbiAgICBkYXRlOiB7XG4gICAgICAgIGNoZWNrOiBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBhcmcgaW5zdGFuY2VvZiBEYXRlOyB9LFxuICAgICAgICBvcGVyYXRvcjogJ2luc3RhbmNlb2YnLFxuICAgICAgICBhY3R1YWw6IF9nZXRDbGFzc1xuICAgIH0sXG4gICAgcmVnZXhwOiB7XG4gICAgICAgIGNoZWNrOiBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBhcmcgaW5zdGFuY2VvZiBSZWdFeHA7IH0sXG4gICAgICAgIG9wZXJhdG9yOiAnaW5zdGFuY2VvZicsXG4gICAgICAgIGFjdHVhbDogX2dldENsYXNzXG4gICAgfSxcbiAgICB1dWlkOiB7XG4gICAgICAgIGNoZWNrOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIChhcmcpID09PSAnc3RyaW5nJyAmJiBVVUlEX1JFR0VYUC50ZXN0KGFyZyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9wZXJhdG9yOiAnaXNVVUlEJ1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIF9zZXRFeHBvcnRzKG5kZWJ1Zykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModHlwZXMpO1xuICAgIHZhciBvdXQ7XG5cbiAgICAvKiByZS1leHBvcnQgc3RhbmRhcmQgYXNzZXJ0ICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfTkRFQlVHKSB7XG4gICAgICAgIG91dCA9IG5vb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ID0gZnVuY3Rpb24gKGFyZywgbXNnKSB7XG4gICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgIF90b3NzKG1zZywgJ3RydWUnLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qIHN0YW5kYXJkIGNoZWNrcyAqL1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAobmRlYnVnKSB7XG4gICAgICAgICAgICBvdXRba10gPSBub29wO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNba107XG4gICAgICAgIG91dFtrXSA9IGZ1bmN0aW9uIChhcmcsIG1zZykge1xuICAgICAgICAgICAgaWYgKCF0eXBlLmNoZWNrKGFyZykpIHtcbiAgICAgICAgICAgICAgICBfdG9zcyhtc2csIGssIHR5cGUub3BlcmF0b3IsIGFyZywgdHlwZS5hY3R1YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyogb3B0aW9uYWwgY2hlY2tzICovXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBuYW1lID0gJ29wdGlvbmFsJyArIF9jYXBpdGFsaXplKGspO1xuICAgICAgICBpZiAobmRlYnVnKSB7XG4gICAgICAgICAgICBvdXRbbmFtZV0gPSBub29wO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNba107XG4gICAgICAgIG91dFtuYW1lXSA9IGZ1bmN0aW9uIChhcmcsIG1zZykge1xuICAgICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IGFyZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHlwZS5jaGVjayhhcmcpKSB7XG4gICAgICAgICAgICAgICAgX3Rvc3MobXNnLCBrLCB0eXBlLm9wZXJhdG9yLCBhcmcsIHR5cGUuYWN0dWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qIGFycmF5T2YgY2hlY2tzICovXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBuYW1lID0gJ2FycmF5T2YnICsgX2NhcGl0YWxpemUoayk7XG4gICAgICAgIGlmIChuZGVidWcpIHtcbiAgICAgICAgICAgIG91dFtuYW1lXSA9IG5vb3A7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1trXTtcbiAgICAgICAgdmFyIGV4cGVjdGVkID0gJ1snICsgayArICddJztcbiAgICAgICAgb3V0W25hbWVdID0gZnVuY3Rpb24gKGFyZywgbXNnKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgICAgIF90b3NzKG1zZywgZXhwZWN0ZWQsIHR5cGUub3BlcmF0b3IsIGFyZywgdHlwZS5hY3R1YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmNoZWNrKGFyZ1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3Rvc3MobXNnLCBleHBlY3RlZCwgdHlwZS5vcGVyYXRvciwgYXJnLCB0eXBlLmFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyogb3B0aW9uYWxBcnJheU9mIGNoZWNrcyAqL1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgbmFtZSA9ICdvcHRpb25hbEFycmF5T2YnICsgX2NhcGl0YWxpemUoayk7XG4gICAgICAgIGlmIChuZGVidWcpIHtcbiAgICAgICAgICAgIG91dFtuYW1lXSA9IG5vb3A7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1trXTtcbiAgICAgICAgdmFyIGV4cGVjdGVkID0gJ1snICsgayArICddJztcbiAgICAgICAgb3V0W25hbWVdID0gZnVuY3Rpb24gKGFyZywgbXNnKSB7XG4gICAgICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQgfHwgYXJnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgICAgICBfdG9zcyhtc2csIGV4cGVjdGVkLCB0eXBlLm9wZXJhdG9yLCBhcmcsIHR5cGUuYWN0dWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdHlwZS5jaGVjayhhcmdbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIF90b3NzKG1zZywgZXhwZWN0ZWQsIHR5cGUub3BlcmF0b3IsIGFyZywgdHlwZS5hY3R1YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qIHJlLWV4cG9ydCBidWlsdC1pbiBhc3NlcnRpb25zICovXG4gICAgT2JqZWN0LmtleXMoYXNzZXJ0KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrID09PSAnQXNzZXJ0aW9uRXJyb3InKSB7XG4gICAgICAgICAgICBvdXRba10gPSBhc3NlcnRba107XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5kZWJ1Zykge1xuICAgICAgICAgICAgb3V0W2tdID0gbm9vcDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvdXRba10gPSBhc3NlcnRba107XG4gICAgfSk7XG5cbiAgICAvKiBleHBvcnQgb3Vyc2VsdmVzIChmb3IgdW5pdCB0ZXN0cyBfb25seV8pICovXG4gICAgb3V0Ll9zZXRFeHBvcnRzID0gX3NldEV4cG9ydHM7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRFeHBvcnRzKHByb2Nlc3MuZW52Lk5PREVfTkRFQlVHKTtcbiIsIm1vZHVsZS5leHBvcnRzID1cbntcbiAgcGFyYWxsZWwgICAgICA6IHJlcXVpcmUoJy4vcGFyYWxsZWwuanMnKSxcbiAgc2VyaWFsICAgICAgICA6IHJlcXVpcmUoJy4vc2VyaWFsLmpzJyksXG4gIHNlcmlhbE9yZGVyZWQgOiByZXF1aXJlKCcuL3NlcmlhbE9yZGVyZWQuanMnKVxufTtcbiIsIi8vIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBhYm9ydDtcblxuLyoqXG4gKiBBYm9ydHMgbGVmdG92ZXIgYWN0aXZlIGpvYnNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBjdXJyZW50IHN0YXRlIG9iamVjdFxuICovXG5mdW5jdGlvbiBhYm9ydChzdGF0ZSlcbntcbiAgT2JqZWN0LmtleXMoc3RhdGUuam9icykuZm9yRWFjaChjbGVhbi5iaW5kKHN0YXRlKSk7XG5cbiAgLy8gcmVzZXQgbGVmdG92ZXIgam9ic1xuICBzdGF0ZS5qb2JzID0ge307XG59XG5cbi8qKlxuICogQ2xlYW5zIHVwIGxlZnRvdmVyIGpvYiBieSBpbnZva2luZyBhYm9ydCBmdW5jdGlvbiBmb3IgdGhlIHByb3ZpZGVkIGpvYiBpZFxuICpcbiAqIEB0aGlzICBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBrZXkgLSBqb2IgaWQgdG8gYWJvcnRcbiAqL1xuZnVuY3Rpb24gY2xlYW4oa2V5KVxue1xuICBpZiAodHlwZW9mIHRoaXMuam9ic1trZXldID09ICdmdW5jdGlvbicpXG4gIHtcbiAgICB0aGlzLmpvYnNba2V5XSgpO1xuICB9XG59XG4iLCJ2YXIgZGVmZXIgPSByZXF1aXJlKCcuL2RlZmVyLmpzJyk7XG5cbi8vIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBhc3luYztcblxuLyoqXG4gKiBSdW5zIHByb3ZpZGVkIGNhbGxiYWNrIGFzeW5jaHJvbm91c2x5XG4gKiBldmVuIGlmIGNhbGxiYWNrIGl0c2VsZiBpcyBub3RcbiAqXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gY2FsbGJhY2sgdG8gaW52b2tlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IC0gYXVnbWVudGVkIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGFzeW5jKGNhbGxiYWNrKVxue1xuICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuXG4gIC8vIGNoZWNrIGlmIGFzeW5jIGhhcHBlbmVkXG4gIGRlZmVyKGZ1bmN0aW9uKCkgeyBpc0FzeW5jID0gdHJ1ZTsgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGFzeW5jX2NhbGxiYWNrKGVyciwgcmVzdWx0KVxuICB7XG4gICAgaWYgKGlzQXN5bmMpXG4gICAge1xuICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgZGVmZXIoZnVuY3Rpb24gbmV4dFRpY2tfY2FsbGJhY2soKVxuICAgICAge1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGRlZmVyO1xuXG4vKipcbiAqIFJ1bnMgcHJvdmlkZWQgZnVuY3Rpb24gb24gbmV4dCBpdGVyYXRpb24gb2YgdGhlIGV2ZW50IGxvb3BcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIGZ1bmN0aW9uIHRvIHJ1blxuICovXG5mdW5jdGlvbiBkZWZlcihmbilcbntcbiAgdmFyIG5leHRUaWNrID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PSAnZnVuY3Rpb24nXG4gICAgPyBzZXRJbW1lZGlhdGVcbiAgICA6IChcbiAgICAgIHR5cGVvZiBwcm9jZXNzID09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvY2Vzcy5uZXh0VGlja1xuICAgICAgOiBudWxsXG4gICAgKTtcblxuICBpZiAobmV4dFRpY2spXG4gIHtcbiAgICBuZXh0VGljayhmbik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgc2V0VGltZW91dChmbiwgMCk7XG4gIH1cbn1cbiIsInZhciBhc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMuanMnKVxuICAsIGFib3J0ID0gcmVxdWlyZSgnLi9hYm9ydC5qcycpXG4gIDtcblxuLy8gQVBJXG5tb2R1bGUuZXhwb3J0cyA9IGl0ZXJhdGU7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlYWNoIGpvYiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge2FycmF5fG9iamVjdH0gbGlzdCAtIGFycmF5IG9yIG9iamVjdCAobmFtZWQgbGlzdCkgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRvciAtIGl0ZXJhdG9yIHRvIHJ1blxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gY3VycmVudCBqb2Igc3RhdHVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGludm9rZWQgd2hlbiBhbGwgZWxlbWVudHMgcHJvY2Vzc2VkXG4gKi9cbmZ1bmN0aW9uIGl0ZXJhdGUobGlzdCwgaXRlcmF0b3IsIHN0YXRlLCBjYWxsYmFjaylcbntcbiAgLy8gc3RvcmUgY3VycmVudCBpbmRleFxuICB2YXIga2V5ID0gc3RhdGVbJ2tleWVkTGlzdCddID8gc3RhdGVbJ2tleWVkTGlzdCddW3N0YXRlLmluZGV4XSA6IHN0YXRlLmluZGV4O1xuXG4gIHN0YXRlLmpvYnNba2V5XSA9IHJ1bkpvYihpdGVyYXRvciwga2V5LCBsaXN0W2tleV0sIGZ1bmN0aW9uKGVycm9yLCBvdXRwdXQpXG4gIHtcbiAgICAvLyBkb24ndCByZXBlYXQgeW91cnNlbGZcbiAgICAvLyBza2lwIHNlY29uZGFyeSBjYWxsYmFja3NcbiAgICBpZiAoIShrZXkgaW4gc3RhdGUuam9icykpXG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNsZWFuIHVwIGpvYnNcbiAgICBkZWxldGUgc3RhdGUuam9ic1trZXldO1xuXG4gICAgaWYgKGVycm9yKVxuICAgIHtcbiAgICAgIC8vIGRvbid0IHByb2Nlc3MgcmVzdCBvZiB0aGUgcmVzdWx0c1xuICAgICAgLy8gc3RvcCBzdGlsbCBhY3RpdmUgam9ic1xuICAgICAgLy8gYW5kIHJlc2V0IHRoZSBsaXN0XG4gICAgICBhYm9ydChzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICBzdGF0ZS5yZXN1bHRzW2tleV0gPSBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHNhbHZhZ2VkIHJlc3VsdHNcbiAgICBjYWxsYmFjayhlcnJvciwgc3RhdGUucmVzdWx0cyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJ1bnMgaXRlcmF0b3Igb3ZlciBwcm92aWRlZCBqb2IgZWxlbWVudFxuICpcbiAqIEBwYXJhbSAgIHtmdW5jdGlvbn0gaXRlcmF0b3IgLSBpdGVyYXRvciB0byBpbnZva2VcbiAqIEBwYXJhbSAgIHtzdHJpbmd8bnVtYmVyfSBrZXkgLSBrZXkvaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhlIGxpc3Qgb2Ygam9ic1xuICogQHBhcmFtICAge21peGVkfSBpdGVtIC0gam9iIGRlc2NyaXB0aW9uXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gaW52b2tlZCBhZnRlciBpdGVyYXRvciBpcyBkb25lIHdpdGggdGhlIGpvYlxuICogQHJldHVybnMge2Z1bmN0aW9ufG1peGVkfSAtIGpvYiBhYm9ydCBmdW5jdGlvbiBvciBzb21ldGhpbmcgZWxzZVxuICovXG5mdW5jdGlvbiBydW5Kb2IoaXRlcmF0b3IsIGtleSwgaXRlbSwgY2FsbGJhY2spXG57XG4gIHZhciBhYm9ydGVyO1xuXG4gIC8vIGFsbG93IHNob3J0Y3V0IGlmIGl0ZXJhdG9yIGV4cGVjdHMgb25seSB0d28gYXJndW1lbnRzXG4gIGlmIChpdGVyYXRvci5sZW5ndGggPT0gMilcbiAge1xuICAgIGFib3J0ZXIgPSBpdGVyYXRvcihpdGVtLCBhc3luYyhjYWxsYmFjaykpO1xuICB9XG4gIC8vIG90aGVyd2lzZSBnbyB3aXRoIGZ1bGwgdGhyZWUgYXJndW1lbnRzXG4gIGVsc2VcbiAge1xuICAgIGFib3J0ZXIgPSBpdGVyYXRvcihpdGVtLCBrZXksIGFzeW5jKGNhbGxiYWNrKSk7XG4gIH1cblxuICByZXR1cm4gYWJvcnRlcjtcbn1cbiIsIi8vIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBzdGF0ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGluaXRpYWwgc3RhdGUgb2JqZWN0XG4gKiBmb3IgaXRlcmF0aW9uIG92ZXIgbGlzdFxuICpcbiAqIEBwYXJhbSAgIHthcnJheXxvYmplY3R9IGxpc3QgLSBsaXN0IHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtICAge2Z1bmN0aW9ufG51bGx9IHNvcnRNZXRob2QgLSBmdW5jdGlvbiB0byB1c2UgZm9yIGtleXMgc29ydCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGBudWxsYCB0byBrZWVwIHRoZW0gYXMgaXNcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0gaW5pdGlhbCBzdGF0ZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc3RhdGUobGlzdCwgc29ydE1ldGhvZClcbntcbiAgdmFyIGlzTmFtZWRMaXN0ID0gIUFycmF5LmlzQXJyYXkobGlzdClcbiAgICAsIGluaXRTdGF0ZSA9XG4gICAge1xuICAgICAgaW5kZXggICAgOiAwLFxuICAgICAga2V5ZWRMaXN0OiBpc05hbWVkTGlzdCB8fCBzb3J0TWV0aG9kID8gT2JqZWN0LmtleXMobGlzdCkgOiBudWxsLFxuICAgICAgam9icyAgICAgOiB7fSxcbiAgICAgIHJlc3VsdHMgIDogaXNOYW1lZExpc3QgPyB7fSA6IFtdLFxuICAgICAgc2l6ZSAgICAgOiBpc05hbWVkTGlzdCA/IE9iamVjdC5rZXlzKGxpc3QpLmxlbmd0aCA6IGxpc3QubGVuZ3RoXG4gICAgfVxuICAgIDtcblxuICBpZiAoc29ydE1ldGhvZClcbiAge1xuICAgIC8vIHNvcnQgYXJyYXkga2V5cyBiYXNlZCBvbiBpdCdzIHZhbHVlc1xuICAgIC8vIHNvcnQgb2JqZWN0J3Mga2V5cyBqdXN0IG9uIG93biBtZXJpdFxuICAgIGluaXRTdGF0ZS5rZXllZExpc3Quc29ydChpc05hbWVkTGlzdCA/IHNvcnRNZXRob2QgOiBmdW5jdGlvbihhLCBiKVxuICAgIHtcbiAgICAgIHJldHVybiBzb3J0TWV0aG9kKGxpc3RbYV0sIGxpc3RbYl0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGluaXRTdGF0ZTtcbn1cbiIsInZhciBhYm9ydCA9IHJlcXVpcmUoJy4vYWJvcnQuanMnKVxuICAsIGFzeW5jID0gcmVxdWlyZSgnLi9hc3luYy5qcycpXG4gIDtcblxuLy8gQVBJXG5tb2R1bGUuZXhwb3J0cyA9IHRlcm1pbmF0b3I7XG5cbi8qKlxuICogVGVybWluYXRlcyBqb2JzIGluIHRoZSBhdHRhY2hlZCBzdGF0ZSBjb250ZXh0XG4gKlxuICogQHRoaXMgIEFzeW5jS2l0U3RhdGUjXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGZpbmFsIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciB0ZXJtaW5hdGlvblxuICovXG5mdW5jdGlvbiB0ZXJtaW5hdG9yKGNhbGxiYWNrKVxue1xuICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuam9icykubGVuZ3RoKVxuICB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZmFzdCBmb3J3YXJkIGl0ZXJhdGlvbiBpbmRleFxuICB0aGlzLmluZGV4ID0gdGhpcy5zaXplO1xuXG4gIC8vIGFib3J0IGpvYnNcbiAgYWJvcnQodGhpcyk7XG5cbiAgLy8gc2VuZCBiYWNrIHJlc3VsdHMgd2UgaGF2ZSBzbyBmYXJcbiAgYXN5bmMoY2FsbGJhY2spKG51bGwsIHRoaXMucmVzdWx0cyk7XG59XG4iLCJ2YXIgaXRlcmF0ZSAgICA9IHJlcXVpcmUoJy4vbGliL2l0ZXJhdGUuanMnKVxuICAsIGluaXRTdGF0ZSAgPSByZXF1aXJlKCcuL2xpYi9zdGF0ZS5qcycpXG4gICwgdGVybWluYXRvciA9IHJlcXVpcmUoJy4vbGliL3Rlcm1pbmF0b3IuanMnKVxuICA7XG5cbi8vIFB1YmxpYyBBUElcbm1vZHVsZS5leHBvcnRzID0gcGFyYWxsZWw7XG5cbi8qKlxuICogUnVucyBpdGVyYXRvciBvdmVyIHByb3ZpZGVkIGFycmF5IGVsZW1lbnRzIGluIHBhcmFsbGVsXG4gKlxuICogQHBhcmFtICAge2FycmF5fG9iamVjdH0gbGlzdCAtIGFycmF5IG9yIG9iamVjdCAobmFtZWQgbGlzdCkgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IGl0ZXJhdG9yIC0gaXRlcmF0b3IgdG8gcnVuXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gaW52b2tlZCB3aGVuIGFsbCBlbGVtZW50cyBwcm9jZXNzZWRcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gLSBqb2JzIHRlcm1pbmF0b3JcbiAqL1xuZnVuY3Rpb24gcGFyYWxsZWwobGlzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKVxue1xuICB2YXIgc3RhdGUgPSBpbml0U3RhdGUobGlzdCk7XG5cbiAgd2hpbGUgKHN0YXRlLmluZGV4IDwgKHN0YXRlWydrZXllZExpc3QnXSB8fCBsaXN0KS5sZW5ndGgpXG4gIHtcbiAgICBpdGVyYXRlKGxpc3QsIGl0ZXJhdG9yLCBzdGF0ZSwgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdClcbiAgICB7XG4gICAgICBpZiAoZXJyb3IpXG4gICAgICB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGxvb2tzIGxpa2UgaXQncyB0aGUgbGFzdCBvbmVcbiAgICAgIGlmIChPYmplY3Qua2V5cyhzdGF0ZS5qb2JzKS5sZW5ndGggPT09IDApXG4gICAgICB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHN0YXRlLnJlc3VsdHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdGF0ZS5pbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIHRlcm1pbmF0b3IuYmluZChzdGF0ZSwgY2FsbGJhY2spO1xufVxuIiwidmFyIHNlcmlhbE9yZGVyZWQgPSByZXF1aXJlKCcuL3NlcmlhbE9yZGVyZWQuanMnKTtcblxuLy8gUHVibGljIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBzZXJpYWw7XG5cbi8qKlxuICogUnVucyBpdGVyYXRvciBvdmVyIHByb3ZpZGVkIGFycmF5IGVsZW1lbnRzIGluIHNlcmllc1xuICpcbiAqIEBwYXJhbSAgIHthcnJheXxvYmplY3R9IGxpc3QgLSBhcnJheSBvciBvYmplY3QgKG5hbWVkIGxpc3QpIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtICAge2Z1bmN0aW9ufSBpdGVyYXRvciAtIGl0ZXJhdG9yIHRvIHJ1blxuICogQHBhcmFtICAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGludm9rZWQgd2hlbiBhbGwgZWxlbWVudHMgcHJvY2Vzc2VkXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IC0gam9icyB0ZXJtaW5hdG9yXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbChsaXN0LCBpdGVyYXRvciwgY2FsbGJhY2spXG57XG4gIHJldHVybiBzZXJpYWxPcmRlcmVkKGxpc3QsIGl0ZXJhdG9yLCBudWxsLCBjYWxsYmFjayk7XG59XG4iLCJ2YXIgaXRlcmF0ZSAgICA9IHJlcXVpcmUoJy4vbGliL2l0ZXJhdGUuanMnKVxuICAsIGluaXRTdGF0ZSAgPSByZXF1aXJlKCcuL2xpYi9zdGF0ZS5qcycpXG4gICwgdGVybWluYXRvciA9IHJlcXVpcmUoJy4vbGliL3Rlcm1pbmF0b3IuanMnKVxuICA7XG5cbi8vIFB1YmxpYyBBUElcbm1vZHVsZS5leHBvcnRzID0gc2VyaWFsT3JkZXJlZDtcbi8vIHNvcnRpbmcgaGVscGVyc1xubW9kdWxlLmV4cG9ydHMuYXNjZW5kaW5nICA9IGFzY2VuZGluZztcbm1vZHVsZS5leHBvcnRzLmRlc2NlbmRpbmcgPSBkZXNjZW5kaW5nO1xuXG4vKipcbiAqIFJ1bnMgaXRlcmF0b3Igb3ZlciBwcm92aWRlZCBzb3J0ZWQgYXJyYXkgZWxlbWVudHMgaW4gc2VyaWVzXG4gKlxuICogQHBhcmFtICAge2FycmF5fG9iamVjdH0gbGlzdCAtIGFycmF5IG9yIG9iamVjdCAobmFtZWQgbGlzdCkgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IGl0ZXJhdG9yIC0gaXRlcmF0b3IgdG8gcnVuXG4gKiBAcGFyYW0gICB7ZnVuY3Rpb259IHNvcnRNZXRob2QgLSBjdXN0b20gc29ydCBmdW5jdGlvblxuICogQHBhcmFtICAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGludm9rZWQgd2hlbiBhbGwgZWxlbWVudHMgcHJvY2Vzc2VkXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IC0gam9icyB0ZXJtaW5hdG9yXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbE9yZGVyZWQobGlzdCwgaXRlcmF0b3IsIHNvcnRNZXRob2QsIGNhbGxiYWNrKVxue1xuICB2YXIgc3RhdGUgPSBpbml0U3RhdGUobGlzdCwgc29ydE1ldGhvZCk7XG5cbiAgaXRlcmF0ZShsaXN0LCBpdGVyYXRvciwgc3RhdGUsIGZ1bmN0aW9uIGl0ZXJhdG9ySGFuZGxlcihlcnJvciwgcmVzdWx0KVxuICB7XG4gICAgaWYgKGVycm9yKVxuICAgIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXRlLmluZGV4Kys7XG5cbiAgICAvLyBhcmUgd2UgdGhlcmUgeWV0P1xuICAgIGlmIChzdGF0ZS5pbmRleCA8IChzdGF0ZVsna2V5ZWRMaXN0J10gfHwgbGlzdCkubGVuZ3RoKVxuICAgIHtcbiAgICAgIGl0ZXJhdGUobGlzdCwgaXRlcmF0b3IsIHN0YXRlLCBpdGVyYXRvckhhbmRsZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGRvbmUgaGVyZVxuICAgIGNhbGxiYWNrKG51bGwsIHN0YXRlLnJlc3VsdHMpO1xuICB9KTtcblxuICByZXR1cm4gdGVybWluYXRvci5iaW5kKHN0YXRlLCBjYWxsYmFjayk7XG59XG5cbi8qXG4gKiAtLSBTb3J0IG1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIHNvcnQgaGVscGVyIHRvIHNvcnQgYXJyYXkgZWxlbWVudHMgaW4gYXNjZW5kaW5nIG9yZGVyXG4gKlxuICogQHBhcmFtICAge21peGVkfSBhIC0gYW4gaXRlbSB0byBjb21wYXJlXG4gKiBAcGFyYW0gICB7bWl4ZWR9IGIgLSBhbiBpdGVtIHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gY29tcGFyaXNvbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpXG57XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cblxuLyoqXG4gKiBzb3J0IGhlbHBlciB0byBzb3J0IGFycmF5IGVsZW1lbnRzIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAqXG4gKiBAcGFyYW0gICB7bWl4ZWR9IGEgLSBhbiBpdGVtIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSAgIHttaXhlZH0gYiAtIGFuIGl0ZW0gdG8gY29tcGFyZVxuICogQHJldHVybnMge251bWJlcn0gLSBjb21wYXJpc29uIHJlc3VsdFxuICovXG5mdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpXG57XG4gIHJldHVybiAtMSAqIGFzY2VuZGluZyhhLCBiKTtcbn1cbiIsIlxuLyohXG4gKiAgQ29weXJpZ2h0IDIwMTAgTGVhcm5Cb29zdCA8ZGV2QGxlYXJuYm9vc3QuY29tPlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG4gICwgcGFyc2UgPSByZXF1aXJlKCd1cmwnKS5wYXJzZVxuICA7XG5cbi8qKlxuICogVmFsaWQga2V5cy5cbiAqL1xuXG52YXIga2V5cyA9IFxuICBbICdhY2wnXG4gICwgJ2xvY2F0aW9uJ1xuICAsICdsb2dnaW5nJ1xuICAsICdub3RpZmljYXRpb24nXG4gICwgJ3BhcnROdW1iZXInXG4gICwgJ3BvbGljeSdcbiAgLCAncmVxdWVzdFBheW1lbnQnXG4gICwgJ3RvcnJlbnQnXG4gICwgJ3VwbG9hZElkJ1xuICAsICd1cGxvYWRzJ1xuICAsICd2ZXJzaW9uSWQnXG4gICwgJ3ZlcnNpb25pbmcnXG4gICwgJ3ZlcnNpb25zJ1xuICAsICd3ZWJzaXRlJ1xuICBdXG5cbi8qKlxuICogUmV0dXJuIGFuIFwiQXV0aG9yaXphdGlvblwiIGhlYWRlciB2YWx1ZSB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2BcbiAqIGluIHRoZSBmb3JtIG9mIFwiQVdTIDxrZXk+OjxzaWduYXR1cmU+XCJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXV0aG9yaXphdGlvbiAob3B0aW9ucykge1xuICByZXR1cm4gJ0FXUyAnICsgb3B0aW9ucy5rZXkgKyAnOicgKyBzaWduKG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXV0aG9yaXphdGlvblxubW9kdWxlLmV4cG9ydHMuYXV0aG9yaXphdGlvbiA9IGF1dGhvcml6YXRpb25cblxuLyoqXG4gKiBTaW1wbGUgSE1BQy1TSEExIFdyYXBwZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi8gXG5cbmZ1bmN0aW9uIGhtYWNTaGExIChvcHRpb25zKSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSG1hYygnc2hhMScsIG9wdGlvbnMuc2VjcmV0KS51cGRhdGUob3B0aW9ucy5tZXNzYWdlKS5kaWdlc3QoJ2Jhc2U2NCcpXG59XG5cbm1vZHVsZS5leHBvcnRzLmhtYWNTaGExID0gaG1hY1NoYTFcblxuLyoqXG4gKiBDcmVhdGUgYSBiYXNlNjQgc2hhMSBITUFDIGZvciBgb3B0aW9uc2AuIFxuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2lnbiAob3B0aW9ucykge1xuICBvcHRpb25zLm1lc3NhZ2UgPSBzdHJpbmdUb1NpZ24ob3B0aW9ucylcbiAgcmV0dXJuIGhtYWNTaGExKG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cy5zaWduID0gc2lnblxuXG4vKipcbiAqIENyZWF0ZSBhIGJhc2U2NCBzaGExIEhNQUMgZm9yIGBvcHRpb25zYC4gXG4gKlxuICogU3BlY2lmaWNhbGx5IHRvIGJlIHVzZWQgd2l0aCBTMyBwcmVzaWduZWQgVVJMc1xuICogXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2lnblF1ZXJ5IChvcHRpb25zKSB7XG4gIG9wdGlvbnMubWVzc2FnZSA9IHF1ZXJ5U3RyaW5nVG9TaWduKG9wdGlvbnMpXG4gIHJldHVybiBobWFjU2hhMShvcHRpb25zKVxufVxubW9kdWxlLmV4cG9ydHMuc2lnblF1ZXJ5PSBzaWduUXVlcnlcblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgZm9yIHNpZ24oKSB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKlxuICogU3BlYzpcbiAqIFxuICogICAgPHZlcmI+XFxuXG4gKiAgICA8bWQ1PlxcblxuICogICAgPGNvbnRlbnQtdHlwZT5cXG5cbiAqICAgIDxkYXRlPlxcblxuICogICAgW2hlYWRlcnNcXG5dXG4gKiAgICA8cmVzb3VyY2U+XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ1RvU2lnbiAob3B0aW9ucykge1xuICB2YXIgaGVhZGVycyA9IG9wdGlvbnMuYW1hem9uSGVhZGVycyB8fCAnJ1xuICBpZiAoaGVhZGVycykgaGVhZGVycyArPSAnXFxuJ1xuICB2YXIgciA9IFxuICAgIFsgb3B0aW9ucy52ZXJiXG4gICAgLCBvcHRpb25zLm1kNVxuICAgICwgb3B0aW9ucy5jb250ZW50VHlwZVxuICAgICwgb3B0aW9ucy5kYXRlID8gb3B0aW9ucy5kYXRlLnRvVVRDU3RyaW5nKCkgOiAnJ1xuICAgICwgaGVhZGVycyArIG9wdGlvbnMucmVzb3VyY2VcbiAgICBdXG4gIHJldHVybiByLmpvaW4oJ1xcbicpXG59XG5tb2R1bGUuZXhwb3J0cy5zdHJpbmdUb1NpZ24gPSBzdHJpbmdUb1NpZ25cblxuLyoqXG4gKiBSZXR1cm4gYSBzdHJpbmcgZm9yIHNpZ24oKSB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AsIGJ1dCBpcyBtZWFudCBleGNsdXNpdmVseVxuICogZm9yIFMzIHByZXNpZ25lZCBVUkxzXG4gKlxuICogU3BlYzpcbiAqIFxuICogICAgPGRhdGU+XFxuXG4gKiAgICA8cmVzb3VyY2U+XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHF1ZXJ5U3RyaW5nVG9TaWduIChvcHRpb25zKXtcbiAgcmV0dXJuICdHRVRcXG5cXG5cXG4nICsgb3B0aW9ucy5kYXRlICsgJ1xcbicgKyBvcHRpb25zLnJlc291cmNlXG59XG5tb2R1bGUuZXhwb3J0cy5xdWVyeVN0cmluZ1RvU2lnbiA9IHF1ZXJ5U3RyaW5nVG9TaWduXG5cbi8qKlxuICogUGVyZm9ybSB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlnbm9yZSBub24tYW1hem9uIGhlYWRlcnNcbiAqICAtIGxvd2VyY2FzZSBmaWVsZHNcbiAqICAtIHNvcnQgbGV4aWNvZ3JhcGhpY2FsbHlcbiAqICAtIHRyaW0gd2hpdGVzcGFjZSBiZXR3ZWVuIFwiOlwiXG4gKiAgLSBqb2luIHdpdGggbmV3bGluZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjYW5vbmljYWxpemVIZWFkZXJzIChoZWFkZXJzKSB7XG4gIHZhciBidWYgPSBbXVxuICAgICwgZmllbGRzID0gT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICA7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV1cbiAgICAgICwgdmFsID0gaGVhZGVyc1tmaWVsZF1cbiAgICAgICwgZmllbGQgPSBmaWVsZC50b0xvd2VyQ2FzZSgpXG4gICAgICA7XG4gICAgaWYgKDAgIT09IGZpZWxkLmluZGV4T2YoJ3gtYW16JykpIGNvbnRpbnVlXG4gICAgYnVmLnB1c2goZmllbGQgKyAnOicgKyB2YWwpXG4gIH1cbiAgcmV0dXJuIGJ1Zi5zb3J0KCkuam9pbignXFxuJylcbn1cbm1vZHVsZS5leHBvcnRzLmNhbm9uaWNhbGl6ZUhlYWRlcnMgPSBjYW5vbmljYWxpemVIZWFkZXJzXG5cbi8qKlxuICogUGVyZm9ybSB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlnbm9yZSBub24gc3ViLXJlc291cmNlc1xuICogIC0gc29ydCBsZXhpY29ncmFwaGljYWxseVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXNvdXJjZVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2Fub25pY2FsaXplUmVzb3VyY2UgKHJlc291cmNlKSB7XG4gIHZhciB1cmwgPSBwYXJzZShyZXNvdXJjZSwgdHJ1ZSlcbiAgICAsIHBhdGggPSB1cmwucGF0aG5hbWVcbiAgICAsIGJ1ZiA9IFtdXG4gICAgO1xuXG4gIE9iamVjdC5rZXlzKHVybC5xdWVyeSkuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgIGlmICghfmtleXMuaW5kZXhPZihrZXkpKSByZXR1cm5cbiAgICB2YXIgdmFsID0gJycgPT0gdXJsLnF1ZXJ5W2tleV0gPyAnJyA6ICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1cmwucXVlcnlba2V5XSlcbiAgICBidWYucHVzaChrZXkgKyB2YWwpXG4gIH0pXG5cbiAgcmV0dXJuIHBhdGggKyAoYnVmLmxlbmd0aCA/ICc/JyArIGJ1Zi5zb3J0KCkuam9pbignJicpIDogJycpXG59XG5tb2R1bGUuZXhwb3J0cy5jYW5vbmljYWxpemVSZXNvdXJjZSA9IGNhbm9uaWNhbGl6ZVJlc291cmNlXG4iLCJ2YXIgYXdzNCA9IGV4cG9ydHMsXG4gICAgdXJsID0gcmVxdWlyZSgndXJsJyksXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpLFxuICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpLFxuICAgIGxydSA9IHJlcXVpcmUoJy4vbHJ1JyksXG4gICAgY3JlZGVudGlhbHNDYWNoZSA9IGxydSgxMDAwKVxuXG4vLyBodHRwOi8vZG9jcy5hbWF6b253ZWJzZXJ2aWNlcy5jb20vZ2VuZXJhbC9sYXRlc3QvZ3Ivc2lnbmF0dXJlLXZlcnNpb24tNC5odG1sXG5cbmZ1bmN0aW9uIGhtYWMoa2V5LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KS51cGRhdGUoc3RyaW5nLCAndXRmOCcpLmRpZ2VzdChlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gaGFzaChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHN0cmluZywgJ3V0ZjgnKS5kaWdlc3QoZW5jb2RpbmcpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgc3RyaW5nIGhhcyBhbHJlYWR5IGJlZW4gcGVyY2VudCBlbmNvZGVkXG5mdW5jdGlvbiBlbmNvZGVSZmMzOTg2KHVybEVuY29kZWRTdHJpbmcpIHtcbiAgcmV0dXJuIHVybEVuY29kZWRTdHJpbmcucmVwbGFjZSgvWyEnKCkqXS9nLCBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vLyByZXF1ZXN0OiB7IHBhdGggfCBib2R5LCBbaG9zdF0sIFttZXRob2RdLCBbaGVhZGVyc10sIFtzZXJ2aWNlXSwgW3JlZ2lvbl0gfVxuLy8gY3JlZGVudGlhbHM6IHsgYWNjZXNzS2V5SWQsIHNlY3JldEFjY2Vzc0tleSwgW3Nlc3Npb25Ub2tlbl0gfVxuZnVuY3Rpb24gUmVxdWVzdFNpZ25lcihyZXF1ZXN0LCBjcmVkZW50aWFscykge1xuXG4gIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpIHJlcXVlc3QgPSB1cmwucGFyc2UocmVxdWVzdClcblxuICB2YXIgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycyA9IChyZXF1ZXN0LmhlYWRlcnMgfHwge30pLFxuICAgICAgaG9zdFBhcnRzID0gdGhpcy5tYXRjaEhvc3QocmVxdWVzdC5ob3N0bmFtZSB8fCByZXF1ZXN0Lmhvc3QgfHwgaGVhZGVycy5Ib3N0IHx8IGhlYWRlcnMuaG9zdClcblxuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscyB8fCB0aGlzLmRlZmF1bHRDcmVkZW50aWFscygpXG5cbiAgdGhpcy5zZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlIHx8IGhvc3RQYXJ0c1swXSB8fCAnJ1xuICB0aGlzLnJlZ2lvbiA9IHJlcXVlc3QucmVnaW9uIHx8IGhvc3RQYXJ0c1sxXSB8fCAndXMtZWFzdC0xJ1xuXG4gIC8vIFNFUyB1c2VzIGEgZGlmZmVyZW50IGRvbWFpbiBmcm9tIHRoZSBzZXJ2aWNlIG5hbWVcbiAgaWYgKHRoaXMuc2VydmljZSA9PT0gJ2VtYWlsJykgdGhpcy5zZXJ2aWNlID0gJ3NlcydcblxuICBpZiAoIXJlcXVlc3QubWV0aG9kICYmIHJlcXVlc3QuYm9keSlcbiAgICByZXF1ZXN0Lm1ldGhvZCA9ICdQT1NUJ1xuXG4gIGlmICghaGVhZGVycy5Ib3N0ICYmICFoZWFkZXJzLmhvc3QpIHtcbiAgICBoZWFkZXJzLkhvc3QgPSByZXF1ZXN0Lmhvc3RuYW1lIHx8IHJlcXVlc3QuaG9zdCB8fCB0aGlzLmNyZWF0ZUhvc3QoKVxuXG4gICAgLy8gSWYgYSBwb3J0IGlzIHNwZWNpZmllZCBleHBsaWNpdGx5LCB1c2UgaXQgYXMgaXNcbiAgICBpZiAocmVxdWVzdC5wb3J0KVxuICAgICAgaGVhZGVycy5Ib3N0ICs9ICc6JyArIHJlcXVlc3QucG9ydFxuICB9XG4gIGlmICghcmVxdWVzdC5ob3N0bmFtZSAmJiAhcmVxdWVzdC5ob3N0KVxuICAgIHJlcXVlc3QuaG9zdG5hbWUgPSBoZWFkZXJzLkhvc3QgfHwgaGVhZGVycy5ob3N0XG5cbiAgdGhpcy5pc0NvZGVDb21taXRHaXQgPSB0aGlzLnNlcnZpY2UgPT09ICdjb2RlY29tbWl0JyAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dJVCdcbn1cblxuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUubWF0Y2hIb3N0ID0gZnVuY3Rpb24oaG9zdCkge1xuICB2YXIgbWF0Y2ggPSAoaG9zdCB8fCAnJykubWF0Y2goLyhbXlxcLl0rKVxcLig/OihbXlxcLl0qKVxcLik/YW1hem9uYXdzXFwuY29tKFxcLmNuKT8kLylcbiAgdmFyIGhvc3RQYXJ0cyA9IChtYXRjaCB8fCBbXSkuc2xpY2UoMSwgMylcblxuICAvLyBFUydzIGhvc3RQYXJ0cyBhcmUgc29tZXRpbWVzIHRoZSBvdGhlciB3YXkgcm91bmQsIGlmIHRoZSB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkXG4gIC8vIHRvIGJlIHJlZ2lvbiBlcXVhbHMg4oCYZXPigJkgc3dpdGNoIHRoZW0gYmFja1xuICAvLyBlLmcuIHNlYXJjaC1jbHVzdGVyLW5hbWUtYWFhYTAwYWFhYTBhYWEwYWFhYWFhYTBhYWEudXMtZWFzdC0xLmVzLmFtYXpvbmF3cy5jb21cbiAgaWYgKGhvc3RQYXJ0c1sxXSA9PT0gJ2VzJylcbiAgICBob3N0UGFydHMgPSBob3N0UGFydHMucmV2ZXJzZSgpXG5cbiAgcmV0dXJuIGhvc3RQYXJ0c1xufVxuXG4vLyBodHRwOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9yYW5kZS5odG1sXG5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS5pc1NpbmdsZVJlZ2lvbiA9IGZ1bmN0aW9uKCkge1xuICAvLyBTcGVjaWFsIGNhc2UgZm9yIFMzIGFuZCBTaW1wbGVEQiBpbiB1cy1lYXN0LTFcbiAgaWYgKFsnczMnLCAnc2RiJ10uaW5kZXhPZih0aGlzLnNlcnZpY2UpID49IDAgJiYgdGhpcy5yZWdpb24gPT09ICd1cy1lYXN0LTEnKSByZXR1cm4gdHJ1ZVxuXG4gIHJldHVybiBbJ2Nsb3VkZnJvbnQnLCAnbHMnLCAncm91dGU1MycsICdpYW0nLCAnaW1wb3J0ZXhwb3J0JywgJ3N0cyddXG4gICAgLmluZGV4T2YodGhpcy5zZXJ2aWNlKSA+PSAwXG59XG5cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLmNyZWF0ZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlZ2lvbiA9IHRoaXMuaXNTaW5nbGVSZWdpb24oKSA/ICcnIDpcbiAgICAgICAgKHRoaXMuc2VydmljZSA9PT0gJ3MzJyAmJiB0aGlzLnJlZ2lvbiAhPT0gJ3VzLWVhc3QtMScgPyAnLScgOiAnLicpICsgdGhpcy5yZWdpb24sXG4gICAgICBzZXJ2aWNlID0gdGhpcy5zZXJ2aWNlID09PSAnc2VzJyA/ICdlbWFpbCcgOiB0aGlzLnNlcnZpY2VcbiAgcmV0dXJuIHNlcnZpY2UgKyByZWdpb24gKyAnLmFtYXpvbmF3cy5jb20nXG59XG5cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLnByZXBhcmVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGFyc2VQYXRoKClcblxuICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdCwgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycywgcXVlcnlcblxuICBpZiAocmVxdWVzdC5zaWduUXVlcnkpIHtcblxuICAgIHRoaXMucGFyc2VkUGF0aC5xdWVyeSA9IHF1ZXJ5ID0gdGhpcy5wYXJzZWRQYXRoLnF1ZXJ5IHx8IHt9XG5cbiAgICBpZiAodGhpcy5jcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pXG4gICAgICBxdWVyeVsnWC1BbXotU2VjdXJpdHktVG9rZW4nXSA9IHRoaXMuY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuXG5cbiAgICBpZiAodGhpcy5zZXJ2aWNlID09PSAnczMnICYmICFxdWVyeVsnWC1BbXotRXhwaXJlcyddKVxuICAgICAgcXVlcnlbJ1gtQW16LUV4cGlyZXMnXSA9IDg2NDAwXG5cbiAgICBpZiAocXVlcnlbJ1gtQW16LURhdGUnXSlcbiAgICAgIHRoaXMuZGF0ZXRpbWUgPSBxdWVyeVsnWC1BbXotRGF0ZSddXG4gICAgZWxzZVxuICAgICAgcXVlcnlbJ1gtQW16LURhdGUnXSA9IHRoaXMuZ2V0RGF0ZVRpbWUoKVxuXG4gICAgcXVlcnlbJ1gtQW16LUFsZ29yaXRobSddID0gJ0FXUzQtSE1BQy1TSEEyNTYnXG4gICAgcXVlcnlbJ1gtQW16LUNyZWRlbnRpYWwnXSA9IHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLycgKyB0aGlzLmNyZWRlbnRpYWxTdHJpbmcoKVxuICAgIHF1ZXJ5WydYLUFtei1TaWduZWRIZWFkZXJzJ10gPSB0aGlzLnNpZ25lZEhlYWRlcnMoKVxuXG4gIH0gZWxzZSB7XG5cbiAgICBpZiAoIXJlcXVlc3QuZG9Ob3RNb2RpZnlIZWFkZXJzICYmICF0aGlzLmlzQ29kZUNvbW1pdEdpdCkge1xuICAgICAgaWYgKHJlcXVlc3QuYm9keSAmJiAhaGVhZGVyc1snQ29udGVudC1UeXBlJ10gJiYgIWhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKVxuICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9dXRmLTgnXG5cbiAgICAgIGlmIChyZXF1ZXN0LmJvZHkgJiYgIWhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gJiYgIWhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pXG4gICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBCdWZmZXIuYnl0ZUxlbmd0aChyZXF1ZXN0LmJvZHkpXG5cbiAgICAgIGlmICh0aGlzLmNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbiAmJiAhaGVhZGVyc1snWC1BbXotU2VjdXJpdHktVG9rZW4nXSAmJiAhaGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSlcbiAgICAgICAgaGVhZGVyc1snWC1BbXotU2VjdXJpdHktVG9rZW4nXSA9IHRoaXMuY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuXG5cbiAgICAgIGlmICh0aGlzLnNlcnZpY2UgPT09ICdzMycgJiYgIWhlYWRlcnNbJ1gtQW16LUNvbnRlbnQtU2hhMjU2J10gJiYgIWhlYWRlcnNbJ3gtYW16LWNvbnRlbnQtc2hhMjU2J10pXG4gICAgICAgIGhlYWRlcnNbJ1gtQW16LUNvbnRlbnQtU2hhMjU2J10gPSBoYXNoKHRoaXMucmVxdWVzdC5ib2R5IHx8ICcnLCAnaGV4JylcblxuICAgICAgaWYgKGhlYWRlcnNbJ1gtQW16LURhdGUnXSB8fCBoZWFkZXJzWyd4LWFtei1kYXRlJ10pXG4gICAgICAgIHRoaXMuZGF0ZXRpbWUgPSBoZWFkZXJzWydYLUFtei1EYXRlJ10gfHwgaGVhZGVyc1sneC1hbXotZGF0ZSddXG4gICAgICBlbHNlXG4gICAgICAgIGhlYWRlcnNbJ1gtQW16LURhdGUnXSA9IHRoaXMuZ2V0RGF0ZVRpbWUoKVxuICAgIH1cblxuICAgIGRlbGV0ZSBoZWFkZXJzLkF1dGhvcml6YXRpb25cbiAgICBkZWxldGUgaGVhZGVycy5hdXRob3JpemF0aW9uXG4gIH1cbn1cblxuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMucGFyc2VkUGF0aCkgdGhpcy5wcmVwYXJlUmVxdWVzdCgpXG5cbiAgaWYgKHRoaXMucmVxdWVzdC5zaWduUXVlcnkpIHtcbiAgICB0aGlzLnBhcnNlZFBhdGgucXVlcnlbJ1gtQW16LVNpZ25hdHVyZSddID0gdGhpcy5zaWduYXR1cmUoKVxuICB9IGVsc2Uge1xuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSB0aGlzLmF1dGhIZWFkZXIoKVxuICB9XG5cbiAgdGhpcy5yZXF1ZXN0LnBhdGggPSB0aGlzLmZvcm1hdFBhdGgoKVxuXG4gIHJldHVybiB0aGlzLnJlcXVlc3Rcbn1cblxuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUuZ2V0RGF0ZVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmRhdGV0aW1lKSB7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLnJlcXVlc3QuaGVhZGVycyxcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShoZWFkZXJzLkRhdGUgfHwgaGVhZGVycy5kYXRlIHx8IG5ldyBEYXRlKVxuXG4gICAgdGhpcy5kYXRldGltZSA9IGRhdGUudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bOlxcLV18XFwuXFxkezN9L2csICcnKVxuXG4gICAgLy8gUmVtb3ZlIHRoZSB0cmFpbGluZyAnWicgb24gdGhlIHRpbWVzdGFtcCBzdHJpbmcgZm9yIENvZGVDb21taXQgZ2l0IGFjY2Vzc1xuICAgIGlmICh0aGlzLmlzQ29kZUNvbW1pdEdpdCkgdGhpcy5kYXRldGltZSA9IHRoaXMuZGF0ZXRpbWUuc2xpY2UoMCwgLTEpXG4gIH1cbiAgcmV0dXJuIHRoaXMuZGF0ZXRpbWVcbn1cblxuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUuZ2V0RGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5nZXREYXRlVGltZSgpLnN1YnN0cigwLCA4KVxufVxuXG5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS5hdXRoSGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbXG4gICAgJ0FXUzQtSE1BQy1TSEEyNTYgQ3JlZGVudGlhbD0nICsgdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICcvJyArIHRoaXMuY3JlZGVudGlhbFN0cmluZygpLFxuICAgICdTaWduZWRIZWFkZXJzPScgKyB0aGlzLnNpZ25lZEhlYWRlcnMoKSxcbiAgICAnU2lnbmF0dXJlPScgKyB0aGlzLnNpZ25hdHVyZSgpLFxuICBdLmpvaW4oJywgJylcbn1cblxuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUuc2lnbmF0dXJlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRlID0gdGhpcy5nZXREYXRlKCksXG4gICAgICBjYWNoZUtleSA9IFt0aGlzLmNyZWRlbnRpYWxzLnNlY3JldEFjY2Vzc0tleSwgZGF0ZSwgdGhpcy5yZWdpb24sIHRoaXMuc2VydmljZV0uam9pbigpLFxuICAgICAga0RhdGUsIGtSZWdpb24sIGtTZXJ2aWNlLCBrQ3JlZGVudGlhbHMgPSBjcmVkZW50aWFsc0NhY2hlLmdldChjYWNoZUtleSlcbiAgaWYgKCFrQ3JlZGVudGlhbHMpIHtcbiAgICBrRGF0ZSA9IGhtYWMoJ0FXUzQnICsgdGhpcy5jcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksIGRhdGUpXG4gICAga1JlZ2lvbiA9IGhtYWMoa0RhdGUsIHRoaXMucmVnaW9uKVxuICAgIGtTZXJ2aWNlID0gaG1hYyhrUmVnaW9uLCB0aGlzLnNlcnZpY2UpXG4gICAga0NyZWRlbnRpYWxzID0gaG1hYyhrU2VydmljZSwgJ2F3czRfcmVxdWVzdCcpXG4gICAgY3JlZGVudGlhbHNDYWNoZS5zZXQoY2FjaGVLZXksIGtDcmVkZW50aWFscylcbiAgfVxuICByZXR1cm4gaG1hYyhrQ3JlZGVudGlhbHMsIHRoaXMuc3RyaW5nVG9TaWduKCksICdoZXgnKVxufVxuXG5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS5zdHJpbmdUb1NpZ24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtcbiAgICAnQVdTNC1ITUFDLVNIQTI1NicsXG4gICAgdGhpcy5nZXREYXRlVGltZSgpLFxuICAgIHRoaXMuY3JlZGVudGlhbFN0cmluZygpLFxuICAgIGhhc2godGhpcy5jYW5vbmljYWxTdHJpbmcoKSwgJ2hleCcpLFxuICBdLmpvaW4oJ1xcbicpXG59XG5cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLmNhbm9uaWNhbFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMucGFyc2VkUGF0aCkgdGhpcy5wcmVwYXJlUmVxdWVzdCgpXG5cbiAgdmFyIHBhdGhTdHIgPSB0aGlzLnBhcnNlZFBhdGgucGF0aCxcbiAgICAgIHF1ZXJ5ID0gdGhpcy5wYXJzZWRQYXRoLnF1ZXJ5LFxuICAgICAgaGVhZGVycyA9IHRoaXMucmVxdWVzdC5oZWFkZXJzLFxuICAgICAgcXVlcnlTdHIgPSAnJyxcbiAgICAgIG5vcm1hbGl6ZVBhdGggPSB0aGlzLnNlcnZpY2UgIT09ICdzMycsXG4gICAgICBkZWNvZGVQYXRoID0gdGhpcy5zZXJ2aWNlID09PSAnczMnIHx8IHRoaXMucmVxdWVzdC5kb05vdEVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVTbGFzaGVzSW5QYXRoID0gdGhpcy5zZXJ2aWNlID09PSAnczMnLFxuICAgICAgZmlyc3RWYWxPbmx5ID0gdGhpcy5zZXJ2aWNlID09PSAnczMnLFxuICAgICAgYm9keUhhc2hcblxuICBpZiAodGhpcy5zZXJ2aWNlID09PSAnczMnICYmIHRoaXMucmVxdWVzdC5zaWduUXVlcnkpIHtcbiAgICBib2R5SGFzaCA9ICdVTlNJR05FRC1QQVlMT0FEJ1xuICB9IGVsc2UgaWYgKHRoaXMuaXNDb2RlQ29tbWl0R2l0KSB7XG4gICAgYm9keUhhc2ggPSAnJ1xuICB9IGVsc2Uge1xuICAgIGJvZHlIYXNoID0gaGVhZGVyc1snWC1BbXotQ29udGVudC1TaGEyNTYnXSB8fCBoZWFkZXJzWyd4LWFtei1jb250ZW50LXNoYTI1NiddIHx8XG4gICAgICBoYXNoKHRoaXMucmVxdWVzdC5ib2R5IHx8ICcnLCAnaGV4JylcbiAgfVxuXG4gIGlmIChxdWVyeSkge1xuICAgIHF1ZXJ5U3RyID0gZW5jb2RlUmZjMzk4NihxdWVyeXN0cmluZy5zdHJpbmdpZnkoT2JqZWN0LmtleXMocXVlcnkpLnNvcnQoKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICAgIGlmICgha2V5KSByZXR1cm4gb2JqXG4gICAgICBvYmpba2V5XSA9ICFBcnJheS5pc0FycmF5KHF1ZXJ5W2tleV0pID8gcXVlcnlba2V5XSA6XG4gICAgICAgIChmaXJzdFZhbE9ubHkgPyBxdWVyeVtrZXldWzBdIDogcXVlcnlba2V5XS5zbGljZSgpLnNvcnQoKSlcbiAgICAgIHJldHVybiBvYmpcbiAgICB9LCB7fSkpKVxuICB9XG4gIGlmIChwYXRoU3RyICE9PSAnLycpIHtcbiAgICBpZiAobm9ybWFsaXplUGF0aCkgcGF0aFN0ciA9IHBhdGhTdHIucmVwbGFjZSgvXFwvezIsfS9nLCAnLycpXG4gICAgcGF0aFN0ciA9IHBhdGhTdHIuc3BsaXQoJy8nKS5yZWR1Y2UoZnVuY3Rpb24ocGF0aCwgcGllY2UpIHtcbiAgICAgIGlmIChub3JtYWxpemVQYXRoICYmIHBpZWNlID09PSAnLi4nKSB7XG4gICAgICAgIHBhdGgucG9wKClcbiAgICAgIH0gZWxzZSBpZiAoIW5vcm1hbGl6ZVBhdGggfHwgcGllY2UgIT09ICcuJykge1xuICAgICAgICBpZiAoZGVjb2RlUGF0aCkgcGllY2UgPSBkZWNvZGVVUklDb21wb25lbnQocGllY2UpXG4gICAgICAgIHBhdGgucHVzaChlbmNvZGVSZmMzOTg2KGVuY29kZVVSSUNvbXBvbmVudChwaWVjZSkpKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGhcbiAgICB9LCBbXSkuam9pbignLycpXG4gICAgaWYgKHBhdGhTdHJbMF0gIT09ICcvJykgcGF0aFN0ciA9ICcvJyArIHBhdGhTdHJcbiAgICBpZiAoZGVjb2RlU2xhc2hlc0luUGF0aCkgcGF0aFN0ciA9IHBhdGhTdHIucmVwbGFjZSgvJTJGL2csICcvJylcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgdGhpcy5yZXF1ZXN0Lm1ldGhvZCB8fCAnR0VUJyxcbiAgICBwYXRoU3RyLFxuICAgIHF1ZXJ5U3RyLFxuICAgIHRoaXMuY2Fub25pY2FsSGVhZGVycygpICsgJ1xcbicsXG4gICAgdGhpcy5zaWduZWRIZWFkZXJzKCksXG4gICAgYm9keUhhc2gsXG4gIF0uam9pbignXFxuJylcbn1cblxuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUuY2Fub25pY2FsSGVhZGVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGVhZGVycyA9IHRoaXMucmVxdWVzdC5oZWFkZXJzXG4gIGZ1bmN0aW9uIHRyaW1BbGwoaGVhZGVyKSB7XG4gICAgcmV0dXJuIGhlYWRlci50b1N0cmluZygpLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLnRvTG93ZXJDYXNlKCkgPCBiLnRvTG93ZXJDYXNlKCkgPyAtMSA6IDEgfSlcbiAgICAubWFwKGZ1bmN0aW9uKGtleSkgeyByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgKyAnOicgKyB0cmltQWxsKGhlYWRlcnNba2V5XSkgfSlcbiAgICAuam9pbignXFxuJylcbn1cblxuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUuc2lnbmVkSGVhZGVycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZXF1ZXN0LmhlYWRlcnMpXG4gICAgLm1hcChmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpIH0pXG4gICAgLnNvcnQoKVxuICAgIC5qb2luKCc7Jylcbn1cblxuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUuY3JlZGVudGlhbFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gW1xuICAgIHRoaXMuZ2V0RGF0ZSgpLFxuICAgIHRoaXMucmVnaW9uLFxuICAgIHRoaXMuc2VydmljZSxcbiAgICAnYXdzNF9yZXF1ZXN0JyxcbiAgXS5qb2luKCcvJylcbn1cblxuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUuZGVmYXVsdENyZWRlbnRpYWxzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbnYgPSBwcm9jZXNzLmVudlxuICByZXR1cm4ge1xuICAgIGFjY2Vzc0tleUlkOiBlbnYuQVdTX0FDQ0VTU19LRVlfSUQgfHwgZW52LkFXU19BQ0NFU1NfS0VZLFxuICAgIHNlY3JldEFjY2Vzc0tleTogZW52LkFXU19TRUNSRVRfQUNDRVNTX0tFWSB8fCBlbnYuQVdTX1NFQ1JFVF9LRVksXG4gICAgc2Vzc2lvblRva2VuOiBlbnYuQVdTX1NFU1NJT05fVE9LRU4sXG4gIH1cbn1cblxuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUucGFyc2VQYXRoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRoID0gdGhpcy5yZXF1ZXN0LnBhdGggfHwgJy8nLFxuICAgICAgcXVlcnlJeCA9IHBhdGguaW5kZXhPZignPycpLFxuICAgICAgcXVlcnkgPSBudWxsXG5cbiAgaWYgKHF1ZXJ5SXggPj0gMCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UocGF0aC5zbGljZShxdWVyeUl4ICsgMSkpXG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJeClcbiAgfVxuXG4gIC8vIFMzIGRvZXNuJ3QgYWx3YXlzIGVuY29kZSBjaGFyYWN0ZXJzID4gMTI3IGNvcnJlY3RseSBhbmRcbiAgLy8gYWxsIHNlcnZpY2VzIGRvbid0IGVuY29kZSBjaGFyYWN0ZXJzID4gMjU1IGNvcnJlY3RseVxuICAvLyBTbyBpZiB0aGVyZSBhcmUgbm9uLXJlc2VydmVkIGNoYXJzIChhbmQgaXQncyBub3QgYWxyZWFkeSBhbGwgJSBlbmNvZGVkKSwganVzdCBlbmNvZGUgdGhlbSBhbGxcbiAgaWYgKC9bXjAtOUEtWmEteiEnKCkqXFwtLl9+JS9dLy50ZXN0KHBhdGgpKSB7XG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJy8nKS5tYXAoZnVuY3Rpb24ocGllY2UpIHtcbiAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHBpZWNlKSlcbiAgICB9KS5qb2luKCcvJylcbiAgfVxuXG4gIHRoaXMucGFyc2VkUGF0aCA9IHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgfVxufVxuXG5SZXF1ZXN0U2lnbmVyLnByb3RvdHlwZS5mb3JtYXRQYXRoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRoID0gdGhpcy5wYXJzZWRQYXRoLnBhdGgsXG4gICAgICBxdWVyeSA9IHRoaXMucGFyc2VkUGF0aC5xdWVyeVxuXG4gIGlmICghcXVlcnkpIHJldHVybiBwYXRoXG5cbiAgLy8gU2VydmljZXMgZG9uJ3Qgc3VwcG9ydCBlbXB0eSBxdWVyeSBzdHJpbmcga2V5c1xuICBpZiAocXVlcnlbJyddICE9IG51bGwpIGRlbGV0ZSBxdWVyeVsnJ11cblxuICByZXR1cm4gcGF0aCArICc/JyArIGVuY29kZVJmYzM5ODYocXVlcnlzdHJpbmcuc3RyaW5naWZ5KHF1ZXJ5KSlcbn1cblxuYXdzNC5SZXF1ZXN0U2lnbmVyID0gUmVxdWVzdFNpZ25lclxuXG5hd3M0LnNpZ24gPSBmdW5jdGlvbihyZXF1ZXN0LCBjcmVkZW50aWFscykge1xuICByZXR1cm4gbmV3IFJlcXVlc3RTaWduZXIocmVxdWVzdCwgY3JlZGVudGlhbHMpLnNpZ24oKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzaXplKSB7XG4gIHJldHVybiBuZXcgTHJ1Q2FjaGUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gTHJ1Q2FjaGUoc2l6ZSkge1xuICB0aGlzLmNhcGFjaXR5ID0gc2l6ZSB8IDBcbiAgdGhpcy5tYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHRoaXMubGlzdCA9IG5ldyBEb3VibHlMaW5rZWRMaXN0KClcbn1cblxuTHJ1Q2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgbm9kZSA9IHRoaXMubWFwW2tleV1cbiAgaWYgKG5vZGUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZFxuICB0aGlzLnVzZWQobm9kZSlcbiAgcmV0dXJuIG5vZGUudmFsXG59XG5cbkxydUNhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbCkge1xuICB2YXIgbm9kZSA9IHRoaXMubWFwW2tleV1cbiAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgIG5vZGUudmFsID0gdmFsXG4gIH0gZWxzZSB7XG4gICAgaWYgKCF0aGlzLmNhcGFjaXR5KSB0aGlzLnBydW5lKClcbiAgICBpZiAoIXRoaXMuY2FwYWNpdHkpIHJldHVybiBmYWxzZVxuICAgIG5vZGUgPSBuZXcgRG91Ymx5TGlua2VkTm9kZShrZXksIHZhbClcbiAgICB0aGlzLm1hcFtrZXldID0gbm9kZVxuICAgIHRoaXMuY2FwYWNpdHktLVxuICB9XG4gIHRoaXMudXNlZChub2RlKVxuICByZXR1cm4gdHJ1ZVxufVxuXG5McnVDYWNoZS5wcm90b3R5cGUudXNlZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5saXN0Lm1vdmVUb0Zyb250KG5vZGUpXG59XG5cbkxydUNhY2hlLnByb3RvdHlwZS5wcnVuZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMubGlzdC5wb3AoKVxuICBpZiAobm9kZSAhPSBudWxsKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vZGUua2V5XVxuICAgIHRoaXMuY2FwYWNpdHkrK1xuICB9XG59XG5cblxuZnVuY3Rpb24gRG91Ymx5TGlua2VkTGlzdCgpIHtcbiAgdGhpcy5maXJzdE5vZGUgPSBudWxsXG4gIHRoaXMubGFzdE5vZGUgPSBudWxsXG59XG5cbkRvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLm1vdmVUb0Zyb250ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAodGhpcy5maXJzdE5vZGUgPT0gbm9kZSkgcmV0dXJuXG5cbiAgdGhpcy5yZW1vdmUobm9kZSlcblxuICBpZiAodGhpcy5maXJzdE5vZGUgPT0gbnVsbCkge1xuICAgIHRoaXMuZmlyc3ROb2RlID0gbm9kZVxuICAgIHRoaXMubGFzdE5vZGUgPSBub2RlXG4gICAgbm9kZS5wcmV2ID0gbnVsbFxuICAgIG5vZGUubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICBub2RlLnByZXYgPSBudWxsXG4gICAgbm9kZS5uZXh0ID0gdGhpcy5maXJzdE5vZGVcbiAgICBub2RlLm5leHQucHJldiA9IG5vZGVcbiAgICB0aGlzLmZpcnN0Tm9kZSA9IG5vZGVcbiAgfVxufVxuXG5Eb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxhc3ROb2RlID0gdGhpcy5sYXN0Tm9kZVxuICBpZiAobGFzdE5vZGUgIT0gbnVsbCkge1xuICAgIHRoaXMucmVtb3ZlKGxhc3ROb2RlKVxuICB9XG4gIHJldHVybiBsYXN0Tm9kZVxufVxuXG5Eb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICh0aGlzLmZpcnN0Tm9kZSA9PSBub2RlKSB7XG4gICAgdGhpcy5maXJzdE5vZGUgPSBub2RlLm5leHRcbiAgfSBlbHNlIGlmIChub2RlLnByZXYgIT0gbnVsbCkge1xuICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0XG4gIH1cbiAgaWYgKHRoaXMubGFzdE5vZGUgPT0gbm9kZSkge1xuICAgIHRoaXMubGFzdE5vZGUgPSBub2RlLnByZXZcbiAgfSBlbHNlIGlmIChub2RlLm5leHQgIT0gbnVsbCkge1xuICAgIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBEb3VibHlMaW5rZWROb2RlKGtleSwgdmFsKSB7XG4gIHRoaXMua2V5ID0ga2V5XG4gIHRoaXMudmFsID0gdmFsXG4gIHRoaXMucHJldiA9IG51bGxcbiAgdGhpcy5uZXh0ID0gbnVsbFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3J5cHRvX2hhc2hfc2hhNTEyID0gcmVxdWlyZSgndHdlZXRuYWNsJykubG93bGV2ZWwuY3J5cHRvX2hhc2g7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaXMgYSAxOjEgcG9ydCBmcm9tIHRoZSBPcGVuQlNEIGJsb3dmaXNoLmMgYW5kIGJjcnlwdF9wYmtkZi5jLiBBcyBhXG4gKiByZXN1bHQsIGl0IHJldGFpbnMgdGhlIG9yaWdpbmFsIGNvcHlyaWdodCBhbmQgbGljZW5zZS4gVGhlIHR3byBmaWxlcyBhcmVcbiAqIHVuZGVyIHNsaWdodGx5IGRpZmZlcmVudCAoYnV0IGNvbXBhdGlibGUpIGxpY2Vuc2VzLCBhbmQgYXJlIGhlcmUgY29tYmluZWQgaW5cbiAqIG9uZSBmaWxlLlxuICpcbiAqIENyZWRpdCBmb3IgdGhlIGFjdHVhbCBwb3J0aW5nIHdvcmsgZ29lcyB0bzpcbiAqICBEZXZpIE1hbmRpcmkgPG1lQGRldmkud2ViLmlkPlxuICovXG5cbi8qXG4gKiBUaGUgQmxvd2Zpc2ggcG9ydGlvbnMgYXJlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqXG4gKiBCbG93ZmlzaCBibG9jayBjaXBoZXIgZm9yIE9wZW5CU0RcbiAqIENvcHlyaWdodCAxOTk3IE5pZWxzIFByb3ZvcyA8cHJvdm9zQHBoeXNuZXQudW5pLWhhbWJ1cmcuZGU+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIEltcGxlbWVudGF0aW9uIGFkdmljZSBieSBEYXZpZCBNYXppZXJlcyA8ZG1AbGNzLm1pdC5lZHU+LlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogMy4gVGhlIG5hbWUgb2YgdGhlIGF1dGhvciBtYXkgbm90IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXG4gKiAgICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBBVVRIT1IgYGBBUyBJUycnIEFORCBBTlkgRVhQUkVTUyBPUlxuICogSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCxcbiAqIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAqIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLypcbiAqIFRoZSBiY3J5cHRfcGJrZGYgcG9ydGlvbnMgYXJlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGVkIFVuYW5nc3QgPHRlZHVAb3BlbmJzZC5vcmc+XG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqL1xuXG4vKlxuICogUGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRzIChKYXZhc2NyaXB0LXNwZWNpZmljKTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNiwgSm95ZW50IEluY1xuICogQXV0aG9yOiBBbGV4IFdpbHNvbiA8YWxleC53aWxzb25Aam95ZW50LmNvbT5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICovXG5cbi8vIFBvcnRlZCBmcm9tIE9wZW5CU0QgYmNyeXB0X3Bia2RmLmMgdjEuOVxuXG52YXIgQkxGX0ogPSAwO1xuXG52YXIgQmxvd2Zpc2ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5TID0gW1xuICAgIG5ldyBVaW50MzJBcnJheShbXG4gICAgICAweGQxMzEwYmE2LCAweDk4ZGZiNWFjLCAweDJmZmQ3MmRiLCAweGQwMWFkZmI3LFxuICAgICAgMHhiOGUxYWZlZCwgMHg2YTI2N2U5NiwgMHhiYTdjOTA0NSwgMHhmMTJjN2Y5OSxcbiAgICAgIDB4MjRhMTk5NDcsIDB4YjM5MTZjZjcsIDB4MDgwMWYyZTIsIDB4ODU4ZWZjMTYsXG4gICAgICAweDYzNjkyMGQ4LCAweDcxNTc0ZTY5LCAweGE0NThmZWEzLCAweGY0OTMzZDdlLFxuICAgICAgMHgwZDk1NzQ4ZiwgMHg3MjhlYjY1OCwgMHg3MThiY2Q1OCwgMHg4MjE1NGFlZSxcbiAgICAgIDB4N2I1NGE0MWQsIDB4YzI1YTU5YjUsIDB4OWMzMGQ1MzksIDB4MmFmMjYwMTMsXG4gICAgICAweGM1ZDFiMDIzLCAweDI4NjA4NWYwLCAweGNhNDE3OTE4LCAweGI4ZGIzOGVmLFxuICAgICAgMHg4ZTc5ZGNiMCwgMHg2MDNhMTgwZSwgMHg2YzllMGU4YiwgMHhiMDFlOGEzZSxcbiAgICAgIDB4ZDcxNTc3YzEsIDB4YmQzMTRiMjcsIDB4NzhhZjJmZGEsIDB4NTU2MDVjNjAsXG4gICAgICAweGU2NTUyNWYzLCAweGFhNTVhYjk0LCAweDU3NDg5ODYyLCAweDYzZTgxNDQwLFxuICAgICAgMHg1NWNhMzk2YSwgMHgyYWFiMTBiNiwgMHhiNGNjNWMzNCwgMHgxMTQxZThjZSxcbiAgICAgIDB4YTE1NDg2YWYsIDB4N2M3MmU5OTMsIDB4YjNlZTE0MTEsIDB4NjM2ZmJjMmEsXG4gICAgICAweDJiYTljNTVkLCAweDc0MTgzMWY2LCAweGNlNWMzZTE2LCAweDliODc5MzFlLFxuICAgICAgMHhhZmQ2YmEzMywgMHg2YzI0Y2Y1YywgMHg3YTMyNTM4MSwgMHgyODk1ODY3NyxcbiAgICAgIDB4M2I4ZjQ4OTgsIDB4NmI0YmI5YWYsIDB4YzRiZmU4MWIsIDB4NjYyODIxOTMsXG4gICAgICAweDYxZDgwOWNjLCAweGZiMjFhOTkxLCAweDQ4N2NhYzYwLCAweDVkZWM4MDMyLFxuICAgICAgMHhlZjg0NWQ1ZCwgMHhlOTg1NzViMSwgMHhkYzI2MjMwMiwgMHhlYjY1MWI4OCxcbiAgICAgIDB4MjM4OTNlODEsIDB4ZDM5NmFjYzUsIDB4MGY2ZDZmZjMsIDB4ODNmNDQyMzksXG4gICAgICAweDJlMGI0NDgyLCAweGE0ODQyMDA0LCAweDY5YzhmMDRhLCAweDllMWY5YjVlLFxuICAgICAgMHgyMWM2Njg0MiwgMHhmNmU5NmM5YSwgMHg2NzBjOWM2MSwgMHhhYmQzODhmMCxcbiAgICAgIDB4NmE1MWEwZDIsIDB4ZDg1NDJmNjgsIDB4OTYwZmE3MjgsIDB4YWI1MTMzYTMsXG4gICAgICAweDZlZWYwYjZjLCAweDEzN2EzYmU0LCAweGJhM2JmMDUwLCAweDdlZmIyYTk4LFxuICAgICAgMHhhMWYxNjUxZCwgMHgzOWFmMDE3NiwgMHg2NmNhNTkzZSwgMHg4MjQzMGU4OCxcbiAgICAgIDB4OGNlZTg2MTksIDB4NDU2ZjlmYjQsIDB4N2Q4NGE1YzMsIDB4M2I4YjVlYmUsXG4gICAgICAweGUwNmY3NWQ4LCAweDg1YzEyMDczLCAweDQwMWE0NDlmLCAweDU2YzE2YWE2LFxuICAgICAgMHg0ZWQzYWE2MiwgMHgzNjNmNzcwNiwgMHgxYmZlZGY3MiwgMHg0MjliMDIzZCxcbiAgICAgIDB4MzdkMGQ3MjQsIDB4ZDAwYTEyNDgsIDB4ZGIwZmVhZDMsIDB4NDlmMWMwOWIsXG4gICAgICAweDA3NTM3MmM5LCAweDgwOTkxYjdiLCAweDI1ZDQ3OWQ4LCAweGY2ZThkZWY3LFxuICAgICAgMHhlM2ZlNTAxYSwgMHhiNjc5NGMzYiwgMHg5NzZjZTBiZCwgMHgwNGMwMDZiYSxcbiAgICAgIDB4YzFhOTRmYjYsIDB4NDA5ZjYwYzQsIDB4NWU1YzllYzIsIDB4MTk2YTI0NjMsXG4gICAgICAweDY4ZmI2ZmFmLCAweDNlNmM1M2I1LCAweDEzMzliMmViLCAweDNiNTJlYzZmLFxuICAgICAgMHg2ZGZjNTExZiwgMHg5YjMwOTUyYywgMHhjYzgxNDU0NCwgMHhhZjVlYmQwOSxcbiAgICAgIDB4YmVlM2QwMDQsIDB4ZGUzMzRhZmQsIDB4NjYwZjI4MDcsIDB4MTkyZTRiYjMsXG4gICAgICAweGMwY2JhODU3LCAweDQ1Yzg3NDBmLCAweGQyMGI1ZjM5LCAweGI5ZDNmYmRiLFxuICAgICAgMHg1NTc5YzBiZCwgMHgxYTYwMzIwYSwgMHhkNmExMDBjNiwgMHg0MDJjNzI3OSxcbiAgICAgIDB4Njc5ZjI1ZmUsIDB4ZmIxZmEzY2MsIDB4OGVhNWU5ZjgsIDB4ZGIzMjIyZjgsXG4gICAgICAweDNjNzUxNmRmLCAweGZkNjE2YjE1LCAweDJmNTAxZWM4LCAweGFkMDU1MmFiLFxuICAgICAgMHgzMjNkYjVmYSwgMHhmZDIzODc2MCwgMHg1MzMxN2I0OCwgMHgzZTAwZGY4MixcbiAgICAgIDB4OWU1YzU3YmIsIDB4Y2E2ZjhjYTAsIDB4MWE4NzU2MmUsIDB4ZGYxNzY5ZGIsXG4gICAgICAweGQ1NDJhOGY2LCAweDI4N2VmZmMzLCAweGFjNjczMmM2LCAweDhjNGY1NTczLFxuICAgICAgMHg2OTViMjdiMCwgMHhiYmNhNThjOCwgMHhlMWZmYTM1ZCwgMHhiOGYwMTFhMCxcbiAgICAgIDB4MTBmYTNkOTgsIDB4ZmQyMTgzYjgsIDB4NGFmY2I1NmMsIDB4MmRkMWQzNWIsXG4gICAgICAweDlhNTNlNDc5LCAweGI2Zjg0NTY1LCAweGQyOGU0OWJjLCAweDRiZmI5NzkwLFxuICAgICAgMHhlMWRkZjJkYSwgMHhhNGNiN2UzMywgMHg2MmZiMTM0MSwgMHhjZWU0YzZlOCxcbiAgICAgIDB4ZWYyMGNhZGEsIDB4MzY3NzRjMDEsIDB4ZDA3ZTllZmUsIDB4MmJmMTFmYjQsXG4gICAgICAweDk1ZGJkYTRkLCAweGFlOTA5MTk4LCAweGVhYWQ4ZTcxLCAweDZiOTNkNWEwLFxuICAgICAgMHhkMDhlZDFkMCwgMHhhZmM3MjVlMCwgMHg4ZTNjNWIyZiwgMHg4ZTc1OTRiNyxcbiAgICAgIDB4OGZmNmUyZmIsIDB4ZjIxMjJiNjQsIDB4ODg4OGI4MTIsIDB4OTAwZGYwMWMsXG4gICAgICAweDRmYWQ1ZWEwLCAweDY4OGZjMzFjLCAweGQxY2ZmMTkxLCAweGIzYThjMWFkLFxuICAgICAgMHgyZjJmMjIxOCwgMHhiZTBlMTc3NywgMHhlYTc1MmRmZSwgMHg4YjAyMWZhMSxcbiAgICAgIDB4ZTVhMGNjMGYsIDB4YjU2Zjc0ZTgsIDB4MThhY2YzZDYsIDB4Y2U4OWUyOTksXG4gICAgICAweGI0YTg0ZmUwLCAweGZkMTNlMGI3LCAweDdjYzQzYjgxLCAweGQyYWRhOGQ5LFxuICAgICAgMHgxNjVmYTI2NiwgMHg4MDk1NzcwNSwgMHg5M2NjNzMxNCwgMHgyMTFhMTQ3NyxcbiAgICAgIDB4ZTZhZDIwNjUsIDB4NzdiNWZhODYsIDB4Yzc1NDQyZjUsIDB4ZmI5ZDM1Y2YsXG4gICAgICAweGViY2RhZjBjLCAweDdiM2U4OWEwLCAweGQ2NDExYmQzLCAweGFlMWU3ZTQ5LFxuICAgICAgMHgwMDI1MGUyZCwgMHgyMDcxYjM1ZSwgMHgyMjY4MDBiYiwgMHg1N2I4ZTBhZixcbiAgICAgIDB4MjQ2NDM2OWIsIDB4ZjAwOWI5MWUsIDB4NTU2MzkxMWQsIDB4NTlkZmE2YWEsXG4gICAgICAweDc4YzE0Mzg5LCAweGQ5NWE1MzdmLCAweDIwN2Q1YmEyLCAweDAyZTViOWM1LFxuICAgICAgMHg4MzI2MDM3NiwgMHg2Mjk1Y2ZhOSwgMHgxMWM4MTk2OCwgMHg0ZTczNGE0MSxcbiAgICAgIDB4YjM0NzJkY2EsIDB4N2IxNGE5NGEsIDB4MWI1MTAwNTIsIDB4OWE1MzI5MTUsXG4gICAgICAweGQ2MGY1NzNmLCAweGJjOWJjNmU0LCAweDJiNjBhNDc2LCAweDgxZTY3NDAwLFxuICAgICAgMHgwOGJhNmZiNSwgMHg1NzFiZTkxZiwgMHhmMjk2ZWM2YiwgMHgyYTBkZDkxNSxcbiAgICAgIDB4YjY2MzY1MjEsIDB4ZTdiOWY5YjYsIDB4ZmYzNDA1MmUsIDB4YzU4NTU2NjQsXG4gICAgICAweDUzYjAyZDVkLCAweGE5OWY4ZmExLCAweDA4YmE0Nzk5LCAweDZlODUwNzZhXSksXG4gICAgbmV3IFVpbnQzMkFycmF5KFtcbiAgICAgIDB4NGI3YTcwZTksIDB4YjViMzI5NDQsIDB4ZGI3NTA5MmUsIDB4YzQxOTI2MjMsXG4gICAgICAweGFkNmVhNmIwLCAweDQ5YTdkZjdkLCAweDljZWU2MGI4LCAweDhmZWRiMjY2LFxuICAgICAgMHhlY2FhOGM3MSwgMHg2OTlhMTdmZiwgMHg1NjY0NTI2YywgMHhjMmIxOWVlMSxcbiAgICAgIDB4MTkzNjAyYTUsIDB4NzUwOTRjMjksIDB4YTA1OTEzNDAsIDB4ZTQxODNhM2UsXG4gICAgICAweDNmNTQ5ODlhLCAweDViNDI5ZDY1LCAweDZiOGZlNGQ2LCAweDk5ZjczZmQ2LFxuICAgICAgMHhhMWQyOWMwNywgMHhlZmU4MzBmNSwgMHg0ZDJkMzhlNiwgMHhmMDI1NWRjMSxcbiAgICAgIDB4NGNkZDIwODYsIDB4ODQ3MGViMjYsIDB4NjM4MmU5YzYsIDB4MDIxZWNjNWUsXG4gICAgICAweDA5Njg2YjNmLCAweDNlYmFlZmM5LCAweDNjOTcxODE0LCAweDZiNmE3MGExLFxuICAgICAgMHg2ODdmMzU4NCwgMHg1MmEwZTI4NiwgMHhiNzljNTMwNSwgMHhhYTUwMDczNyxcbiAgICAgIDB4M2UwNzg0MWMsIDB4N2ZkZWFlNWMsIDB4OGU3ZDQ0ZWMsIDB4NTcxNmYyYjgsXG4gICAgICAweGIwM2FkYTM3LCAweGYwNTAwYzBkLCAweGYwMWMxZjA0LCAweDAyMDBiM2ZmLFxuICAgICAgMHhhZTBjZjUxYSwgMHgzY2I1NzRiMiwgMHgyNTgzN2E1OCwgMHhkYzA5MjFiZCxcbiAgICAgIDB4ZDE5MTEzZjksIDB4N2NhOTJmZjYsIDB4OTQzMjQ3NzMsIDB4MjJmNTQ3MDEsXG4gICAgICAweDNhZTVlNTgxLCAweDM3YzJkYWRjLCAweGM4YjU3NjM0LCAweDlhZjNkZGE3LFxuICAgICAgMHhhOTQ0NjE0NiwgMHgwZmQwMDMwZSwgMHhlY2M4YzczZSwgMHhhNDc1MWU0MSxcbiAgICAgIDB4ZTIzOGNkOTksIDB4M2JlYTBlMmYsIDB4MzI4MGJiYTEsIDB4MTgzZWIzMzEsXG4gICAgICAweDRlNTQ4YjM4LCAweDRmNmRiOTA4LCAweDZmNDIwZDAzLCAweGY2MGEwNGJmLFxuICAgICAgMHgyY2I4MTI5MCwgMHgyNDk3N2M3OSwgMHg1Njc5YjA3MiwgMHhiY2FmODlhZixcbiAgICAgIDB4ZGU5YTc3MWYsIDB4ZDk5MzA4MTAsIDB4YjM4YmFlMTIsIDB4ZGNjZjNmMmUsXG4gICAgICAweDU1MTI3MjFmLCAweDJlNmI3MTI0LCAweDUwMWFkZGU2LCAweDlmODRjZDg3LFxuICAgICAgMHg3YTU4NDcxOCwgMHg3NDA4ZGExNywgMHhiYzlmOWFiYywgMHhlOTRiN2Q4YyxcbiAgICAgIDB4ZWM3YWVjM2EsIDB4ZGI4NTFkZmEsIDB4NjMwOTQzNjYsIDB4YzQ2NGMzZDIsXG4gICAgICAweGVmMWMxODQ3LCAweDMyMTVkOTA4LCAweGRkNDMzYjM3LCAweDI0YzJiYTE2LFxuICAgICAgMHgxMmExNGQ0MywgMHgyYTY1YzQ1MSwgMHg1MDk0MDAwMiwgMHgxMzNhZTRkZCxcbiAgICAgIDB4NzFkZmY4OWUsIDB4MTAzMTRlNTUsIDB4ODFhYzc3ZDYsIDB4NWYxMTE5OWIsXG4gICAgICAweDA0MzU1NmYxLCAweGQ3YTNjNzZiLCAweDNjMTExODNiLCAweDU5MjRhNTA5LFxuICAgICAgMHhmMjhmZTZlZCwgMHg5N2YxZmJmYSwgMHg5ZWJhYmYyYywgMHgxZTE1M2M2ZSxcbiAgICAgIDB4ODZlMzQ1NzAsIDB4ZWFlOTZmYjEsIDB4ODYwZTVlMGEsIDB4NWEzZTJhYjMsXG4gICAgICAweDc3MWZlNzFjLCAweDRlM2QwNmZhLCAweDI5NjVkY2I5LCAweDk5ZTcxZDBmLFxuICAgICAgMHg4MDNlODlkNiwgMHg1MjY2YzgyNSwgMHgyZTRjYzk3OCwgMHg5YzEwYjM2YSxcbiAgICAgIDB4YzYxNTBlYmEsIDB4OTRlMmVhNzgsIDB4YTVmYzNjNTMsIDB4MWUwYTJkZjQsXG4gICAgICAweGYyZjc0ZWE3LCAweDM2MWQyYjNkLCAweDE5MzkyNjBmLCAweDE5YzI3OTYwLFxuICAgICAgMHg1MjIzYTcwOCwgMHhmNzEzMTJiNiwgMHhlYmFkZmU2ZSwgMHhlYWMzMWY2NixcbiAgICAgIDB4ZTNiYzQ1OTUsIDB4YTY3YmM4ODMsIDB4YjE3ZjM3ZDEsIDB4MDE4Y2ZmMjgsXG4gICAgICAweGMzMzJkZGVmLCAweGJlNmM1YWE1LCAweDY1NTgyMTg1LCAweDY4YWI5ODAyLFxuICAgICAgMHhlZWNlYTUwZiwgMHhkYjJmOTUzYiwgMHgyYWVmN2RhZCwgMHg1YjZlMmY4NCxcbiAgICAgIDB4MTUyMWI2MjgsIDB4MjkwNzYxNzAsIDB4ZWNkZDQ3NzUsIDB4NjE5ZjE1MTAsXG4gICAgICAweDEzY2NhODMwLCAweGViNjFiZDk2LCAweDAzMzRmZTFlLCAweGFhMDM2M2NmLFxuICAgICAgMHhiNTczNWM5MCwgMHg0YzcwYTIzOSwgMHhkNTllOWUwYiwgMHhjYmFhZGUxNCxcbiAgICAgIDB4ZWVjYzg2YmMsIDB4NjA2MjJjYTcsIDB4OWNhYjVjYWIsIDB4YjJmMzg0NmUsXG4gICAgICAweDY0OGIxZWFmLCAweDE5YmRmMGNhLCAweGEwMjM2OWI5LCAweDY1NWFiYjUwLFxuICAgICAgMHg0MDY4NWEzMiwgMHgzYzJhYjRiMywgMHgzMTllZTlkNSwgMHhjMDIxYjhmNyxcbiAgICAgIDB4OWI1NDBiMTksIDB4ODc1ZmEwOTksIDB4OTVmNzk5N2UsIDB4NjIzZDdkYTgsXG4gICAgICAweGY4Mzc4ODlhLCAweDk3ZTMyZDc3LCAweDExZWQ5MzVmLCAweDE2NjgxMjgxLFxuICAgICAgMHgwZTM1ODgyOSwgMHhjN2U2MWZkNiwgMHg5NmRlZGZhMSwgMHg3ODU4YmE5OSxcbiAgICAgIDB4NTdmNTg0YTUsIDB4MWIyMjcyNjMsIDB4OWI4M2MzZmYsIDB4MWFjMjQ2OTYsXG4gICAgICAweGNkYjMwYWViLCAweDUzMmUzMDU0LCAweDhmZDk0OGU0LCAweDZkYmMzMTI4LFxuICAgICAgMHg1OGViZjJlZiwgMHgzNGM2ZmZlYSwgMHhmZTI4ZWQ2MSwgMHhlZTdjM2M3MyxcbiAgICAgIDB4NWQ0YTE0ZDksIDB4ZTg2NGI3ZTMsIDB4NDIxMDVkMTQsIDB4MjAzZTEzZTAsXG4gICAgICAweDQ1ZWVlMmI2LCAweGEzYWFhYmVhLCAweGRiNmM0ZjE1LCAweGZhY2I0ZmQwLFxuICAgICAgMHhjNzQyZjQ0MiwgMHhlZjZhYmJiNSwgMHg2NTRmM2IxZCwgMHg0MWNkMjEwNSxcbiAgICAgIDB4ZDgxZTc5OWUsIDB4ODY4NTRkYzcsIDB4ZTQ0YjQ3NmEsIDB4M2Q4MTYyNTAsXG4gICAgICAweGNmNjJhMWYyLCAweDViOGQyNjQ2LCAweGZjODg4M2EwLCAweGMxYzdiNmEzLFxuICAgICAgMHg3ZjE1MjRjMywgMHg2OWNiNzQ5MiwgMHg0Nzg0OGEwYiwgMHg1NjkyYjI4NSxcbiAgICAgIDB4MDk1YmJmMDAsIDB4YWQxOTQ4OWQsIDB4MTQ2MmIxNzQsIDB4MjM4MjBlMDAsXG4gICAgICAweDU4NDI4ZDJhLCAweDBjNTVmNWVhLCAweDFkYWRmNDNlLCAweDIzM2Y3MDYxLFxuICAgICAgMHgzMzcyZjA5MiwgMHg4ZDkzN2U0MSwgMHhkNjVmZWNmMSwgMHg2YzIyM2JkYixcbiAgICAgIDB4N2NkZTM3NTksIDB4Y2JlZTc0NjAsIDB4NDA4NWYyYTcsIDB4Y2U3NzMyNmUsXG4gICAgICAweGE2MDc4MDg0LCAweDE5Zjg1MDllLCAweGU4ZWZkODU1LCAweDYxZDk5NzM1LFxuICAgICAgMHhhOTY5YTdhYSwgMHhjNTBjMDZjMiwgMHg1YTA0YWJmYywgMHg4MDBiY2FkYyxcbiAgICAgIDB4OWU0NDdhMmUsIDB4YzM0NTM0ODQsIDB4ZmRkNTY3MDUsIDB4MGUxZTllYzksXG4gICAgICAweGRiNzNkYmQzLCAweDEwNTU4OGNkLCAweDY3NWZkYTc5LCAweGUzNjc0MzQwLFxuICAgICAgMHhjNWM0MzQ2NSwgMHg3MTNlMzhkOCwgMHgzZDI4Zjg5ZSwgMHhmMTZkZmYyMCxcbiAgICAgIDB4MTUzZTIxZTcsIDB4OGZiMDNkNGEsIDB4ZTZlMzlmMmIsIDB4ZGI4M2FkZjddKSxcbiAgICBuZXcgVWludDMyQXJyYXkoW1xuICAgICAgMHhlOTNkNWE2OCwgMHg5NDgxNDBmNywgMHhmNjRjMjYxYywgMHg5NDY5MjkzNCxcbiAgICAgIDB4NDExNTIwZjcsIDB4NzYwMmQ0ZjcsIDB4YmNmNDZiMmUsIDB4ZDRhMjAwNjgsXG4gICAgICAweGQ0MDgyNDcxLCAweDMzMjBmNDZhLCAweDQzYjdkNGI3LCAweDUwMDA2MWFmLFxuICAgICAgMHgxZTM5ZjYyZSwgMHg5NzI0NDU0NiwgMHgxNDIxNGY3NCwgMHhiZjhiODg0MCxcbiAgICAgIDB4NGQ5NWZjMWQsIDB4OTZiNTkxYWYsIDB4NzBmNGRkZDMsIDB4NjZhMDJmNDUsXG4gICAgICAweGJmYmMwOWVjLCAweDAzYmQ5Nzg1LCAweDdmYWM2ZGQwLCAweDMxY2I4NTA0LFxuICAgICAgMHg5NmViMjdiMywgMHg1NWZkMzk0MSwgMHhkYTI1NDdlNiwgMHhhYmNhMGE5YSxcbiAgICAgIDB4Mjg1MDc4MjUsIDB4NTMwNDI5ZjQsIDB4MGEyYzg2ZGEsIDB4ZTliNjZkZmIsXG4gICAgICAweDY4ZGMxNDYyLCAweGQ3NDg2OTAwLCAweDY4MGVjMGE0LCAweDI3YTE4ZGVlLFxuICAgICAgMHg0ZjNmZmVhMiwgMHhlODg3YWQ4YywgMHhiNThjZTAwNiwgMHg3YWY0ZDZiNixcbiAgICAgIDB4YWFjZTFlN2MsIDB4ZDMzNzVmZWMsIDB4Y2U3OGEzOTksIDB4NDA2YjJhNDIsXG4gICAgICAweDIwZmU5ZTM1LCAweGQ5ZjM4NWI5LCAweGVlMzlkN2FiLCAweDNiMTI0ZThiLFxuICAgICAgMHgxZGM5ZmFmNywgMHg0YjZkMTg1NiwgMHgyNmEzNjYzMSwgMHhlYWUzOTdiMixcbiAgICAgIDB4M2E2ZWZhNzQsIDB4ZGQ1YjQzMzIsIDB4Njg0MWU3ZjcsIDB4Y2E3ODIwZmIsXG4gICAgICAweGZiMGFmNTRlLCAweGQ4ZmViMzk3LCAweDQ1NDA1NmFjLCAweGJhNDg5NTI3LFxuICAgICAgMHg1NTUzM2EzYSwgMHgyMDgzOGQ4NywgMHhmZTZiYTliNywgMHhkMDk2OTU0YixcbiAgICAgIDB4NTVhODY3YmMsIDB4YTExNTlhNTgsIDB4Y2NhOTI5NjMsIDB4OTllMWRiMzMsXG4gICAgICAweGE2MmE0YTU2LCAweDNmMzEyNWY5LCAweDVlZjQ3ZTFjLCAweDkwMjkzMTdjLFxuICAgICAgMHhmZGY4ZTgwMiwgMHgwNDI3MmY3MCwgMHg4MGJiMTU1YywgMHgwNTI4MmNlMyxcbiAgICAgIDB4OTVjMTE1NDgsIDB4ZTRjNjZkMjIsIDB4NDhjMTEzM2YsIDB4YzcwZjg2ZGMsXG4gICAgICAweDA3ZjljOWVlLCAweDQxMDQxZjBmLCAweDQwNDc3OWE0LCAweDVkODg2ZTE3LFxuICAgICAgMHgzMjVmNTFlYiwgMHhkNTliYzBkMSwgMHhmMmJjYzE4ZiwgMHg0MTExMzU2NCxcbiAgICAgIDB4MjU3Yjc4MzQsIDB4NjAyYTljNjAsIDB4ZGZmOGU4YTMsIDB4MWY2MzZjMWIsXG4gICAgICAweDBlMTJiNGMyLCAweDAyZTEzMjllLCAweGFmNjY0ZmQxLCAweGNhZDE4MTE1LFxuICAgICAgMHg2YjIzOTVlMCwgMHgzMzNlOTJlMSwgMHgzYjI0MGI2MiwgMHhlZWJlYjkyMixcbiAgICAgIDB4ODViMmEyMGUsIDB4ZTZiYTBkOTksIDB4ZGU3MjBjOGMsIDB4MmRhMmY3MjgsXG4gICAgICAweGQwMTI3ODQ1LCAweDk1Yjc5NGZkLCAweDY0N2QwODYyLCAweGU3Y2NmNWYwLFxuICAgICAgMHg1NDQ5YTM2ZiwgMHg4NzdkNDhmYSwgMHhjMzlkZmQyNywgMHhmMzNlOGQxZSxcbiAgICAgIDB4MGE0NzYzNDEsIDB4OTkyZWZmNzQsIDB4M2E2ZjZlYWIsIDB4ZjRmOGZkMzcsXG4gICAgICAweGE4MTJkYzYwLCAweGExZWJkZGY4LCAweDk5MWJlMTRjLCAweGRiNmU2YjBkLFxuICAgICAgMHhjNjdiNTUxMCwgMHg2ZDY3MmMzNywgMHgyNzY1ZDQzYiwgMHhkY2QwZTgwNCxcbiAgICAgIDB4ZjEyOTBkYzcsIDB4Y2MwMGZmYTMsIDB4YjUzOTBmOTIsIDB4NjkwZmVkMGIsXG4gICAgICAweDY2N2I5ZmZiLCAweGNlZGI3ZDljLCAweGEwOTFjZjBiLCAweGQ5MTU1ZWEzLFxuICAgICAgMHhiYjEzMmY4OCwgMHg1MTViYWQyNCwgMHg3Yjk0NzliZiwgMHg3NjNiZDZlYixcbiAgICAgIDB4MzczOTJlYjMsIDB4Y2MxMTU5NzksIDB4ODAyNmUyOTcsIDB4ZjQyZTMxMmQsXG4gICAgICAweDY4NDJhZGE3LCAweGM2NmEyYjNiLCAweDEyNzU0Y2NjLCAweDc4MmVmMTFjLFxuICAgICAgMHg2YTEyNDIzNywgMHhiNzkyNTFlNywgMHgwNmExYmJlNiwgMHg0YmZiNjM1MCxcbiAgICAgIDB4MWE2YjEwMTgsIDB4MTFjYWVkZmEsIDB4M2QyNWJkZDgsIDB4ZTJlMWMzYzksXG4gICAgICAweDQ0NDIxNjU5LCAweDBhMTIxMzg2LCAweGQ5MGNlYzZlLCAweGQ1YWJlYTJhLFxuICAgICAgMHg2NGFmNjc0ZSwgMHhkYTg2YTg1ZiwgMHhiZWJmZTk4OCwgMHg2NGU0YzNmZSxcbiAgICAgIDB4OWRiYzgwNTcsIDB4ZjBmN2MwODYsIDB4NjA3ODdiZjgsIDB4NjAwMzYwNGQsXG4gICAgICAweGQxZmQ4MzQ2LCAweGY2MzgxZmIwLCAweDc3NDVhZTA0LCAweGQ3MzZmY2NjLFxuICAgICAgMHg4MzQyNmIzMywgMHhmMDFlYWI3MSwgMHhiMDgwNDE4NywgMHgzYzAwNWU1ZixcbiAgICAgIDB4NzdhMDU3YmUsIDB4YmRlOGFlMjQsIDB4NTU0NjQyOTksIDB4YmY1ODJlNjEsXG4gICAgICAweDRlNThmNDhmLCAweGYyZGRmZGEyLCAweGY0NzRlZjM4LCAweDg3ODliZGMyLFxuICAgICAgMHg1MzY2ZjljMywgMHhjOGIzOGU3NCwgMHhiNDc1ZjI1NSwgMHg0NmZjZDliOSxcbiAgICAgIDB4N2FlYjI2NjEsIDB4OGIxZGRmODQsIDB4ODQ2YTBlNzksIDB4OTE1Zjk1ZTIsXG4gICAgICAweDQ2NmU1OThlLCAweDIwYjQ1NzcwLCAweDhjZDU1NTkxLCAweGM5MDJkZTRjLFxuICAgICAgMHhiOTBiYWNlMSwgMHhiYjgyMDVkMCwgMHgxMWE4NjI0OCwgMHg3NTc0YTk5ZSxcbiAgICAgIDB4Yjc3ZjE5YjYsIDB4ZTBhOWRjMDksIDB4NjYyZDA5YTEsIDB4YzQzMjQ2MzMsXG4gICAgICAweGU4NWExZjAyLCAweDA5ZjBiZThjLCAweDRhOTlhMDI1LCAweDFkNmVmZTEwLFxuICAgICAgMHgxYWI5M2QxZCwgMHgwYmE1YTRkZiwgMHhhMTg2ZjIwZiwgMHgyODY4ZjE2OSxcbiAgICAgIDB4ZGNiN2RhODMsIDB4NTczOTA2ZmUsIDB4YTFlMmNlOWIsIDB4NGZjZDdmNTIsXG4gICAgICAweDUwMTE1ZTAxLCAweGE3MDY4M2ZhLCAweGEwMDJiNWM0LCAweDBkZTZkMDI3LFxuICAgICAgMHg5YWY4OGMyNywgMHg3NzNmODY0MSwgMHhjMzYwNGMwNiwgMHg2MWE4MDZiNSxcbiAgICAgIDB4ZjAxNzdhMjgsIDB4YzBmNTg2ZTAsIDB4MDA2MDU4YWEsIDB4MzBkYzdkNjIsXG4gICAgICAweDExZTY5ZWQ3LCAweDIzMzhlYTYzLCAweDUzYzJkZDk0LCAweGMyYzIxNjM0LFxuICAgICAgMHhiYmNiZWU1NiwgMHg5MGJjYjZkZSwgMHhlYmZjN2RhMSwgMHhjZTU5MWQ3NixcbiAgICAgIDB4NmYwNWU0MDksIDB4NGI3YzAxODgsIDB4Mzk3MjBhM2QsIDB4N2M5MjdjMjQsXG4gICAgICAweDg2ZTM3MjVmLCAweDcyNGQ5ZGI5LCAweDFhYzE1YmI0LCAweGQzOWViOGZjLFxuICAgICAgMHhlZDU0NTU3OCwgMHgwOGZjYTViNSwgMHhkODNkN2NkMywgMHg0ZGFkMGZjNCxcbiAgICAgIDB4MWU1MGVmNWUsIDB4YjE2MWU2ZjgsIDB4YTI4NTE0ZDksIDB4NmM1MTEzM2MsXG4gICAgICAweDZmZDVjN2U3LCAweDU2ZTE0ZWM0LCAweDM2MmFiZmNlLCAweGRkYzZjODM3LFxuICAgICAgMHhkNzlhMzIzNCwgMHg5MjYzODIxMiwgMHg2NzBlZmE4ZSwgMHg0MDYwMDBlMF0pLFxuICAgIG5ldyBVaW50MzJBcnJheShbXG4gICAgICAweDNhMzljZTM3LCAweGQzZmFmNWNmLCAweGFiYzI3NzM3LCAweDVhYzUyZDFiLFxuICAgICAgMHg1Y2IwNjc5ZSwgMHg0ZmEzMzc0MiwgMHhkMzgyMjc0MCwgMHg5OWJjOWJiZSxcbiAgICAgIDB4ZDUxMThlOWQsIDB4YmYwZjczMTUsIDB4ZDYyZDFjN2UsIDB4YzcwMGM0N2IsXG4gICAgICAweGI3OGMxYjZiLCAweDIxYTE5MDQ1LCAweGIyNmViMWJlLCAweDZhMzY2ZWI0LFxuICAgICAgMHg1NzQ4YWIyZiwgMHhiYzk0NmU3OSwgMHhjNmEzNzZkMiwgMHg2NTQ5YzJjOCxcbiAgICAgIDB4NTMwZmY4ZWUsIDB4NDY4ZGRlN2QsIDB4ZDU3MzBhMWQsIDB4NGNkMDRkYzYsXG4gICAgICAweDI5MzliYmRiLCAweGE5YmE0NjUwLCAweGFjOTUyNmU4LCAweGJlNWVlMzA0LFxuICAgICAgMHhhMWZhZDVmMCwgMHg2YTJkNTE5YSwgMHg2M2VmOGNlMiwgMHg5YTg2ZWUyMixcbiAgICAgIDB4YzA4OWMyYjgsIDB4NDMyNDJlZjYsIDB4YTUxZTAzYWEsIDB4OWNmMmQwYTQsXG4gICAgICAweDgzYzA2MWJhLCAweDliZTk2YTRkLCAweDhmZTUxNTUwLCAweGJhNjQ1YmQ2LFxuICAgICAgMHgyODI2YTJmOSwgMHhhNzNhM2FlMSwgMHg0YmE5OTU4NiwgMHhlZjU1NjJlOSxcbiAgICAgIDB4YzcyZmVmZDMsIDB4Zjc1MmY3ZGEsIDB4M2YwNDZmNjksIDB4NzdmYTBhNTksXG4gICAgICAweDgwZTRhOTE1LCAweDg3YjA4NjAxLCAweDliMDllNmFkLCAweDNiM2VlNTkzLFxuICAgICAgMHhlOTkwZmQ1YSwgMHg5ZTM0ZDc5NywgMHgyY2YwYjdkOSwgMHgwMjJiOGI1MSxcbiAgICAgIDB4OTZkNWFjM2EsIDB4MDE3ZGE2N2QsIDB4ZDFjZjNlZDYsIDB4N2M3ZDJkMjgsXG4gICAgICAweDFmOWYyNWNmLCAweGFkZjJiODliLCAweDVhZDZiNDcyLCAweDVhODhmNTRjLFxuICAgICAgMHhlMDI5YWM3MSwgMHhlMDE5YTVlNiwgMHg0N2IwYWNmZCwgMHhlZDkzZmE5YixcbiAgICAgIDB4ZThkM2M0OGQsIDB4MjgzYjU3Y2MsIDB4ZjhkNTY2MjksIDB4NzkxMzJlMjgsXG4gICAgICAweDc4NWYwMTkxLCAweGVkNzU2MDU1LCAweGY3OTYwZTQ0LCAweGUzZDM1ZThjLFxuICAgICAgMHgxNTA1NmRkNCwgMHg4OGY0NmRiYSwgMHgwM2ExNjEyNSwgMHgwNTY0ZjBiZCxcbiAgICAgIDB4YzNlYjllMTUsIDB4M2M5MDU3YTIsIDB4OTcyNzFhZWMsIDB4YTkzYTA3MmEsXG4gICAgICAweDFiM2Y2ZDliLCAweDFlNjMyMWY1LCAweGY1OWM2NmZiLCAweDI2ZGNmMzE5LFxuICAgICAgMHg3NTMzZDkyOCwgMHhiMTU1ZmRmNSwgMHgwMzU2MzQ4MiwgMHg4YWJhM2NiYixcbiAgICAgIDB4Mjg1MTc3MTEsIDB4YzIwYWQ5ZjgsIDB4YWJjYzUxNjcsIDB4Y2NhZDkyNWYsXG4gICAgICAweDRkZTgxNzUxLCAweDM4MzBkYzhlLCAweDM3OWQ1ODYyLCAweDkzMjBmOTkxLFxuICAgICAgMHhlYTdhOTBjMiwgMHhmYjNlN2JjZSwgMHg1MTIxY2U2NCwgMHg3NzRmYmUzMixcbiAgICAgIDB4YThiNmUzN2UsIDB4YzMyOTNkNDYsIDB4NDhkZTUzNjksIDB4NjQxM2U2ODAsXG4gICAgICAweGEyYWUwODEwLCAweGRkNmRiMjI0LCAweDY5ODUyZGZkLCAweDA5MDcyMTY2LFxuICAgICAgMHhiMzlhNDYwYSwgMHg2NDQ1YzBkZCwgMHg1ODZjZGVjZiwgMHgxYzIwYzhhZSxcbiAgICAgIDB4NWJiZWY3ZGQsIDB4MWI1ODhkNDAsIDB4Y2NkMjAxN2YsIDB4NmJiNGUzYmIsXG4gICAgICAweGRkYTI2YTdlLCAweDNhNTlmZjQ1LCAweDNlMzUwYTQ0LCAweGJjYjRjZGQ1LFxuICAgICAgMHg3MmVhY2VhOCwgMHhmYTY0ODRiYiwgMHg4ZDY2MTJhZSwgMHhiZjNjNmY0NyxcbiAgICAgIDB4ZDI5YmU0NjMsIDB4NTQyZjVkOWUsIDB4YWVjMjc3MWIsIDB4ZjY0ZTYzNzAsXG4gICAgICAweDc0MGUwZDhkLCAweGU3NWIxMzU3LCAweGY4NzIxNjcxLCAweGFmNTM3ZDVkLFxuICAgICAgMHg0MDQwY2IwOCwgMHg0ZWI0ZTJjYywgMHgzNGQyNDY2YSwgMHgwMTE1YWY4NCxcbiAgICAgIDB4ZTFiMDA0MjgsIDB4OTU5ODNhMWQsIDB4MDZiODlmYjQsIDB4Y2U2ZWEwNDgsXG4gICAgICAweDZmM2YzYjgyLCAweDM1MjBhYjgyLCAweDAxMWExZDRiLCAweDI3NzIyN2Y4LFxuICAgICAgMHg2MTE1NjBiMSwgMHhlNzkzM2ZkYywgMHhiYjNhNzkyYiwgMHgzNDQ1MjViZCxcbiAgICAgIDB4YTA4ODM5ZTEsIDB4NTFjZTc5NGIsIDB4MmYzMmM5YjcsIDB4YTAxZmJhYzksXG4gICAgICAweGUwMWNjODdlLCAweGJjYzdkMWY2LCAweGNmMDExMWMzLCAweGExZThhYWM3LFxuICAgICAgMHgxYTkwODc0OSwgMHhkNDRmYmQ5YSwgMHhkMGRhZGVjYiwgMHhkNTBhZGEzOCxcbiAgICAgIDB4MDMzOWMzMmEsIDB4YzY5MTM2NjcsIDB4OGRmOTMxN2MsIDB4ZTBiMTJiNGYsXG4gICAgICAweGY3OWU1OWI3LCAweDQzZjViYjNhLCAweGYyZDUxOWZmLCAweDI3ZDk0NTljLFxuICAgICAgMHhiZjk3MjIyYywgMHgxNWU2ZmMyYSwgMHgwZjkxZmM3MSwgMHg5Yjk0MTUyNSxcbiAgICAgIDB4ZmFlNTkzNjEsIDB4Y2ViNjljZWIsIDB4YzJhODY0NTksIDB4MTJiYWE4ZDEsXG4gICAgICAweGI2YzEwNzVlLCAweGUzMDU2YTBjLCAweDEwZDI1MDY1LCAweGNiMDNhNDQyLFxuICAgICAgMHhlMGVjNmUwZSwgMHgxNjk4ZGIzYiwgMHg0Yzk4YTBiZSwgMHgzMjc4ZTk2NCxcbiAgICAgIDB4OWYxZjk1MzIsIDB4ZTBkMzkyZGYsIDB4ZDNhMDM0MmIsIDB4ODk3MWYyMWUsXG4gICAgICAweDFiMGE3NDQxLCAweDRiYTMzNDhjLCAweGM1YmU3MTIwLCAweGMzNzYzMmQ4LFxuICAgICAgMHhkZjM1OWY4ZCwgMHg5Yjk5MmYyZSwgMHhlNjBiNmY0NywgMHgwZmUzZjExZCxcbiAgICAgIDB4ZTU0Y2RhNTQsIDB4MWVkYWQ4OTEsIDB4Y2U2Mjc5Y2YsIDB4Y2QzZTdlNmYsXG4gICAgICAweDE2MThiMTY2LCAweGZkMmMxZDA1LCAweDg0OGZkMmM1LCAweGY2ZmIyMjk5LFxuICAgICAgMHhmNTIzZjM1NywgMHhhNjMyNzYyMywgMHg5M2E4MzUzMSwgMHg1NmNjY2QwMixcbiAgICAgIDB4YWNmMDgxNjIsIDB4NWE3NWViYjUsIDB4NmUxNjM2OTcsIDB4ODhkMjczY2MsXG4gICAgICAweGRlOTY2MjkyLCAweDgxYjk0OWQwLCAweDRjNTA5MDFiLCAweDcxYzY1NjE0LFxuICAgICAgMHhlNmM2YzdiZCwgMHgzMjdhMTQwYSwgMHg0NWUxZDAwNiwgMHhjM2YyN2I5YSxcbiAgICAgIDB4YzlhYTUzZmQsIDB4NjJhODBmMDAsIDB4YmIyNWJmZTIsIDB4MzViZGQyZjYsXG4gICAgICAweDcxMTI2OTA1LCAweGIyMDQwMjIyLCAweGI2Y2JjZjdjLCAweGNkNzY5YzJiLFxuICAgICAgMHg1MzExM2VjMCwgMHgxNjQwZTNkMywgMHgzOGFiYmQ2MCwgMHgyNTQ3YWRmMCxcbiAgICAgIDB4YmEzODIwOWMsIDB4Zjc0NmNlNzYsIDB4NzdhZmExYzUsIDB4MjA3NTYwNjAsXG4gICAgICAweDg1Y2JmZTRlLCAweDhhZTg4ZGQ4LCAweDdhYWFmOWIwLCAweDRjZjlhYTdlLFxuICAgICAgMHgxOTQ4YzI1YywgMHgwMmZiOGE4YywgMHgwMWMzNmFlNCwgMHhkNmViZTFmOSxcbiAgICAgIDB4OTBkNGY4NjksIDB4YTY1Y2RlYTAsIDB4M2YwOTI1MmQsIDB4YzIwOGU2OWYsXG4gICAgICAweGI3NGU2MTMyLCAweGNlNzdlMjViLCAweDU3OGZkZmUzLCAweDNhYzM3MmU2XSlcbiAgICBdO1xuICB0aGlzLlAgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4MjQzZjZhODgsIDB4ODVhMzA4ZDMsIDB4MTMxOThhMmUsIDB4MDM3MDczNDQsXG4gICAgMHhhNDA5MzgyMiwgMHgyOTlmMzFkMCwgMHgwODJlZmE5OCwgMHhlYzRlNmM4OSxcbiAgICAweDQ1MjgyMWU2LCAweDM4ZDAxMzc3LCAweGJlNTQ2NmNmLCAweDM0ZTkwYzZjLFxuICAgIDB4YzBhYzI5YjcsIDB4Yzk3YzUwZGQsIDB4M2Y4NGQ1YjUsIDB4YjU0NzA5MTcsXG4gICAgMHg5MjE2ZDVkOSwgMHg4OTc5ZmIxYl0pO1xufTtcblxuZnVuY3Rpb24gRihTLCB4OCwgaSkge1xuICByZXR1cm4gKCgoU1swXVt4OFtpKzNdXSArXG4gICAgICAgICAgICBTWzFdW3g4W2krMl1dKSBeXG4gICAgICAgICAgICBTWzJdW3g4W2krMV1dKSArXG4gICAgICAgICAgICBTWzNdW3g4W2ldXSk7XG59O1xuXG5CbG93ZmlzaC5wcm90b3R5cGUuZW5jaXBoZXIgPSBmdW5jdGlvbih4LCB4OCkge1xuICBpZiAoeDggPT09IHVuZGVmaW5lZCkge1xuICAgIHg4ID0gbmV3IFVpbnQ4QXJyYXkoeC5idWZmZXIpO1xuICAgIGlmICh4LmJ5dGVPZmZzZXQgIT09IDApXG4gICAgICB4OCA9IHg4LnN1YmFycmF5KHguYnl0ZU9mZnNldCk7XG4gIH1cbiAgeFswXSBePSB0aGlzLlBbMF07XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgMTY7IGkgKz0gMikge1xuICAgIHhbMV0gXj0gRih0aGlzLlMsIHg4LCAwKSBeIHRoaXMuUFtpXTtcbiAgICB4WzBdIF49IEYodGhpcy5TLCB4OCwgNCkgXiB0aGlzLlBbaSsxXTtcbiAgfVxuICB2YXIgdCA9IHhbMF07XG4gIHhbMF0gPSB4WzFdIF4gdGhpcy5QWzE3XTtcbiAgeFsxXSA9IHQ7XG59O1xuXG5CbG93ZmlzaC5wcm90b3R5cGUuZGVjaXBoZXIgPSBmdW5jdGlvbih4KSB7XG4gIHZhciB4OCA9IG5ldyBVaW50OEFycmF5KHguYnVmZmVyKTtcbiAgaWYgKHguYnl0ZU9mZnNldCAhPT0gMClcbiAgICB4OCA9IHg4LnN1YmFycmF5KHguYnl0ZU9mZnNldCk7XG4gIHhbMF0gXj0gdGhpcy5QWzE3XTtcbiAgZm9yICh2YXIgaSA9IDE2OyBpID4gMDsgaSAtPSAyKSB7XG4gICAgeFsxXSBePSBGKHRoaXMuUywgeDgsIDApIF4gdGhpcy5QW2ldO1xuICAgIHhbMF0gXj0gRih0aGlzLlMsIHg4LCA0KSBeIHRoaXMuUFtpLTFdO1xuICB9XG4gIHZhciB0ID0geFswXTtcbiAgeFswXSA9IHhbMV0gXiB0aGlzLlBbMF07XG4gIHhbMV0gPSB0O1xufTtcblxuZnVuY3Rpb24gc3RyZWFtMndvcmQoZGF0YSwgZGF0YWJ5dGVzKXtcbiAgdmFyIGksIHRlbXAgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrLCBCTEZfSisrKSB7XG4gICAgaWYgKEJMRl9KID49IGRhdGFieXRlcykgQkxGX0ogPSAwO1xuICAgIHRlbXAgPSAodGVtcCA8PCA4KSB8IGRhdGFbQkxGX0pdO1xuICB9XG4gIHJldHVybiB0ZW1wO1xufTtcblxuQmxvd2Zpc2gucHJvdG90eXBlLmV4cGFuZDBzdGF0ZSA9IGZ1bmN0aW9uKGtleSwga2V5Ynl0ZXMpIHtcbiAgdmFyIGQgPSBuZXcgVWludDMyQXJyYXkoMiksIGksIGs7XG4gIHZhciBkOCA9IG5ldyBVaW50OEFycmF5KGQuYnVmZmVyKTtcblxuICBmb3IgKGkgPSAwLCBCTEZfSiA9IDA7IGkgPCAxODsgaSsrKSB7XG4gICAgdGhpcy5QW2ldIF49IHN0cmVhbTJ3b3JkKGtleSwga2V5Ynl0ZXMpO1xuICB9XG4gIEJMRl9KID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTg7IGkgKz0gMikge1xuICAgIHRoaXMuZW5jaXBoZXIoZCwgZDgpO1xuICAgIHRoaXMuUFtpXSAgID0gZFswXTtcbiAgICB0aGlzLlBbaSsxXSA9IGRbMV07XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgZm9yIChrID0gMDsgayA8IDI1NjsgayArPSAyKSB7XG4gICAgICB0aGlzLmVuY2lwaGVyKGQsIGQ4KTtcbiAgICAgIHRoaXMuU1tpXVtrXSAgID0gZFswXTtcbiAgICAgIHRoaXMuU1tpXVtrKzFdID0gZFsxXTtcbiAgICB9XG4gIH1cbn07XG5cbkJsb3dmaXNoLnByb3RvdHlwZS5leHBhbmRzdGF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGRhdGFieXRlcywga2V5LCBrZXlieXRlcykge1xuICB2YXIgZCA9IG5ldyBVaW50MzJBcnJheSgyKSwgaSwgaztcblxuICBmb3IgKGkgPSAwLCBCTEZfSiA9IDA7IGkgPCAxODsgaSsrKSB7XG4gICAgdGhpcy5QW2ldIF49IHN0cmVhbTJ3b3JkKGtleSwga2V5Ynl0ZXMpO1xuICB9XG5cbiAgZm9yIChpID0gMCwgQkxGX0ogPSAwOyBpIDwgMTg7IGkgKz0gMikge1xuICAgIGRbMF0gXj0gc3RyZWFtMndvcmQoZGF0YSwgZGF0YWJ5dGVzKTtcbiAgICBkWzFdIF49IHN0cmVhbTJ3b3JkKGRhdGEsIGRhdGFieXRlcyk7XG4gICAgdGhpcy5lbmNpcGhlcihkKTtcbiAgICB0aGlzLlBbaV0gICA9IGRbMF07XG4gICAgdGhpcy5QW2krMV0gPSBkWzFdO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGZvciAoayA9IDA7IGsgPCAyNTY7IGsgKz0gMikge1xuICAgICAgZFswXSBePSBzdHJlYW0yd29yZChkYXRhLCBkYXRhYnl0ZXMpO1xuICAgICAgZFsxXSBePSBzdHJlYW0yd29yZChkYXRhLCBkYXRhYnl0ZXMpO1xuICAgICAgdGhpcy5lbmNpcGhlcihkKTtcbiAgICAgIHRoaXMuU1tpXVtrXSAgID0gZFswXTtcbiAgICAgIHRoaXMuU1tpXVtrKzFdID0gZFsxXTtcbiAgICB9XG4gIH1cbiAgQkxGX0ogPSAwO1xufTtcblxuQmxvd2Zpc2gucHJvdG90eXBlLmVuYyA9IGZ1bmN0aW9uKGRhdGEsIGJsb2Nrcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrczsgaSsrKSB7XG4gICAgdGhpcy5lbmNpcGhlcihkYXRhLnN1YmFycmF5KGkqMikpO1xuICB9XG59O1xuXG5CbG93ZmlzaC5wcm90b3R5cGUuZGVjID0gZnVuY3Rpb24oZGF0YSwgYmxvY2tzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tzOyBpKyspIHtcbiAgICB0aGlzLmRlY2lwaGVyKGRhdGEuc3ViYXJyYXkoaSoyKSk7XG4gIH1cbn07XG5cbnZhciBCQ1JZUFRfQkxPQ0tTID0gOCxcbiAgICBCQ1JZUFRfSEFTSFNJWkUgPSAzMjtcblxuZnVuY3Rpb24gYmNyeXB0X2hhc2goc2hhMnBhc3MsIHNoYTJzYWx0LCBvdXQpIHtcbiAgdmFyIHN0YXRlID0gbmV3IEJsb3dmaXNoKCksXG4gICAgICBjZGF0YSA9IG5ldyBVaW50MzJBcnJheShCQ1JZUFRfQkxPQ0tTKSwgaSxcbiAgICAgIGNpcGhlcnRleHQgPSBuZXcgVWludDhBcnJheShbNzksMTIwLDEyMSw5OSwxMDQsMTE0LDExMSwxMDksOTcsMTE2LDEwNSxcbiAgICAgICAgICAgIDk5LDY2LDEwOCwxMTEsMTE5LDEwMiwxMDUsMTE1LDEwNCw4MywxMTksOTcsMTE2LDY4LDEyMSwxMTAsOTcsMTA5LFxuICAgICAgICAgICAgMTA1LDExNiwxMDFdKTsgLy9cIk94eWNocm9tYXRpY0Jsb3dmaXNoU3dhdER5bmFtaXRlXCJcblxuICBzdGF0ZS5leHBhbmRzdGF0ZShzaGEyc2FsdCwgNjQsIHNoYTJwYXNzLCA2NCk7XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgc3RhdGUuZXhwYW5kMHN0YXRlKHNoYTJzYWx0LCA2NCk7XG4gICAgc3RhdGUuZXhwYW5kMHN0YXRlKHNoYTJwYXNzLCA2NCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgQkNSWVBUX0JMT0NLUzsgaSsrKVxuICAgIGNkYXRhW2ldID0gc3RyZWFtMndvcmQoY2lwaGVydGV4dCwgY2lwaGVydGV4dC5ieXRlTGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspXG4gICAgc3RhdGUuZW5jKGNkYXRhLCBjZGF0YS5ieXRlTGVuZ3RoIC8gOCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IEJDUllQVF9CTE9DS1M7IGkrKykge1xuICAgIG91dFs0KmkrM10gPSBjZGF0YVtpXSA+Pj4gMjQ7XG4gICAgb3V0WzQqaSsyXSA9IGNkYXRhW2ldID4+PiAxNjtcbiAgICBvdXRbNCppKzFdID0gY2RhdGFbaV0gPj4+IDg7XG4gICAgb3V0WzQqaSswXSA9IGNkYXRhW2ldO1xuICB9XG59O1xuXG5mdW5jdGlvbiBiY3J5cHRfcGJrZGYocGFzcywgcGFzc2xlbiwgc2FsdCwgc2FsdGxlbiwga2V5LCBrZXlsZW4sIHJvdW5kcykge1xuICB2YXIgc2hhMnBhc3MgPSBuZXcgVWludDhBcnJheSg2NCksXG4gICAgICBzaGEyc2FsdCA9IG5ldyBVaW50OEFycmF5KDY0KSxcbiAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KEJDUllQVF9IQVNIU0laRSksXG4gICAgICB0bXBvdXQgPSBuZXcgVWludDhBcnJheShCQ1JZUFRfSEFTSFNJWkUpLFxuICAgICAgY291bnRzYWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2FsdGxlbis0KSxcbiAgICAgIGksIGosIGFtdCwgc3RyaWRlLCBkZXN0LCBjb3VudCxcbiAgICAgIG9yaWdrZXlsZW4gPSBrZXlsZW47XG5cbiAgaWYgKHJvdW5kcyA8IDEpXG4gICAgcmV0dXJuIC0xO1xuICBpZiAocGFzc2xlbiA9PT0gMCB8fCBzYWx0bGVuID09PSAwIHx8IGtleWxlbiA9PT0gMCB8fFxuICAgICAga2V5bGVuID4gKG91dC5ieXRlTGVuZ3RoICogb3V0LmJ5dGVMZW5ndGgpIHx8IHNhbHRsZW4gPiAoMTw8MjApKVxuICAgIHJldHVybiAtMTtcblxuICBzdHJpZGUgPSBNYXRoLmZsb29yKChrZXlsZW4gKyBvdXQuYnl0ZUxlbmd0aCAtIDEpIC8gb3V0LmJ5dGVMZW5ndGgpO1xuICBhbXQgPSBNYXRoLmZsb29yKChrZXlsZW4gKyBzdHJpZGUgLSAxKSAvIHN0cmlkZSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNhbHRsZW47IGkrKylcbiAgICBjb3VudHNhbHRbaV0gPSBzYWx0W2ldO1xuXG4gIGNyeXB0b19oYXNoX3NoYTUxMihzaGEycGFzcywgcGFzcywgcGFzc2xlbik7XG5cbiAgZm9yIChjb3VudCA9IDE7IGtleWxlbiA+IDA7IGNvdW50KyspIHtcbiAgICBjb3VudHNhbHRbc2FsdGxlbiswXSA9IGNvdW50ID4+PiAyNDtcbiAgICBjb3VudHNhbHRbc2FsdGxlbisxXSA9IGNvdW50ID4+PiAxNjtcbiAgICBjb3VudHNhbHRbc2FsdGxlbisyXSA9IGNvdW50ID4+PiAgODtcbiAgICBjb3VudHNhbHRbc2FsdGxlbiszXSA9IGNvdW50O1xuXG4gICAgY3J5cHRvX2hhc2hfc2hhNTEyKHNoYTJzYWx0LCBjb3VudHNhbHQsIHNhbHRsZW4gKyA0KTtcbiAgICBiY3J5cHRfaGFzaChzaGEycGFzcywgc2hhMnNhbHQsIHRtcG91dCk7XG4gICAgZm9yIChpID0gb3V0LmJ5dGVMZW5ndGg7IGktLTspXG4gICAgICBvdXRbaV0gPSB0bXBvdXRbaV07XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgcm91bmRzOyBpKyspIHtcbiAgICAgIGNyeXB0b19oYXNoX3NoYTUxMihzaGEyc2FsdCwgdG1wb3V0LCB0bXBvdXQuYnl0ZUxlbmd0aCk7XG4gICAgICBiY3J5cHRfaGFzaChzaGEycGFzcywgc2hhMnNhbHQsIHRtcG91dCk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgb3V0LmJ5dGVMZW5ndGg7IGorKylcbiAgICAgICAgb3V0W2pdIF49IHRtcG91dFtqXTtcbiAgICB9XG5cbiAgICBhbXQgPSBNYXRoLm1pbihhbXQsIGtleWxlbik7XG4gICAgZm9yIChpID0gMDsgaSA8IGFtdDsgaSsrKSB7XG4gICAgICBkZXN0ID0gaSAqIHN0cmlkZSArIChjb3VudCAtIDEpO1xuICAgICAgaWYgKGRlc3QgPj0gb3JpZ2tleWxlbilcbiAgICAgICAgYnJlYWs7XG4gICAgICBrZXlbZGVzdF0gPSBvdXRbaV07XG4gICAgfVxuICAgIGtleWxlbiAtPSBpO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIEJMT0NLUzogQkNSWVBUX0JMT0NLUyxcbiAgICAgIEhBU0hTSVpFOiBCQ1JZUFRfSEFTSFNJWkUsXG4gICAgICBoYXNoOiBiY3J5cHRfaGFzaCxcbiAgICAgIHBia2RmOiBiY3J5cHRfcGJrZGZcbn07XG4iLCJmdW5jdGlvbiBDYXNlbGVzcyAoZGljdCkge1xuICB0aGlzLmRpY3QgPSBkaWN0IHx8IHt9XG59XG5DYXNlbGVzcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBjbG9iYmVyKSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBpIGluIG5hbWUpIHtcbiAgICAgIHRoaXMuc2V0KGksIG5hbWVbaV0sIHZhbHVlKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGNsb2JiZXIgPT09ICd1bmRlZmluZWQnKSBjbG9iYmVyID0gdHJ1ZVxuICAgIHZhciBoYXMgPSB0aGlzLmhhcyhuYW1lKVxuXG4gICAgaWYgKCFjbG9iYmVyICYmIGhhcykgdGhpcy5kaWN0W2hhc10gPSB0aGlzLmRpY3RbaGFzXSArICcsJyArIHZhbHVlXG4gICAgZWxzZSB0aGlzLmRpY3RbaGFzIHx8IG5hbWVdID0gdmFsdWVcbiAgICByZXR1cm4gaGFzXG4gIH1cbn1cbkNhc2VsZXNzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuZGljdClcbiAgICAsIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcbiAgICA7XG4gIGZvciAodmFyIGk9MDtpPGtleXMubGVuZ3RoO2krKykge1xuICAgIGlmIChrZXlzW2ldLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUpIHJldHVybiBrZXlzW2ldXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5DYXNlbGVzcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuICB2YXIgcmVzdWx0LCBfa2V5XG4gIHZhciBoZWFkZXJzID0gdGhpcy5kaWN0XG4gIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIF9rZXkgPSBrZXkudG9Mb3dlckNhc2UoKVxuICAgIGlmIChuYW1lID09PSBfa2V5KSByZXN1bHQgPSBoZWFkZXJzW2tleV1cbiAgfSlcbiAgcmV0dXJuIHJlc3VsdFxufVxuQ2FzZWxlc3MucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgaGFzID0gdGhpcy5oYXMobmFtZSlcbiAgaWYgKGhhcyA9PT0gbmFtZSkgcmV0dXJuXG4gIGlmICghaGFzKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIGhlYWRlciB0aGFuIG1hdGNoZXMgXCInK25hbWUrJ1wiJylcbiAgdGhpcy5kaWN0W25hbWVdID0gdGhpcy5kaWN0W2hhc11cbiAgZGVsZXRlIHRoaXMuZGljdFtoYXNdXG59XG5DYXNlbGVzcy5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGhhcyA9IHRoaXMuaGFzKG5hbWUpXG4gIHJldHVybiBkZWxldGUgdGhpcy5kaWN0W2hhcyB8fCBuYW1lXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkaWN0KSB7cmV0dXJuIG5ldyBDYXNlbGVzcyhkaWN0KX1cbm1vZHVsZS5leHBvcnRzLmh0dHBpZnkgPSBmdW5jdGlvbiAocmVzcCwgaGVhZGVycykge1xuICB2YXIgYyA9IG5ldyBDYXNlbGVzcyhoZWFkZXJzKVxuICByZXNwLnNldEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjbG9iYmVyKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVyblxuICAgIHJldHVybiBjLnNldChrZXksIHZhbHVlLCBjbG9iYmVyKVxuICB9XG4gIHJlc3AuaGFzSGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBjLmhhcyhrZXkpXG4gIH1cbiAgcmVzcC5nZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGMuZ2V0KGtleSlcbiAgfVxuICByZXNwLnJlbW92ZUhlYWRlciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gYy5kZWwoa2V5KVxuICB9XG4gIHJlc3AuaGVhZGVycyA9IGMuZGljdFxuICByZXR1cm4gY1xufVxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIERlbGF5ZWRTdHJlYW0gPSByZXF1aXJlKCdkZWxheWVkLXN0cmVhbScpO1xudmFyIGRlZmVyID0gcmVxdWlyZSgnLi9kZWZlci5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbWJpbmVkU3RyZWFtO1xuZnVuY3Rpb24gQ29tYmluZWRTdHJlYW0oKSB7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG4gIHRoaXMuZGF0YVNpemUgPSAwO1xuICB0aGlzLm1heERhdGFTaXplID0gMiAqIDEwMjQgKiAxMDI0O1xuICB0aGlzLnBhdXNlU3RyZWFtcyA9IHRydWU7XG5cbiAgdGhpcy5fcmVsZWFzZWQgPSBmYWxzZTtcbiAgdGhpcy5fc3RyZWFtcyA9IFtdO1xuICB0aGlzLl9jdXJyZW50U3RyZWFtID0gbnVsbDtcbn1cbnV0aWwuaW5oZXJpdHMoQ29tYmluZWRTdHJlYW0sIFN0cmVhbSk7XG5cbkNvbWJpbmVkU3RyZWFtLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGNvbWJpbmVkU3RyZWFtID0gbmV3IHRoaXMoKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBjb21iaW5lZFN0cmVhbVtvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmVkU3RyZWFtO1xufTtcblxuQ29tYmluZWRTdHJlYW0uaXNTdHJlYW1MaWtlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHJldHVybiAodHlwZW9mIHN0cmVhbSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAmJiAodHlwZW9mIHN0cmVhbSAhPT0gJ3N0cmluZycpXG4gICAgJiYgKHR5cGVvZiBzdHJlYW0gIT09ICdib29sZWFuJylcbiAgICAmJiAodHlwZW9mIHN0cmVhbSAhPT0gJ251bWJlcicpXG4gICAgJiYgKCFCdWZmZXIuaXNCdWZmZXIoc3RyZWFtKSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBpc1N0cmVhbUxpa2UgPSBDb21iaW5lZFN0cmVhbS5pc1N0cmVhbUxpa2Uoc3RyZWFtKTtcblxuICBpZiAoaXNTdHJlYW1MaWtlKSB7XG4gICAgaWYgKCEoc3RyZWFtIGluc3RhbmNlb2YgRGVsYXllZFN0cmVhbSkpIHtcbiAgICAgIHZhciBuZXdTdHJlYW0gPSBEZWxheWVkU3RyZWFtLmNyZWF0ZShzdHJlYW0sIHtcbiAgICAgICAgbWF4RGF0YVNpemU6IEluZmluaXR5LFxuICAgICAgICBwYXVzZVN0cmVhbTogdGhpcy5wYXVzZVN0cmVhbXMsXG4gICAgICB9KTtcbiAgICAgIHN0cmVhbS5vbignZGF0YScsIHRoaXMuX2NoZWNrRGF0YVNpemUuYmluZCh0aGlzKSk7XG4gICAgICBzdHJlYW0gPSBuZXdTdHJlYW07XG4gICAgfVxuXG4gICAgdGhpcy5faGFuZGxlRXJyb3JzKHN0cmVhbSk7XG5cbiAgICBpZiAodGhpcy5wYXVzZVN0cmVhbXMpIHtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3N0cmVhbXMucHVzaChzdHJlYW0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICBTdHJlYW0ucHJvdG90eXBlLnBpcGUuY2FsbCh0aGlzLCBkZXN0LCBvcHRpb25zKTtcbiAgdGhpcy5yZXN1bWUoKTtcbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX2dldE5leHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY3VycmVudFN0cmVhbSA9IG51bGw7XG4gIHZhciBzdHJlYW0gPSB0aGlzLl9zdHJlYW1zLnNoaWZ0KCk7XG5cblxuICBpZiAodHlwZW9mIHN0cmVhbSA9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuZW5kKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9waXBlTmV4dChzdHJlYW0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXRTdHJlYW0gPSBzdHJlYW07XG4gIGdldFN0cmVhbShmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgaXNTdHJlYW1MaWtlID0gQ29tYmluZWRTdHJlYW0uaXNTdHJlYW1MaWtlKHN0cmVhbSk7XG4gICAgaWYgKGlzU3RyZWFtTGlrZSkge1xuICAgICAgc3RyZWFtLm9uKCdkYXRhJywgdGhpcy5fY2hlY2tEYXRhU2l6ZS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX2hhbmRsZUVycm9ycyhzdHJlYW0pO1xuICAgIH1cblxuICAgIGRlZmVyKHRoaXMuX3BpcGVOZXh0LmJpbmQodGhpcywgc3RyZWFtKSk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX3BpcGVOZXh0ID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHRoaXMuX2N1cnJlbnRTdHJlYW0gPSBzdHJlYW07XG5cbiAgdmFyIGlzU3RyZWFtTGlrZSA9IENvbWJpbmVkU3RyZWFtLmlzU3RyZWFtTGlrZShzdHJlYW0pO1xuICBpZiAoaXNTdHJlYW1MaWtlKSB7XG4gICAgc3RyZWFtLm9uKCdlbmQnLCB0aGlzLl9nZXROZXh0LmJpbmQodGhpcykpO1xuICAgIHN0cmVhbS5waXBlKHRoaXMsIHtlbmQ6IGZhbHNlfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gc3RyZWFtO1xuICB0aGlzLndyaXRlKHZhbHVlKTtcbiAgdGhpcy5fZ2V0TmV4dCgpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVFcnJvcnMgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgc2VsZi5fZW1pdEVycm9yKGVycik7XG4gIH0pO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMucGF1c2VTdHJlYW1zKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYodGhpcy5wYXVzZVN0cmVhbXMgJiYgdGhpcy5fY3VycmVudFN0cmVhbSAmJiB0eXBlb2YodGhpcy5fY3VycmVudFN0cmVhbS5wYXVzZSkgPT0gJ2Z1bmN0aW9uJykgdGhpcy5fY3VycmVudFN0cmVhbS5wYXVzZSgpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcmVsZWFzZWQpIHtcbiAgICB0aGlzLl9yZWxlYXNlZCA9IHRydWU7XG4gICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5fZ2V0TmV4dCgpO1xuICB9XG5cbiAgaWYodGhpcy5wYXVzZVN0cmVhbXMgJiYgdGhpcy5fY3VycmVudFN0cmVhbSAmJiB0eXBlb2YodGhpcy5fY3VycmVudFN0cmVhbS5yZXN1bWUpID09ICdmdW5jdGlvbicpIHRoaXMuX2N1cnJlbnRTdHJlYW0ucmVzdW1lKCk7XG4gIHRoaXMuZW1pdCgncmVzdW1lJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuZW1pdCgnZW5kJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZXNldCgpO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdGhpcy5fc3RyZWFtcyA9IFtdO1xuICB0aGlzLl9jdXJyZW50U3RyZWFtID0gbnVsbDtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fY2hlY2tEYXRhU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl91cGRhdGVEYXRhU2l6ZSgpO1xuICBpZiAodGhpcy5kYXRhU2l6ZSA8PSB0aGlzLm1heERhdGFTaXplKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1lc3NhZ2UgPVxuICAgICdEZWxheWVkU3RyZWFtI21heERhdGFTaXplIG9mICcgKyB0aGlzLm1heERhdGFTaXplICsgJyBieXRlcyBleGNlZWRlZC4nO1xuICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fdXBkYXRlRGF0YVNpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kYXRhU2l6ZSA9IDA7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9zdHJlYW1zLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgaWYgKCFzdHJlYW0uZGF0YVNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLmRhdGFTaXplICs9IHN0cmVhbS5kYXRhU2l6ZTtcbiAgfSk7XG5cbiAgaWYgKHRoaXMuX2N1cnJlbnRTdHJlYW0gJiYgdGhpcy5fY3VycmVudFN0cmVhbS5kYXRhU2l6ZSkge1xuICAgIHRoaXMuZGF0YVNpemUgKz0gdGhpcy5fY3VycmVudFN0cmVhbS5kYXRhU2l6ZTtcbiAgfVxufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9lbWl0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgdGhpcy5fcmVzZXQoKTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBkZWZlcjtcblxuLyoqXG4gKiBSdW5zIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBldmVudCBsb29wXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBmdW5jdGlvbiB0byBydW5cbiAqL1xuZnVuY3Rpb24gZGVmZXIoZm4pXG57XG4gIHZhciBuZXh0VGljayA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2V0SW1tZWRpYXRlXG4gICAgOiAoXG4gICAgICB0eXBlb2YgcHJvY2VzcyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb2Nlc3MubmV4dFRpY2tcbiAgICAgIDogbnVsbFxuICAgICk7XG5cbiAgaWYgKG5leHRUaWNrKVxuICB7XG4gICAgbmV4dFRpY2soZm4pO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGVsYXllZFN0cmVhbTtcbmZ1bmN0aW9uIERlbGF5ZWRTdHJlYW0oKSB7XG4gIHRoaXMuc291cmNlID0gbnVsbDtcbiAgdGhpcy5kYXRhU2l6ZSA9IDA7XG4gIHRoaXMubWF4RGF0YVNpemUgPSAxMDI0ICogMTAyNDtcbiAgdGhpcy5wYXVzZVN0cmVhbSA9IHRydWU7XG5cbiAgdGhpcy5fbWF4RGF0YVNpemVFeGNlZWRlZCA9IGZhbHNlO1xuICB0aGlzLl9yZWxlYXNlZCA9IGZhbHNlO1xuICB0aGlzLl9idWZmZXJlZEV2ZW50cyA9IFtdO1xufVxudXRpbC5pbmhlcml0cyhEZWxheWVkU3RyZWFtLCBTdHJlYW0pO1xuXG5EZWxheWVkU3RyZWFtLmNyZWF0ZSA9IGZ1bmN0aW9uKHNvdXJjZSwgb3B0aW9ucykge1xuICB2YXIgZGVsYXllZFN0cmVhbSA9IG5ldyB0aGlzKCk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZvciAodmFyIG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgZGVsYXllZFN0cmVhbVtvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICB9XG5cbiAgZGVsYXllZFN0cmVhbS5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgdmFyIHJlYWxFbWl0ID0gc291cmNlLmVtaXQ7XG4gIHNvdXJjZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgZGVsYXllZFN0cmVhbS5faGFuZGxlRW1pdChhcmd1bWVudHMpO1xuICAgIHJldHVybiByZWFsRW1pdC5hcHBseShzb3VyY2UsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge30pO1xuICBpZiAoZGVsYXllZFN0cmVhbS5wYXVzZVN0cmVhbSkge1xuICAgIHNvdXJjZS5wYXVzZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlbGF5ZWRTdHJlYW07XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGVsYXllZFN0cmVhbS5wcm90b3R5cGUsICdyZWFkYWJsZScsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5yZWFkYWJsZTtcbiAgfVxufSk7XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZS5zZXRFbmNvZGluZy5hcHBseSh0aGlzLnNvdXJjZSwgYXJndW1lbnRzKTtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3JlbGVhc2VkKSB7XG4gICAgdGhpcy5yZWxlYXNlKCk7XG4gIH1cblxuICB0aGlzLnNvdXJjZS5yZXN1bWUoKTtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc291cmNlLnBhdXNlKCk7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3JlbGVhc2VkID0gdHJ1ZTtcblxuICB0aGlzLl9idWZmZXJlZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0uYmluZCh0aGlzKSk7XG4gIHRoaXMuX2J1ZmZlcmVkRXZlbnRzID0gW107XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByID0gU3RyZWFtLnByb3RvdHlwZS5waXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMucmVzdW1lKCk7XG4gIHJldHVybiByO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUuX2hhbmRsZUVtaXQgPSBmdW5jdGlvbihhcmdzKSB7XG4gIGlmICh0aGlzLl9yZWxlYXNlZCkge1xuICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoYXJnc1swXSA9PT0gJ2RhdGEnKSB7XG4gICAgdGhpcy5kYXRhU2l6ZSArPSBhcmdzWzFdLmxlbmd0aDtcbiAgICB0aGlzLl9jaGVja0lmTWF4RGF0YVNpemVFeGNlZWRlZCgpO1xuICB9XG5cbiAgdGhpcy5fYnVmZmVyZWRFdmVudHMucHVzaChhcmdzKTtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLl9jaGVja0lmTWF4RGF0YVNpemVFeGNlZWRlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fbWF4RGF0YVNpemVFeGNlZWRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLmRhdGFTaXplIDw9IHRoaXMubWF4RGF0YVNpemUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9tYXhEYXRhU2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgdmFyIG1lc3NhZ2UgPVxuICAgICdEZWxheWVkU3RyZWFtI21heERhdGFTaXplIG9mICcgKyB0aGlzLm1heERhdGFTaXplICsgJyBieXRlcyBleGNlZWRlZC4nXG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xufTtcbiIsInZhciBjcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKFwianNiblwiKS5CaWdJbnRlZ2VyO1xudmFyIEVDUG9pbnRGcCA9IHJlcXVpcmUoXCIuL2xpYi9lYy5qc1wiKS5FQ1BvaW50RnA7XG52YXIgQnVmZmVyID0gcmVxdWlyZShcInNhZmVyLWJ1ZmZlclwiKS5CdWZmZXI7XG5leHBvcnRzLkVDQ3VydmVzID0gcmVxdWlyZShcIi4vbGliL3NlYy5qc1wiKTtcblxuLy8gemVybyBwcmVwYWRcbmZ1bmN0aW9uIHVuc3R1cGlkKGhleCxsZW4pXG57XG5cdHJldHVybiAoaGV4Lmxlbmd0aCA+PSBsZW4pID8gaGV4IDogdW5zdHVwaWQoXCIwXCIraGV4LGxlbik7XG59XG5cbmV4cG9ydHMuRUNLZXkgPSBmdW5jdGlvbihjdXJ2ZSwga2V5LCBpc1B1YmxpYylcbntcbiAgdmFyIHByaXY7XG5cdHZhciBjID0gY3VydmUoKTtcblx0dmFyIG4gPSBjLmdldE4oKTtcbiAgdmFyIGJ5dGVzID0gTWF0aC5mbG9vcihuLmJpdExlbmd0aCgpLzgpO1xuXG4gIGlmKGtleSlcbiAge1xuICAgIGlmKGlzUHVibGljKVxuICAgIHtcbiAgICAgIHZhciBjdXJ2ZSA9IGMuZ2V0Q3VydmUoKTtcbi8vICAgICAgdmFyIHggPSBrZXkuc2xpY2UoMSxieXRlcysxKTsgLy8gc2tpcCB0aGUgMDQgZm9yIHVuY29tcHJlc3NlZCBmb3JtYXRcbi8vICAgICAgdmFyIHkgPSBrZXkuc2xpY2UoYnl0ZXMrMSk7XG4vLyAgICAgIHRoaXMuUCA9IG5ldyBFQ1BvaW50RnAoY3VydmUsXG4vLyAgICAgICAgY3VydmUuZnJvbUJpZ0ludGVnZXIobmV3IEJpZ0ludGVnZXIoeC50b1N0cmluZyhcImhleFwiKSwgMTYpKSxcbi8vICAgICAgICBjdXJ2ZS5mcm9tQmlnSW50ZWdlcihuZXcgQmlnSW50ZWdlcih5LnRvU3RyaW5nKFwiaGV4XCIpLCAxNikpKTsgICAgICBcbiAgICAgIHRoaXMuUCA9IGN1cnZlLmRlY29kZVBvaW50SGV4KGtleS50b1N0cmluZyhcImhleFwiKSk7XG4gICAgfWVsc2V7XG4gICAgICBpZihrZXkubGVuZ3RoICE9IGJ5dGVzKSByZXR1cm4gZmFsc2U7XG4gICAgICBwcml2ID0gbmV3IEJpZ0ludGVnZXIoa2V5LnRvU3RyaW5nKFwiaGV4XCIpLCAxNik7ICAgICAgXG4gICAgfVxuICB9ZWxzZXtcbiAgICB2YXIgbjEgPSBuLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgICB2YXIgciA9IG5ldyBCaWdJbnRlZ2VyKGNyeXB0by5yYW5kb21CeXRlcyhuLmJpdExlbmd0aCgpKSk7XG4gICAgcHJpdiA9IHIubW9kKG4xKS5hZGQoQmlnSW50ZWdlci5PTkUpO1xuICAgIHRoaXMuUCA9IGMuZ2V0RygpLm11bHRpcGx5KHByaXYpO1xuICB9XG4gIGlmKHRoaXMuUClcbiAge1xuLy8gIHZhciBwdWJoZXggPSB1bnN0dXBpZCh0aGlzLlAuZ2V0WCgpLnRvQmlnSW50ZWdlcigpLnRvU3RyaW5nKDE2KSxieXRlcyoyKSt1bnN0dXBpZCh0aGlzLlAuZ2V0WSgpLnRvQmlnSW50ZWdlcigpLnRvU3RyaW5nKDE2KSxieXRlcyoyKTtcbi8vICB0aGlzLlB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKFwiMDRcIitwdWJoZXgsXCJoZXhcIik7XG4gICAgdGhpcy5QdWJsaWNLZXkgPSBCdWZmZXIuZnJvbShjLmdldEN1cnZlKCkuZW5jb2RlQ29tcHJlc3NlZFBvaW50SGV4KHRoaXMuUCksXCJoZXhcIik7XG4gIH1cbiAgaWYocHJpdilcbiAge1xuICAgIHRoaXMuUHJpdmF0ZUtleSA9IEJ1ZmZlci5mcm9tKHVuc3R1cGlkKHByaXYudG9TdHJpbmcoMTYpLGJ5dGVzKjIpLFwiaGV4XCIpO1xuICAgIHRoaXMuZGVyaXZlU2hhcmVkU2VjcmV0ID0gZnVuY3Rpb24oa2V5KVxuICAgIHtcbiAgICAgIGlmKCFrZXkgfHwgIWtleS5QKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgUyA9IGtleS5QLm11bHRpcGx5KHByaXYpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHVuc3R1cGlkKFMuZ2V0WCgpLnRvQmlnSW50ZWdlcigpLnRvU3RyaW5nKDE2KSxieXRlcyoyKSxcImhleFwiKTtcbiAgIH0gICAgIFxuICB9XG59XG5cbiIsIi8vIEJhc2ljIEphdmFzY3JpcHQgRWxsaXB0aWMgQ3VydmUgaW1wbGVtZW50YXRpb25cbi8vIFBvcnRlZCBsb29zZWx5IGZyb20gQm91bmN5Q2FzdGxlJ3MgSmF2YSBFQyBjb2RlXG4vLyBPbmx5IEZwIGN1cnZlcyBpbXBsZW1lbnRlZCBmb3Igbm93XG5cbi8vIFJlcXVpcmVzIGpzYm4uanMgYW5kIGpzYm4yLmpzXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoJ2pzYm4nKS5CaWdJbnRlZ2VyXG52YXIgQmFycmV0dCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLkJhcnJldHRcblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gRUNGaWVsZEVsZW1lbnRGcFxuXG4vLyBjb25zdHJ1Y3RvclxuZnVuY3Rpb24gRUNGaWVsZEVsZW1lbnRGcChxLHgpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIC8vIFRPRE8gaWYoeC5jb21wYXJlVG8ocSkgPj0gMCkgZXJyb3JcbiAgICB0aGlzLnEgPSBxO1xufVxuXG5mdW5jdGlvbiBmZUZwRXF1YWxzKG90aGVyKSB7XG4gICAgaWYob3RoZXIgPT0gdGhpcykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuICh0aGlzLnEuZXF1YWxzKG90aGVyLnEpICYmIHRoaXMueC5lcXVhbHMob3RoZXIueCkpO1xufVxuXG5mdW5jdGlvbiBmZUZwVG9CaWdJbnRlZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLng7XG59XG5cbmZ1bmN0aW9uIGZlRnBOZWdhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucSwgdGhpcy54Lm5lZ2F0ZSgpLm1vZCh0aGlzLnEpKTtcbn1cblxuZnVuY3Rpb24gZmVGcEFkZChiKSB7XG4gICAgcmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucSwgdGhpcy54LmFkZChiLnRvQmlnSW50ZWdlcigpKS5tb2QodGhpcy5xKSk7XG59XG5cbmZ1bmN0aW9uIGZlRnBTdWJ0cmFjdChiKSB7XG4gICAgcmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucSwgdGhpcy54LnN1YnRyYWN0KGIudG9CaWdJbnRlZ2VyKCkpLm1vZCh0aGlzLnEpKTtcbn1cblxuZnVuY3Rpb24gZmVGcE11bHRpcGx5KGIpIHtcbiAgICByZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5xLCB0aGlzLngubXVsdGlwbHkoYi50b0JpZ0ludGVnZXIoKSkubW9kKHRoaXMucSkpO1xufVxuXG5mdW5jdGlvbiBmZUZwU3F1YXJlKCkge1xuICAgIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnEsIHRoaXMueC5zcXVhcmUoKS5tb2QodGhpcy5xKSk7XG59XG5cbmZ1bmN0aW9uIGZlRnBEaXZpZGUoYikge1xuICAgIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnEsIHRoaXMueC5tdWx0aXBseShiLnRvQmlnSW50ZWdlcigpLm1vZEludmVyc2UodGhpcy5xKSkubW9kKHRoaXMucSkpO1xufVxuXG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5lcXVhbHMgPSBmZUZwRXF1YWxzO1xuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUudG9CaWdJbnRlZ2VyID0gZmVGcFRvQmlnSW50ZWdlcjtcbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLm5lZ2F0ZSA9IGZlRnBOZWdhdGU7XG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5hZGQgPSBmZUZwQWRkO1xuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuc3VidHJhY3QgPSBmZUZwU3VidHJhY3Q7XG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5tdWx0aXBseSA9IGZlRnBNdWx0aXBseTtcbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLnNxdWFyZSA9IGZlRnBTcXVhcmU7XG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5kaXZpZGUgPSBmZUZwRGl2aWRlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBFQ1BvaW50RnBcblxuLy8gY29uc3RydWN0b3JcbmZ1bmN0aW9uIEVDUG9pbnRGcChjdXJ2ZSx4LHkseikge1xuICAgIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgLy8gUHJvamVjdGl2ZSBjb29yZGluYXRlczogZWl0aGVyIHppbnYgPT0gbnVsbCBvciB6ICogemludiA9PSAxXG4gICAgLy8geiBhbmQgemludiBhcmUganVzdCBCaWdJbnRlZ2Vycywgbm90IGZpZWxkRWxlbWVudHNcbiAgICBpZih6ID09IG51bGwpIHtcbiAgICAgIHRoaXMueiA9IEJpZ0ludGVnZXIuT05FO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMueiA9IHo7XG4gICAgfVxuICAgIHRoaXMuemludiA9IG51bGw7XG4gICAgLy9UT0RPOiBjb21wcmVzc2lvbiBmbGFnXG59XG5cbmZ1bmN0aW9uIHBvaW50RnBHZXRYKCkge1xuICAgIGlmKHRoaXMuemludiA9PSBudWxsKSB7XG4gICAgICB0aGlzLnppbnYgPSB0aGlzLnoubW9kSW52ZXJzZSh0aGlzLmN1cnZlLnEpO1xuICAgIH1cbiAgICB2YXIgciA9IHRoaXMueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnppbnYpO1xuICAgIHRoaXMuY3VydmUucmVkdWNlKHIpO1xuICAgIHJldHVybiB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHIpO1xufVxuXG5mdW5jdGlvbiBwb2ludEZwR2V0WSgpIHtcbiAgICBpZih0aGlzLnppbnYgPT0gbnVsbCkge1xuICAgICAgdGhpcy56aW52ID0gdGhpcy56Lm1vZEludmVyc2UodGhpcy5jdXJ2ZS5xKTtcbiAgICB9XG4gICAgdmFyIHIgPSB0aGlzLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56aW52KTtcbiAgICB0aGlzLmN1cnZlLnJlZHVjZShyKTtcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcihyKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRGcEVxdWFscyhvdGhlcikge1xuICAgIGlmKG90aGVyID09IHRoaXMpIHJldHVybiB0cnVlO1xuICAgIGlmKHRoaXMuaXNJbmZpbml0eSgpKSByZXR1cm4gb3RoZXIuaXNJbmZpbml0eSgpO1xuICAgIGlmKG90aGVyLmlzSW5maW5pdHkoKSkgcmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpO1xuICAgIHZhciB1LCB2O1xuICAgIC8vIHUgPSBZMiAqIFoxIC0gWTEgKiBaMlxuICAgIHUgPSBvdGhlci55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KG90aGVyLnopKS5tb2QodGhpcy5jdXJ2ZS5xKTtcbiAgICBpZighdS5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIHYgPSBYMiAqIFoxIC0gWDEgKiBaMlxuICAgIHYgPSBvdGhlci54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KG90aGVyLnopKS5tb2QodGhpcy5jdXJ2ZS5xKTtcbiAgICByZXR1cm4gdi5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRGcElzSW5maW5pdHkoKSB7XG4gICAgaWYoKHRoaXMueCA9PSBudWxsKSAmJiAodGhpcy55ID09IG51bGwpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy56LmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pICYmICF0aGlzLnkudG9CaWdJbnRlZ2VyKCkuZXF1YWxzKEJpZ0ludGVnZXIuWkVSTyk7XG59XG5cbmZ1bmN0aW9uIHBvaW50RnBOZWdhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcy5jdXJ2ZSwgdGhpcy54LCB0aGlzLnkubmVnYXRlKCksIHRoaXMueik7XG59XG5cbmZ1bmN0aW9uIHBvaW50RnBBZGQoYikge1xuICAgIGlmKHRoaXMuaXNJbmZpbml0eSgpKSByZXR1cm4gYjtcbiAgICBpZihiLmlzSW5maW5pdHkoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyB1ID0gWTIgKiBaMSAtIFkxICogWjJcbiAgICB2YXIgdSA9IGIueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseShiLnopKS5tb2QodGhpcy5jdXJ2ZS5xKTtcbiAgICAvLyB2ID0gWDIgKiBaMSAtIFgxICogWjJcbiAgICB2YXIgdiA9IGIueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseShiLnopKS5tb2QodGhpcy5jdXJ2ZS5xKTtcblxuICAgIGlmKEJpZ0ludGVnZXIuWkVSTy5lcXVhbHModikpIHtcbiAgICAgICAgaWYoQmlnSW50ZWdlci5aRVJPLmVxdWFscyh1KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHdpY2UoKTsgLy8gdGhpcyA9PSBiLCBzbyBkb3VibGVcbiAgICAgICAgfVxuXHRyZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpOyAvLyB0aGlzID0gLWIsIHNvIGluZmluaXR5XG4gICAgfVxuXG4gICAgdmFyIFRIUkVFID0gbmV3IEJpZ0ludGVnZXIoXCIzXCIpO1xuICAgIHZhciB4MSA9IHRoaXMueC50b0JpZ0ludGVnZXIoKTtcbiAgICB2YXIgeTEgPSB0aGlzLnkudG9CaWdJbnRlZ2VyKCk7XG4gICAgdmFyIHgyID0gYi54LnRvQmlnSW50ZWdlcigpO1xuICAgIHZhciB5MiA9IGIueS50b0JpZ0ludGVnZXIoKTtcblxuICAgIHZhciB2MiA9IHYuc3F1YXJlKCk7XG4gICAgdmFyIHYzID0gdjIubXVsdGlwbHkodik7XG4gICAgdmFyIHgxdjIgPSB4MS5tdWx0aXBseSh2Mik7XG4gICAgdmFyIHp1MiA9IHUuc3F1YXJlKCkubXVsdGlwbHkodGhpcy56KTtcblxuICAgIC8vIHgzID0gdiAqICh6MiAqICh6MSAqIHVeMiAtIDIgKiB4MSAqIHZeMikgLSB2XjMpXG4gICAgdmFyIHgzID0genUyLnN1YnRyYWN0KHgxdjIuc2hpZnRMZWZ0KDEpKS5tdWx0aXBseShiLnopLnN1YnRyYWN0KHYzKS5tdWx0aXBseSh2KS5tb2QodGhpcy5jdXJ2ZS5xKTtcbiAgICAvLyB5MyA9IHoyICogKDMgKiB4MSAqIHUgKiB2XjIgLSB5MSAqIHZeMyAtIHoxICogdV4zKSArIHUgKiB2XjNcbiAgICB2YXIgeTMgPSB4MXYyLm11bHRpcGx5KFRIUkVFKS5tdWx0aXBseSh1KS5zdWJ0cmFjdCh5MS5tdWx0aXBseSh2MykpLnN1YnRyYWN0KHp1Mi5tdWx0aXBseSh1KSkubXVsdGlwbHkoYi56KS5hZGQodS5tdWx0aXBseSh2MykpLm1vZCh0aGlzLmN1cnZlLnEpO1xuICAgIC8vIHozID0gdl4zICogejEgKiB6MlxuICAgIHZhciB6MyA9IHYzLm11bHRpcGx5KHRoaXMueikubXVsdGlwbHkoYi56KS5tb2QodGhpcy5jdXJ2ZS5xKTtcblxuICAgIHJldHVybiBuZXcgRUNQb2ludEZwKHRoaXMuY3VydmUsIHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoeDMpLCB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHkzKSwgejMpO1xufVxuXG5mdW5jdGlvbiBwb2ludEZwVHdpY2UoKSB7XG4gICAgaWYodGhpcy5pc0luZmluaXR5KCkpIHJldHVybiB0aGlzO1xuICAgIGlmKHRoaXMueS50b0JpZ0ludGVnZXIoKS5zaWdudW0oKSA9PSAwKSByZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpO1xuXG4gICAgLy8gVE9ETzogb3B0aW1pemVkIGhhbmRsaW5nIG9mIGNvbnN0YW50c1xuICAgIHZhciBUSFJFRSA9IG5ldyBCaWdJbnRlZ2VyKFwiM1wiKTtcbiAgICB2YXIgeDEgPSB0aGlzLngudG9CaWdJbnRlZ2VyKCk7XG4gICAgdmFyIHkxID0gdGhpcy55LnRvQmlnSW50ZWdlcigpO1xuXG4gICAgdmFyIHkxejEgPSB5MS5tdWx0aXBseSh0aGlzLnopO1xuICAgIHZhciB5MXNxejEgPSB5MXoxLm11bHRpcGx5KHkxKS5tb2QodGhpcy5jdXJ2ZS5xKTtcbiAgICB2YXIgYSA9IHRoaXMuY3VydmUuYS50b0JpZ0ludGVnZXIoKTtcblxuICAgIC8vIHcgPSAzICogeDFeMiArIGEgKiB6MV4yXG4gICAgdmFyIHcgPSB4MS5zcXVhcmUoKS5tdWx0aXBseShUSFJFRSk7XG4gICAgaWYoIUJpZ0ludGVnZXIuWkVSTy5lcXVhbHMoYSkpIHtcbiAgICAgIHcgPSB3LmFkZCh0aGlzLnouc3F1YXJlKCkubXVsdGlwbHkoYSkpO1xuICAgIH1cbiAgICB3ID0gdy5tb2QodGhpcy5jdXJ2ZS5xKTtcbiAgICAvL3RoaXMuY3VydmUucmVkdWNlKHcpO1xuICAgIC8vIHgzID0gMiAqIHkxICogejEgKiAod14yIC0gOCAqIHgxICogeTFeMiAqIHoxKVxuICAgIHZhciB4MyA9IHcuc3F1YXJlKCkuc3VidHJhY3QoeDEuc2hpZnRMZWZ0KDMpLm11bHRpcGx5KHkxc3F6MSkpLnNoaWZ0TGVmdCgxKS5tdWx0aXBseSh5MXoxKS5tb2QodGhpcy5jdXJ2ZS5xKTtcbiAgICAvLyB5MyA9IDQgKiB5MV4yICogejEgKiAoMyAqIHcgKiB4MSAtIDIgKiB5MV4yICogejEpIC0gd14zXG4gICAgdmFyIHkzID0gdy5tdWx0aXBseShUSFJFRSkubXVsdGlwbHkoeDEpLnN1YnRyYWN0KHkxc3F6MS5zaGlmdExlZnQoMSkpLnNoaWZ0TGVmdCgyKS5tdWx0aXBseSh5MXNxejEpLnN1YnRyYWN0KHcuc3F1YXJlKCkubXVsdGlwbHkodykpLm1vZCh0aGlzLmN1cnZlLnEpO1xuICAgIC8vIHozID0gOCAqICh5MSAqIHoxKV4zXG4gICAgdmFyIHozID0geTF6MS5zcXVhcmUoKS5tdWx0aXBseSh5MXoxKS5zaGlmdExlZnQoMykubW9kKHRoaXMuY3VydmUucSk7XG5cbiAgICByZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLmN1cnZlLCB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHgzKSwgdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih5MyksIHozKTtcbn1cblxuLy8gU2ltcGxlIE5BRiAoTm9uLUFkamFjZW50IEZvcm0pIG11bHRpcGxpY2F0aW9uIGFsZ29yaXRobVxuLy8gVE9ETzogbW9kdWxhcml6ZSB0aGUgbXVsdGlwbGljYXRpb24gYWxnb3JpdGhtXG5mdW5jdGlvbiBwb2ludEZwTXVsdGlwbHkoaykge1xuICAgIGlmKHRoaXMuaXNJbmZpbml0eSgpKSByZXR1cm4gdGhpcztcbiAgICBpZihrLnNpZ251bSgpID09IDApIHJldHVybiB0aGlzLmN1cnZlLmdldEluZmluaXR5KCk7XG5cbiAgICB2YXIgZSA9IGs7XG4gICAgdmFyIGggPSBlLm11bHRpcGx5KG5ldyBCaWdJbnRlZ2VyKFwiM1wiKSk7XG5cbiAgICB2YXIgbmVnID0gdGhpcy5uZWdhdGUoKTtcbiAgICB2YXIgUiA9IHRoaXM7XG5cbiAgICB2YXIgaTtcbiAgICBmb3IoaSA9IGguYml0TGVuZ3RoKCkgLSAyOyBpID4gMDsgLS1pKSB7XG5cdFIgPSBSLnR3aWNlKCk7XG5cblx0dmFyIGhCaXQgPSBoLnRlc3RCaXQoaSk7XG5cdHZhciBlQml0ID0gZS50ZXN0Qml0KGkpO1xuXG5cdGlmIChoQml0ICE9IGVCaXQpIHtcblx0ICAgIFIgPSBSLmFkZChoQml0ID8gdGhpcyA6IG5lZyk7XG5cdH1cbiAgICB9XG5cbiAgICByZXR1cm4gUjtcbn1cblxuLy8gQ29tcHV0ZSB0aGlzKmogKyB4KmsgKHNpbXVsdGFuZW91cyBtdWx0aXBsaWNhdGlvbilcbmZ1bmN0aW9uIHBvaW50RnBNdWx0aXBseVR3byhqLHgsaykge1xuICB2YXIgaTtcbiAgaWYoai5iaXRMZW5ndGgoKSA+IGsuYml0TGVuZ3RoKCkpXG4gICAgaSA9IGouYml0TGVuZ3RoKCkgLSAxO1xuICBlbHNlXG4gICAgaSA9IGsuYml0TGVuZ3RoKCkgLSAxO1xuXG4gIHZhciBSID0gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpO1xuICB2YXIgYm90aCA9IHRoaXMuYWRkKHgpO1xuICB3aGlsZShpID49IDApIHtcbiAgICBSID0gUi50d2ljZSgpO1xuICAgIGlmKGoudGVzdEJpdChpKSkge1xuICAgICAgaWYoay50ZXN0Qml0KGkpKSB7XG4gICAgICAgIFIgPSBSLmFkZChib3RoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBSID0gUi5hZGQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYoay50ZXN0Qml0KGkpKSB7XG4gICAgICAgIFIgPSBSLmFkZCh4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLS1pO1xuICB9XG5cbiAgcmV0dXJuIFI7XG59XG5cbkVDUG9pbnRGcC5wcm90b3R5cGUuZ2V0WCA9IHBvaW50RnBHZXRYO1xuRUNQb2ludEZwLnByb3RvdHlwZS5nZXRZID0gcG9pbnRGcEdldFk7XG5FQ1BvaW50RnAucHJvdG90eXBlLmVxdWFscyA9IHBvaW50RnBFcXVhbHM7XG5FQ1BvaW50RnAucHJvdG90eXBlLmlzSW5maW5pdHkgPSBwb2ludEZwSXNJbmZpbml0eTtcbkVDUG9pbnRGcC5wcm90b3R5cGUubmVnYXRlID0gcG9pbnRGcE5lZ2F0ZTtcbkVDUG9pbnRGcC5wcm90b3R5cGUuYWRkID0gcG9pbnRGcEFkZDtcbkVDUG9pbnRGcC5wcm90b3R5cGUudHdpY2UgPSBwb2ludEZwVHdpY2U7XG5FQ1BvaW50RnAucHJvdG90eXBlLm11bHRpcGx5ID0gcG9pbnRGcE11bHRpcGx5O1xuRUNQb2ludEZwLnByb3RvdHlwZS5tdWx0aXBseVR3byA9IHBvaW50RnBNdWx0aXBseVR3bztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gRUNDdXJ2ZUZwXG5cbi8vIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBFQ0N1cnZlRnAocSxhLGIpIHtcbiAgICB0aGlzLnEgPSBxO1xuICAgIHRoaXMuYSA9IHRoaXMuZnJvbUJpZ0ludGVnZXIoYSk7XG4gICAgdGhpcy5iID0gdGhpcy5mcm9tQmlnSW50ZWdlcihiKTtcbiAgICB0aGlzLmluZmluaXR5ID0gbmV3IEVDUG9pbnRGcCh0aGlzLCBudWxsLCBudWxsKTtcbiAgICB0aGlzLnJlZHVjZXIgPSBuZXcgQmFycmV0dCh0aGlzLnEpO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwR2V0USgpIHtcbiAgICByZXR1cm4gdGhpcy5xO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwR2V0QSgpIHtcbiAgICByZXR1cm4gdGhpcy5hO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwR2V0QigpIHtcbiAgICByZXR1cm4gdGhpcy5iO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwRXF1YWxzKG90aGVyKSB7XG4gICAgaWYob3RoZXIgPT0gdGhpcykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuKHRoaXMucS5lcXVhbHMob3RoZXIucSkgJiYgdGhpcy5hLmVxdWFscyhvdGhlci5hKSAmJiB0aGlzLmIuZXF1YWxzKG90aGVyLmIpKTtcbn1cblxuZnVuY3Rpb24gY3VydmVGcEdldEluZmluaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmluZmluaXR5O1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwRnJvbUJpZ0ludGVnZXIoeCkge1xuICAgIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnEsIHgpO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZVJlZHVjZSh4KSB7XG4gICAgdGhpcy5yZWR1Y2VyLnJlZHVjZSh4KTtcbn1cblxuLy8gZm9yIG5vdywgd29yayB3aXRoIGhleCBzdHJpbmdzIGJlY2F1c2UgdGhleSdyZSBlYXNpZXIgaW4gSlNcbmZ1bmN0aW9uIGN1cnZlRnBEZWNvZGVQb2ludEhleChzKSB7XG4gICAgc3dpdGNoKHBhcnNlSW50KHMuc3Vic3RyKDAsMiksIDE2KSkgeyAvLyBmaXJzdCBieXRlXG4gICAgY2FzZSAwOlxuXHRyZXR1cm4gdGhpcy5pbmZpbml0eTtcbiAgICBjYXNlIDI6XG4gICAgY2FzZSAzOlxuXHQvLyBwb2ludCBjb21wcmVzc2lvbiBub3Qgc3VwcG9ydGVkIHlldFxuXHRyZXR1cm4gbnVsbDtcbiAgICBjYXNlIDQ6XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgNzpcblx0dmFyIGxlbiA9IChzLmxlbmd0aCAtIDIpIC8gMjtcblx0dmFyIHhIZXggPSBzLnN1YnN0cigyLCBsZW4pO1xuXHR2YXIgeUhleCA9IHMuc3Vic3RyKGxlbisyLCBsZW4pO1xuXG5cdHJldHVybiBuZXcgRUNQb2ludEZwKHRoaXMsXG5cdFx0XHQgICAgIHRoaXMuZnJvbUJpZ0ludGVnZXIobmV3IEJpZ0ludGVnZXIoeEhleCwgMTYpKSxcblx0XHRcdCAgICAgdGhpcy5mcm9tQmlnSW50ZWdlcihuZXcgQmlnSW50ZWdlcih5SGV4LCAxNikpKTtcblxuICAgIGRlZmF1bHQ6IC8vIHVuc3VwcG9ydGVkXG5cdHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3VydmVGcEVuY29kZVBvaW50SGV4KHApIHtcblx0aWYgKHAuaXNJbmZpbml0eSgpKSByZXR1cm4gXCIwMFwiO1xuXHR2YXIgeEhleCA9IHAuZ2V0WCgpLnRvQmlnSW50ZWdlcigpLnRvU3RyaW5nKDE2KTtcblx0dmFyIHlIZXggPSBwLmdldFkoKS50b0JpZ0ludGVnZXIoKS50b1N0cmluZygxNik7XG5cdHZhciBvTGVuID0gdGhpcy5nZXRRKCkudG9TdHJpbmcoMTYpLmxlbmd0aDtcblx0aWYgKChvTGVuICUgMikgIT0gMCkgb0xlbisrO1xuXHR3aGlsZSAoeEhleC5sZW5ndGggPCBvTGVuKSB7XG5cdFx0eEhleCA9IFwiMFwiICsgeEhleDtcblx0fVxuXHR3aGlsZSAoeUhleC5sZW5ndGggPCBvTGVuKSB7XG5cdFx0eUhleCA9IFwiMFwiICsgeUhleDtcblx0fVxuXHRyZXR1cm4gXCIwNFwiICsgeEhleCArIHlIZXg7XG59XG5cbkVDQ3VydmVGcC5wcm90b3R5cGUuZ2V0USA9IGN1cnZlRnBHZXRRO1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5nZXRBID0gY3VydmVGcEdldEE7XG5FQ0N1cnZlRnAucHJvdG90eXBlLmdldEIgPSBjdXJ2ZUZwR2V0QjtcbkVDQ3VydmVGcC5wcm90b3R5cGUuZXF1YWxzID0gY3VydmVGcEVxdWFscztcbkVDQ3VydmVGcC5wcm90b3R5cGUuZ2V0SW5maW5pdHkgPSBjdXJ2ZUZwR2V0SW5maW5pdHk7XG5FQ0N1cnZlRnAucHJvdG90eXBlLmZyb21CaWdJbnRlZ2VyID0gY3VydmVGcEZyb21CaWdJbnRlZ2VyO1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5yZWR1Y2UgPSBjdXJ2ZVJlZHVjZTtcbi8vRUNDdXJ2ZUZwLnByb3RvdHlwZS5kZWNvZGVQb2ludEhleCA9IGN1cnZlRnBEZWNvZGVQb2ludEhleDtcbkVDQ3VydmVGcC5wcm90b3R5cGUuZW5jb2RlUG9pbnRIZXggPSBjdXJ2ZUZwRW5jb2RlUG9pbnRIZXg7XG5cbi8vIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9rYWllbHZpbi9qc2JuLWVjLXBvaW50LWNvbXByZXNzaW9uXG5FQ0N1cnZlRnAucHJvdG90eXBlLmRlY29kZVBvaW50SGV4ID0gZnVuY3Rpb24ocylcbntcblx0dmFyIHlJc0V2ZW47XG4gICAgc3dpdGNoKHBhcnNlSW50KHMuc3Vic3RyKDAsMiksIDE2KSkgeyAvLyBmaXJzdCBieXRlXG4gICAgY2FzZSAwOlxuXHRyZXR1cm4gdGhpcy5pbmZpbml0eTtcbiAgICBjYXNlIDI6XG5cdHlJc0V2ZW4gPSBmYWxzZTtcbiAgICBjYXNlIDM6XG5cdGlmKHlJc0V2ZW4gPT0gdW5kZWZpbmVkKSB5SXNFdmVuID0gdHJ1ZTtcblx0dmFyIGxlbiA9IHMubGVuZ3RoIC0gMjtcblx0dmFyIHhIZXggPSBzLnN1YnN0cigyLCBsZW4pO1xuXHR2YXIgeCA9IHRoaXMuZnJvbUJpZ0ludGVnZXIobmV3IEJpZ0ludGVnZXIoeEhleCwxNikpO1xuXHR2YXIgYWxwaGEgPSB4Lm11bHRpcGx5KHguc3F1YXJlKCkuYWRkKHRoaXMuZ2V0QSgpKSkuYWRkKHRoaXMuZ2V0QigpKTtcblx0dmFyIGJldGEgPSBhbHBoYS5zcXJ0KCk7XG5cbiAgICBpZiAoYmV0YSA9PSBudWxsKSB0aHJvdyBcIkludmFsaWQgcG9pbnQgY29tcHJlc3Npb25cIjtcblxuICAgIHZhciBiZXRhVmFsdWUgPSBiZXRhLnRvQmlnSW50ZWdlcigpO1xuICAgIGlmIChiZXRhVmFsdWUudGVzdEJpdCgwKSAhPSB5SXNFdmVuKVxuICAgIHtcbiAgICAgICAgLy8gVXNlIHRoZSBvdGhlciByb290XG4gICAgICAgIGJldGEgPSB0aGlzLmZyb21CaWdJbnRlZ2VyKHRoaXMuZ2V0USgpLnN1YnRyYWN0KGJldGFWYWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLHgsYmV0YSk7XG4gICAgY2FzZSA0OlxuICAgIGNhc2UgNjpcbiAgICBjYXNlIDc6XG5cdHZhciBsZW4gPSAocy5sZW5ndGggLSAyKSAvIDI7XG5cdHZhciB4SGV4ID0gcy5zdWJzdHIoMiwgbGVuKTtcblx0dmFyIHlIZXggPSBzLnN1YnN0cihsZW4rMiwgbGVuKTtcblxuXHRyZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLFxuXHRcdFx0ICAgICB0aGlzLmZyb21CaWdJbnRlZ2VyKG5ldyBCaWdJbnRlZ2VyKHhIZXgsIDE2KSksXG5cdFx0XHQgICAgIHRoaXMuZnJvbUJpZ0ludGVnZXIobmV3IEJpZ0ludGVnZXIoeUhleCwgMTYpKSk7XG5cbiAgICBkZWZhdWx0OiAvLyB1bnN1cHBvcnRlZFxuXHRyZXR1cm4gbnVsbDtcbiAgICB9XG59XG5FQ0N1cnZlRnAucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWRQb2ludEhleCA9IGZ1bmN0aW9uKHApXG57XG5cdGlmIChwLmlzSW5maW5pdHkoKSkgcmV0dXJuIFwiMDBcIjtcblx0dmFyIHhIZXggPSBwLmdldFgoKS50b0JpZ0ludGVnZXIoKS50b1N0cmluZygxNik7XG5cdHZhciBvTGVuID0gdGhpcy5nZXRRKCkudG9TdHJpbmcoMTYpLmxlbmd0aDtcblx0aWYgKChvTGVuICUgMikgIT0gMCkgb0xlbisrO1xuXHR3aGlsZSAoeEhleC5sZW5ndGggPCBvTGVuKVxuXHRcdHhIZXggPSBcIjBcIiArIHhIZXg7XG5cdHZhciB5UHJlZml4O1xuXHRpZihwLmdldFkoKS50b0JpZ0ludGVnZXIoKS5pc0V2ZW4oKSkgeVByZWZpeCA9IFwiMDJcIjtcblx0ZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlQcmVmaXggPSBcIjAzXCI7XG5cblx0cmV0dXJuIHlQcmVmaXggKyB4SGV4O1xufVxuXG5cbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLmdldFIgPSBmdW5jdGlvbigpXG57XG5cdGlmKHRoaXMuciAhPSB1bmRlZmluZWQpIHJldHVybiB0aGlzLnI7XG5cbiAgICB0aGlzLnIgPSBudWxsO1xuICAgIHZhciBiaXRMZW5ndGggPSB0aGlzLnEuYml0TGVuZ3RoKCk7XG4gICAgaWYgKGJpdExlbmd0aCA+IDEyOClcbiAgICB7XG4gICAgICAgIHZhciBmaXJzdFdvcmQgPSB0aGlzLnEuc2hpZnRSaWdodChiaXRMZW5ndGggLSA2NCk7XG4gICAgICAgIGlmIChmaXJzdFdvcmQuaW50VmFsdWUoKSA9PSAtMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KGJpdExlbmd0aCkuc3VidHJhY3QodGhpcy5xKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yO1xufVxuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUubW9kTXVsdCA9IGZ1bmN0aW9uKHgxLHgyKVxue1xuICAgIHJldHVybiB0aGlzLm1vZFJlZHVjZSh4MS5tdWx0aXBseSh4MikpO1xufVxuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUubW9kUmVkdWNlID0gZnVuY3Rpb24oeClcbntcbiAgICBpZiAodGhpcy5nZXRSKCkgIT0gbnVsbClcbiAgICB7XG4gICAgICAgIHZhciBxTGVuID0gcS5iaXRMZW5ndGgoKTtcbiAgICAgICAgd2hpbGUgKHguYml0TGVuZ3RoKCkgPiAocUxlbiArIDEpKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdSA9IHguc2hpZnRSaWdodChxTGVuKTtcbiAgICAgICAgICAgIHZhciB2ID0geC5zdWJ0cmFjdCh1LnNoaWZ0TGVmdChxTGVuKSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0UigpLmVxdWFscyhCaWdJbnRlZ2VyLk9ORSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdSA9IHUubXVsdGlwbHkodGhpcy5nZXRSKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCA9IHUuYWRkKHYpOyBcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoeC5jb21wYXJlVG8ocSkgPj0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgeCA9IHguc3VidHJhY3QocSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgeCA9IHgubW9kKHEpO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbigpXG57XG4gICAgaWYgKCF0aGlzLnEudGVzdEJpdCgwKSkgdGhyb3cgXCJ1bnN1cHBvcnRlZFwiO1xuXG4gICAgLy8gcCBtb2QgNCA9PSAzXG4gICAgaWYgKHRoaXMucS50ZXN0Qml0KDEpKVxuICAgIHtcbiAgICBcdHZhciB6ID0gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5xLHRoaXMueC5tb2RQb3codGhpcy5xLnNoaWZ0UmlnaHQoMikuYWRkKEJpZ0ludGVnZXIuT05FKSx0aGlzLnEpKTtcbiAgICBcdHJldHVybiB6LnNxdWFyZSgpLmVxdWFscyh0aGlzKSA/IHogOiBudWxsO1xuICAgIH1cblxuICAgIC8vIHAgbW9kIDQgPT0gMVxuICAgIHZhciBxTWludXNPbmUgPSB0aGlzLnEuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuXG4gICAgdmFyIGxlZ2VuZHJlRXhwb25lbnQgPSBxTWludXNPbmUuc2hpZnRSaWdodCgxKTtcbiAgICBpZiAoISh0aGlzLngubW9kUG93KGxlZ2VuZHJlRXhwb25lbnQsIHRoaXMucSkuZXF1YWxzKEJpZ0ludGVnZXIuT05FKSkpXG4gICAge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdSA9IHFNaW51c09uZS5zaGlmdFJpZ2h0KDIpO1xuICAgIHZhciBrID0gdS5zaGlmdExlZnQoMSkuYWRkKEJpZ0ludGVnZXIuT05FKTtcblxuICAgIHZhciBRID0gdGhpcy54O1xuICAgIHZhciBmb3VyUSA9IG1vZERvdWJsZShtb2REb3VibGUoUSkpO1xuXG4gICAgdmFyIFUsIFY7XG4gICAgZG9cbiAgICB7XG4gICAgICAgIHZhciBQO1xuICAgICAgICBkb1xuICAgICAgICB7XG4gICAgICAgICAgICBQID0gbmV3IEJpZ0ludGVnZXIodGhpcy5xLmJpdExlbmd0aCgpLCBuZXcgU2VjdXJlUmFuZG9tKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChQLmNvbXBhcmVUbyh0aGlzLnEpID49IDBcbiAgICAgICAgICAgIHx8ICEoUC5tdWx0aXBseShQKS5zdWJ0cmFjdChmb3VyUSkubW9kUG93KGxlZ2VuZHJlRXhwb25lbnQsIHRoaXMucSkuZXF1YWxzKHFNaW51c09uZSkpKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5sdWNhc1NlcXVlbmNlKFAsIFEsIGspO1xuICAgICAgICBVID0gcmVzdWx0WzBdO1xuICAgICAgICBWID0gcmVzdWx0WzFdO1xuXG4gICAgICAgIGlmICh0aGlzLm1vZE11bHQoViwgVikuZXF1YWxzKGZvdXJRKSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gSW50ZWdlciBkaXZpc2lvbiBieSAyLCBtb2QgcVxuICAgICAgICAgICAgaWYgKFYudGVzdEJpdCgwKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBWID0gVi5hZGQocSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFYgPSBWLnNoaWZ0UmlnaHQoMSk7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcChxLFYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChVLmVxdWFscyhCaWdJbnRlZ2VyLk9ORSkgfHwgVS5lcXVhbHMocU1pbnVzT25lKSk7XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLmx1Y2FzU2VxdWVuY2UgPSBmdW5jdGlvbihQLFEsaylcbntcbiAgICB2YXIgbiA9IGsuYml0TGVuZ3RoKCk7XG4gICAgdmFyIHMgPSBrLmdldExvd2VzdFNldEJpdCgpO1xuXG4gICAgdmFyIFVoID0gQmlnSW50ZWdlci5PTkU7XG4gICAgdmFyIFZsID0gQmlnSW50ZWdlci5UV087XG4gICAgdmFyIFZoID0gUDtcbiAgICB2YXIgUWwgPSBCaWdJbnRlZ2VyLk9ORTtcbiAgICB2YXIgUWggPSBCaWdJbnRlZ2VyLk9ORTtcblxuICAgIGZvciAodmFyIGogPSBuIC0gMTsgaiA+PSBzICsgMTsgLS1qKVxuICAgIHtcbiAgICAgICAgUWwgPSB0aGlzLm1vZE11bHQoUWwsIFFoKTtcblxuICAgICAgICBpZiAoay50ZXN0Qml0KGopKVxuICAgICAgICB7XG4gICAgICAgICAgICBRaCA9IHRoaXMubW9kTXVsdChRbCwgUSk7XG4gICAgICAgICAgICBVaCA9IHRoaXMubW9kTXVsdChVaCwgVmgpO1xuICAgICAgICAgICAgVmwgPSB0aGlzLm1vZFJlZHVjZShWaC5tdWx0aXBseShWbCkuc3VidHJhY3QoUC5tdWx0aXBseShRbCkpKTtcbiAgICAgICAgICAgIFZoID0gdGhpcy5tb2RSZWR1Y2UoVmgubXVsdGlwbHkoVmgpLnN1YnRyYWN0KFFoLnNoaWZ0TGVmdCgxKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgUWggPSBRbDtcbiAgICAgICAgICAgIFVoID0gdGhpcy5tb2RSZWR1Y2UoVWgubXVsdGlwbHkoVmwpLnN1YnRyYWN0KFFsKSk7XG4gICAgICAgICAgICBWaCA9IHRoaXMubW9kUmVkdWNlKFZoLm11bHRpcGx5KFZsKS5zdWJ0cmFjdChQLm11bHRpcGx5KFFsKSkpO1xuICAgICAgICAgICAgVmwgPSB0aGlzLm1vZFJlZHVjZShWbC5tdWx0aXBseShWbCkuc3VidHJhY3QoUWwuc2hpZnRMZWZ0KDEpKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBRbCA9IHRoaXMubW9kTXVsdChRbCwgUWgpO1xuICAgIFFoID0gdGhpcy5tb2RNdWx0KFFsLCBRKTtcbiAgICBVaCA9IHRoaXMubW9kUmVkdWNlKFVoLm11bHRpcGx5KFZsKS5zdWJ0cmFjdChRbCkpO1xuICAgIFZsID0gdGhpcy5tb2RSZWR1Y2UoVmgubXVsdGlwbHkoVmwpLnN1YnRyYWN0KFAubXVsdGlwbHkoUWwpKSk7XG4gICAgUWwgPSB0aGlzLm1vZE11bHQoUWwsIFFoKTtcblxuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IHM7ICsrailcbiAgICB7XG4gICAgICAgIFVoID0gdGhpcy5tb2RNdWx0KFVoLCBWbCk7XG4gICAgICAgIFZsID0gdGhpcy5tb2RSZWR1Y2UoVmwubXVsdGlwbHkoVmwpLnN1YnRyYWN0KFFsLnNoaWZ0TGVmdCgxKSkpO1xuICAgICAgICBRbCA9IHRoaXMubW9kTXVsdChRbCwgUWwpO1xuICAgIH1cblxuICAgIHJldHVybiBbIFVoLCBWbCBdO1xufVxuXG52YXIgZXhwb3J0cyA9IHtcbiAgRUNDdXJ2ZUZwOiBFQ0N1cnZlRnAsXG4gIEVDUG9pbnRGcDogRUNQb2ludEZwLFxuICBFQ0ZpZWxkRWxlbWVudEZwOiBFQ0ZpZWxkRWxlbWVudEZwXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1xuIiwiLy8gTmFtZWQgRUMgY3VydmVzXG5cbi8vIFJlcXVpcmVzIGVjLmpzLCBqc2JuLmpzLCBhbmQganNibjIuanNcbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZSgnanNibicpLkJpZ0ludGVnZXJcbnZhciBFQ0N1cnZlRnAgPSByZXF1aXJlKCcuL2VjLmpzJykuRUNDdXJ2ZUZwXG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gWDlFQ1BhcmFtZXRlcnNcblxuLy8gY29uc3RydWN0b3JcbmZ1bmN0aW9uIFg5RUNQYXJhbWV0ZXJzKGN1cnZlLGcsbixoKSB7XG4gICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgIHRoaXMuZyA9IGc7XG4gICAgdGhpcy5uID0gbjtcbiAgICB0aGlzLmggPSBoO1xufVxuXG5mdW5jdGlvbiB4OWdldEN1cnZlKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnZlO1xufVxuXG5mdW5jdGlvbiB4OWdldEcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZztcbn1cblxuZnVuY3Rpb24geDlnZXROKCkge1xuICAgIHJldHVybiB0aGlzLm47XG59XG5cbmZ1bmN0aW9uIHg5Z2V0SCgpIHtcbiAgICByZXR1cm4gdGhpcy5oO1xufVxuXG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0Q3VydmUgPSB4OWdldEN1cnZlO1xuWDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldEcgPSB4OWdldEc7XG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0TiA9IHg5Z2V0Tjtcblg5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRIID0geDlnZXRIO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBTRUNOYW1lZEN1cnZlc1xuXG5mdW5jdGlvbiBmcm9tSGV4KHMpIHsgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHMsIDE2KTsgfVxuXG5mdW5jdGlvbiBzZWNwMTI4cjEoKSB7XG4gICAgLy8gcCA9IDJeMTI4IC0gMl45NyAtIDFcbiAgICB2YXIgcCA9IGZyb21IZXgoXCJGRkZGRkZGREZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRlwiKTtcbiAgICB2YXIgYSA9IGZyb21IZXgoXCJGRkZGRkZGREZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGQ1wiKTtcbiAgICB2YXIgYiA9IGZyb21IZXgoXCJFODc1NzlDMTEwNzlGNDNERDgyNDk5M0MyQ0VFNUVEM1wiKTtcbiAgICAvL2J5dGVbXSBTID0gSGV4LmRlY29kZShcIjAwMEUwRDRENjk2RTY3Njg3NTYxNTE3NTBDQzAzQTQ0NzNEMDM2NzlcIik7XG4gICAgdmFyIG4gPSBmcm9tSGV4KFwiRkZGRkZGRkUwMDAwMDAwMDc1QTMwRDFCOTAzOEExMTVcIik7XG4gICAgdmFyIGggPSBCaWdJbnRlZ2VyLk9ORTtcbiAgICB2YXIgY3VydmUgPSBuZXcgRUNDdXJ2ZUZwKHAsIGEsIGIpO1xuICAgIHZhciBHID0gY3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiXG4gICAgICAgICAgICAgICAgKyBcIjE2MUZGNzUyOEI4OTlCMkQwQzI4NjA3Q0E1MkM1Qjg2XCJcblx0XHQrIFwiQ0Y1QUM4Mzk1QkFGRUIxM0MwMkRBMjkyRERFRDdBODNcIik7XG4gICAgcmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSwgRywgbiwgaCk7XG59XG5cbmZ1bmN0aW9uIHNlY3AxNjBrMSgpIHtcbiAgICAvLyBwID0gMl4xNjAgLSAyXjMyIC0gMl4xNCAtIDJeMTIgLSAyXjkgLSAyXjggLSAyXjcgLSAyXjMgLSAyXjIgLSAxXG4gICAgdmFyIHAgPSBmcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVGRkZGQUM3M1wiKTtcbiAgICB2YXIgYSA9IEJpZ0ludGVnZXIuWkVSTztcbiAgICB2YXIgYiA9IGZyb21IZXgoXCI3XCIpO1xuICAgIC8vYnl0ZVtdIFMgPSBudWxsO1xuICAgIHZhciBuID0gZnJvbUhleChcIjAxMDAwMDAwMDAwMDAwMDAwMDAwMDFCOEZBMTZERkFCOUFDQTE2QjZCM1wiKTtcbiAgICB2YXIgaCA9IEJpZ0ludGVnZXIuT05FO1xuICAgIHZhciBjdXJ2ZSA9IG5ldyBFQ0N1cnZlRnAocCwgYSwgYik7XG4gICAgdmFyIEcgPSBjdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCJcbiAgICAgICAgICAgICAgICArIFwiM0I0QzM4MkNFMzdBQTE5MkE0MDE5RTc2MzAzNkY0RjVERDREN0VCQlwiXG4gICAgICAgICAgICAgICAgKyBcIjkzOENGOTM1MzE4RkRDRUQ2QkMyODI4NjUzMTczM0MzRjAzQzRGRUVcIik7XG4gICAgcmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSwgRywgbiwgaCk7XG59XG5cbmZ1bmN0aW9uIHNlY3AxNjByMSgpIHtcbiAgICAvLyBwID0gMl4xNjAgLSAyXjMxIC0gMVxuICAgIHZhciBwID0gZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGN0ZGRkZGRkZcIik7XG4gICAgdmFyIGEgPSBmcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY3RkZGRkZGQ1wiKTtcbiAgICB2YXIgYiA9IGZyb21IZXgoXCIxQzk3QkVGQzU0QkQ3QThCNjVBQ0Y4OUY4MUQ0RDRBREM1NjVGQTQ1XCIpO1xuICAgIC8vYnl0ZVtdIFMgPSBIZXguZGVjb2RlKFwiMTA1M0NERTQyQzE0RDY5NkU2NzY4NzU2MTUxNzUzM0JGM0Y4MzM0NVwiKTtcbiAgICB2YXIgbiA9IGZyb21IZXgoXCIwMTAwMDAwMDAwMDAwMDAwMDAwMDAxRjRDOEY5MjdBRUQzQ0E3NTIyNTdcIik7XG4gICAgdmFyIGggPSBCaWdJbnRlZ2VyLk9ORTtcbiAgICB2YXIgY3VydmUgPSBuZXcgRUNDdXJ2ZUZwKHAsIGEsIGIpO1xuICAgIHZhciBHID0gY3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiXG5cdFx0KyBcIjRBOTZCNTY4OEVGNTczMjg0NjY0Njk4OTY4QzM4QkI5MTNDQkZDODJcIlxuXHRcdCsgXCIyM0E2Mjg1NTMxNjg5NDdENTlEQ0M5MTIwNDIzNTEzNzdBQzVGQjMyXCIpO1xuICAgIHJldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsIEcsIG4sIGgpO1xufVxuXG5mdW5jdGlvbiBzZWNwMTkyazEoKSB7XG4gICAgLy8gcCA9IDJeMTkyIC0gMl4zMiAtIDJeMTIgLSAyXjggLSAyXjcgLSAyXjYgLSAyXjMgLSAxXG4gICAgdmFyIHAgPSBmcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUZGRkZFRTM3XCIpO1xuICAgIHZhciBhID0gQmlnSW50ZWdlci5aRVJPO1xuICAgIHZhciBiID0gZnJvbUhleChcIjNcIik7XG4gICAgLy9ieXRlW10gUyA9IG51bGw7XG4gICAgdmFyIG4gPSBmcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFMjZGMkZDMTcwRjY5NDY2QTc0REVGRDhEXCIpO1xuICAgIHZhciBoID0gQmlnSW50ZWdlci5PTkU7XG4gICAgdmFyIGN1cnZlID0gbmV3IEVDQ3VydmVGcChwLCBhLCBiKTtcbiAgICB2YXIgRyA9IGN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIlxuICAgICAgICAgICAgICAgICsgXCJEQjRGRjEwRUMwNTdFOUFFMjZCMDdEMDI4MEI3RjQzNDFEQTVEMUIxRUFFMDZDN0RcIlxuICAgICAgICAgICAgICAgICsgXCI5QjJGMkY2RDlDNTYyOEE3ODQ0MTYzRDAxNUJFODYzNDQwODJBQTg4RDk1RTJGOURcIik7XG4gICAgcmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSwgRywgbiwgaCk7XG59XG5cbmZ1bmN0aW9uIHNlY3AxOTJyMSgpIHtcbiAgICAvLyBwID0gMl4xOTIgLSAyXjY0IC0gMVxuICAgIHZhciBwID0gZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFRkZGRkZGRkZGRkZGRkZGRlwiKTtcbiAgICB2YXIgYSA9IGZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUZGRkZGRkZGRkZGRkZGRkNcIik7XG4gICAgdmFyIGIgPSBmcm9tSGV4KFwiNjQyMTA1MTlFNTlDODBFNzBGQTdFOUFCNzIyNDMwNDlGRUI4REVFQ0MxNDZCOUIxXCIpO1xuICAgIC8vYnl0ZVtdIFMgPSBIZXguZGVjb2RlKFwiMzA0NUFFNkZDODQyMkY2NEVENTc5NTI4RDM4MTIwRUFFMTIxOTZENVwiKTtcbiAgICB2YXIgbiA9IGZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkY5OURFRjgzNjE0NkJDOUIxQjREMjI4MzFcIik7XG4gICAgdmFyIGggPSBCaWdJbnRlZ2VyLk9ORTtcbiAgICB2YXIgY3VydmUgPSBuZXcgRUNDdXJ2ZUZwKHAsIGEsIGIpO1xuICAgIHZhciBHID0gY3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiXG4gICAgICAgICAgICAgICAgKyBcIjE4OERBODBFQjAzMDkwRjY3Q0JGMjBFQjQzQTE4ODAwRjRGRjBBRkQ4MkZGMTAxMlwiXG4gICAgICAgICAgICAgICAgKyBcIjA3MTkyQjk1RkZDOERBNzg2MzEwMTFFRDZCMjRDREQ1NzNGOTc3QTExRTc5NDgxMVwiKTtcbiAgICByZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLCBHLCBuLCBoKTtcbn1cblxuZnVuY3Rpb24gc2VjcDIyNHIxKCkge1xuICAgIC8vIHAgPSAyXjIyNCAtIDJeOTYgKyAxXG4gICAgdmFyIHAgPSBmcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIik7XG4gICAgdmFyIGEgPSBmcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVcIik7XG4gICAgdmFyIGIgPSBmcm9tSGV4KFwiQjQwNTBBODUwQzA0QjNBQkY1NDEzMjU2NTA0NEIwQjdEN0JGRDhCQTI3MEIzOTQzMjM1NUZGQjRcIik7XG4gICAgLy9ieXRlW10gUyA9IEhleC5kZWNvZGUoXCJCRDcxMzQ0Nzk5RDVDN0ZDREM0NUI1OUZBM0I5QUI4RjZBOTQ4QkM1XCIpO1xuICAgIHZhciBuID0gZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkYxNkEyRTBCOEYwM0UxM0REMjk0NTVDNUMyQTNEXCIpO1xuICAgIHZhciBoID0gQmlnSW50ZWdlci5PTkU7XG4gICAgdmFyIGN1cnZlID0gbmV3IEVDQ3VydmVGcChwLCBhLCBiKTtcbiAgICB2YXIgRyA9IGN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIlxuICAgICAgICAgICAgICAgICsgXCJCNzBFMENCRDZCQjRCRjdGMzIxMzkwQjk0QTAzQzFEMzU2QzIxMTIyMzQzMjgwRDYxMTVDMUQyMVwiXG4gICAgICAgICAgICAgICAgKyBcIkJEMzc2Mzg4QjVGNzIzRkI0QzIyREZFNkNENDM3NUEwNUEwNzQ3NjQ0NEQ1ODE5OTg1MDA3RTM0XCIpO1xuICAgIHJldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsIEcsIG4sIGgpO1xufVxuXG5mdW5jdGlvbiBzZWNwMjU2cjEoKSB7XG4gICAgLy8gcCA9IDJeMjI0ICgyXjMyIC0gMSkgKyAyXjE5MiArIDJeOTYgLSAxXG4gICAgdmFyIHAgPSBmcm9tSGV4KFwiRkZGRkZGRkYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRlwiKTtcbiAgICB2YXIgYSA9IGZyb21IZXgoXCJGRkZGRkZGRjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZDXCIpO1xuICAgIHZhciBiID0gZnJvbUhleChcIjVBQzYzNUQ4QUEzQTkzRTdCM0VCQkQ1NTc2OTg4NkJDNjUxRDA2QjBDQzUzQjBGNjNCQ0UzQzNFMjdEMjYwNEJcIik7XG4gICAgLy9ieXRlW10gUyA9IEhleC5kZWNvZGUoXCJDNDlEMzYwODg2RTcwNDkzNkE2Njc4RTExMzlEMjZCNzgxOUY3RTkwXCIpO1xuICAgIHZhciBuID0gZnJvbUhleChcIkZGRkZGRkZGMDAwMDAwMDBGRkZGRkZGRkZGRkZGRkZGQkNFNkZBQURBNzE3OUU4NEYzQjlDQUMyRkM2MzI1NTFcIik7XG4gICAgdmFyIGggPSBCaWdJbnRlZ2VyLk9ORTtcbiAgICB2YXIgY3VydmUgPSBuZXcgRUNDdXJ2ZUZwKHAsIGEsIGIpO1xuICAgIHZhciBHID0gY3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiXG4gICAgICAgICAgICAgICAgKyBcIjZCMTdEMUYyRTEyQzQyNDdGOEJDRTZFNTYzQTQ0MEYyNzcwMzdEODEyREVCMzNBMEY0QTEzOTQ1RDg5OEMyOTZcIlxuXHRcdCsgXCI0RkUzNDJFMkZFMUE3RjlCOEVFN0VCNEE3QzBGOUUxNjJCQ0UzMzU3NkIzMTVFQ0VDQkI2NDA2ODM3QkY1MUY1XCIpO1xuICAgIHJldHVybiBuZXcgWDlFQ1BhcmFtZXRlcnMoY3VydmUsIEcsIG4sIGgpO1xufVxuXG4vLyBUT0RPOiBtYWtlIHRoaXMgaW50byBhIHByb3BlciBoYXNodGFibGVcbmZ1bmN0aW9uIGdldFNFQ0N1cnZlQnlOYW1lKG5hbWUpIHtcbiAgICBpZihuYW1lID09IFwic2VjcDEyOHIxXCIpIHJldHVybiBzZWNwMTI4cjEoKTtcbiAgICBpZihuYW1lID09IFwic2VjcDE2MGsxXCIpIHJldHVybiBzZWNwMTYwazEoKTtcbiAgICBpZihuYW1lID09IFwic2VjcDE2MHIxXCIpIHJldHVybiBzZWNwMTYwcjEoKTtcbiAgICBpZihuYW1lID09IFwic2VjcDE5MmsxXCIpIHJldHVybiBzZWNwMTkyazEoKTtcbiAgICBpZihuYW1lID09IFwic2VjcDE5MnIxXCIpIHJldHVybiBzZWNwMTkycjEoKTtcbiAgICBpZihuYW1lID09IFwic2VjcDIyNHIxXCIpIHJldHVybiBzZWNwMjI0cjEoKTtcbiAgICBpZihuYW1lID09IFwic2VjcDI1NnIxXCIpIHJldHVybiBzZWNwMjU2cjEoKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwic2VjcDEyOHIxXCI6c2VjcDEyOHIxLFxuICBcInNlY3AxNjBrMVwiOnNlY3AxNjBrMSxcbiAgXCJzZWNwMTYwcjFcIjpzZWNwMTYwcjEsXG4gIFwic2VjcDE5MmsxXCI6c2VjcDE5MmsxLFxuICBcInNlY3AxOTJyMVwiOnNlY3AxOTJyMSxcbiAgXCJzZWNwMjI0cjFcIjpzZWNwMjI0cjEsXG4gIFwic2VjcDI1NnIxXCI6c2VjcDI1NnIxXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuXHRpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpO1xuXHR9XG5cblx0cmV0dXJuIHRvU3RyLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcblx0aWYgKCFvYmogfHwgdG9TdHIuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBoYXNPd25Db25zdHJ1Y3RvciA9IGhhc093bi5jYWxsKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XG5cdHZhciBoYXNJc1Byb3RvdHlwZU9mID0gb2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgJiYgaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcblx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNPd25Db25zdHJ1Y3RvciAmJiAhaGFzSXNQcm90b3R5cGVPZikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIE93biBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhdGVkIGZpcnN0bHksIHNvIHRvIHNwZWVkIHVwLFxuXHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93bi5cblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gb2JqKSB7IC8qKi8gfVxuXG5cdHJldHVybiB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyB8fCBoYXNPd24uY2FsbChvYmosIGtleSk7XG59O1xuXG4vLyBJZiBuYW1lIGlzICdfX3Byb3RvX18nLCBhbmQgT2JqZWN0LmRlZmluZVByb3BlcnR5IGlzIGF2YWlsYWJsZSwgZGVmaW5lIF9fcHJvdG9fXyBhcyBhbiBvd24gcHJvcGVydHkgb24gdGFyZ2V0XG52YXIgc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eSh0YXJnZXQsIG9wdGlvbnMpIHtcblx0aWYgKGRlZmluZVByb3BlcnR5ICYmIG9wdGlvbnMubmFtZSA9PT0gJ19fcHJvdG9fXycpIHtcblx0XHRkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG9wdGlvbnMubmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBvcHRpb25zLm5ld1ZhbHVlLFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR0YXJnZXRbb3B0aW9ucy5uYW1lXSA9IG9wdGlvbnMubmV3VmFsdWU7XG5cdH1cbn07XG5cbi8vIFJldHVybiB1bmRlZmluZWQgaW5zdGVhZCBvZiBfX3Byb3RvX18gaWYgJ19fcHJvdG9fXycgaXMgbm90IGFuIG93biBwcm9wZXJ0eVxudmFyIGdldFByb3BlcnR5ID0gZnVuY3Rpb24gZ2V0UHJvcGVydHkob2JqLCBuYW1lKSB7XG5cdGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuXHRcdGlmICghaGFzT3duLmNhbGwob2JqLCBuYW1lKSkge1xuXHRcdFx0cmV0dXJuIHZvaWQgMDtcblx0XHR9IGVsc2UgaWYgKGdPUEQpIHtcblx0XHRcdC8vIEluIGVhcmx5IHZlcnNpb25zIG9mIG5vZGUsIG9ialsnX19wcm90b19fJ10gaXMgYnVnZ3kgd2hlbiBvYmogaGFzXG5cdFx0XHQvLyBfX3Byb3RvX18gYXMgYW4gb3duIHByb3BlcnR5LiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkgd29ya3MuXG5cdFx0XHRyZXR1cm4gZ09QRChvYmosIG5hbWUpLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvYmpbbmFtZV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lO1xuXHR2YXIgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuXHR2YXIgaSA9IDE7XG5cdHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXHR2YXIgZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKHR5cGVvZiB0YXJnZXQgPT09ICdib29sZWFuJykge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHRpID0gMjtcblx0fVxuXHRpZiAodGFyZ2V0ID09IG51bGwgfHwgKHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnICYmIHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHRmb3IgKDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1tpXTtcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yIChuYW1lIGluIG9wdGlvbnMpIHtcblx0XHRcdFx0c3JjID0gZ2V0UHJvcGVydHkodGFyZ2V0LCBuYW1lKTtcblx0XHRcdFx0Y29weSA9IGdldFByb3BlcnR5KG9wdGlvbnMsIG5hbWUpO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKHRhcmdldCAhPT0gY29weSkge1xuXHRcdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRcdGlmIChkZWVwICYmIGNvcHkgJiYgKGlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gaXNBcnJheShjb3B5KSkpKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29weUlzQXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0XHRzZXRQcm9wZXJ0eSh0YXJnZXQsIHsgbmFtZTogbmFtZSwgbmV3VmFsdWU6IGV4dGVuZChkZWVwLCBjbG9uZSwgY29weSkgfSk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29weSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdHNldFByb3BlcnR5KHRhcmdldCwgeyBuYW1lOiBuYW1lLCBuZXdWYWx1ZTogY29weSB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcbiIsIi8qXG4gKiBleHRzcHJpbnRmLmpzOiBleHRlbmRlZCBQT1NJWC1zdHlsZSBzcHJpbnRmXG4gKi9cblxudmFyIG1vZF9hc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBtb2RfdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLypcbiAqIFB1YmxpYyBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0cy5zcHJpbnRmID0ganNTcHJpbnRmO1xuZXhwb3J0cy5wcmludGYgPSBqc1ByaW50ZjtcbmV4cG9ydHMuZnByaW50ZiA9IGpzRnByaW50ZjtcblxuLypcbiAqIFN0cmlwcGVkIGRvd24gdmVyc2lvbiBvZiBzW25dcHJpbnRmKDNjKS4gIFdlIG1ha2UgYSBiZXN0IGVmZm9ydCB0byB0aHJvdyBhblxuICogZXhjZXB0aW9uIHdoZW4gZ2l2ZW4gYSBmb3JtYXQgc3RyaW5nIHdlIGRvbid0IHVuZGVyc3RhbmQsIHJhdGhlciB0aGFuXG4gKiBpZ25vcmluZyBpdCwgc28gdGhhdCB3ZSB3b24ndCBicmVhayBleGlzdGluZyBwcm9ncmFtcyBpZi93aGVuIHdlIGdvIGltcGxlbWVudFxuICogdGhlIHJlc3Qgb2YgdGhpcy5cbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGN1cnJlbnRseSBzdXBwb3J0cyBzcGVjaWZ5aW5nXG4gKlx0LSBmaWVsZCBhbGlnbm1lbnQgKCctJyBmbGFnKSxcbiAqIFx0LSB6ZXJvLXBhZCAoJzAnIGZsYWcpXG4gKlx0LSBhbHdheXMgc2hvdyBudW1lcmljIHNpZ24gKCcrJyBmbGFnKSxcbiAqXHQtIGZpZWxkIHdpZHRoXG4gKlx0LSBjb252ZXJzaW9ucyBmb3Igc3RyaW5ncywgZGVjaW1hbCBpbnRlZ2VycywgYW5kIGZsb2F0cyAobnVtYmVycykuXG4gKlx0LSBhcmd1bWVudCBzaXplIHNwZWNpZmllcnMuICBUaGVzZSBhcmUgYWxsIGFjY2VwdGVkIGJ1dCBpZ25vcmVkLCBzaW5jZVxuICpcdCAgSmF2YXNjcmlwdCBoYXMgbm8gbm90aW9uIG9mIHRoZSBwaHlzaWNhbCBzaXplIG9mIGFuIGFyZ3VtZW50LlxuICpcbiAqIEV2ZXJ5dGhpbmcgZWxzZSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQsIG1vc3Qgbm90YWJseSBwcmVjaXNpb24sIHVuc2lnbmVkXG4gKiBudW1iZXJzLCBub24tZGVjaW1hbCBudW1iZXJzLCBhbmQgY2hhcmFjdGVycy5cbiAqL1xuZnVuY3Rpb24ganNTcHJpbnRmKGZtdClcbntcblx0dmFyIHJlZ2V4ID0gW1xuXHQgICAgJyhbXiVdKiknLFx0XHRcdFx0Lyogbm9ybWFsIHRleHQgKi9cblx0ICAgICclJyxcdFx0XHRcdC8qIHN0YXJ0IG9mIGZvcm1hdCAqL1xuXHQgICAgJyhbXFwnXFxcXC0rICMwXSo/KScsXHRcdFx0LyogZmxhZ3MgKG9wdGlvbmFsKSAqL1xuXHQgICAgJyhbMS05XVxcXFxkKik/JyxcdFx0XHQvKiB3aWR0aCAob3B0aW9uYWwpICovXG5cdCAgICAnKFxcXFwuKFsxLTldXFxcXGQqKSk/JyxcdFx0LyogcHJlY2lzaW9uIChvcHRpb25hbCkgKi9cblx0ICAgICdbbGhqenRMXSo/JyxcdFx0XHQvKiBsZW5ndGggbW9kcyAoaWdub3JlZCkgKi9cblx0ICAgICcoW2Rpb3V4WGZGZUVnR2FBY0NzU3AlanJdKSdcdC8qIGNvbnZlcnNpb24gKi9cblx0XS5qb2luKCcnKTtcblxuXHR2YXIgcmUgPSBuZXcgUmVnRXhwKHJlZ2V4KTtcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHR2YXIgZmxhZ3MsIHdpZHRoLCBwcmVjaXNpb24sIGNvbnZlcnNpb247XG5cdHZhciBsZWZ0LCBwYWQsIHNpZ24sIGFyZywgbWF0Y2g7XG5cdHZhciByZXQgPSAnJztcblx0dmFyIGFyZ24gPSAxO1xuXG5cdG1vZF9hc3NlcnQuZXF1YWwoJ3N0cmluZycsIHR5cGVvZiAoZm10KSk7XG5cblx0d2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZm10KSkgIT09IG51bGwpIHtcblx0XHRyZXQgKz0gbWF0Y2hbMV07XG5cdFx0Zm10ID0gZm10LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuXG5cdFx0ZmxhZ3MgPSBtYXRjaFsyXSB8fCAnJztcblx0XHR3aWR0aCA9IG1hdGNoWzNdIHx8IDA7XG5cdFx0cHJlY2lzaW9uID0gbWF0Y2hbNF0gfHwgJyc7XG5cdFx0Y29udmVyc2lvbiA9IG1hdGNoWzZdO1xuXHRcdGxlZnQgPSBmYWxzZTtcblx0XHRzaWduID0gZmFsc2U7XG5cdFx0cGFkID0gJyAnO1xuXG5cdFx0aWYgKGNvbnZlcnNpb24gPT0gJyUnKSB7XG5cdFx0XHRyZXQgKz0gJyUnO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcigndG9vIGZldyBhcmdzIHRvIHNwcmludGYnKSk7XG5cblx0XHRhcmcgPSBhcmdzLnNoaWZ0KCk7XG5cdFx0YXJnbisrO1xuXG5cdFx0aWYgKGZsYWdzLm1hdGNoKC9bXFwnICNdLykpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKFxuXHRcdFx0ICAgICd1bnN1cHBvcnRlZCBmbGFnczogJyArIGZsYWdzKSk7XG5cblx0XHRpZiAocHJlY2lzaW9uLmxlbmd0aCA+IDApXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKFxuXHRcdFx0ICAgICdub24temVybyBwcmVjaXNpb24gbm90IHN1cHBvcnRlZCcpKTtcblxuXHRcdGlmIChmbGFncy5tYXRjaCgvLS8pKVxuXHRcdFx0bGVmdCA9IHRydWU7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goLzAvKSlcblx0XHRcdHBhZCA9ICcwJztcblxuXHRcdGlmIChmbGFncy5tYXRjaCgvXFwrLykpXG5cdFx0XHRzaWduID0gdHJ1ZTtcblxuXHRcdHN3aXRjaCAoY29udmVyc2lvbikge1xuXHRcdGNhc2UgJ3MnOlxuXHRcdFx0aWYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8IGFyZyA9PT0gbnVsbClcblx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignYXJndW1lbnQgJyArIGFyZ24gK1xuXHRcdFx0XHQgICAgJzogYXR0ZW1wdGVkIHRvIHByaW50IHVuZGVmaW5lZCBvciBudWxsICcgK1xuXHRcdFx0XHQgICAgJ2FzIGEgc3RyaW5nJykpO1xuXHRcdFx0cmV0ICs9IGRvUGFkKHBhZCwgd2lkdGgsIGxlZnQsIGFyZy50b1N0cmluZygpKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnZCc6XG5cdFx0XHRhcmcgPSBNYXRoLmZsb29yKGFyZyk7XG5cdFx0XHQvKmpzbDpmYWxsdGhydSovXG5cdFx0Y2FzZSAnZic6XG5cdFx0XHRzaWduID0gc2lnbiAmJiBhcmcgPiAwID8gJysnIDogJyc7XG5cdFx0XHRyZXQgKz0gc2lnbiArIGRvUGFkKHBhZCwgd2lkdGgsIGxlZnQsXG5cdFx0XHQgICAgYXJnLnRvU3RyaW5nKCkpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICd4Jzpcblx0XHRcdHJldCArPSBkb1BhZChwYWQsIHdpZHRoLCBsZWZ0LCBhcmcudG9TdHJpbmcoMTYpKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnaic6IC8qIG5vbi1zdGFuZGFyZCAqL1xuXHRcdFx0aWYgKHdpZHRoID09PSAwKVxuXHRcdFx0XHR3aWR0aCA9IDEwO1xuXHRcdFx0cmV0ICs9IG1vZF91dGlsLmluc3BlY3QoYXJnLCBmYWxzZSwgd2lkdGgpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdyJzogLyogbm9uLXN0YW5kYXJkICovXG5cdFx0XHRyZXQgKz0gZHVtcEV4Y2VwdGlvbihhcmcpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgY29udmVyc2lvbjogJyArXG5cdFx0XHQgICAgY29udmVyc2lvbikpO1xuXHRcdH1cblx0fVxuXG5cdHJldCArPSBmbXQ7XG5cdHJldHVybiAocmV0KTtcbn1cblxuZnVuY3Rpb24ganNQcmludGYoKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0YXJncy51bnNoaWZ0KHByb2Nlc3Muc3Rkb3V0KTtcblx0anNGcHJpbnRmLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc0ZwcmludGYoc3RyZWFtKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0cmV0dXJuIChzdHJlYW0ud3JpdGUoanNTcHJpbnRmLmFwcGx5KHRoaXMsIGFyZ3MpKSk7XG59XG5cbmZ1bmN0aW9uIGRvUGFkKGNociwgd2lkdGgsIGxlZnQsIHN0cilcbntcblx0dmFyIHJldCA9IHN0cjtcblxuXHR3aGlsZSAocmV0Lmxlbmd0aCA8IHdpZHRoKSB7XG5cdFx0aWYgKGxlZnQpXG5cdFx0XHRyZXQgKz0gY2hyO1xuXHRcdGVsc2Vcblx0XHRcdHJldCA9IGNociArIHJldDtcblx0fVxuXG5cdHJldHVybiAocmV0KTtcbn1cblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gZHVtcHMgbG9uZyBzdGFjayB0cmFjZXMgZm9yIGV4Y2VwdGlvbnMgaGF2aW5nIGEgY2F1c2UoKSBtZXRob2QuXG4gKiBTZWUgbm9kZS12ZXJyb3IgZm9yIGFuIGV4YW1wbGUuXG4gKi9cbmZ1bmN0aW9uIGR1bXBFeGNlcHRpb24oZXgpXG57XG5cdHZhciByZXQ7XG5cblx0aWYgKCEoZXggaW5zdGFuY2VvZiBFcnJvcikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcihqc1NwcmludGYoJ2ludmFsaWQgdHlwZSBmb3IgJSVyOiAlaicsIGV4KSkpO1xuXG5cdC8qIE5vdGUgdGhhdCBWOCBwcmVwZW5kcyBcImV4LnN0YWNrXCIgd2l0aCBleC50b1N0cmluZygpLiAqL1xuXHRyZXQgPSAnRVhDRVBUSU9OOiAnICsgZXguY29uc3RydWN0b3IubmFtZSArICc6ICcgKyBleC5zdGFjaztcblxuXHRpZiAoZXguY2F1c2UgJiYgdHlwZW9mIChleC5jYXVzZSkgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgY2V4ID0gZXguY2F1c2UoKTtcblx0XHRpZiAoY2V4KSB7XG5cdFx0XHRyZXQgKz0gJ1xcbkNhdXNlZCBieTogJyArIGR1bXBFeGNlcHRpb24oY2V4KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKHJldCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBrZXlMaXN0ID0gT2JqZWN0LmtleXM7XG52YXIgaGFzUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIHZhciBhcnJBID0gaXNBcnJheShhKVxuICAgICAgLCBhcnJCID0gaXNBcnJheShiKVxuICAgICAgLCBpXG4gICAgICAsIGxlbmd0aFxuICAgICAgLCBrZXk7XG5cbiAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGFyckEgIT0gYXJyQikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGRhdGVBID0gYSBpbnN0YW5jZW9mIERhdGVcbiAgICAgICwgZGF0ZUIgPSBiIGluc3RhbmNlb2YgRGF0ZTtcbiAgICBpZiAoZGF0ZUEgIT0gZGF0ZUIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGF0ZUEgJiYgZGF0ZUIpIHJldHVybiBhLmdldFRpbWUoKSA9PSBiLmdldFRpbWUoKTtcblxuICAgIHZhciByZWdleHBBID0gYSBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgLCByZWdleHBCID0gYiBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICBpZiAocmVnZXhwQSAhPSByZWdleHBCKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHJlZ2V4cEEgJiYgcmVnZXhwQikgcmV0dXJuIGEudG9TdHJpbmcoKSA9PSBiLnRvU3RyaW5nKCk7XG5cbiAgICB2YXIga2V5cyA9IGtleUxpc3QoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cbiAgICBpZiAobGVuZ3RoICE9PSBrZXlMaXN0KGIpLmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghaGFzUHJvcC5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgb3B0cyA9IHsgY21wOiBvcHRzIH07XG4gICAgdmFyIGN5Y2xlcyA9ICh0eXBlb2Ygb3B0cy5jeWNsZXMgPT09ICdib29sZWFuJykgPyBvcHRzLmN5Y2xlcyA6IGZhbHNlO1xuXG4gICAgdmFyIGNtcCA9IG9wdHMuY21wICYmIChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhb2JqID0geyBrZXk6IGEsIHZhbHVlOiBub2RlW2FdIH07XG4gICAgICAgICAgICAgICAgdmFyIGJvYmogPSB7IGtleTogYiwgdmFsdWU6IG5vZGVbYl0gfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihhb2JqLCBib2JqKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkob3B0cy5jbXApO1xuXG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHN0cmluZ2lmeSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnRvSlNPTiAmJiB0eXBlb2Ygbm9kZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnRvSlNPTigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT0gJ251bWJlcicpIHJldHVybiBpc0Zpbml0ZShub2RlKSA/ICcnICsgbm9kZSA6ICdudWxsJztcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vZGUpO1xuXG4gICAgICAgIHZhciBpLCBvdXQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICBvdXQgPSAnWyc7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpKSBvdXQgKz0gJywnO1xuICAgICAgICAgICAgICAgIG91dCArPSBzdHJpbmdpZnkobm9kZVtpXSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dCArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuXG4gICAgICAgIGlmIChzZWVuLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVzKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ19fY3ljbGVfXycpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ucHVzaChub2RlKSAtIDE7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZSkuc29ydChjbXAgJiYgY21wKG5vZGUpKTtcbiAgICAgICAgb3V0ID0gJyc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0cmluZ2lmeShub2RlW2tleV0pO1xuXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChvdXQpIG91dCArPSAnLCc7XG4gICAgICAgICAgICBvdXQgKz0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6JyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uc3BsaWNlKHNlZW5JbmRleCwgMSk7XG4gICAgICAgIHJldHVybiAneycgKyBvdXQgKyAnfSc7XG4gICAgfSkoZGF0YSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBGb3JldmVyQWdlbnRcbkZvcmV2ZXJBZ2VudC5TU0wgPSBGb3JldmVyQWdlbnRTU0xcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbiAgLCBBZ2VudCA9IHJlcXVpcmUoJ2h0dHAnKS5BZ2VudFxuICAsIG5ldCA9IHJlcXVpcmUoJ25ldCcpXG4gICwgdGxzID0gcmVxdWlyZSgndGxzJylcbiAgLCBBZ2VudFNTTCA9IHJlcXVpcmUoJ2h0dHBzJykuQWdlbnRcbiAgXG5mdW5jdGlvbiBnZXRDb25uZWN0aW9uTmFtZShob3N0LCBwb3J0KSB7ICBcbiAgdmFyIG5hbWUgPSAnJ1xuICBpZiAodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9IGhvc3QgKyAnOicgKyBwb3J0XG4gIH0gZWxzZSB7XG4gICAgLy8gRm9yIG5vZGUuanMgdjAxMi4wIGFuZCBpb2pzLXYxLjUuMSwgaG9zdCBpcyBhbiBvYmplY3QuIEFuZCBhbnkgZXhpc3RpbmcgbG9jYWxBZGRyZXNzIGlzIHBhcnQgb2YgdGhlIGNvbm5lY3Rpb24gbmFtZS5cbiAgICBuYW1lID0gaG9zdC5ob3N0ICsgJzonICsgaG9zdC5wb3J0ICsgJzonICsgKGhvc3QubG9jYWxBZGRyZXNzID8gKGhvc3QubG9jYWxBZGRyZXNzICsgJzonKSA6ICc6JylcbiAgfVxuICByZXR1cm4gbmFtZVxufSAgICBcblxuZnVuY3Rpb24gRm9yZXZlckFnZW50KG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYub3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgc2VsZi5yZXF1ZXN0cyA9IHt9XG4gIHNlbGYuc29ja2V0cyA9IHt9XG4gIHNlbGYuZnJlZVNvY2tldHMgPSB7fVxuICBzZWxmLm1heFNvY2tldHMgPSBzZWxmLm9wdGlvbnMubWF4U29ja2V0cyB8fCBBZ2VudC5kZWZhdWx0TWF4U29ja2V0c1xuICBzZWxmLm1pblNvY2tldHMgPSBzZWxmLm9wdGlvbnMubWluU29ja2V0cyB8fCBGb3JldmVyQWdlbnQuZGVmYXVsdE1pblNvY2tldHNcbiAgc2VsZi5vbignZnJlZScsIGZ1bmN0aW9uKHNvY2tldCwgaG9zdCwgcG9ydCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29ubmVjdGlvbk5hbWUoaG9zdCwgcG9ydClcblxuICAgIGlmIChzZWxmLnJlcXVlc3RzW25hbWVdICYmIHNlbGYucmVxdWVzdHNbbmFtZV0ubGVuZ3RoKSB7XG4gICAgICBzZWxmLnJlcXVlc3RzW25hbWVdLnNoaWZ0KCkub25Tb2NrZXQoc29ja2V0KVxuICAgIH0gZWxzZSBpZiAoc2VsZi5zb2NrZXRzW25hbWVdLmxlbmd0aCA8IHNlbGYubWluU29ja2V0cykge1xuICAgICAgaWYgKCFzZWxmLmZyZWVTb2NrZXRzW25hbWVdKSBzZWxmLmZyZWVTb2NrZXRzW25hbWVdID0gW11cbiAgICAgIHNlbGYuZnJlZVNvY2tldHNbbmFtZV0ucHVzaChzb2NrZXQpXG4gICAgICBcbiAgICAgIC8vIGlmIGFuIGVycm9yIGhhcHBlbnMgd2hpbGUgd2UgZG9uJ3QgdXNlIHRoZSBzb2NrZXQgYW55d2F5LCBtZWgsIHRocm93IHRoZSBzb2NrZXQgYXdheVxuICAgICAgdmFyIG9uSWRsZUVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNvY2tldC5kZXN0cm95KClcbiAgICAgIH1cbiAgICAgIHNvY2tldC5fb25JZGxlRXJyb3IgPSBvbklkbGVFcnJvclxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIG9uSWRsZUVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcGVuZGluZyByZXF1ZXN0cyBqdXN0IGRlc3Ryb3kgdGhlXG4gICAgICAvLyBzb2NrZXQgYW5kIGl0IHdpbGwgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcG9vbC4gVGhpc1xuICAgICAgLy8gZ2V0cyB1cyBvdXQgb2YgdGltZW91dCBpc3N1ZXMgYW5kIGFsbG93cyB1cyB0b1xuICAgICAgLy8gZGVmYXVsdCB0byBDb25uZWN0aW9uOmtlZXAtYWxpdmUuXG4gICAgICBzb2NrZXQuZGVzdHJveSgpXG4gICAgfVxuICB9KVxuXG59XG51dGlsLmluaGVyaXRzKEZvcmV2ZXJBZ2VudCwgQWdlbnQpXG5cbkZvcmV2ZXJBZ2VudC5kZWZhdWx0TWluU29ja2V0cyA9IDVcblxuXG5Gb3JldmVyQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBuZXQuY3JlYXRlQ29ubmVjdGlvblxuRm9yZXZlckFnZW50LnByb3RvdHlwZS5hZGRSZXF1ZXN0Tm9yZXVzZSA9IEFnZW50LnByb3RvdHlwZS5hZGRSZXF1ZXN0XG5Gb3JldmVyQWdlbnQucHJvdG90eXBlLmFkZFJlcXVlc3QgPSBmdW5jdGlvbihyZXEsIGhvc3QsIHBvcnQpIHtcbiAgdmFyIG5hbWUgPSBnZXRDb25uZWN0aW9uTmFtZShob3N0LCBwb3J0KVxuICBcbiAgaWYgKHR5cGVvZiBob3N0ICE9PSAnc3RyaW5nJykge1xuICAgIHZhciBvcHRpb25zID0gaG9zdFxuICAgIHBvcnQgPSBvcHRpb25zLnBvcnRcbiAgICBob3N0ID0gb3B0aW9ucy5ob3N0XG4gIH1cblxuICBpZiAodGhpcy5mcmVlU29ja2V0c1tuYW1lXSAmJiB0aGlzLmZyZWVTb2NrZXRzW25hbWVdLmxlbmd0aCA+IDAgJiYgIXJlcS51c2VDaHVua2VkRW5jb2RpbmdCeURlZmF1bHQpIHtcbiAgICB2YXIgaWRsZVNvY2tldCA9IHRoaXMuZnJlZVNvY2tldHNbbmFtZV0ucG9wKClcbiAgICBpZGxlU29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGlkbGVTb2NrZXQuX29uSWRsZUVycm9yKVxuICAgIGRlbGV0ZSBpZGxlU29ja2V0Ll9vbklkbGVFcnJvclxuICAgIHJlcS5fcmV1c2VkU29ja2V0ID0gdHJ1ZVxuICAgIHJlcS5vblNvY2tldChpZGxlU29ja2V0KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuYWRkUmVxdWVzdE5vcmV1c2UocmVxLCBob3N0LCBwb3J0KVxuICB9XG59XG5cbkZvcmV2ZXJBZ2VudC5wcm90b3R5cGUucmVtb3ZlU29ja2V0ID0gZnVuY3Rpb24ocywgbmFtZSwgaG9zdCwgcG9ydCkge1xuICBpZiAodGhpcy5zb2NrZXRzW25hbWVdKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zb2NrZXRzW25hbWVdLmluZGV4T2YocylcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnNvY2tldHNbbmFtZV0uc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLnNvY2tldHNbbmFtZV0gJiYgdGhpcy5zb2NrZXRzW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGRvbid0IGxlYWtcbiAgICBkZWxldGUgdGhpcy5zb2NrZXRzW25hbWVdXG4gICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbbmFtZV1cbiAgfVxuICBcbiAgaWYgKHRoaXMuZnJlZVNvY2tldHNbbmFtZV0pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmZyZWVTb2NrZXRzW25hbWVdLmluZGV4T2YocylcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLmZyZWVTb2NrZXRzW25hbWVdLnNwbGljZShpbmRleCwgMSlcbiAgICAgIGlmICh0aGlzLmZyZWVTb2NrZXRzW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5mcmVlU29ja2V0c1tuYW1lXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnJlcXVlc3RzW25hbWVdICYmIHRoaXMucmVxdWVzdHNbbmFtZV0ubGVuZ3RoKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHJlcXVlc3RzIGFuZCBhIHNvY2tldCBnZXRzIGNsb3NlZCBhIG5ldyBvbmVcbiAgICAvLyBuZWVkcyB0byBiZSBjcmVhdGVkIHRvIHRha2Ugb3ZlciBpbiB0aGUgcG9vbCBmb3IgdGhlIG9uZSB0aGF0IGNsb3NlZC5cbiAgICB0aGlzLmNyZWF0ZVNvY2tldChuYW1lLCBob3N0LCBwb3J0KS5lbWl0KCdmcmVlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBGb3JldmVyQWdlbnRTU0wgKG9wdGlvbnMpIHtcbiAgRm9yZXZlckFnZW50LmNhbGwodGhpcywgb3B0aW9ucylcbn1cbnV0aWwuaW5oZXJpdHMoRm9yZXZlckFnZW50U1NMLCBGb3JldmVyQWdlbnQpXG5cbkZvcmV2ZXJBZ2VudFNTTC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGNyZWF0ZUNvbm5lY3Rpb25TU0xcbkZvcmV2ZXJBZ2VudFNTTC5wcm90b3R5cGUuYWRkUmVxdWVzdE5vcmV1c2UgPSBBZ2VudFNTTC5wcm90b3R5cGUuYWRkUmVxdWVzdFxuXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU1NMIChwb3J0LCBob3N0LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcG9ydCA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gcG9ydDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaG9zdCA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gaG9zdDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIHBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgb3B0aW9ucy5wb3J0ID0gcG9ydDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLmhvc3QgPSBob3N0O1xuICB9XG5cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuIiwidmFyIENvbWJpbmVkU3RyZWFtID0gcmVxdWlyZSgnY29tYmluZWQtc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHBhcnNlVXJsID0gcmVxdWlyZSgndXJsJykucGFyc2U7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIG1pbWUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJyk7XG52YXIgYXN5bmNraXQgPSByZXF1aXJlKCdhc3luY2tpdCcpO1xudmFyIHBvcHVsYXRlID0gcmVxdWlyZSgnLi9wb3B1bGF0ZS5qcycpO1xuXG4vLyBQdWJsaWMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1EYXRhO1xuXG4vLyBtYWtlIGl0IGEgU3RyZWFtXG51dGlsLmluaGVyaXRzKEZvcm1EYXRhLCBDb21iaW5lZFN0cmVhbSk7XG5cbi8qKlxuICogQ3JlYXRlIHJlYWRhYmxlIFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiIHN0cmVhbXMuXG4gKiBDYW4gYmUgdXNlZCB0byBzdWJtaXQgZm9ybXNcbiAqIGFuZCBmaWxlIHVwbG9hZHMgdG8gb3RoZXIgd2ViIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvcGVydGllcyB0byBiZSBhZGRlZC9vdmVycmlkZW4gZm9yIEZvcm1EYXRhIGFuZCBDb21iaW5lZFN0cmVhbVxuICovXG5mdW5jdGlvbiBGb3JtRGF0YShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGb3JtRGF0YSkpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1EYXRhKCk7XG4gIH1cblxuICB0aGlzLl9vdmVyaGVhZExlbmd0aCA9IDA7XG4gIHRoaXMuX3ZhbHVlTGVuZ3RoID0gMDtcbiAgdGhpcy5fdmFsdWVzVG9NZWFzdXJlID0gW107XG5cbiAgQ29tYmluZWRTdHJlYW0uY2FsbCh0aGlzKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gIH1cbn1cblxuRm9ybURhdGEuTElORV9CUkVBSyA9ICdcXHJcXG4nO1xuRm9ybURhdGEuREVGQVVMVF9DT05URU5UX1RZUEUgPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcblxuRm9ybURhdGEucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIGFsbG93IGZpbGVuYW1lIGFzIHNpbmdsZSBvcHRpb25cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHtmaWxlbmFtZTogb3B0aW9uc307XG4gIH1cblxuICB2YXIgYXBwZW5kID0gQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLmFwcGVuZC5iaW5kKHRoaXMpO1xuXG4gIC8vIGFsbCB0aGF0IHN0cmVhbXkgYnVzaW5lc3MgY2FuJ3QgaGFuZGxlIG51bWJlcnNcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHZhbHVlID0gJycgKyB2YWx1ZTtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZWxpeGdlL25vZGUtZm9ybS1kYXRhL2lzc3Vlcy8zOFxuICBpZiAodXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFBsZWFzZSBjb252ZXJ0IHlvdXIgYXJyYXkgaW50byBzdHJpbmdcbiAgICAvLyB0aGUgd2F5IHdlYiBzZXJ2ZXIgZXhwZWN0cyBpdFxuICAgIHRoaXMuX2Vycm9yKG5ldyBFcnJvcignQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLicpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaGVhZGVyID0gdGhpcy5fbXVsdGlQYXJ0SGVhZGVyKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIHZhciBmb290ZXIgPSB0aGlzLl9tdWx0aVBhcnRGb290ZXIoKTtcblxuICBhcHBlbmQoaGVhZGVyKTtcbiAgYXBwZW5kKHZhbHVlKTtcbiAgYXBwZW5kKGZvb3Rlcik7XG5cbiAgLy8gcGFzcyBhbG9uZyBvcHRpb25zLmtub3duTGVuZ3RoXG4gIHRoaXMuX3RyYWNrTGVuZ3RoKGhlYWRlciwgdmFsdWUsIG9wdGlvbnMpO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl90cmFja0xlbmd0aCA9IGZ1bmN0aW9uKGhlYWRlciwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlTGVuZ3RoID0gMDtcblxuICAvLyB1c2VkIHcvIGdldExlbmd0aFN5bmMoKSwgd2hlbiBsZW5ndGggaXMga25vd24uXG4gIC8vIGUuZy4gZm9yIHN0cmVhbWluZyBkaXJlY3RseSBmcm9tIGEgcmVtb3RlIHNlcnZlcixcbiAgLy8gdy8gYSBrbm93biBmaWxlIGEgc2l6ZSwgYW5kIG5vdCB3YW50aW5nIHRvIHdhaXQgZm9yXG4gIC8vIGluY29taW5nIGZpbGUgdG8gZmluaXNoIHRvIGdldCBpdHMgc2l6ZS5cbiAgaWYgKG9wdGlvbnMua25vd25MZW5ndGggIT0gbnVsbCkge1xuICAgIHZhbHVlTGVuZ3RoICs9ICtvcHRpb25zLmtub3duTGVuZ3RoO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gIH1cblxuICB0aGlzLl92YWx1ZUxlbmd0aCArPSB2YWx1ZUxlbmd0aDtcblxuICAvLyBAY2hlY2sgd2h5IGFkZCBDUkxGPyBkb2VzIHRoaXMgYWNjb3VudCBmb3IgY3VzdG9tL211bHRpcGxlIENSTEZzP1xuICB0aGlzLl9vdmVyaGVhZExlbmd0aCArPVxuICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKGhlYWRlcikgK1xuICAgIEZvcm1EYXRhLkxJTkVfQlJFQUsubGVuZ3RoO1xuXG4gIC8vIGVtcHR5IG9yIGVpdGhlciBkb2Vzbid0IGhhdmUgcGF0aCBvciBub3QgYW4gaHR0cCByZXNwb25zZVxuICBpZiAoIXZhbHVlIHx8ICggIXZhbHVlLnBhdGggJiYgISh2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkgKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIG5vIG5lZWQgdG8gYm90aGVyIHdpdGggdGhlIGxlbmd0aFxuICBpZiAoIW9wdGlvbnMua25vd25MZW5ndGgpIHtcbiAgICB0aGlzLl92YWx1ZXNUb01lYXN1cmUucHVzaCh2YWx1ZSk7XG4gIH1cbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbGVuZ3RoUmV0cmlldmVyID0gZnVuY3Rpb24odmFsdWUsIGNhbGxiYWNrKSB7XG5cbiAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdmZCcpKSB7XG5cbiAgICAvLyB0YWtlIHJlYWQgcmFuZ2UgaW50byBhIGFjY291bnRcbiAgICAvLyBgZW5kYCA9IEluZmluaXR5IOKAkz4gcmVhZCBmaWxlIHRpbGwgdGhlIGVuZFxuICAgIC8vXG4gICAgLy8gVE9ETzogTG9va3MgbGlrZSB0aGVyZSBpcyBidWcgaW4gTm9kZSBmcy5jcmVhdGVSZWFkU3RyZWFtXG4gICAgLy8gaXQgZG9lc24ndCByZXNwZWN0IGBlbmRgIG9wdGlvbnMgd2l0aG91dCBgc3RhcnRgIG9wdGlvbnNcbiAgICAvLyBGaXggaXQgd2hlbiBub2RlIGZpeGVzIGl0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvNzgxOVxuICAgIGlmICh2YWx1ZS5lbmQgIT0gdW5kZWZpbmVkICYmIHZhbHVlLmVuZCAhPSBJbmZpbml0eSAmJiB2YWx1ZS5zdGFydCAhPSB1bmRlZmluZWQpIHtcblxuICAgICAgLy8gd2hlbiBlbmQgc3BlY2lmaWVkXG4gICAgICAvLyBubyBuZWVkIHRvIGNhbGN1bGF0ZSByYW5nZVxuICAgICAgLy8gaW5jbHVzaXZlLCBzdGFydHMgd2l0aCAwXG4gICAgICBjYWxsYmFjayhudWxsLCB2YWx1ZS5lbmQgKyAxIC0gKHZhbHVlLnN0YXJ0ID8gdmFsdWUuc3RhcnQgOiAwKSk7XG5cbiAgICAvLyBub3QgdGhhdCBmYXN0IHNub29weVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdGlsbCBuZWVkIHRvIGZldGNoIGZpbGUgc2l6ZSBmcm9tIGZzXG4gICAgICBmcy5zdGF0KHZhbHVlLnBhdGgsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuXG4gICAgICAgIHZhciBmaWxlU2l6ZTtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgZmluYWwgc2l6ZSBiYXNlZCBvbiB0aGUgcmFuZ2Ugb3B0aW9uc1xuICAgICAgICBmaWxlU2l6ZSA9IHN0YXQuc2l6ZSAtICh2YWx1ZS5zdGFydCA/IHZhbHVlLnN0YXJ0IDogMCk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGZpbGVTaXplKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAvLyBvciBodHRwIHJlc3BvbnNlXG4gIH0gZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBWZXJzaW9uJykpIHtcbiAgICBjYWxsYmFjayhudWxsLCArdmFsdWUuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSk7XG5cbiAgLy8gb3IgcmVxdWVzdCBzdHJlYW0gaHR0cDovL2dpdGh1Yi5jb20vbWlrZWFsL3JlcXVlc3RcbiAgfSBlbHNlIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cE1vZHVsZScpKSB7XG4gICAgLy8gd2FpdCB0aWxsIHJlc3BvbnNlIGNvbWUgYmFja1xuICAgIHZhbHVlLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICB2YWx1ZS5wYXVzZSgpO1xuICAgICAgY2FsbGJhY2sobnVsbCwgK3Jlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xuICAgIH0pO1xuICAgIHZhbHVlLnJlc3VtZSgpO1xuXG4gIC8vIHNvbWV0aGluZyBlbHNlXG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soJ1Vua25vd24gc3RyZWFtJyk7XG4gIH1cbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbXVsdGlQYXJ0SGVhZGVyID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIC8vIGN1c3RvbSBoZWFkZXIgc3BlY2lmaWVkIChhcyBzdHJpbmcpP1xuICAvLyBpdCBiZWNvbWVzIHJlc3BvbnNpYmxlIGZvciBib3VuZGFyeVxuICAvLyAoZS5nLiB0byBoYW5kbGUgZXh0cmEgQ1JMRnMgb24gLk5FVCBzZXJ2ZXJzKVxuICBpZiAodHlwZW9mIG9wdGlvbnMuaGVhZGVyID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuaGVhZGVyO1xuICB9XG5cbiAgdmFyIGNvbnRlbnREaXNwb3NpdGlvbiA9IHRoaXMuX2dldENvbnRlbnREaXNwb3NpdGlvbih2YWx1ZSwgb3B0aW9ucyk7XG4gIHZhciBjb250ZW50VHlwZSA9IHRoaXMuX2dldENvbnRlbnRUeXBlKHZhbHVlLCBvcHRpb25zKTtcblxuICB2YXIgY29udGVudHMgPSAnJztcbiAgdmFyIGhlYWRlcnMgID0ge1xuICAgIC8vIGFkZCBjdXN0b20gZGlzcG9zaXRpb24gYXMgdGhpcmQgZWxlbWVudCBvciBrZWVwIGl0IHR3byBlbGVtZW50cyBpZiBub3RcbiAgICAnQ29udGVudC1EaXNwb3NpdGlvbic6IFsnZm9ybS1kYXRhJywgJ25hbWU9XCInICsgZmllbGQgKyAnXCInXS5jb25jYXQoY29udGVudERpc3Bvc2l0aW9uIHx8IFtdKSxcbiAgICAvLyBpZiBubyBjb250ZW50IHR5cGUuIGFsbG93IGl0IHRvIGJlIGVtcHR5IGFycmF5XG4gICAgJ0NvbnRlbnQtVHlwZSc6IFtdLmNvbmNhdChjb250ZW50VHlwZSB8fCBbXSlcbiAgfTtcblxuICAvLyBhbGxvdyBjdXN0b20gaGVhZGVycy5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmhlYWRlciA9PSAnb2JqZWN0Jykge1xuICAgIHBvcHVsYXRlKGhlYWRlcnMsIG9wdGlvbnMuaGVhZGVyKTtcbiAgfVxuXG4gIHZhciBoZWFkZXI7XG4gIGZvciAodmFyIHByb3AgaW4gaGVhZGVycykge1xuICAgIGlmICghaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG4gICAgaGVhZGVyID0gaGVhZGVyc1twcm9wXTtcblxuICAgIC8vIHNraXAgbnVsbGlzaCBoZWFkZXJzLlxuICAgIGlmIChoZWFkZXIgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbGwgaGVhZGVycyB0byBhcnJheXMuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgIGhlYWRlciA9IFtoZWFkZXJdO1xuICAgIH1cblxuICAgIC8vIGFkZCBub24tZW1wdHkgaGVhZGVycy5cbiAgICBpZiAoaGVhZGVyLmxlbmd0aCkge1xuICAgICAgY29udGVudHMgKz0gcHJvcCArICc6ICcgKyBoZWFkZXIuam9pbignOyAnKSArIEZvcm1EYXRhLkxJTkVfQlJFQUs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICctLScgKyB0aGlzLmdldEJvdW5kYXJ5KCkgKyBGb3JtRGF0YS5MSU5FX0JSRUFLICsgY29udGVudHMgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9nZXRDb250ZW50RGlzcG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuXG4gIHZhciBmaWxlbmFtZVxuICAgICwgY29udGVudERpc3Bvc2l0aW9uXG4gICAgO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5maWxlcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBjdXN0b20gZmlsZXBhdGggZm9yIHJlbGF0aXZlIHBhdGhzXG4gICAgZmlsZW5hbWUgPSBwYXRoLm5vcm1hbGl6ZShvcHRpb25zLmZpbGVwYXRoKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5maWxlbmFtZSB8fCB2YWx1ZS5uYW1lIHx8IHZhbHVlLnBhdGgpIHtcbiAgICAvLyBjdXN0b20gZmlsZW5hbWUgdGFrZSBwcmVjZWRlbmNlXG4gICAgLy8gZm9ybWlkYWJsZSBhbmQgdGhlIGJyb3dzZXIgYWRkIGEgbmFtZSBwcm9wZXJ0eVxuICAgIC8vIGZzLSBhbmQgcmVxdWVzdC0gc3RyZWFtcyBoYXZlIHBhdGggcHJvcGVydHlcbiAgICBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUob3B0aW9ucy5maWxlbmFtZSB8fCB2YWx1ZS5uYW1lIHx8IHZhbHVlLnBhdGgpO1xuICB9IGVsc2UgaWYgKHZhbHVlLnJlYWRhYmxlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwVmVyc2lvbicpKSB7XG4gICAgLy8gb3IgdHJ5IGh0dHAgcmVzcG9uc2VcbiAgICBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUodmFsdWUuY2xpZW50Ll9odHRwTWVzc2FnZS5wYXRoKTtcbiAgfVxuXG4gIGlmIChmaWxlbmFtZSkge1xuICAgIGNvbnRlbnREaXNwb3NpdGlvbiA9ICdmaWxlbmFtZT1cIicgKyBmaWxlbmFtZSArICdcIic7XG4gIH1cblxuICByZXR1cm4gY29udGVudERpc3Bvc2l0aW9uO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9nZXRDb250ZW50VHlwZSA9IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgLy8gdXNlIGN1c3RvbSBjb250ZW50LXR5cGUgYWJvdmUgYWxsXG4gIHZhciBjb250ZW50VHlwZSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG5cbiAgLy8gb3IgdHJ5IGBuYW1lYCBmcm9tIGZvcm1pZGFibGUsIGJyb3dzZXJcbiAgaWYgKCFjb250ZW50VHlwZSAmJiB2YWx1ZS5uYW1lKSB7XG4gICAgY29udGVudFR5cGUgPSBtaW1lLmxvb2t1cCh2YWx1ZS5uYW1lKTtcbiAgfVxuXG4gIC8vIG9yIHRyeSBgcGF0aGAgZnJvbSBmcy0sIHJlcXVlc3QtIHN0cmVhbXNcbiAgaWYgKCFjb250ZW50VHlwZSAmJiB2YWx1ZS5wYXRoKSB7XG4gICAgY29udGVudFR5cGUgPSBtaW1lLmxvb2t1cCh2YWx1ZS5wYXRoKTtcbiAgfVxuXG4gIC8vIG9yIGlmIGl0J3MgaHR0cC1yZXBvbnNlXG4gIGlmICghY29udGVudFR5cGUgJiYgdmFsdWUucmVhZGFibGUgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBWZXJzaW9uJykpIHtcbiAgICBjb250ZW50VHlwZSA9IHZhbHVlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICB9XG5cbiAgLy8gb3IgZ3Vlc3MgaXQgZnJvbSB0aGUgZmlsZXBhdGggb3IgZmlsZW5hbWVcbiAgaWYgKCFjb250ZW50VHlwZSAmJiAob3B0aW9ucy5maWxlcGF0aCB8fCBvcHRpb25zLmZpbGVuYW1lKSkge1xuICAgIGNvbnRlbnRUeXBlID0gbWltZS5sb29rdXAob3B0aW9ucy5maWxlcGF0aCB8fCBvcHRpb25zLmZpbGVuYW1lKTtcbiAgfVxuXG4gIC8vIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IGNvbnRlbnQgdHlwZSBpZiBgdmFsdWVgIGlzIG5vdCBzaW1wbGUgdmFsdWVcbiAgaWYgKCFjb250ZW50VHlwZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICBjb250ZW50VHlwZSA9IEZvcm1EYXRhLkRFRkFVTFRfQ09OVEVOVF9UWVBFO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnRUeXBlO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLl9tdWx0aVBhcnRGb290ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5leHQpIHtcbiAgICB2YXIgZm9vdGVyID0gRm9ybURhdGEuTElORV9CUkVBSztcblxuICAgIHZhciBsYXN0UGFydCA9ICh0aGlzLl9zdHJlYW1zLmxlbmd0aCA9PT0gMCk7XG4gICAgaWYgKGxhc3RQYXJ0KSB7XG4gICAgICBmb290ZXIgKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCk7XG4gICAgfVxuXG4gICAgbmV4dChmb290ZXIpO1xuICB9LmJpbmQodGhpcyk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2xhc3RCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJy0tJyArIHRoaXMuZ2V0Qm91bmRhcnkoKSArICctLScgKyBGb3JtRGF0YS5MSU5FX0JSRUFLO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLmdldEhlYWRlcnMgPSBmdW5jdGlvbih1c2VySGVhZGVycykge1xuICB2YXIgaGVhZGVyO1xuICB2YXIgZm9ybUhlYWRlcnMgPSB7XG4gICAgJ2NvbnRlbnQtdHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0nICsgdGhpcy5nZXRCb3VuZGFyeSgpXG4gIH07XG5cbiAgZm9yIChoZWFkZXIgaW4gdXNlckhlYWRlcnMpIHtcbiAgICBpZiAodXNlckhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xuICAgICAgZm9ybUhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gdXNlckhlYWRlcnNbaGVhZGVyXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZm9ybUhlYWRlcnM7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9ib3VuZGFyeSkge1xuICAgIHRoaXMuX2dlbmVyYXRlQm91bmRhcnkoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9ib3VuZGFyeTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fZ2VuZXJhdGVCb3VuZGFyeSA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGlzIGdlbmVyYXRlcyBhIDUwIGNoYXJhY3RlciBib3VuZGFyeSBzaW1pbGFyIHRvIHRob3NlIHVzZWQgYnkgRmlyZWZveC5cbiAgLy8gVGhleSBhcmUgb3B0aW1pemVkIGZvciBib3llci1tb29yZSBwYXJzaW5nLlxuICB2YXIgYm91bmRhcnkgPSAnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICBib3VuZGFyeSArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCkudG9TdHJpbmcoMTYpO1xuICB9XG5cbiAgdGhpcy5fYm91bmRhcnkgPSBib3VuZGFyeTtcbn07XG5cbi8vIE5vdGU6IGdldExlbmd0aFN5bmMgRE9FU04nVCBjYWxjdWxhdGUgc3RyZWFtcyBsZW5ndGhcbi8vIEFzIHdvcmthcm91bmQgb25lIGNhbiBjYWxjdWxhdGUgZmlsZSBzaXplIG1hbnVhbGx5XG4vLyBhbmQgYWRkIGl0IGFzIGtub3duTGVuZ3RoIG9wdGlvblxuRm9ybURhdGEucHJvdG90eXBlLmdldExlbmd0aFN5bmMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGtub3duTGVuZ3RoID0gdGhpcy5fb3ZlcmhlYWRMZW5ndGggKyB0aGlzLl92YWx1ZUxlbmd0aDtcblxuICAvLyBEb24ndCBnZXQgY29uZnVzZWQsIHRoZXJlIGFyZSAzIFwiaW50ZXJuYWxcIiBzdHJlYW1zIGZvciBlYWNoIGtleXZhbCBwYWlyXG4gIC8vIHNvIGl0IGJhc2ljYWxseSBjaGVja3MgaWYgdGhlcmUgaXMgYW55IHZhbHVlIGFkZGVkIHRvIHRoZSBmb3JtXG4gIGlmICh0aGlzLl9zdHJlYW1zLmxlbmd0aCkge1xuICAgIGtub3duTGVuZ3RoICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhL2lzc3Vlcy80MFxuICBpZiAoIXRoaXMuaGFzS25vd25MZW5ndGgoKSkge1xuICAgIC8vIFNvbWUgYXN5bmMgbGVuZ3RoIHJldHJpZXZlcnMgYXJlIHByZXNlbnRcbiAgICAvLyB0aGVyZWZvcmUgc3luY2hyb25vdXMgbGVuZ3RoIGNhbGN1bGF0aW9uIGlzIGZhbHNlLlxuICAgIC8vIFBsZWFzZSB1c2UgZ2V0TGVuZ3RoKGNhbGxiYWNrKSB0byBnZXQgcHJvcGVyIGxlbmd0aFxuICAgIHRoaXMuX2Vycm9yKG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBwcm9wZXIgbGVuZ3RoIGluIHN5bmNocm9ub3VzIHdheS4nKSk7XG4gIH1cblxuICByZXR1cm4ga25vd25MZW5ndGg7XG59O1xuXG4vLyBQdWJsaWMgQVBJIHRvIGNoZWNrIGlmIGxlbmd0aCBvZiBhZGRlZCB2YWx1ZXMgaXMga25vd25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhL2lzc3Vlcy8xOTZcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtLWRhdGEvZm9ybS1kYXRhL2lzc3Vlcy8yNjJcbkZvcm1EYXRhLnByb3RvdHlwZS5oYXNLbm93bkxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGFzS25vd25MZW5ndGggPSB0cnVlO1xuXG4gIGlmICh0aGlzLl92YWx1ZXNUb01lYXN1cmUubGVuZ3RoKSB7XG4gICAgaGFzS25vd25MZW5ndGggPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBoYXNLbm93bkxlbmd0aDtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbihjYikge1xuICB2YXIga25vd25MZW5ndGggPSB0aGlzLl9vdmVyaGVhZExlbmd0aCArIHRoaXMuX3ZhbHVlTGVuZ3RoO1xuXG4gIGlmICh0aGlzLl9zdHJlYW1zLmxlbmd0aCkge1xuICAgIGtub3duTGVuZ3RoICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpLmxlbmd0aDtcbiAgfVxuXG4gIGlmICghdGhpcy5fdmFsdWVzVG9NZWFzdXJlLmxlbmd0aCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IuYmluZCh0aGlzLCBudWxsLCBrbm93bkxlbmd0aCkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFzeW5ja2l0LnBhcmFsbGVsKHRoaXMuX3ZhbHVlc1RvTWVhc3VyZSwgdGhpcy5fbGVuZ3RoUmV0cmlldmVyLCBmdW5jdGlvbihlcnIsIHZhbHVlcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNiKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBrbm93bkxlbmd0aCArPSBsZW5ndGg7XG4gICAgfSk7XG5cbiAgICBjYihudWxsLCBrbm93bkxlbmd0aCk7XG4gIH0pO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLnN1Ym1pdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHtcbiAgdmFyIHJlcXVlc3RcbiAgICAsIG9wdGlvbnNcbiAgICAsIGRlZmF1bHRzID0ge21ldGhvZDogJ3Bvc3QnfVxuICAgIDtcblxuICAvLyBwYXJzZSBwcm92aWRlZCB1cmwgaWYgaXQncyBzdHJpbmdcbiAgLy8gb3IgdHJlYXQgaXQgYXMgb3B0aW9ucyBvYmplY3RcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ3N0cmluZycpIHtcblxuICAgIHBhcmFtcyA9IHBhcnNlVXJsKHBhcmFtcyk7XG4gICAgb3B0aW9ucyA9IHBvcHVsYXRlKHtcbiAgICAgIHBvcnQ6IHBhcmFtcy5wb3J0LFxuICAgICAgcGF0aDogcGFyYW1zLnBhdGhuYW1lLFxuICAgICAgaG9zdDogcGFyYW1zLmhvc3RuYW1lLFxuICAgICAgcHJvdG9jb2w6IHBhcmFtcy5wcm90b2NvbFxuICAgIH0sIGRlZmF1bHRzKTtcblxuICAvLyB1c2UgY3VzdG9tIHBhcmFtc1xuICB9IGVsc2Uge1xuXG4gICAgb3B0aW9ucyA9IHBvcHVsYXRlKHBhcmFtcywgZGVmYXVsdHMpO1xuICAgIC8vIGlmIG5vIHBvcnQgcHJvdmlkZWQgdXNlIGRlZmF1bHQgb25lXG4gICAgaWYgKCFvcHRpb25zLnBvcnQpIHtcbiAgICAgIG9wdGlvbnMucG9ydCA9IG9wdGlvbnMucHJvdG9jb2wgPT0gJ2h0dHBzOicgPyA0NDMgOiA4MDtcbiAgICB9XG4gIH1cblxuICAvLyBwdXQgdGhhdCBnb29kIGNvZGUgaW4gZ2V0SGVhZGVycyB0byBzb21lIHVzZVxuICBvcHRpb25zLmhlYWRlcnMgPSB0aGlzLmdldEhlYWRlcnMocGFyYW1zLmhlYWRlcnMpO1xuXG4gIC8vIGh0dHBzIGlmIHNwZWNpZmllZCwgZmFsbGJhY2sgdG8gaHR0cCBpbiBhbnkgb3RoZXIgY2FzZVxuICBpZiAob3B0aW9ucy5wcm90b2NvbCA9PSAnaHR0cHM6Jykge1xuICAgIHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucyk7XG4gIH1cblxuICAvLyBnZXQgY29udGVudCBsZW5ndGggYW5kIGZpcmUgYXdheVxuICB0aGlzLmdldExlbmd0aChmdW5jdGlvbihlcnIsIGxlbmd0aCkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkIGNvbnRlbnQgbGVuZ3RoXG4gICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJywgbGVuZ3RoKTtcblxuICAgIHRoaXMucGlwZShyZXF1ZXN0KTtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgY2IpO1xuICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCBjYi5iaW5kKHRoaXMsIG51bGwpKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICghdGhpcy5lcnJvcikge1xuICAgIHRoaXMuZXJyb3IgPSBlcnI7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnW29iamVjdCBGb3JtRGF0YV0nO1xufTtcbiIsIi8vIHBvcHVsYXRlcyBtaXNzaW5nIHZhbHVlc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkc3QsIHNyYykge1xuXG4gIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbihwcm9wKVxuICB7XG4gICAgZHN0W3Byb3BdID0gZHN0W3Byb3BdIHx8IHNyY1twcm9wXTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRzdDtcbn07XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFmdGVyUmVxdWVzdDogcmVxdWlyZSgnLi9hZnRlclJlcXVlc3QuanNvbicpLFxuICBiZWZvcmVSZXF1ZXN0OiByZXF1aXJlKCcuL2JlZm9yZVJlcXVlc3QuanNvbicpLFxuICBicm93c2VyOiByZXF1aXJlKCcuL2Jyb3dzZXIuanNvbicpLFxuICBjYWNoZTogcmVxdWlyZSgnLi9jYWNoZS5qc29uJyksXG4gIGNvbnRlbnQ6IHJlcXVpcmUoJy4vY29udGVudC5qc29uJyksXG4gIGNvb2tpZTogcmVxdWlyZSgnLi9jb29raWUuanNvbicpLFxuICBjcmVhdG9yOiByZXF1aXJlKCcuL2NyZWF0b3IuanNvbicpLFxuICBlbnRyeTogcmVxdWlyZSgnLi9lbnRyeS5qc29uJyksXG4gIGhhcjogcmVxdWlyZSgnLi9oYXIuanNvbicpLFxuICBoZWFkZXI6IHJlcXVpcmUoJy4vaGVhZGVyLmpzb24nKSxcbiAgbG9nOiByZXF1aXJlKCcuL2xvZy5qc29uJyksXG4gIHBhZ2U6IHJlcXVpcmUoJy4vcGFnZS5qc29uJyksXG4gIHBhZ2VUaW1pbmdzOiByZXF1aXJlKCcuL3BhZ2VUaW1pbmdzLmpzb24nKSxcbiAgcG9zdERhdGE6IHJlcXVpcmUoJy4vcG9zdERhdGEuanNvbicpLFxuICBxdWVyeTogcmVxdWlyZSgnLi9xdWVyeS5qc29uJyksXG4gIHJlcXVlc3Q6IHJlcXVpcmUoJy4vcmVxdWVzdC5qc29uJyksXG4gIHJlc3BvbnNlOiByZXF1aXJlKCcuL3Jlc3BvbnNlLmpzb24nKSxcbiAgdGltaW5nczogcmVxdWlyZSgnLi90aW1pbmdzLmpzb24nKVxufVxuIiwiZnVuY3Rpb24gSEFSRXJyb3IgKGVycm9ycykge1xuICB2YXIgbWVzc2FnZSA9ICd2YWxpZGF0aW9uIGZhaWxlZCdcblxuICB0aGlzLm5hbWUgPSAnSEFSRXJyb3InXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgdGhpcy5lcnJvcnMgPSBlcnJvcnNcblxuICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3RvcilcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcihtZXNzYWdlKSkuc3RhY2tcbiAgfVxufVxuXG5IQVJFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGVcblxubW9kdWxlLmV4cG9ydHMgPSBIQVJFcnJvclxuIiwidmFyIEFqdiA9IHJlcXVpcmUoJ2FqdicpXG52YXIgSEFSRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJylcbnZhciBzY2hlbWFzID0gcmVxdWlyZSgnaGFyLXNjaGVtYScpXG5cbnZhciBhanZcblxuZnVuY3Rpb24gY3JlYXRlQWp2SW5zdGFuY2UgKCkge1xuICB2YXIgYWp2ID0gbmV3IEFqdih7XG4gICAgYWxsRXJyb3JzOiB0cnVlXG4gIH0pXG4gIGFqdi5hZGRNZXRhU2NoZW1hKHJlcXVpcmUoJ2Fqdi9saWIvcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNi5qc29uJykpXG4gIGFqdi5hZGRTY2hlbWEoc2NoZW1hcylcblxuICByZXR1cm4gYWp2XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlIChuYW1lLCBkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9XG5cbiAgLy8gdmFsaWRhdG9yIGNvbmZpZ1xuICBhanYgPSBhanYgfHwgY3JlYXRlQWp2SW5zdGFuY2UoKVxuXG4gIHZhciB2YWxpZGF0ZSA9IGFqdi5nZXRTY2hlbWEobmFtZSArICcuanNvbicpXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgdmFsaWQgPSB2YWxpZGF0ZShkYXRhKVxuXG4gICAgIXZhbGlkID8gcmVqZWN0KG5ldyBIQVJFcnJvcih2YWxpZGF0ZS5lcnJvcnMpKSA6IHJlc29sdmUoZGF0YSlcbiAgfSlcbn1cblxuZXhwb3J0cy5hZnRlclJlcXVlc3QgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gdmFsaWRhdGUoJ2FmdGVyUmVxdWVzdCcsIGRhdGEpXG59XG5cbmV4cG9ydHMuYmVmb3JlUmVxdWVzdCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiB2YWxpZGF0ZSgnYmVmb3JlUmVxdWVzdCcsIGRhdGEpXG59XG5cbmV4cG9ydHMuYnJvd3NlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiB2YWxpZGF0ZSgnYnJvd3NlcicsIGRhdGEpXG59XG5cbmV4cG9ydHMuY2FjaGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gdmFsaWRhdGUoJ2NhY2hlJywgZGF0YSlcbn1cblxuZXhwb3J0cy5jb250ZW50ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIHZhbGlkYXRlKCdjb250ZW50JywgZGF0YSlcbn1cblxuZXhwb3J0cy5jb29raWUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gdmFsaWRhdGUoJ2Nvb2tpZScsIGRhdGEpXG59XG5cbmV4cG9ydHMuY3JlYXRvciA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiB2YWxpZGF0ZSgnY3JlYXRvcicsIGRhdGEpXG59XG5cbmV4cG9ydHMuZW50cnkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gdmFsaWRhdGUoJ2VudHJ5JywgZGF0YSlcbn1cblxuZXhwb3J0cy5oYXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gdmFsaWRhdGUoJ2hhcicsIGRhdGEpXG59XG5cbmV4cG9ydHMuaGVhZGVyID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIHZhbGlkYXRlKCdoZWFkZXInLCBkYXRhKVxufVxuXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiB2YWxpZGF0ZSgnbG9nJywgZGF0YSlcbn1cblxuZXhwb3J0cy5wYWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIHZhbGlkYXRlKCdwYWdlJywgZGF0YSlcbn1cblxuZXhwb3J0cy5wYWdlVGltaW5ncyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiB2YWxpZGF0ZSgncGFnZVRpbWluZ3MnLCBkYXRhKVxufVxuXG5leHBvcnRzLnBvc3REYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIHZhbGlkYXRlKCdwb3N0RGF0YScsIGRhdGEpXG59XG5cbmV4cG9ydHMucXVlcnkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gdmFsaWRhdGUoJ3F1ZXJ5JywgZGF0YSlcbn1cblxuZXhwb3J0cy5yZXF1ZXN0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgcmV0dXJuIHZhbGlkYXRlKCdyZXF1ZXN0JywgZGF0YSlcbn1cblxuZXhwb3J0cy5yZXNwb25zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiB2YWxpZGF0ZSgncmVzcG9uc2UnLCBkYXRhKVxufVxuXG5leHBvcnRzLnRpbWluZ3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICByZXR1cm4gdmFsaWRhdGUoJ3RpbWluZ3MnLCBkYXRhKVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xudmFyIHNpZ25lciA9IHJlcXVpcmUoJy4vc2lnbmVyJyk7XG52YXIgdmVyaWZ5ID0gcmVxdWlyZSgnLi92ZXJpZnknKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuXG5cbi8vLy0tLSBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcGFyc2U6IHBhcnNlci5wYXJzZVJlcXVlc3QsXG4gIHBhcnNlUmVxdWVzdDogcGFyc2VyLnBhcnNlUmVxdWVzdCxcblxuICBzaWduOiBzaWduZXIuc2lnblJlcXVlc3QsXG4gIHNpZ25SZXF1ZXN0OiBzaWduZXIuc2lnblJlcXVlc3QsXG4gIGNyZWF0ZVNpZ25lcjogc2lnbmVyLmNyZWF0ZVNpZ25lcixcbiAgaXNTaWduZXI6IHNpZ25lci5pc1NpZ25lcixcblxuICBzc2hLZXlUb1BFTTogdXRpbHMuc3NoS2V5VG9QRU0sXG4gIHNzaEtleUZpbmdlcnByaW50OiB1dGlscy5maW5nZXJwcmludCxcbiAgcGVtVG9Sc2FTU0hLZXk6IHV0aWxzLnBlbVRvUnNhU1NIS2V5LFxuXG4gIHZlcmlmeTogdmVyaWZ5LnZlcmlmeVNpZ25hdHVyZSxcbiAgdmVyaWZ5U2lnbmF0dXJlOiB2ZXJpZnkudmVyaWZ5U2lnbmF0dXJlLFxuICB2ZXJpZnlITUFDOiB2ZXJpZnkudmVyaWZ5SE1BQ1xufTtcbiIsIi8vIENvcHlyaWdodCAyMDEyIEpveWVudCwgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuXG5cbi8vLy0tLSBHbG9iYWxzXG5cbnZhciBIQVNIX0FMR09TID0gdXRpbHMuSEFTSF9BTEdPUztcbnZhciBQS19BTEdPUyA9IHV0aWxzLlBLX0FMR09TO1xudmFyIEh0dHBTaWduYXR1cmVFcnJvciA9IHV0aWxzLkh0dHBTaWduYXR1cmVFcnJvcjtcbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSB1dGlscy5JbnZhbGlkQWxnb3JpdGhtRXJyb3I7XG52YXIgdmFsaWRhdGVBbGdvcml0aG0gPSB1dGlscy52YWxpZGF0ZUFsZ29yaXRobTtcblxudmFyIFN0YXRlID0ge1xuICBOZXc6IDAsXG4gIFBhcmFtczogMVxufTtcblxudmFyIFBhcmFtc1N0YXRlID0ge1xuICBOYW1lOiAwLFxuICBRdW90ZTogMSxcbiAgVmFsdWU6IDIsXG4gIENvbW1hOiAzXG59O1xuXG5cbi8vLy0tLSBTcGVjaWZpYyBFcnJvcnNcblxuXG5mdW5jdGlvbiBFeHBpcmVkUmVxdWVzdEVycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgRXhwaXJlZFJlcXVlc3RFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKEV4cGlyZWRSZXF1ZXN0RXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cblxuZnVuY3Rpb24gSW52YWxpZEhlYWRlckVycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgSW52YWxpZEhlYWRlckVycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoSW52YWxpZEhlYWRlckVycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG5cbmZ1bmN0aW9uIEludmFsaWRQYXJhbXNFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIEludmFsaWRQYXJhbXNFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKEludmFsaWRQYXJhbXNFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuXG5mdW5jdGlvbiBNaXNzaW5nSGVhZGVyRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBNaXNzaW5nSGVhZGVyRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhNaXNzaW5nSGVhZGVyRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cbmZ1bmN0aW9uIFN0cmljdFBhcnNpbmdFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIFN0cmljdFBhcnNpbmdFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKFN0cmljdFBhcnNpbmdFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuLy8vLS0tIEV4cG9ydGVkIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogUGFyc2VzIHRoZSAnQXV0aG9yaXphdGlvbicgaGVhZGVyIG91dCBvZiBhbiBodHRwLlNlcnZlclJlcXVlc3Qgb2JqZWN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBBUEkgd2lsbCBmdWxseSB2YWxpZGF0ZSB0aGUgQXV0aG9yaXphdGlvbiBoZWFkZXIsIGFuZCB0aHJvd1xuICAgKiBvbiBhbnkgZXJyb3IuICBJdCB3aWxsIG5vdCBob3dldmVyIGNoZWNrIHRoZSBzaWduYXR1cmUsIG9yIHRoZSBrZXlJZCBmb3JtYXRcbiAgICogYXMgdGhvc2UgYXJlIHNwZWNpZmljIHRvIHlvdXIgZW52aXJvbm1lbnQuICBZb3UgY2FuIHVzZSB0aGUgb3B0aW9ucyBvYmplY3RcbiAgICogdG8gcGFzcyBpbiBleHRyYSBjb25zdHJhaW50cy5cbiAgICpcbiAgICogQXMgYSByZXNwb25zZSBvYmplY3QgeW91IGNhbiBleHBlY3QgdGhpczpcbiAgICpcbiAgICogICAgIHtcbiAgICogICAgICAgXCJzY2hlbWVcIjogXCJTaWduYXR1cmVcIixcbiAgICogICAgICAgXCJwYXJhbXNcIjoge1xuICAgKiAgICAgICAgIFwia2V5SWRcIjogXCJmb29cIixcbiAgICogICAgICAgICBcImFsZ29yaXRobVwiOiBcInJzYS1zaGEyNTZcIixcbiAgICogICAgICAgICBcImhlYWRlcnNcIjogW1xuICAgKiAgICAgICAgICAgXCJkYXRlXCIgb3IgXCJ4LWRhdGVcIixcbiAgICogICAgICAgICAgIFwiZGlnZXN0XCJcbiAgICogICAgICAgICBdLFxuICAgKiAgICAgICAgIFwic2lnbmF0dXJlXCI6IFwiYmFzZTY0XCJcbiAgICogICAgICAgfSxcbiAgICogICAgICAgXCJzaWduaW5nU3RyaW5nXCI6IFwicmVhZHkgdG8gYmUgcGFzc2VkIHRvIGNyeXB0by52ZXJpZnkoKVwiXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IGFuIGh0dHAuU2VydmVyUmVxdWVzdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3Qgd2l0aDpcbiAgICogICAgICAgICAgICAgICAgICAgLSBjbG9ja1NrZXc6IGFsbG93ZWQgY2xvY2sgc2tldyBpbiBzZWNvbmRzIChkZWZhdWx0IDMwMCkuXG4gICAqICAgICAgICAgICAgICAgICAgIC0gaGVhZGVyczogcmVxdWlyZWQgaGVhZGVyIG5hbWVzIChkZWY6IGRhdGUgb3IgeC1kYXRlKVxuICAgKiAgICAgICAgICAgICAgICAgICAtIGFsZ29yaXRobXM6IGFsZ29yaXRobXMgdG8gc3VwcG9ydCAoZGVmYXVsdDogYWxsKS5cbiAgICogICAgICAgICAgICAgICAgICAgLSBzdHJpY3Q6IHNob3VsZCBlbmZvcmNlIGxhdGVzdCBzcGVjIHBhcnNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkZWZhdWx0OiBmYWxzZSkuXG4gICAqIEByZXR1cm4ge09iamVjdH0gcGFyc2VkIG91dCBvYmplY3QgKHNlZSBhYm92ZSkuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gb24gaW52YWxpZCBpbnB1dC5cbiAgICogQHRocm93cyB7SW52YWxpZEhlYWRlckVycm9yfSBvbiBhbiBpbnZhbGlkIEF1dGhvcml6YXRpb24gaGVhZGVyIGVycm9yLlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkUGFyYW1zRXJyb3J9IGlmIHRoZSBwYXJhbXMgaW4gdGhlIHNjaGVtZSBhcmUgaW52YWxpZC5cbiAgICogQHRocm93cyB7TWlzc2luZ0hlYWRlckVycm9yfSBpZiB0aGUgcGFyYW1zIGluZGljYXRlIGEgaGVhZGVyIG5vdCBwcmVzZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVpdGhlciBpbiB0aGUgcmVxdWVzdCBoZWFkZXJzIGZyb20gdGhlIHBhcmFtcyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBub3QgaW4gdGhlIHBhcmFtcyBmcm9tIGEgcmVxdWlyZWQgaGVhZGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gb3B0aW9ucy5cbiAgICogQHRocm93cyB7U3RyaWN0UGFyc2luZ0Vycm9yfSBpZiBvbGQgYXR0cmlidXRlcyBhcmUgdXNlZCBpbiBzdHJpY3QgcGFyc2luZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUuXG4gICAqIEB0aHJvd3Mge0V4cGlyZWRSZXF1ZXN0RXJyb3J9IGlmIHRoZSB2YWx1ZSBvZiBkYXRlIG9yIHgtZGF0ZSBleGNlZWRzIHNrZXcuXG4gICAqL1xuICBwYXJzZVJlcXVlc3Q6IGZ1bmN0aW9uIHBhcnNlUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0Lm9iamVjdChyZXF1ZXN0LCAncmVxdWVzdCcpO1xuICAgIGFzc2VydC5vYmplY3QocmVxdWVzdC5oZWFkZXJzLCAncmVxdWVzdC5oZWFkZXJzJyk7XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycyA9IFtyZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddID8gJ3gtZGF0ZScgOiAnZGF0ZSddO1xuICAgIH1cbiAgICBhc3NlcnQub2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG4gICAgYXNzZXJ0LmFycmF5T2ZTdHJpbmcob3B0aW9ucy5oZWFkZXJzLCAnb3B0aW9ucy5oZWFkZXJzJyk7XG4gICAgYXNzZXJ0Lm9wdGlvbmFsRmluaXRlKG9wdGlvbnMuY2xvY2tTa2V3LCAnb3B0aW9ucy5jbG9ja1NrZXcnKTtcblxuICAgIHZhciBhdXRoekhlYWRlck5hbWUgPSBvcHRpb25zLmF1dGhvcml6YXRpb25IZWFkZXJOYW1lIHx8ICdhdXRob3JpemF0aW9uJztcblxuICAgIGlmICghcmVxdWVzdC5oZWFkZXJzW2F1dGh6SGVhZGVyTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBNaXNzaW5nSGVhZGVyRXJyb3IoJ25vICcgKyBhdXRoekhlYWRlck5hbWUgKyAnIGhlYWRlciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByZXNlbnQgaW4gdGhlIHJlcXVlc3QnKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmNsb2NrU2tldyA9IG9wdGlvbnMuY2xvY2tTa2V3IHx8IDMwMDtcblxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBzdGF0ZSA9IFN0YXRlLk5ldztcbiAgICB2YXIgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5OYW1lO1xuICAgIHZhciB0bXBOYW1lID0gJyc7XG4gICAgdmFyIHRtcFZhbHVlID0gJyc7XG5cbiAgICB2YXIgcGFyc2VkID0ge1xuICAgICAgc2NoZW1lOiAnJyxcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBzaWduaW5nU3RyaW5nOiAnJ1xuICAgIH07XG5cbiAgICB2YXIgYXV0aHogPSByZXF1ZXN0LmhlYWRlcnNbYXV0aHpIZWFkZXJOYW1lXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXV0aHoubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gYXV0aHouY2hhckF0KGkpO1xuXG4gICAgICBzd2l0Y2ggKE51bWJlcihzdGF0ZSkpIHtcblxuICAgICAgY2FzZSBTdGF0ZS5OZXc6XG4gICAgICAgIGlmIChjICE9PSAnICcpIHBhcnNlZC5zY2hlbWUgKz0gYztcbiAgICAgICAgZWxzZSBzdGF0ZSA9IFN0YXRlLlBhcmFtcztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU3RhdGUuUGFyYW1zOlxuICAgICAgICBzd2l0Y2ggKE51bWJlcihzdWJzdGF0ZSkpIHtcblxuICAgICAgICBjYXNlIFBhcmFtc1N0YXRlLk5hbWU6XG4gICAgICAgICAgdmFyIGNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgLy8gcmVzdHJpY3RlZCBuYW1lIG9mIEEtWiAvIGEtelxuICAgICAgICAgIGlmICgoY29kZSA+PSAweDQxICYmIGNvZGUgPD0gMHg1YSkgfHwgLy8gQS1aXG4gICAgICAgICAgICAgIChjb2RlID49IDB4NjEgJiYgY29kZSA8PSAweDdhKSkgeyAvLyBhLXpcbiAgICAgICAgICAgIHRtcE5hbWUgKz0gYztcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgaWYgKHRtcE5hbWUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdiYWQgcGFyYW0gZm9ybWF0Jyk7XG4gICAgICAgICAgICBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLlF1b3RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdiYWQgcGFyYW0gZm9ybWF0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGFyYW1zU3RhdGUuUXVvdGU6XG4gICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgIHRtcFZhbHVlID0gJyc7XG4gICAgICAgICAgICBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLlZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdiYWQgcGFyYW0gZm9ybWF0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGFyYW1zU3RhdGUuVmFsdWU6XG4gICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXJhbXNbdG1wTmFtZV0gPSB0bXBWYWx1ZTtcbiAgICAgICAgICAgIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuQ29tbWE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRtcFZhbHVlICs9IGM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGFyYW1zU3RhdGUuQ29tbWE6XG4gICAgICAgICAgaWYgKGMgPT09ICcsJykge1xuICAgICAgICAgICAgdG1wTmFtZSA9ICcnO1xuICAgICAgICAgICAgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5OYW1lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdiYWQgcGFyYW0gZm9ybWF0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnN0YXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdWJzdGF0ZScpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZWQucGFyYW1zLmhlYWRlcnMgfHwgcGFyc2VkLnBhcmFtcy5oZWFkZXJzID09PSAnJykge1xuICAgICAgaWYgKHJlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10pIHtcbiAgICAgICAgcGFyc2VkLnBhcmFtcy5oZWFkZXJzID0gWyd4LWRhdGUnXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5wYXJhbXMuaGVhZGVycyA9IFsnZGF0ZSddO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQucGFyYW1zLmhlYWRlcnMgPSBwYXJzZWQucGFyYW1zLmhlYWRlcnMuc3BsaXQoJyAnKTtcbiAgICB9XG5cbiAgICAvLyBNaW5pbWFsbHkgdmFsaWRhdGUgdGhlIHBhcnNlZCBvYmplY3RcbiAgICBpZiAoIXBhcnNlZC5zY2hlbWUgfHwgcGFyc2VkLnNjaGVtZSAhPT0gJ1NpZ25hdHVyZScpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdzY2hlbWUgd2FzIG5vdCBcIlNpZ25hdHVyZVwiJyk7XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMua2V5SWQpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdrZXlJZCB3YXMgbm90IHNwZWNpZmllZCcpO1xuXG4gICAgaWYgKCFwYXJzZWQucGFyYW1zLmFsZ29yaXRobSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2FsZ29yaXRobSB3YXMgbm90IHNwZWNpZmllZCcpO1xuXG4gICAgaWYgKCFwYXJzZWQucGFyYW1zLnNpZ25hdHVyZSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ3NpZ25hdHVyZSB3YXMgbm90IHNwZWNpZmllZCcpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGFsZ29yaXRobSBhZ2FpbnN0IHRoZSBvZmZpY2lhbCBsaXN0XG4gICAgcGFyc2VkLnBhcmFtcy5hbGdvcml0aG0gPSBwYXJzZWQucGFyYW1zLmFsZ29yaXRobS50b0xvd2VyQ2FzZSgpO1xuICAgIHRyeSB7XG4gICAgICB2YWxpZGF0ZUFsZ29yaXRobShwYXJzZWQucGFyYW1zLmFsZ29yaXRobSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBJbnZhbGlkQWxnb3JpdGhtRXJyb3IpXG4gICAgICAgIHRocm93IChuZXcgSW52YWxpZFBhcmFtc0Vycm9yKHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtICsgJyBpcyBub3QgJyArXG4gICAgICAgICAgJ3N1cHBvcnRlZCcpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgKGUpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBzaWduaW5nU3RyaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnNlZC5wYXJhbXMuaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGggPSBwYXJzZWQucGFyYW1zLmhlYWRlcnNbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHBhcnNlZC5wYXJhbXMuaGVhZGVyc1tpXSA9IGg7XG5cbiAgICAgIGlmIChoID09PSAncmVxdWVzdC1saW5lJykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBXZSBhbGxvdyBoZWFkZXJzIGZyb20gdGhlIG9sZGVyIHNwZWMgZHJhZnRzIGlmIHN0cmljdCBwYXJzaW5nIGlzbid0XG4gICAgICAgICAgICogc3BlY2lmaWVkIGluIG9wdGlvbnMuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcGFyc2VkLnNpZ25pbmdTdHJpbmcgKz1cbiAgICAgICAgICAgIHJlcXVlc3QubWV0aG9kICsgJyAnICsgcmVxdWVzdC51cmwgKyAnIEhUVFAvJyArIHJlcXVlc3QuaHR0cFZlcnNpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogU3RyaWN0IHBhcnNpbmcgZG9lc24ndCBhbGxvdyBvbGRlciBkcmFmdCBoZWFkZXJzLiAqL1xuICAgICAgICAgIHRocm93IChuZXcgU3RyaWN0UGFyc2luZ0Vycm9yKCdyZXF1ZXN0LWxpbmUgaXMgbm90IGEgdmFsaWQgaGVhZGVyICcgK1xuICAgICAgICAgICAgJ3dpdGggc3RyaWN0IHBhcnNpbmcgZW5hYmxlZC4nKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaCA9PT0gJyhyZXF1ZXN0LXRhcmdldCknKSB7XG4gICAgICAgIHBhcnNlZC5zaWduaW5nU3RyaW5nICs9XG4gICAgICAgICAgJyhyZXF1ZXN0LXRhcmdldCk6ICcgKyByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpICsgJyAnICtcbiAgICAgICAgICByZXF1ZXN0LnVybDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlcXVlc3QuaGVhZGVyc1toXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdIZWFkZXJFcnJvcihoICsgJyB3YXMgbm90IGluIHRoZSByZXF1ZXN0Jyk7XG4gICAgICAgIHBhcnNlZC5zaWduaW5nU3RyaW5nICs9IGggKyAnOiAnICsgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoaSArIDEpIDwgcGFyc2VkLnBhcmFtcy5oZWFkZXJzLmxlbmd0aClcbiAgICAgICAgcGFyc2VkLnNpZ25pbmdTdHJpbmcgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYWdhaW5zdCB0aGUgY29uc3RyYWludHNcbiAgICB2YXIgZGF0ZTtcbiAgICBpZiAocmVxdWVzdC5oZWFkZXJzLmRhdGUgfHwgcmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSkge1xuICAgICAgICBpZiAocmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSkge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShyZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUocmVxdWVzdC5oZWFkZXJzLmRhdGUpO1xuICAgICAgICB9XG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIHZhciBza2V3ID0gTWF0aC5hYnMobm93LmdldFRpbWUoKSAtIGRhdGUuZ2V0VGltZSgpKTtcblxuICAgICAgaWYgKHNrZXcgPiBvcHRpb25zLmNsb2NrU2tldyAqIDEwMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4cGlyZWRSZXF1ZXN0RXJyb3IoJ2Nsb2NrIHNrZXcgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChza2V3IC8gMTAwMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncyB3YXMgZ3JlYXRlciB0aGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNsb2NrU2tldyArICdzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucy5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhkcikge1xuICAgICAgLy8gUmVtZW1iZXIgdGhhdCB3ZSBhbHJlYWR5IGNoZWNrZWQgYW55IGhlYWRlcnMgaW4gdGhlIHBhcmFtc1xuICAgICAgLy8gd2VyZSBpbiB0aGUgcmVxdWVzdCwgc28gaWYgdGhpcyBwYXNzZXMgd2UncmUgZ29vZC5cbiAgICAgIGlmIChwYXJzZWQucGFyYW1zLmhlYWRlcnMuaW5kZXhPZihoZHIudG9Mb3dlckNhc2UoKSkgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlckVycm9yKGhkciArICcgd2FzIG5vdCBhIHNpZ25lZCBoZWFkZXInKTtcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmFsZ29yaXRobXMpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsZ29yaXRobXMuaW5kZXhPZihwYXJzZWQucGFyYW1zLmFsZ29yaXRobSkgPT09IC0xKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtc0Vycm9yKHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGlzIG5vdCBhIHN1cHBvcnRlZCBhbGdvcml0aG0nKTtcbiAgICB9XG5cbiAgICBwYXJzZWQuYWxnb3JpdGhtID0gcGFyc2VkLnBhcmFtcy5hbGdvcml0aG0udG9VcHBlckNhc2UoKTtcbiAgICBwYXJzZWQua2V5SWQgPSBwYXJzZWQucGFyYW1zLmtleUlkO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxufTtcbiIsIi8vIENvcHlyaWdodCAyMDEyIEpveWVudCwgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHNzaHBrID0gcmVxdWlyZSgnc3NocGsnKTtcbnZhciBqc3ByaW0gPSByZXF1aXJlKCdqc3ByaW0nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIHNwcmludGYgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xuXG52YXIgSEFTSF9BTEdPUyA9IHV0aWxzLkhBU0hfQUxHT1M7XG52YXIgUEtfQUxHT1MgPSB1dGlscy5QS19BTEdPUztcbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSB1dGlscy5JbnZhbGlkQWxnb3JpdGhtRXJyb3I7XG52YXIgSHR0cFNpZ25hdHVyZUVycm9yID0gdXRpbHMuSHR0cFNpZ25hdHVyZUVycm9yO1xudmFyIHZhbGlkYXRlQWxnb3JpdGhtID0gdXRpbHMudmFsaWRhdGVBbGdvcml0aG07XG5cbi8vLy0tLSBHbG9iYWxzXG5cbnZhciBBVVRIWl9GTVQgPVxuICAnU2lnbmF0dXJlIGtleUlkPVwiJXNcIixhbGdvcml0aG09XCIlc1wiLGhlYWRlcnM9XCIlc1wiLHNpZ25hdHVyZT1cIiVzXCInO1xuXG4vLy8tLS0gU3BlY2lmaWMgRXJyb3JzXG5cbmZ1bmN0aW9uIE1pc3NpbmdIZWFkZXJFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIE1pc3NpbmdIZWFkZXJFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKE1pc3NpbmdIZWFkZXJFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuZnVuY3Rpb24gU3RyaWN0UGFyc2luZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgU3RyaWN0UGFyc2luZ0Vycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoU3RyaWN0UGFyc2luZ0Vycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG4vKiBTZWUgY3JlYXRlU2lnbmVyKCkgKi9cbmZ1bmN0aW9uIFJlcXVlc3RTaWduZXIob3B0aW9ucykge1xuICBhc3NlcnQub2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cbiAgdmFyIGFsZyA9IFtdO1xuICBpZiAob3B0aW9ucy5hbGdvcml0aG0gIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydC5zdHJpbmcob3B0aW9ucy5hbGdvcml0aG0sICdvcHRpb25zLmFsZ29yaXRobScpO1xuICAgIGFsZyA9IHZhbGlkYXRlQWxnb3JpdGhtKG9wdGlvbnMuYWxnb3JpdGhtKTtcbiAgfVxuICB0aGlzLnJzX2FsZyA9IGFsZztcblxuICAvKlxuICAgKiBSZXF1ZXN0U2lnbmVycyBjb21lIGluIHR3byB2YXJpZXRpZXM6IG9uZXMgd2l0aCBhbiByc19zaWduRnVuYywgYW5kIG9uZXNcbiAgICogd2l0aCBhbiByc19zaWduZXIuXG4gICAqXG4gICAqIHJzX3NpZ25GdW5jLWJhc2VkIFJlcXVlc3RTaWduZXJzIGhhdmUgdG8gYnVpbGQgdXAgdGhlaXIgZW50aXJlIHNpZ25pbmdcbiAgICogc3RyaW5nIHdpdGhpbiB0aGUgcnNfbGluZXMgYXJyYXkgYW5kIGdpdmUgaXQgdG8gcnNfc2lnbkZ1bmMgYXMgYSBzaW5nbGVcbiAgICogY29uY2F0J2QgYmxvYi4gcnNfc2lnbmVyLWJhc2VkIFJlcXVlc3RTaWduZXJzIGNhbiBhZGQgYSBsaW5lIGF0IGEgdGltZSB0b1xuICAgKiB0aGVpciBzaWduaW5nIHN0YXRlIGJ5IHVzaW5nIHJzX3NpZ25lci51cGRhdGUoKSwgdGh1cyBvbmx5IG5lZWRpbmcgdG9cbiAgICogYnVmZmVyIHRoZSBoYXNoIGZ1bmN0aW9uIHN0YXRlIGFuZCBvbmUgbGluZSBhdCBhIHRpbWUuXG4gICAqL1xuICBpZiAob3B0aW9ucy5zaWduICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnQuZnVuYyhvcHRpb25zLnNpZ24sICdvcHRpb25zLnNpZ24nKTtcbiAgICB0aGlzLnJzX3NpZ25GdW5jID0gb3B0aW9ucy5zaWduO1xuXG4gIH0gZWxzZSBpZiAoYWxnWzBdID09PSAnaG1hYycgJiYgb3B0aW9ucy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydC5zdHJpbmcob3B0aW9ucy5rZXlJZCwgJ29wdGlvbnMua2V5SWQnKTtcbiAgICB0aGlzLnJzX2tleUlkID0gb3B0aW9ucy5rZXlJZDtcblxuICAgIGlmICh0eXBlb2YgKG9wdGlvbnMua2V5KSAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmtleSkpXG4gICAgICB0aHJvdyAobmV3IFR5cGVFcnJvcignb3B0aW9ucy5rZXkgZm9yIEhNQUMgbXVzdCBiZSBhIHN0cmluZyBvciBCdWZmZXInKSk7XG5cbiAgICAvKlxuICAgICAqIE1ha2UgYW4gcnNfc2lnbmVyIGZvciBITUFDcywgbm90IGEgcnNfc2lnbkZ1bmMgLS0gSE1BQ3MgZGlnZXN0IHRoZWlyXG4gICAgICogZGF0YSBpbiBjaHVua3MgcmF0aGVyIHRoYW4gcmVxdWlyaW5nIGl0IGFsbCB0byBiZSBnaXZlbiBpbiBvbmUgZ29cbiAgICAgKiBhdCB0aGUgZW5kLCBzbyB0aGV5IGFyZSBtb3JlIHNpbWlsYXIgdG8gc2lnbmVycyB0aGFuIHNpZ25GdW5jcy5cbiAgICAgKi9cbiAgICB0aGlzLnJzX3NpZ25lciA9IGNyeXB0by5jcmVhdGVIbWFjKGFsZ1sxXS50b1VwcGVyQ2FzZSgpLCBvcHRpb25zLmtleSk7XG4gICAgdGhpcy5yc19zaWduZXIuc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkaWdlc3QgPSB0aGlzLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgICByZXR1cm4gKHtcbiAgICAgICAgaGFzaEFsZ29yaXRobTogYWxnWzFdLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gKGRpZ2VzdCk7IH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgfSBlbHNlIGlmIChvcHRpb25zLmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGlmICh0eXBlb2YgKGtleSkgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihrZXkpKVxuICAgICAga2V5ID0gc3NocGsucGFyc2VQcml2YXRlS2V5KGtleSk7XG5cbiAgICBhc3NlcnQub2soc3NocGsuUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5LCBbMSwgMl0pLFxuICAgICAgJ29wdGlvbnMua2V5IG11c3QgYmUgYSBzc2hway5Qcml2YXRlS2V5Jyk7XG4gICAgdGhpcy5yc19rZXkgPSBrZXk7XG5cbiAgICBhc3NlcnQuc3RyaW5nKG9wdGlvbnMua2V5SWQsICdvcHRpb25zLmtleUlkJyk7XG4gICAgdGhpcy5yc19rZXlJZCA9IG9wdGlvbnMua2V5SWQ7XG5cbiAgICBpZiAoIVBLX0FMR09TW2tleS50eXBlXSkge1xuICAgICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3Ioa2V5LnR5cGUudG9VcHBlckNhc2UoKSArICcgdHlwZSAnICtcbiAgICAgICAgJ2tleXMgYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgfVxuXG4gICAgaWYgKGFsZ1swXSAhPT0gdW5kZWZpbmVkICYmIGtleS50eXBlICE9PSBhbGdbMF0pIHtcbiAgICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKCdvcHRpb25zLmtleSBtdXN0IGJlIGEgJyArXG4gICAgICAgIGFsZ1swXS50b1VwcGVyQ2FzZSgpICsgJyBrZXksIHdhcyBnaXZlbiBhICcgK1xuICAgICAgICBrZXkudHlwZS50b1VwcGVyQ2FzZSgpICsgJyBrZXkgaW5zdGVhZCcpKTtcbiAgICB9XG5cbiAgICB0aGlzLnJzX3NpZ25lciA9IGtleS5jcmVhdGVTaWduKGFsZ1sxXSk7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyAobmV3IFR5cGVFcnJvcignb3B0aW9ucy5zaWduIChmdW5jKSBvciBvcHRpb25zLmtleSBpcyByZXF1aXJlZCcpKTtcbiAgfVxuXG4gIHRoaXMucnNfaGVhZGVycyA9IFtdO1xuICB0aGlzLnJzX2xpbmVzID0gW107XG59XG5cbi8qKlxuICogQWRkcyBhIGhlYWRlciB0byBiZSBzaWduZWQsIHdpdGggaXRzIHZhbHVlLCBpbnRvIHRoaXMgc2lnbmVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSB2YWx1ZSB3cml0dGVuXG4gKi9cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLndyaXRlSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlciwgdmFsdWUpIHtcbiAgYXNzZXJ0LnN0cmluZyhoZWFkZXIsICdoZWFkZXInKTtcbiAgaGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XG4gIGFzc2VydC5zdHJpbmcodmFsdWUsICd2YWx1ZScpO1xuXG4gIHRoaXMucnNfaGVhZGVycy5wdXNoKGhlYWRlcik7XG5cbiAgaWYgKHRoaXMucnNfc2lnbkZ1bmMpIHtcbiAgICB0aGlzLnJzX2xpbmVzLnB1c2goaGVhZGVyICsgJzogJyArIHZhbHVlKTtcblxuICB9IGVsc2Uge1xuICAgIHZhciBsaW5lID0gaGVhZGVyICsgJzogJyArIHZhbHVlO1xuICAgIGlmICh0aGlzLnJzX2hlYWRlcnMubGVuZ3RoID4gMClcbiAgICAgIGxpbmUgPSAnXFxuJyArIGxpbmU7XG4gICAgdGhpcy5yc19zaWduZXIudXBkYXRlKGxpbmUpO1xuICB9XG5cbiAgcmV0dXJuICh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBkZWZhdWx0IERhdGUgaGVhZGVyLCByZXR1cm5pbmcgaXRzIHZhbHVlLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUud3JpdGVEYXRlSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMud3JpdGVIZWFkZXIoJ2RhdGUnLCBqc3ByaW0ucmZjMTEyMyhuZXcgRGF0ZSgpKSkpO1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSByZXF1ZXN0IHRhcmdldCBsaW5lIHRvIGJlIHNpZ25lZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kLCBIVFRQIG1ldGhvZCAoZS5nLiAnZ2V0JywgJ3Bvc3QnLCAncHV0JylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKi9cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLndyaXRlVGFyZ2V0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcGF0aCkge1xuICBhc3NlcnQuc3RyaW5nKG1ldGhvZCwgJ21ldGhvZCcpO1xuICBhc3NlcnQuc3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gIG1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB0aGlzLndyaXRlSGVhZGVyKCcocmVxdWVzdC10YXJnZXQpJywgbWV0aG9kICsgJyAnICsgcGF0aCk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgdmFsdWUgZm9yIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlciBvbiB0aGlzIHJlcXVlc3RcbiAqIGFzeW5jaHJvbm91c2x5LlxuICpcbiAqIEBwYXJhbSB7RnVuY30gY2FsbGJhY2sgKGVyciwgYXV0aHopXG4gKi9cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoY2IpIHtcbiAgYXNzZXJ0LmZ1bmMoY2IsICdjYWxsYmFjaycpO1xuXG4gIGlmICh0aGlzLnJzX2hlYWRlcnMubGVuZ3RoIDwgMSlcbiAgICB0aHJvdyAobmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgaGVhZGVyIG11c3QgYmUgc2lnbmVkJykpO1xuXG4gIHZhciBhbGcsIGF1dGh6O1xuICBpZiAodGhpcy5yc19zaWduRnVuYykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yc19saW5lcy5qb2luKCdcXG4nKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5yc19zaWduRnVuYyhkYXRhLCBmdW5jdGlvbiAoZXJyLCBzaWcpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0Lm9iamVjdChzaWcsICdzaWduYXR1cmUnKTtcbiAgICAgICAgYXNzZXJ0LnN0cmluZyhzaWcua2V5SWQsICdzaWduYXR1cmUua2V5SWQnKTtcbiAgICAgICAgYXNzZXJ0LnN0cmluZyhzaWcuYWxnb3JpdGhtLCAnc2lnbmF0dXJlLmFsZ29yaXRobScpO1xuICAgICAgICBhc3NlcnQuc3RyaW5nKHNpZy5zaWduYXR1cmUsICdzaWduYXR1cmUuc2lnbmF0dXJlJyk7XG4gICAgICAgIGFsZyA9IHZhbGlkYXRlQWxnb3JpdGhtKHNpZy5hbGdvcml0aG0pO1xuXG4gICAgICAgIGF1dGh6ID0gc3ByaW50ZihBVVRIWl9GTVQsXG4gICAgICAgICAgc2lnLmtleUlkLFxuICAgICAgICAgIHNpZy5hbGdvcml0aG0sXG4gICAgICAgICAgc2VsZi5yc19oZWFkZXJzLmpvaW4oJyAnKSxcbiAgICAgICAgICBzaWcuc2lnbmF0dXJlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2IoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNiKG51bGwsIGF1dGh6KTtcbiAgICB9KTtcblxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICB2YXIgc2lnT2JqID0gdGhpcy5yc19zaWduZXIuc2lnbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbGcgPSAodGhpcy5yc19hbGdbMF0gfHwgdGhpcy5yc19rZXkudHlwZSkgKyAnLScgKyBzaWdPYmouaGFzaEFsZ29yaXRobTtcbiAgICB2YXIgc2lnbmF0dXJlID0gc2lnT2JqLnRvU3RyaW5nKCk7XG4gICAgYXV0aHogPSBzcHJpbnRmKEFVVEhaX0ZNVCxcbiAgICAgIHRoaXMucnNfa2V5SWQsXG4gICAgICBhbGcsXG4gICAgICB0aGlzLnJzX2hlYWRlcnMuam9pbignICcpLFxuICAgICAgc2lnbmF0dXJlKTtcbiAgICBjYihudWxsLCBhdXRoeik7XG4gIH1cbn07XG5cbi8vLy0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBJZGVudGlmaWVzIHdoZXRoZXIgYSBnaXZlbiBvYmplY3QgaXMgYSByZXF1ZXN0IHNpZ25lciBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QsIHRoZSBvYmplY3QgdG8gaWRlbnRpZnlcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBpc1NpZ25lcjogZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICh0eXBlb2YgKG9iaikgPT09ICdvYmplY3QnICYmIG9iaiBpbnN0YW5jZW9mIFJlcXVlc3RTaWduZXIpXG4gICAgICByZXR1cm4gKHRydWUpO1xuICAgIHJldHVybiAoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVxdWVzdCBzaWduZXIsIHVzZWQgdG8gYXN5bmNocm9ub3VzbHkgYnVpbGQgYSBzaWduYXR1cmVcbiAgICogZm9yIGEgcmVxdWVzdCAoZG9lcyBub3QgaGF2ZSB0byBiZSBhbiBodHRwLkNsaWVudFJlcXVlc3QpLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucywgZWl0aGVyOlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGtleUlkXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ3xCdWZmZXJ9IGtleVxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGFsZ29yaXRobSAob3B0aW9uYWwsIHJlcXVpcmVkIGZvciBITUFDKVxuICAgKiAgICAgICAgICAgICAgICAgb3I6XG4gICAqICAgICAgICAgICAgICAgICAgIC0ge0Z1bmN9IHNpZ24gKGRhdGEsIGNiKVxuICAgKiBAcmV0dXJuIHtSZXF1ZXN0U2lnbmVyfVxuICAgKi9cbiAgY3JlYXRlU2lnbmVyOiBmdW5jdGlvbiBjcmVhdGVTaWduZXIob3B0aW9ucykge1xuICAgIHJldHVybiAobmV3IFJlcXVlc3RTaWduZXIob3B0aW9ucykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGFuICdBdXRob3JpemF0aW9uJyBoZWFkZXIgdG8gYW4gaHR0cC5DbGllbnRSZXF1ZXN0IG9iamVjdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgQVBJIHdpbGwgYWRkIGEgRGF0ZSBoZWFkZXIgaWYgaXQncyBub3QgYWxyZWFkeSBzZXQuIEFueVxuICAgKiBvdGhlciBoZWFkZXJzIGluIHRoZSBvcHRpb25zLmhlYWRlcnMgYXJyYXkgTVVTVCBiZSBwcmVzZW50LCBvciB0aGlzXG4gICAqIHdpbGwgdGhyb3cuXG4gICAqXG4gICAqIFlvdSBzaG91bGRuJ3QgbmVlZCB0byBjaGVjayB0aGUgcmV0dXJuIHR5cGU7IGl0J3MganVzdCB0aGVyZSBpZiB5b3Ugd2FudFxuICAgKiB0byBiZSBwZWRhbnRpYy5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIGZsYWcgaW5kaWNhdGVzIHdoZXRoZXIgcGFyc2luZyBzaG91bGQgdXNlIHN0cmljdCBlbmZvcmNlbWVudFxuICAgKiBvZiB0aGUgdmVyc2lvbiBkcmFmdC1jYXZhZ2UtaHR0cC1zaWduYXR1cmVzLTA0IG9mIHRoZSBzcGVjIG9yIGJleW9uZC5cbiAgICogVGhlIGRlZmF1bHQgaXMgdG8gYmUgbG9vc2UgYW5kIHN1cHBvcnRcbiAgICogb2xkZXIgdmVyc2lvbnMgZm9yIGNvbXBhdGliaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IGFuIGluc3RhbmNlIG9mIGh0dHAuQ2xpZW50UmVxdWVzdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgc2lnbmluZyBwYXJhbWV0ZXJzIG9iamVjdDpcbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBrZXlJZCByZXF1aXJlZC5cbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBrZXkgcmVxdWlyZWQgKGVpdGhlciBhIFBFTSBvciBITUFDIGtleSkuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge0FycmF5fSBoZWFkZXJzIG9wdGlvbmFsOyBkZWZhdWx0cyB0byBbJ2RhdGUnXS5cbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhbGdvcml0aG0gb3B0aW9uYWwgKHVubGVzcyBrZXkgaXMgSE1BQyk7XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCBpcyB0aGUgc2FtZSBhcyB0aGUgc3NocGsgZGVmYXVsdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25pbmcgYWxnb3JpdGhtIGZvciB0aGUgdHlwZSBvZiBrZXkgZ2l2ZW5cbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBodHRwVmVyc2lvbiBvcHRpb25hbDsgZGVmYXVsdHMgdG8gJzEuMScuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHN0cmljdCBvcHRpb25hbDsgZGVmYXVsdHMgdG8gJ2ZhbHNlJy5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBBdXRob3JpemF0aW9uIChhbmQgb3B0aW9uYWxseSBEYXRlKSB3ZXJlIGFkZGVkLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9uIGJhZCBwYXJhbWV0ZXIgdHlwZXMgKGlucHV0KS5cbiAgICogQHRocm93cyB7SW52YWxpZEFsZ29yaXRobUVycm9yfSBpZiBhbGdvcml0aG0gd2FzIGJhZCBvciBpbmNvbXBhdGlibGUgd2l0aFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBnaXZlbiBrZXkuXG4gICAqIEB0aHJvd3Mge3NzaHBrLktleVBhcnNlRXJyb3J9IGlmIGtleSB3YXMgYmFkLlxuICAgKiBAdGhyb3dzIHtNaXNzaW5nSGVhZGVyRXJyb3J9IGlmIGEgaGVhZGVyIHRvIGJlIHNpZ25lZCB3YXMgc3BlY2lmaWVkIGJ1dFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyBub3QgcHJlc2VudC5cbiAgICovXG4gIHNpZ25SZXF1ZXN0OiBmdW5jdGlvbiBzaWduUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0Lm9iamVjdChyZXF1ZXN0LCAncmVxdWVzdCcpO1xuICAgIGFzc2VydC5vYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0aW9ucy5hbGdvcml0aG0sICdvcHRpb25zLmFsZ29yaXRobScpO1xuICAgIGFzc2VydC5zdHJpbmcob3B0aW9ucy5rZXlJZCwgJ29wdGlvbnMua2V5SWQnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxBcnJheU9mU3RyaW5nKG9wdGlvbnMuaGVhZGVycywgJ29wdGlvbnMuaGVhZGVycycpO1xuICAgIGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRpb25zLmh0dHBWZXJzaW9uLCAnb3B0aW9ucy5odHRwVmVyc2lvbicpO1xuXG4gICAgaWYgKCFyZXF1ZXN0LmdldEhlYWRlcignRGF0ZScpKVxuICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0RhdGUnLCBqc3ByaW0ucmZjMTEyMyhuZXcgRGF0ZSgpKSk7XG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpXG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSBbJ2RhdGUnXTtcbiAgICBpZiAoIW9wdGlvbnMuaHR0cFZlcnNpb24pXG4gICAgICBvcHRpb25zLmh0dHBWZXJzaW9uID0gJzEuMSc7XG5cbiAgICB2YXIgYWxnID0gW107XG4gICAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgICBvcHRpb25zLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCk7XG4gICAgICBhbGcgPSB2YWxpZGF0ZUFsZ29yaXRobShvcHRpb25zLmFsZ29yaXRobSk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIHN0cmluZ1RvU2lnbiA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMuaGVhZGVyc1tpXSkgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmhlYWRlcnMgbXVzdCBiZSBhbiBhcnJheSBvZiBTdHJpbmdzJyk7XG5cbiAgICAgIHZhciBoID0gb3B0aW9ucy5oZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmIChoID09PSAncmVxdWVzdC1saW5lJykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2UgYWxsb3cgaGVhZGVycyBmcm9tIHRoZSBvbGRlciBzcGVjIGRyYWZ0cyBpZiBzdHJpY3QgcGFyc2luZyBpc24ndFxuICAgICAgICAgICAqIHNwZWNpZmllZCBpbiBvcHRpb25zLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHN0cmluZ1RvU2lnbiArPVxuICAgICAgICAgICAgcmVxdWVzdC5tZXRob2QgKyAnICcgKyByZXF1ZXN0LnBhdGggKyAnIEhUVFAvJyArXG4gICAgICAgICAgICBvcHRpb25zLmh0dHBWZXJzaW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIFN0cmljdCBwYXJzaW5nIGRvZXNuJ3QgYWxsb3cgb2xkZXIgZHJhZnQgaGVhZGVycy4gKi9cbiAgICAgICAgICB0aHJvdyAobmV3IFN0cmljdFBhcnNpbmdFcnJvcigncmVxdWVzdC1saW5lIGlzIG5vdCBhIHZhbGlkIGhlYWRlciAnICtcbiAgICAgICAgICAgICd3aXRoIHN0cmljdCBwYXJzaW5nIGVuYWJsZWQuJykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGggPT09ICcocmVxdWVzdC10YXJnZXQpJykge1xuICAgICAgICBzdHJpbmdUb1NpZ24gKz1cbiAgICAgICAgICAnKHJlcXVlc3QtdGFyZ2V0KTogJyArIHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkgKyAnICcgK1xuICAgICAgICAgIHJlcXVlc3QucGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKGgpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlckVycm9yKGggKyAnIHdhcyBub3QgaW4gdGhlIHJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmdUb1NpZ24gKz0gaCArICc6ICcgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpICsgMSkgPCBvcHRpb25zLmhlYWRlcnMubGVuZ3RoKVxuICAgICAgICBzdHJpbmdUb1NpZ24gKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLyogVGhpcyBpcyBqdXN0IGZvciB1bml0IHRlc3RzLiAqL1xuICAgIGlmIChyZXF1ZXN0Lmhhc093blByb3BlcnR5KCdfc3RyaW5nVG9TaWduJykpIHtcbiAgICAgIHJlcXVlc3QuX3N0cmluZ1RvU2lnbiA9IHN0cmluZ1RvU2lnbjtcbiAgICB9XG5cbiAgICB2YXIgc2lnbmF0dXJlO1xuICAgIGlmIChhbGdbMF0gPT09ICdobWFjJykge1xuICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy5rZXkpICE9PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMua2V5KSlcbiAgICAgICAgdGhyb3cgKG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMua2V5IG11c3QgYmUgYSBzdHJpbmcgb3IgQnVmZmVyJykpO1xuXG4gICAgICB2YXIgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGFsZ1sxXS50b1VwcGVyQ2FzZSgpLCBvcHRpb25zLmtleSk7XG4gICAgICBobWFjLnVwZGF0ZShzdHJpbmdUb1NpZ24pO1xuICAgICAgc2lnbmF0dXJlID0gaG1hYy5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICAgIGlmICh0eXBlb2YgKGtleSkgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihrZXkpKVxuICAgICAgICBrZXkgPSBzc2hway5wYXJzZVByaXZhdGVLZXkob3B0aW9ucy5rZXkpO1xuXG4gICAgICBhc3NlcnQub2soc3NocGsuUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5LCBbMSwgMl0pLFxuICAgICAgICAnb3B0aW9ucy5rZXkgbXVzdCBiZSBhIHNzaHBrLlByaXZhdGVLZXknKTtcblxuICAgICAgaWYgKCFQS19BTEdPU1trZXkudHlwZV0pIHtcbiAgICAgICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3Ioa2V5LnR5cGUudG9VcHBlckNhc2UoKSArICcgdHlwZSAnICtcbiAgICAgICAgICAna2V5cyBhcmUgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsZ1swXSAhPT0gdW5kZWZpbmVkICYmIGtleS50eXBlICE9PSBhbGdbMF0pIHtcbiAgICAgICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3IoJ29wdGlvbnMua2V5IG11c3QgYmUgYSAnICtcbiAgICAgICAgICBhbGdbMF0udG9VcHBlckNhc2UoKSArICcga2V5LCB3YXMgZ2l2ZW4gYSAnICtcbiAgICAgICAgICBrZXkudHlwZS50b1VwcGVyQ2FzZSgpICsgJyBrZXkgaW5zdGVhZCcpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpZ25lciA9IGtleS5jcmVhdGVTaWduKGFsZ1sxXSk7XG4gICAgICBzaWduZXIudXBkYXRlKHN0cmluZ1RvU2lnbik7XG4gICAgICB2YXIgc2lnT2JqID0gc2lnbmVyLnNpZ24oKTtcbiAgICAgIGlmICghSEFTSF9BTEdPU1tzaWdPYmouaGFzaEFsZ29yaXRobV0pIHtcbiAgICAgICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3Ioc2lnT2JqLmhhc2hBbGdvcml0aG0udG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgJyBpcyBub3QgYSBzdXBwb3J0ZWQgaGFzaCBhbGdvcml0aG0nKSk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmFsZ29yaXRobSA9IGtleS50eXBlICsgJy0nICsgc2lnT2JqLmhhc2hBbGdvcml0aG07XG4gICAgICBzaWduYXR1cmUgPSBzaWdPYmoudG9TdHJpbmcoKTtcbiAgICAgIGFzc2VydC5ub3RTdHJpY3RFcXVhbChzaWduYXR1cmUsICcnLCAnZW1wdHkgc2lnbmF0dXJlIHByb2R1Y2VkJyk7XG4gICAgfVxuXG4gICAgdmFyIGF1dGh6SGVhZGVyTmFtZSA9IG9wdGlvbnMuYXV0aG9yaXphdGlvbkhlYWRlck5hbWUgfHwgJ0F1dGhvcml6YXRpb24nO1xuXG4gICAgcmVxdWVzdC5zZXRIZWFkZXIoYXV0aHpIZWFkZXJOYW1lLCBzcHJpbnRmKEFVVEhaX0ZNVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5rZXlJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5qb2luKCcgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSkpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufTtcbiIsIi8vIENvcHlyaWdodCAyMDEyIEpveWVudCwgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgc3NocGsgPSByZXF1aXJlKCdzc2hwaycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBIQVNIX0FMR09TID0ge1xuICAnc2hhMSc6IHRydWUsXG4gICdzaGEyNTYnOiB0cnVlLFxuICAnc2hhNTEyJzogdHJ1ZVxufTtcblxudmFyIFBLX0FMR09TID0ge1xuICAncnNhJzogdHJ1ZSxcbiAgJ2RzYSc6IHRydWUsXG4gICdlY2RzYSc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIEh0dHBTaWduYXR1cmVFcnJvcihtZXNzYWdlLCBjYWxsZXIpIHtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGNhbGxlciB8fCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9IGNhbGxlci5uYW1lO1xufVxudXRpbC5pbmhlcml0cyhIdHRwU2lnbmF0dXJlRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gSW52YWxpZEFsZ29yaXRobUVycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgSW52YWxpZEFsZ29yaXRobUVycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoSW52YWxpZEFsZ29yaXRobUVycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUFsZ29yaXRobShhbGdvcml0aG0pIHtcbiAgdmFyIGFsZyA9IGFsZ29yaXRobS50b0xvd2VyQ2FzZSgpLnNwbGl0KCctJyk7XG5cbiAgaWYgKGFsZy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcihhbGdbMF0udG9VcHBlckNhc2UoKSArICcgaXMgbm90IGEgJyArXG4gICAgICAndmFsaWQgYWxnb3JpdGhtJykpO1xuICB9XG5cbiAgaWYgKGFsZ1swXSAhPT0gJ2htYWMnICYmICFQS19BTEdPU1thbGdbMF1dKSB7XG4gICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3IoYWxnWzBdLnRvVXBwZXJDYXNlKCkgKyAnIHR5cGUga2V5cyAnICtcbiAgICAgICdhcmUgbm90IHN1cHBvcnRlZCcpKTtcbiAgfVxuXG4gIGlmICghSEFTSF9BTEdPU1thbGdbMV1dKSB7XG4gICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3IoYWxnWzFdLnRvVXBwZXJDYXNlKCkgKyAnIGlzIG5vdCBhICcgK1xuICAgICAgJ3N1cHBvcnRlZCBoYXNoIGFsZ29yaXRobScpKTtcbiAgfVxuXG4gIHJldHVybiAoYWxnKTtcbn1cblxuLy8vLS0tIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBIQVNIX0FMR09TOiBIQVNIX0FMR09TLFxuICBQS19BTEdPUzogUEtfQUxHT1MsXG5cbiAgSHR0cFNpZ25hdHVyZUVycm9yOiBIdHRwU2lnbmF0dXJlRXJyb3IsXG4gIEludmFsaWRBbGdvcml0aG1FcnJvcjogSW52YWxpZEFsZ29yaXRobUVycm9yLFxuXG4gIHZhbGlkYXRlQWxnb3JpdGhtOiB2YWxpZGF0ZUFsZ29yaXRobSxcblxuICAvKipcbiAgICogQ29udmVydHMgYW4gT3BlblNTSCBwdWJsaWMga2V5IChyc2Egb25seSkgdG8gYSBQS0NTIzggUEVNIGZpbGUuXG4gICAqXG4gICAqIFRoZSBpbnRlbnQgb2YgdGhpcyBtb2R1bGUgaXMgdG8gaW50ZXJvcGVyYXRlIHdpdGggT3BlblNTTCBvbmx5LFxuICAgKiBzcGVjaWZpY2FsbHkgdGhlIG5vZGUgY3J5cHRvIG1vZHVsZSdzIGB2ZXJpZnlgIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBhbiBPcGVuU1NIIHB1YmxpYyBrZXkuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gUEVNIGVuY29kZWQgZm9ybSBvZiB0aGUgUlNBIHB1YmxpYyBrZXkuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gb24gYmFkIGlucHV0LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gb24gaW52YWxpZCBzc2gga2V5IGZvcm1hdHRlZCBkYXRhLlxuICAgKi9cbiAgc3NoS2V5VG9QRU06IGZ1bmN0aW9uIHNzaEtleVRvUEVNKGtleSkge1xuICAgIGFzc2VydC5zdHJpbmcoa2V5LCAnc3NoX2tleScpO1xuXG4gICAgdmFyIGsgPSBzc2hway5wYXJzZUtleShrZXksICdzc2gnKTtcbiAgICByZXR1cm4gKGsudG9TdHJpbmcoJ3BlbScpKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gT3BlblNTSCBmaW5nZXJwcmludCBmcm9tIGFuIHNzaCBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IGFuIE9wZW5TU0ggcHVibGljIGtleS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBrZXkgZmluZ2VycHJpbnQuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gb24gYmFkIGlucHV0LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgd2hhdCB5b3UgcGFzc2VkIGRvZXNuJ3QgbG9vayBsaWtlIGFuIHNzaCBwdWJsaWMga2V5LlxuICAgKi9cbiAgZmluZ2VycHJpbnQ6IGZ1bmN0aW9uIGZpbmdlcnByaW50KGtleSkge1xuICAgIGFzc2VydC5zdHJpbmcoa2V5LCAnc3NoX2tleScpO1xuXG4gICAgdmFyIGsgPSBzc2hway5wYXJzZUtleShrZXksICdzc2gnKTtcbiAgICByZXR1cm4gKGsuZmluZ2VycHJpbnQoJ21kNScpLnRvU3RyaW5nKCdoZXgnKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgUEtHQ1MjOCBQRU0gZmlsZSB0byBhbiBPcGVuU1NIIHB1YmxpYyBrZXkgKHJzYSlcbiAgICpcbiAgICogVGhlIHJldmVyc2Ugb2YgdGhlIGFib3ZlIGZ1bmN0aW9uLlxuICAgKi9cbiAgcGVtVG9Sc2FTU0hLZXk6IGZ1bmN0aW9uIHBlbVRvUnNhU1NIS2V5KHBlbSwgY29tbWVudCkge1xuICAgIGFzc2VydC5lcXVhbCgnc3RyaW5nJywgdHlwZW9mIChwZW0pLCAndHlwZW9mIHBlbScpO1xuXG4gICAgdmFyIGsgPSBzc2hway5wYXJzZUtleShwZW0sICdwZW0nKTtcbiAgICBrLmNvbW1lbnQgPSBjb21tZW50O1xuICAgIHJldHVybiAoay50b1N0cmluZygnc3NoJykpO1xuICB9XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHNzaHBrID0gcmVxdWlyZSgnc3NocGsnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIEhBU0hfQUxHT1MgPSB1dGlscy5IQVNIX0FMR09TO1xudmFyIFBLX0FMR09TID0gdXRpbHMuUEtfQUxHT1M7XG52YXIgSW52YWxpZEFsZ29yaXRobUVycm9yID0gdXRpbHMuSW52YWxpZEFsZ29yaXRobUVycm9yO1xudmFyIEh0dHBTaWduYXR1cmVFcnJvciA9IHV0aWxzLkh0dHBTaWduYXR1cmVFcnJvcjtcbnZhciB2YWxpZGF0ZUFsZ29yaXRobSA9IHV0aWxzLnZhbGlkYXRlQWxnb3JpdGhtO1xuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVmVyaWZ5IFJTQS9EU0Egc2lnbmF0dXJlIGFnYWluc3QgcHVibGljIGtleS4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcGFzcyBpblxuICAgKiBhbiBvYmplY3QgdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSBgcGFyc2UoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWRTaWduYXR1cmUgdGhlIG9iamVjdCB5b3UgZ290IGZyb20gYHBhcnNlYC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YmtleSBSU0EvRFNBIHByaXZhdGUga2V5IFBFTS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHlvdSBwYXNzIGluIGJhZCBhcmd1bWVudHMuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRBbGdvcml0aG1FcnJvcn1cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZTogZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHBhcnNlZFNpZ25hdHVyZSwgcHVia2V5KSB7XG4gICAgYXNzZXJ0Lm9iamVjdChwYXJzZWRTaWduYXR1cmUsICdwYXJzZWRTaWduYXR1cmUnKTtcbiAgICBpZiAodHlwZW9mIChwdWJrZXkpID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIocHVia2V5KSlcbiAgICAgIHB1YmtleSA9IHNzaHBrLnBhcnNlS2V5KHB1YmtleSk7XG4gICAgYXNzZXJ0Lm9rKHNzaHBrLktleS5pc0tleShwdWJrZXksIFsxLCAxXSksICdwdWJrZXkgbXVzdCBiZSBhIHNzaHBrLktleScpO1xuXG4gICAgdmFyIGFsZyA9IHZhbGlkYXRlQWxnb3JpdGhtKHBhcnNlZFNpZ25hdHVyZS5hbGdvcml0aG0pO1xuICAgIGlmIChhbGdbMF0gPT09ICdobWFjJyB8fCBhbGdbMF0gIT09IHB1YmtleS50eXBlKVxuICAgICAgcmV0dXJuIChmYWxzZSk7XG5cbiAgICB2YXIgdiA9IHB1YmtleS5jcmVhdGVWZXJpZnkoYWxnWzFdKTtcbiAgICB2LnVwZGF0ZShwYXJzZWRTaWduYXR1cmUuc2lnbmluZ1N0cmluZyk7XG4gICAgcmV0dXJuICh2LnZlcmlmeShwYXJzZWRTaWduYXR1cmUucGFyYW1zLnNpZ25hdHVyZSwgJ2Jhc2U2NCcpKTtcbiAgfSxcblxuICAvKipcbiAgICogVmVyaWZ5IEhNQUMgYWdhaW5zdCBzaGFyZWQgc2VjcmV0LiAgWW91IGFyZSBleHBlY3RlZCB0byBwYXNzIGluIGFuIG9iamVjdFxuICAgKiB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIGBwYXJzZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZFNpZ25hdHVyZSB0aGUgb2JqZWN0IHlvdSBnb3QgZnJvbSBgcGFyc2VgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VjcmV0IEhNQUMgc2hhcmVkIHNlY3JldC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHlvdSBwYXNzIGluIGJhZCBhcmd1bWVudHMuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRBbGdvcml0aG1FcnJvcn1cbiAgICovXG4gIHZlcmlmeUhNQUM6IGZ1bmN0aW9uIHZlcmlmeUhNQUMocGFyc2VkU2lnbmF0dXJlLCBzZWNyZXQpIHtcbiAgICBhc3NlcnQub2JqZWN0KHBhcnNlZFNpZ25hdHVyZSwgJ3BhcnNlZEhNQUMnKTtcbiAgICBhc3NlcnQuc3RyaW5nKHNlY3JldCwgJ3NlY3JldCcpO1xuXG4gICAgdmFyIGFsZyA9IHZhbGlkYXRlQWxnb3JpdGhtKHBhcnNlZFNpZ25hdHVyZS5hbGdvcml0aG0pO1xuICAgIGlmIChhbGdbMF0gIT09ICdobWFjJylcbiAgICAgIHJldHVybiAoZmFsc2UpO1xuXG4gICAgdmFyIGhhc2hBbGcgPSBhbGdbMV0udG9VcHBlckNhc2UoKTtcblxuICAgIHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaEFsZywgc2VjcmV0KTtcbiAgICBobWFjLnVwZGF0ZShwYXJzZWRTaWduYXR1cmUuc2lnbmluZ1N0cmluZyk7XG5cbiAgICAvKlxuICAgICAqIE5vdyBkb3VibGUtaGFzaCB0byBhdm9pZCBsZWFraW5nIHRpbWluZyBpbmZvcm1hdGlvbiAtIHRoZXJlJ3NcbiAgICAgKiBubyBlYXN5IGNvbnN0YW50LXRpbWUgY29tcGFyZSBpbiBKUywgc28gd2UgdXNlIHRoaXMgYXBwcm9hY2hcbiAgICAgKiBpbnN0ZWFkLiBTZWUgZm9yIG1vcmUgaW5mbzpcbiAgICAgKiBodHRwczovL3d3dy5pc2VjcGFydG5lcnMuY29tL2Jsb2cvMjAxMS9mZWJydWFyeS9kb3VibGUtaG1hYy1cbiAgICAgKiB2ZXJpZmljYXRpb24uYXNweFxuICAgICAqL1xuICAgIHZhciBoMSA9IGNyeXB0by5jcmVhdGVIbWFjKGhhc2hBbGcsIHNlY3JldCk7XG4gICAgaDEudXBkYXRlKGhtYWMuZGlnZXN0KCkpO1xuICAgIGgxID0gaDEuZGlnZXN0KCk7XG4gICAgdmFyIGgyID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaEFsZywgc2VjcmV0KTtcbiAgICBoMi51cGRhdGUobmV3IEJ1ZmZlcihwYXJzZWRTaWduYXR1cmUucGFyYW1zLnNpZ25hdHVyZSwgJ2Jhc2U2NCcpKTtcbiAgICBoMiA9IGgyLmRpZ2VzdCgpO1xuXG4gICAgLyogTm9kZSAwLjggcmV0dXJucyBzdHJpbmdzIGZyb20gLmRpZ2VzdCgpLiAqL1xuICAgIGlmICh0eXBlb2YgKGgxKSA9PT0gJ3N0cmluZycpXG4gICAgICByZXR1cm4gKGgxID09PSBoMik7XG4gICAgLyogQW5kIG5vZGUgMC4xMCBsYWNrcyB0aGUgLmVxdWFscygpIG1ldGhvZCBvbiBCdWZmZXJzLiAqL1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoaDEpICYmICFoMS5lcXVhbHMpXG4gICAgICByZXR1cm4gKGgxLnRvU3RyaW5nKCdiaW5hcnknKSA9PT0gaDIudG9TdHJpbmcoJ2JpbmFyeScpKTtcblxuICAgIHJldHVybiAoaDEuZXF1YWxzKGgyKSk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyAgICAgID0gaXNUeXBlZEFycmF5XG5pc1R5cGVkQXJyYXkuc3RyaWN0ID0gaXNTdHJpY3RUeXBlZEFycmF5XG5pc1R5cGVkQXJyYXkubG9vc2UgID0gaXNMb29zZVR5cGVkQXJyYXlcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xudmFyIG5hbWVzID0ge1xuICAgICdbb2JqZWN0IEludDhBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgSW50MTZBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgSW50MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDhBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzogdHJ1ZVxuICAsICdbb2JqZWN0IFVpbnQxNkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBVaW50MzJBcnJheV0nOiB0cnVlXG4gICwgJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc6IHRydWVcbiAgLCAnW29iamVjdCBGbG9hdDY0QXJyYXldJzogdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkoYXJyKSB7XG4gIHJldHVybiAoXG4gICAgICAgaXNTdHJpY3RUeXBlZEFycmF5KGFycilcbiAgICB8fCBpc0xvb3NlVHlwZWRBcnJheShhcnIpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNTdHJpY3RUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gKFxuICAgICAgIGFyciBpbnN0YW5jZW9mIEludDhBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEludDE2QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBJbnQzMkFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5XG4gICAgfHwgYXJyIGluc3RhbmNlb2YgVWludDE2QXJyYXlcbiAgICB8fCBhcnIgaW5zdGFuY2VvZiBVaW50MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheVxuICAgIHx8IGFyciBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuICApXG59XG5cbmZ1bmN0aW9uIGlzTG9vc2VUeXBlZEFycmF5KGFycikge1xuICByZXR1cm4gbmFtZXNbdG9TdHJpbmcuY2FsbChhcnIpXVxufVxuIiwidmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cblxuZnVuY3Rpb24gaXNTdHJlYW0gKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2Ygc3RyZWFtLlN0cmVhbVxufVxuXG5cbmZ1bmN0aW9uIGlzUmVhZGFibGUgKG9iaikge1xuICByZXR1cm4gaXNTdHJlYW0ob2JqKSAmJiB0eXBlb2Ygb2JqLl9yZWFkID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5fcmVhZGFibGVTdGF0ZSA9PSAnb2JqZWN0J1xufVxuXG5cbmZ1bmN0aW9uIGlzV3JpdGFibGUgKG9iaikge1xuICByZXR1cm4gaXNTdHJlYW0ob2JqKSAmJiB0eXBlb2Ygb2JqLl93cml0ZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouX3dyaXRhYmxlU3RhdGUgPT0gJ29iamVjdCdcbn1cblxuXG5mdW5jdGlvbiBpc0R1cGxleCAob2JqKSB7XG4gIHJldHVybiBpc1JlYWRhYmxlKG9iaikgJiYgaXNXcml0YWJsZShvYmopXG59XG5cblxubW9kdWxlLmV4cG9ydHMgICAgICAgICAgICA9IGlzU3RyZWFtXG5tb2R1bGUuZXhwb3J0cy5pc1JlYWRhYmxlID0gaXNSZWFkYWJsZVxubW9kdWxlLmV4cG9ydHMuaXNXcml0YWJsZSA9IGlzV3JpdGFibGVcbm1vZHVsZS5leHBvcnRzLmlzRHVwbGV4ICAgPSBpc0R1cGxleFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gQXBwbGljYXRpb25Qcm9wZXJ0aWVzQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL2FwcGxpY2F0aW9uLXByb3BlcnRpZXMnXG4gKiBAY29uc3RydWN0b3IgQXBwbGljYXRpb25Qcm9wZXJ0aWVzQ2xpZW50XG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqL1xuZnVuY3Rpb24gQXBwbGljYXRpb25Qcm9wZXJ0aWVzQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBhcHBsaWNhdGlvbiBwcm9wZXJ0eS5cbiAgICAgKiBAbWV0aG9kIGdldFByb3BlcnRpZXNcbiAgICAgKiBAbWVtYmVyT2YgQXBwbGljYXRpb25Qcm9wZXJ0aWVzQ2xpZW50I1xuICAgICAqIEBwYXJhbSBbb3B0c10gVGhlIG9wdGlvbnMgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBbb3B0cy5rZXldIEEgU3RyaW5nIGNvbnRhaW5pbmcgdGhlIHByb3BlcnR5IGtleS5cbiAgICAgKiBAcGFyYW0gW29wdHMucGVybWlzc2lvbkxldmVsXSBXaGVuIGZldGNoaW5nIGEgbGlzdCBzcGVjaWZpZXMgdGhlIHBlcm1pc3Npb24gbGV2ZWwgb2YgYWxsIGl0ZW1zIGluIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSBbb3B0cy5rZXlGaWx0ZXJdIFdoZW4gZmV0Y2hpbmcgYSBsaXN0IGFsbG93cyB0aGUgbGlzdCB0byBiZSBmaWx0ZXJlZCBieSB0aGUgcHJvcGVydHkncyBzdGFydCBvZiBrZXkgZS5nLlxuICAgICAqICAgICBcImppcmEubGYuKlwiIHdob3VsZCBmZXRjaCBvbmx5IHRob3NlIHBlcm1pc3Npb25zIHRoYXQgYXJlIGVkaXRhYmxlIGFuZCB3aG9zZSBrZXlzIHN0YXJ0IHdpdGggXCJqaXJhLmxmLlwiLiBUaGlzXG4gICAgICogICAgIGlzIGEgcmVnZXhcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcHJvcGVydGllcyBhcmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHByb3BlcnRpZXMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHFzID0ge307XG4gICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5rZXkpIHtcbiAgICAgICAgICAgICAgICBxcy5rZXkgPSBvcHRzLmtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmtleUZpbHRlcikge1xuICAgICAgICAgICAgICAgIHFzLmtleUZpbHRlciA9IG9wdHMua2V5RmlsdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMucGVybWlzc2lvbkxldmVsKSB7XG4gICAgICAgICAgICAgICAgcXMua2V5RmlsdGVyID0gb3B0cy5wZXJtaXNzaW9uTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvYXBwbGljYXRpb24tcHJvcGVydGllcycpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiBxc1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgYW4gYXBwbGljYXRpb24gcHJvcGVydHkgdmlhIFBVVC4gVGhlIFwidmFsdWVcIiBmaWVsZCBwcmVzZW50IGluIHRoZSBQVVQgd2lsbCBvdmVycmlkZSB0aGVlIGV4aXN0aW5nIHZhbHVlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRQcm9wZXJ0aWVzXG4gICAgICogQG1lbWJlck9mIEFwcGxpY2F0aW9uUHJvcGVydGllc0NsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgb3B0aW9ucyBmb3IgbW9kaWZ5aW5nIHRoZSBhcHBsaWNhdGlvbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0gb3B0cy5pZCBUaGUgaWQgb2YgdGhlIHByb3BlcnR5IHRvIGJlIG1vZGlmaWVkXG4gICAgICogQHBhcmFtIG9wdHMucHJvcGVydHkgVGhlIG5ldyBkYXRhIGZvciB0aGUgcHJvcGVydHkuICBTZWVcbiAgICAgKiAgICAge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTQ4OTF9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHByb3BlcnR5IGhhcyBiZWVuIG1vZGlmaWVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcHJvcGVydHkgaGFzIGJlZW4gbW9kaWZpZWRcbiAgICAgKi9cbiAgICB0aGlzLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9hcHBsaWNhdGlvbi1wcm9wZXJ0aWVzJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogb3B0cy5wcm9wZXJ0eVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdQcm9wZXJ0eSBVcGRhdGVkJyk7XG4gICAgfTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVycm9yU3RyaW5ncyA9IHJlcXVpcmUoJy4vLi4vbGliL2Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXR0YWNobWVudENsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9hdGFjaG1lbnQnXG4gKlxuICogQGNvbnN0cnVjdG9yIEF0dGFjaG1lbnRDbGllbnRcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICovXG5mdW5jdGlvbiBBdHRhY2htZW50Q2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWV0YS1kYXRhIGZvciBhbiBhdHRhY2htZW50LCBpbmNsdWRpbmcgdGhlIFVSSSBvZiB0aGUgYWN0dWFsIGF0dGFjaGVkIGZpbGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEF0dGFjaG1lbnRcbiAgICAgKiBAbWVtYmVyT2YgQXR0YWNobWVudENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgb3B0aW9ucyBmb3IgdGhlIEFQSSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLmF0dGFjaG1lbnRJZCBUaGUgaWQgb2YgdGhlIGF0dGFjaG1lbnQgdG8gcmV0cmlldmVcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgYXR0YWNobWVudCBtZXRhZGF0YSBpcyByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgYXR0YWNobWVudCBtZXRhZGF0YSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRBdHRhY2htZW50ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5hdHRhY2htZW50SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fQVRUQUNITUVOVF9JRF9FUlJPUik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvYXR0YWNobWVudC8nICsgb3B0cy5hdHRhY2htZW50SWQpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGF0dGFjaG1lbnQgZnJvbSBhbiBpc3N1ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlQXR0YWNobWVudFxuICAgICAqIEBtZW1iZXJPZiBBdHRhY2htZW50Q2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBvcHRpb25zIGZvciB0aGUgQVBJIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdHMuYXR0YWNobWVudElkIFRoZSBpZCBvZiB0aGUgYXR0YWNobWVudCB0byBkZWxldGVcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgYXR0YWNobWVudCBpcyBkZWxldGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGF0dGFjaG1lbnQgaXMgZGVsZXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZUF0dGFjaG1lbnQgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLmF0dGFjaG1lbnRJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19BVFRBQ0hNRU5UX0lEX0VSUk9SKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9hdHRhY2htZW50LycgKyBvcHRzLmF0dGFjaG1lbnRJZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdBdHRhY2htZW50IERlbGV0ZWQnKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXRhIGluZm9ybWF0aW9ucyBmb3IgYW4gYXR0YWNobWVudHMsIHNwZWNpZmljYWxseSBpZiB0aGV5IGFyZSBlbmFibGVkIGFuZCB0aGUgbWF4aW11bSB1cGxvYWQgc2l6ZVxuICAgICAqIGFsbG93ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEdsb2JhbEF0dGFjaG1lbnRNZXRhZGF0YVxuICAgICAqIEBtZW1iZXJPZiBBdHRhY2htZW50Q2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoaXMgQVBJIHJlcXVlc3QgYWN0dWFsbHkgdGFrZXMgbm8gb3B0aW9uczsgdGhpcyBwYXJhbWV0ZXIgaXMgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgbWV0YWRhdGEgaXMgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIG1ldGFkYXRhIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEdsb2JhbEF0dGFjaG1lbnRNZXRhZGF0YSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvYXR0YWNobWVudC9tZXRhJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlcnJvclN0cmluZ3MgPSByZXF1aXJlKCcuLy4uL2xpYi9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1ZGl0aW5nQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL2F1ZGl0aW5nJ1xuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgQXVkaXRpbmdDbGllbnRcbiAqL1xuZnVuY3Rpb24gQXVkaXRpbmdDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGF1ZGl0aW5nIHJlY29yZHMgZmlsdGVyZWQgdXNpbmcgcHJvdmlkZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRBdWRpdHNcbiAgICAgKiBAbWVtYmVyT2YgQXVkaXRpbmdDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIGZpbHRlcmluZyBvcHRpb25zIGZvciByZXRyaWV2aW5nIGF1ZGl0cy5cbiAgICAgKiBAcGFyYW0gW29wdHMub2Zmc2V0XSBUaGUgbnVtYmVyIG9mIHJlY29yZCBmcm9tIHdoaWNoIHNlYXJjaCBzdGFydHNcbiAgICAgKiBAcGFyYW0gW29wdHMubGltaXRdIE1heGltdW0gbnVtYmVyIG9mIHJldHVybmVkIHJlc3VsdHMgKGlmIGlzIGxpbWl0IGlzIDw9IDAgb3IgPiAxMDAwLCBpdCB3aWxsIGJlIHNldCBkbyBkZWZhdWx0XG4gICAgICogICAgIHZhbHVlOiAxMDAwKVxuICAgICAqIEBwYXJhbSBbb3B0cy5maWx0ZXJdIFRleHQgcXVlcnk7IGVhY2ggcmVjb3JkIHRoYXQgd2lsbCBiZSByZXR1cm5lZCBtdXN0IGNvbnRhaW4gdGhlIHByb3ZpZGVkIHRleHQgaW4gb25lIG9mIGl0c1xuICAgICAqICAgICBmaWVsZHNcbiAgICAgKiBAcGFyYW0gW29wdHMuZnJvbV0gVGltZXN0YW1wIGluIHBhc3Q7ICdmcm9tJyBtdXN0IGJlIGxlc3Mgb3IgZXF1YWwgJ3RvJywgb3RoZXJ3aXNlIHRoZSByZXN1bHQgc2V0IHdpbGwgYmUgZW1wdHlcbiAgICAgKiAgICAgb25seSByZWNvcmRzIHRoYXQgd2hlcmUgY3JlYXRlZCBpbiB0aGUgc2FtZSBtb21lbnQgb3IgYWZ0ZXIgdGhlICdmcm9tJyB0aW1lc3RhbXAgd2lsbCBiZSBwcm92aWRlZCBpblxuICAgICAqICAgICByZXNwb25zZVxuICAgICAqIEBwYXJhbSBbb3B0cy50b10gVGltZXN0YW1wIGluIHBhc3Q7ICdmcm9tJyBtdXN0IGJlIGxlc3Mgb3IgZXF1YWwgJ3RvJywgb3RoZXJ3aXNlIHRoZSByZXN1bHQgc2V0IHdpbGwgYmUgZW1wdHlcbiAgICAgKiAgICAgb25seSByZWNvcmRzIHRoYXQgd2hlcmUgY3JlYXRlZCBpbiB0aGUgc2FtZSBtb21lbnQgb3IgZWFybGllciB0aGFuIHRoZSAndG8nIHRpbWVzdGFtcCB3aWxsIGJlIHByb3ZpZGVkIGluXG4gICAgICogICAgIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGF1ZGl0cyBhcmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGF1ZGl0cyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0QXVkaXRzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9hdWRpdGluZy9yZWNvcmQnKSxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9wdHMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGxpbWl0OiBvcHRzLmxpbWl0LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogb3B0cy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgZnJvbTogb3B0cy5mcm9tLFxuICAgICAgICAgICAgICAgIHRvOiBvcHRzLnRvXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVBdWRpdFxuICAgICAqIEBtZW1iZXJPZiBBdWRpdGluZ0NsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzLmF1ZGl0IFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMjU1N31cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgYXVkaXQgaXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhdWRpdCBpcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlQXVkaXQgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLmF1ZGl0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0FVRElUX0VSUk9SKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9hdWRpdGluZy9yZWNvcmQnKSxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMuYXVkaXRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnQXVkaXQgUmVjb3JkIEFkZGVkJyk7XG4gICAgfTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXV0aC8xL3Nlc3Npb24nXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgVXNlckNsaWVudFxuICovXG5mdW5jdGlvbiBBdXRoQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogTG9ncyB0aGUgY3VycmVudCB1c2VyIG91dCBvZiBKSVJBLCBkZXN0cm95aW5nIHRoZSBleGlzdGluZyBzZXNzaW9uLCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGxvZ291dFxuICAgICAqIEBtZW1iZXJPZiBBdXRoI1xuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBiZWVuIGxvZ2dlZCBvdXQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgdXNlciBoYXMgYmVlbiBsb2dnZWQgb3V0LlxuICAgICAqL1xuICAgIHRoaXMubG9nb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRBdXRoVVJMKCcvc2Vzc2lvbicpLFxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKSwgJ1VzZXIgbG9nZ2VkIG91dC4nO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNlc3Npb24gZm9yIGEgdXNlciBpbiBKSVJBLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBsb2dpblxuICAgICAqIEBtZW1iZXJPZiBBdXRoI1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy51c2VybmFtZSBUaGUgbmFtZSBvZiB0aGUgdXNlciB0byBsb2dpbi5cbiAgICAgKiBAcGFyYW0gb3B0cy5wYXNzd29yZCBUaGUgcGFzc3dvcmQgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHVzZXIgaGFzIGJlZW4gbG9nZ2VkIGluLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHVzZXIgaGFzIGJlZW4gbG9nZ2VkIGluLlxuICAgICAqL1xuICAgIHRoaXMubG9naW4gPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEF1dGhVUkwoJy9zZXNzaW9uJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBvcHRzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ1VzZXIgbG9nZ2VkIGluLicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBVc2VyLiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50bHkgYXV0aGVudGljYXRlZCB1c2VyJ3Mgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3VycmVudFVzZXJcbiAgICAgKiBAbWVtYmVyT2YgQXV0aCNcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgY3VycmVudCB1c2VyIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB1c2VyIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRVc2VyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9zZXNzaW9uJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBlcnJvclN0cmluZ3MgPSByZXF1aXJlKCcuLy4uL2xpYi9lcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF2YXRhckNsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9hdmF0YXInXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBBdmF0YXJDbGllbnRcbiAqL1xuZnVuY3Rpb24gQXZhdGFyQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgc3lzdGVtIGF2YXRhcnMgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEF2YXRhcnNcbiAgICAgKiBAbWVtYmVyT2YgQXZhdGFyQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBvcHRpb25zIHRvIGJlIHVzZWQgaW4gdGhlIEFQSSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLmF2YXRhclR5cGUgVGhlIGF2YXRhciB0eXBlLiAgTWF5IGJlICdwcm9qZWN0JyBvciAndXNlcicuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGF2YXRhcnMgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhdmF0YXJzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRBdmF0YXJzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5hdmF0YXJUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0FWQVRBUl9UWVBFX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9hdmF0YXIvJyArIG9wdHMuYXZhdGFyVHlwZSArICcvc3lzdGVtJylcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRlbXBvcmFyeSBhdmF0YXIuICBUaGlzIGZ1bmN0aW9uIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIHRoZSB3YXkgdGhlIEppcmEgQVBJIGRlc2NyaWJlcywgc28gZm9yIG5vd1xuICAgICAqIGp1c3QgZG9uJ3QgdXNlIGl0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVUZW1wb3JhcnlBdmF0YXJcbiAgICAgKiBAbWVtYmVyT2YgQXZhdGFyQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBvcHRpb25zIHRvIGJlIHVzZWQgaW4gdGhlIEFQSSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLmF2YXRhclR5cGUgVGhlIGF2YXRhciB0eXBlLiAgTWF5IGJlICdwcm9qZWN0JyBvciAndXNlcicuXG4gICAgICogQHBhcmFtIG9wdHMuYXZhdGFyRmlsZW5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgYmVpbmcgdXBsb2FkZWRcbiAgICAgKiBAcGFyYW0gb3B0cy5hdmF0YXJGaWxlU2l6ZSBUaGUgc2l6ZSBvZiB0aGUgZmlsZVxuICAgICAqIEBwYXJhbSBvcHRzLmF2YXRhckZpbGVQYXRoIFRoZSBwYXRoIHRvIHRoZSBhdmF0YXIgZmlsZS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgYXZhdGFyIGlzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgYXZhdGFyIGlzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVUZW1wb3JhcnlBdmF0YXIgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLmF2YXRhclR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fQVZBVEFSX1RZUEVfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaXplID0gZnMuc3RhdFN5bmMob3B0cy5hdmF0YXJGaWxlUGF0aCkuc2l6ZTtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXRoLmJhc2VuYW1lKG9wdHMuYXZhdGFyRmlsZVBhdGgpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvYXZhdGFyLycgKyBvcHRzLmF2YXRhclR5cGUgKyAnL3RlbXBvcmFyeScpLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiWC1BdGxhc3NpYW4tVG9rZW5cIjogXCJuby1jaGVja1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybURhdGE6IHtcbiAgICAgICAgICAgICAgICBmaWxlOiBmcy5jcmVhdGVSZWFkU3RyZWFtKG9wdHMuYXZhdGFyRmlsZVBhdGgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmJvZHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNyb3BwaW5nIGluc3RydWN0aW9ucyBvZiB0aGUgdGVtcG9yYXJ5IGF2YXRhci4gIFRoaXMgZnVuY3Rpb24gZG9lc24ndCBzZWVtIHRvIHdvcmsgdGhlIHdheSB0aGUgSmlyYVxuICAgICAqIEFQSSBkZXNjcmliZXMsIHNvIGZvciBub3cganVzdCBkb24ndCB1c2UgaXQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNyb3BUZW1wb3JhcnlBdmF0YXJcbiAgICAgKiBAbWVtYmVyT2YgQXZhdGFyQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIGJlIHVzZWQgaW4gdGhlIEFQSSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmF2YXRhclR5cGUgVGhlIGF2YXRhciB0eXBlLiAgTWF5IGJlICdwcm9qZWN0JyBvciAndXNlcicuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY3JvcCBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTMzMTZ9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGF2YXRhciBoYXMgYmVlbiBjcm9wcGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGF2YXRhciBoYXMgYmVlbiBjcm9wcGVkLlxuICAgICAqL1xuICAgIHRoaXMuY3JvcFRlbXBvcmFyeUF2YXRhciA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMuYXZhdGFyVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19BVkFUQVJfVFlQRV9FUlJPUik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvYXZhdGFyLycgKyBvcHRzLmF2YXRhclR5cGUgKyAnL3RlbXBvcmFyeUNyb3AnKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIlgtQXRsYXNzaWFuLVRva2VuXCI6IFwibm8tY2hlY2tcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMuY3JvcFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gQWdpbGVCb2FyZENsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hZ2lsZS8xLjAvZGFzaGJvYXJkJ1xuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgQWdpbGVCb2FyZENsaWVudFxuICovXG5mdW5jdGlvbiBBZ2lsZUJvYXJkQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwgZGFzaGJvYXJkcywgb3B0aW9uYWxseSBmaWx0ZXJpbmcgdGhlbS5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRBbGxCb2FyZHNcbiAgICogQG1lbWJlck9mIEFnaWxlQm9hcmRDbGllbnQjXG4gICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgdG8gc2VuZCB0byB0aGUgSmlyYSBBUElcbiAgICogQHBhcmFtIFtvcHRzLnR5cGVdIExpbWl0cyByZXR1cm5pbmcgYm9hcmRzIG9mIGEgc3BlY2lmaWMgdHlwZTogYHNjcnVtYCBvciBga2FuYmFuYC5cbiAgICogQHBhcmFtIFtvcHRzLnN0YXJ0QXRdIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGFzaGJvYXJkIHRvIHJldHVybiAoMC1iYXNlZCkuIG11c3QgYmUgMCBvciBhIG11bHRpcGxlIG9mXG4gICAqICAgICBtYXhSZXN1bHRzXG4gICAqIEBwYXJhbSBbb3B0cy5uYW1lXSBGaWx0ZXJzIHJlc3VsdHMgdG8gYm9hcmRzIHRoYXQgbWF0Y2ggb3IgcGFydGlhbGx5IG1hdGNoIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICogQHBhcmFtIFtvcHRzLnByb2plY3RLZXlPcklkXSBGaWx0ZXJzIHJlc3VsdHMgdG8gYm9hcmRzIHRoYXQgYXJlIHJlbGV2YW50IHRvIGEgcHJvamVjdC4gUmVsZXZhbmNlIG1lYW5pbmcgdGhhdFxuICAgKiAgICAgdGhlIGpxbCBmaWx0ZXIgZGVmaW5lZCBpbiBib2FyZCBjb250YWlucyBhIHJlZmVyZW5jZSB0byBhIHByb2plY3QuXG4gICAqIEBwYXJhbSBbb3B0cy5tYXhSZXN1bHRzXSBBIGhpbnQgYXMgdG8gdGhlIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkYXNoYm9hcmRzIHRvIHJldHVybiBpbiBlYWNoIGNhbGwuIE5vdGUgdGhhdCB0aGVcbiAgICogICAgIEpJUkEgc2VydmVyIHJlc2VydmVzIHRoZSByaWdodCB0byBpbXBvc2UgYSBtYXhSZXN1bHRzIGxpbWl0IHRoYXQgaXMgbG93ZXIgdGhhbiB0aGUgdmFsdWUgdGhhdCBhIGNsaWVudFxuICAgKiAgICAgcHJvdmlkZXMsIGR1ZXMgdG8gbGFjayBvciByZXNvdXJjZXMgb3IgYW55IG90aGVyIGNvbmRpdGlvbi4gV2hlbiB0aGlzIGhhcHBlbnMsIHlvdXIgcmVzdWx0cyB3aWxsIGJlXG4gICAqICAgICB0cnVuY2F0ZWQuIENhbGxlcnMgc2hvdWxkIGFsd2F5cyBjaGVjayB0aGUgcmV0dXJuZWQgbWF4UmVzdWx0cyB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIHRoYXQgaXMgZWZmZWN0aXZlbHlcbiAgICogICAgIGJlaW5nIHVzZWQuXG4gICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBkYXNoYm9hcmRzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGRhc2hib2FyZHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICovXG4gIHRoaXMuZ2V0QWxsQm9hcmRzID0gZnVuY3Rpb24ob3B0cywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkQWdpbGVVUkwoXCIvYm9hcmRcIiksXG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBqc29uOiB0cnVlLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgcXM6IHtcbiAgICAgICAgdHlwZTogb3B0cy50eXBlLFxuICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgcHJvamVjdEtleU9ySWQ6IG9wdHMucHJvamVjdEtleU9ySWQsXG4gICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0c1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgc2luZ2xlIGFnaWxlIGJvYXJkLlxuICAgKlxuICAgKiBAbWV0aG9kIGdldEJvYXJkXG4gICAqIEBtZW1iZXJPZiBBZ2lsZUJvYXJkQ2xpZW50I1xuICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgKiBAcGFyYW0gb3B0cy5ib2FyZElkIFRoZSBhZ2lsZSBib2FyZCBpZC5cbiAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGRhc2hib2FyZCBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgZGFzaGJvYXJkIGhhcyBiZWVuIHJldHJpZXZlZFxuICAgKi9cbiAgdGhpcy5nZXRCb2FyZCA9IGZ1bmN0aW9uKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEFnaWxlVVJMKFwiL2JvYXJkL1wiICsgb3B0cy5ib2FyZElkKSxcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICBxczoge1xuICAgICAgICBmaWx0ZXI6IG9wdHMuZmlsdGVyLFxuICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0c1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwgaXNzdWVzIGFzc29jaWF0ZWQgd2l0aCBhbiBhZ2lsZSBib2FyZFxuICAgKlxuICAgKiBAbWV0aG9kIGdldElzc3Vlc0ZvckJvYXJkXG4gICAqIEBtZW1iZXJPZiBBZ2lsZUJvYXJkQ2xpZW50I1xuICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHRvIHNlbmQgdG8gdGhlIEppcmEgQVBJXG4gICAqIEBwYXJhbSBvcHRzLmJvYXJkSWQgVGhlIGFnaWxlIGJvYXJkIGlkLlxuICAgKiBAcGFyYW0gW29wdHMuc3RhcnRBdF0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpc3N1ZSB0byByZXR1cm4gKDAtYmFzZWQpLiBtdXN0IGJlIDAgb3IgYSBtdWx0aXBsZSBvZlxuICAgKiAgICAgbWF4UmVzdWx0c1xuICAgKiBAcGFyYW0gW29wdHMubWF4UmVzdWx0c10gQSBoaW50IGFzIHRvIHRoZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgaXNzdWVzIHRvIHJldHVybiBpbiBlYWNoIGNhbGwuIE5vdGUgdGhhdCB0aGVcbiAgICogICAgIEpJUkEgc2VydmVyIHJlc2VydmVzIHRoZSByaWdodCB0byBpbXBvc2UgYSBtYXhSZXN1bHRzIGxpbWl0IHRoYXQgaXMgbG93ZXIgdGhhbiB0aGUgdmFsdWUgdGhhdCBhIGNsaWVudFxuICAgKiAgICAgcHJvdmlkZXMsIGR1ZXMgdG8gbGFjayBvciByZXNvdXJjZXMgb3IgYW55IG90aGVyIGNvbmRpdGlvbi4gV2hlbiB0aGlzIGhhcHBlbnMsIHlvdXIgcmVzdWx0cyB3aWxsIGJlXG4gICAqICAgICB0cnVuY2F0ZWQuIENhbGxlcnMgc2hvdWxkIGFsd2F5cyBjaGVjayB0aGUgcmV0dXJuZWQgbWF4UmVzdWx0cyB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIHRoYXQgaXMgZWZmZWN0aXZlbHlcbiAgICogICAgIGJlaW5nIHVzZWQuXG4gICAqIEBwYXJhbSBbb3B0cy5qcWxdIEZpbHRlcnMgcmVzdWx0cyB1c2luZyBhIEpRTCBxdWVyeS4gSWYgeW91IGRlZmluZSBhbiBvcmRlciBpbiB5b3VyIEpRTCBxdWVyeSwgaXQgd2lsbCBvdmVycmlkZVxuICAgKiAgICAgdGhlIGRlZmF1bHQgb3JkZXIgb2YgdGhlIHJldHVybmVkIGlzc3Vlcy4gTm90ZSB0aGF0IHVzZXJuYW1lIGFuZCB1c2Vya2V5IGhhdmUgYmVlbiBkZXByZWNhdGVkIGFzIHNlYXJjaCB0ZXJtc1xuICAgKiAgICAgZm9yIHRoaXMgcGFyYW1ldGVyLiBTZWUgdGhlIG1pZ3JhdGlvbiBndWlkZSBmb3IgZGV0YWlscy4gVXNlIGFjY291bnRJZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0gW29wdHMuZmllbGRzXSBUaGUgbGlzdCBvZiBmaWVsZHMgdG8gcmV0dXJuIGZvciBlYWNoIGlzc3VlLiBCeSBkZWZhdWx0LCBhbGwgbmF2aWdhYmxlIGFuZCBBZ2lsZSBmaWVsZHMgYXJlXG4gICAqICAgICByZXR1cm5lZC5cbiAgICogQHBhcmFtIFtvcHRzLmV4cGFuZF0gVGhlIHBhcmFtZXRlcnMgdG8gZXhwYW5kXG4gICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBpc3N1ZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgaXNzdWVzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAqL1xuICB0aGlzLmdldElzc3Vlc0ZvckJvYXJkID0gZnVuY3Rpb24ob3B0cywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkQWdpbGVVUkwoXCIvYm9hcmQvXCIgKyBvcHRzLmJvYXJkSWQgKyBcIi9pc3N1ZVwiKSxcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICBxczoge1xuICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0cyxcbiAgICAgICAganFsOiBvcHRzLmpxbCxcbiAgICAgICAgZmllbGRzOiBvcHRzLmZpZWxkcy5qb2luKCcsJyksXG4gICAgICAgIGV4cGFuZDogb3B0cy5leHBhbmRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2Ygc3ByaW50cyBhc3NvY2lhdGVkIHdpdGggYW4gYWdpbGUgYm9hcmRcbiAgICpcbiAgICogQG1ldGhvZCBnZXRTcHJpbnRzRm9yQm9hcmRcbiAgICogQG1lbWJlck9mIEFnaWxlQm9hcmRDbGllbnQjXG4gICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgdG8gc2VuZCB0byB0aGUgSmlyYSBBUElcbiAgICogQHBhcmFtIG9wdHMuYm9hcmRJZCBUaGUgYWdpbGUgYm9hcmQgaWQuXG4gICAqIEBwYXJhbSBbb3B0cy5zdGFydEF0XSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IHNwcmludCB0byByZXR1cm4gKDAtYmFzZWQpLiBtdXN0IGJlIDAgb3IgYSBtdWx0aXBsZSBvZlxuICAgKiAgICAgbWF4UmVzdWx0c1xuICAgKiBAcGFyYW0gW29wdHMubWF4UmVzdWx0c10gQSBoaW50IGFzIHRvIHRoZSB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3ByaW50cyB0byByZXR1cm4gaW4gZWFjaCBjYWxsLiBOb3RlIHRoYXQgdGhlXG4gICAqICAgICBKSVJBIHNlcnZlciByZXNlcnZlcyB0aGUgcmlnaHQgdG8gaW1wb3NlIGEgbWF4UmVzdWx0cyBsaW1pdCB0aGF0IGlzIGxvd2VyIHRoYW4gdGhlIHZhbHVlIHRoYXQgYSBjbGllbnRcbiAgICogICAgIHByb3ZpZGVzLCBkdWVzIHRvIGxhY2sgb3IgcmVzb3VyY2VzIG9yIGFueSBvdGhlciBjb25kaXRpb24uIFdoZW4gdGhpcyBoYXBwZW5zLCB5b3VyIHJlc3VsdHMgd2lsbCBiZVxuICAgKiAgICAgdHJ1bmNhdGVkLiBDYWxsZXJzIHNob3VsZCBhbHdheXMgY2hlY2sgdGhlIHJldHVybmVkIG1heFJlc3VsdHMgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSB0aGF0IGlzIGVmZmVjdGl2ZWx5XG4gICAqICAgICBiZWluZyB1c2VkLlxuICAgKiBAcGFyYW0gW29wdHMuc3RhdGVdIE9wdGlvbmFsbHkgZmlsdGVyIGJ5IHN0YXRlLCBlLmcuICdhY3RpdmUnLlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gdGhlIHNwcmludHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc3ByaW50cyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgKi9cbiAgdGhpcy5nZXRTcHJpbnRzRm9yQm9hcmQgPSBmdW5jdGlvbihvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRBZ2lsZVVSTChcIi9ib2FyZC9cIiArIG9wdHMuYm9hcmRJZCArIFwiL3NwcmludFwiKSxcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICBxczoge1xuICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0cyxcbiAgICAgICAgc3RhdGU6IG9wdHMuc3RhdGVcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgYWxsIGlzc3VlcyBmcm9tIHRoZSBib2FyZCdzIGJhY2tsb2csIGZvciB0aGUgZ2l2ZW4gYm9hcmQgSWQuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0SXNzdWVzRm9yQmFja2xvZ1xuICAgKiBAbWVtYmVyT2YgQWdpbGVCb2FyZENsaWVudCNcbiAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyB0byBzZW5kIHRvIHRoZSBKaXJhIEFQSVxuICAgKiBAcGFyYW0gb3B0cy5ib2FyZElkIFRoZSBhZ2lsZSBib2FyZCBpZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGpxbCBGaWx0ZXJzIHJlc3VsdHMgdXNpbmcgYSBKUUwgcXVlcnkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsaWRhdGVRdWVyeSBTcGVjaWZpZXMgd2hldGhlciB0byB2YWxpZGUgdGhlIEpRTCBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkcyBUaGUgbGlzdCBvZiBmaWVsZHMgdG8gcmV0dXJuIGZvciBlYWNoIGlzc3VlLlxuICAgKiBAcGFyYW0gW29wdHMuc3RhcnRBdF0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXNoYm9hcmQgdG8gcmV0dXJuICgwLWJhc2VkKS4gbXVzdCBiZSAwIG9yIGEgbXVsdGlwbGUgb2ZcbiAgICogICAgIG1heFJlc3VsdHNcbiAgICogQHBhcmFtIFtvcHRzLm1heFJlc3VsdHNdIEEgaGludCBhcyB0byB0aGUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGlzc3VlcyB0byByZXR1cm4gaW4gZWFjaCBjYWxsLiBOb3RlIHRoYXQgdGhlXG4gICAqICAgICBKSVJBIHNlcnZlciByZXNlcnZlcyB0aGUgcmlnaHQgdG8gaW1wb3NlIGEgbWF4UmVzdWx0cyBsaW1pdCB0aGF0IGlzIGxvd2VyIHRoYW4gdGhlIHZhbHVlIHRoYXQgYSBjbGllbnRcbiAgICogICAgIHByb3ZpZGVzLCBkdWVzIHRvIGxhY2sgb3IgcmVzb3VyY2VzIG9yIGFueSBvdGhlciBjb25kaXRpb24uIFdoZW4gdGhpcyBoYXBwZW5zLCB5b3VyIHJlc3VsdHMgd2lsbCBiZVxuICAgKiAgICAgdHJ1bmNhdGVkLiBDYWxsZXJzIHNob3VsZCBhbHdheXMgY2hlY2sgdGhlIHJldHVybmVkIG1heFJlc3VsdHMgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSB0aGF0IGlzIGVmZmVjdGl2ZWx5XG4gICAqICAgICBiZWluZyB1c2VkLlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgYmFja2xvZyBpc3N1ZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgYmFja2xvZyBpc3N1ZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICovXG4gIHRoaXMuZ2V0SXNzdWVzRm9yQmFja2xvZyA9IGZ1bmN0aW9uKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEFnaWxlVVJMKFwiL2JvYXJkL1wiICsgb3B0cy5ib2FyZElkICsgXCIvYmFja2xvZ1wiKSxcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICBxczoge1xuICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0cyxcbiAgICAgICAganFsOiBvcHRzLmpxbCxcbiAgICAgICAgdmFsaWRhdGVRdWVyeTogb3B0cy52YWxpZGF0ZVF1ZXJ5LFxuICAgICAgICBmaWVsZHM6IG9wdHMuZmllbGRzXG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgY29uZmlndXJhdGlvbiBmb3IgYSBib2FyZFxuICAgKlxuICAgKiBAbWV0aG9kIGdldEJvYXJkQ29uZmlndXJhdGlvblxuICAgKiBAbWVtYmVyT2YgQWdpbGVCb2FyZENsaWVudCNcbiAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyB0byBzZW5kIHRvIHRoZSBKaXJhIEFQSVxuICAgKiBAcGFyYW0gb3B0cy5ib2FyZElkIFRoZSBhZ2lsZSBib2FyZCBpZC5cbiAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGJvYXJkIGNvbmZpZ3VyYXRpb24gaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBib2FyZCBjb25maWd1cmF0aW9uIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICovXG4gIHRoaXMuZ2V0Qm9hcmRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24ob3B0cywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkQWdpbGVVUkwoXG4gICAgICAgIFwiL2JvYXJkL1wiICsgb3B0cy5ib2FyZElkICsgXCIvY29uZmlndXJhdGlvblwiXG4gICAgICApLFxuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGJvYXJkXG4gICAqXG4gICAqIEBtZXRob2QgY3JlYXRlQm9hcmRcbiAgICogQG1lbWJlck9mIEFnaWxlU3ByaW50Q2xpZW50I1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNdXN0IGJlIGxlc3MgdGhhbiAyNTUgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVmFsaWQgdmFsdWVzOiBzY3J1bSwga2FuYmFuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmaWx0ZXJJZCBJRCBvZiBhIGZpbHRlciB0aGF0IHRoZSB1c2VyIGhhcyBwZXJtaXNzaW9ucyB0byB2aWV3LiBOb3RlLCBpZiB0aGVcbiAgICogIHVzZXIgZG9lcyBub3QgaGF2ZSB0aGUgJ0NyZWF0ZSBzaGFyZWQgb2JqZWN0cycgcGVybWlzc2lvbiBhbmQgdHJpZXMgdG8gY3JlYXRlIGEgc2hhcmVkIGJvYXJkLFxuICAgKiAgYSBwcml2YXRlIGJvYXJkIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkIChyZW1lbWJlciB0aGF0IGJvYXJkIHNoYXJpbmcgZGVwZW5kcyBvbiB0aGUgZmlsdGVyIHNoYXJpbmcpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbG9jYXRpb24gVGhlIGNvbnRhaW5lciB0aGF0IHRoZSBib2FyZCB3aWxsIGJlIGxvY2F0ZWQgaW4uIGxvY2F0aW9uIG11c3QgaW5jbHVkZSB0aGVcbiAgICogIHR5cGUgcHJvcGVydHkgKFZhbGlkIHZhbHVlczogcHJvamVjdCwgdXNlcikuIElmIGNob29zaW5nICdwcm9qZWN0JywgdGhlbiBhIHByb2plY3QgbXVzdCBiZSBzcGVjaWZpZWRcbiAgICogIGJ5IGEgcHJvamVjdEtleU9ySWQgcHJvcGVydHkgaW4gbG9jYXRpb24uIElmIGNob29zaW5nICd1c2VyJywgdGhlIGN1cnJlbnQgdXNlciBpcyBjaG9zZW4gYnkgZGVmYXVsdC5cbiAgICogIFRoZSBwcm9qZWN0S2V5T3JJZCBwcm9wZXJ0eSBzaG91bGQgbm90IGJlIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc3ByaW50IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHNwcmludCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgKi9cbiAgdGhpcy5jcmVhdGVCb2FyZCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIGZpbHRlcklkLCBsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkQWdpbGVVUkwoXCIvYm9hcmRcIiksXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgZmlsdGVySWQsXG4gICAgICAgIGxvY2F0aW9uXG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIHByb2plY3RzIGFzc29jaWF0ZWQgYm9hcmRcbiAgICpcbiAgICogQG1ldGhvZCBnZXRQcm9qZWN0c0ZvckJvYXJkXG4gICAqIEBtZW1iZXJPZiBBZ2lsZUJvYXJkQ2xpZW50I1xuICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHRvIHNlbmQgdG8gdGhlIEppcmEgQVBJXG4gICAqIEBwYXJhbSBvcHRzLmJvYXJkSWQgVGhlIGFnaWxlIGJvYXJkIGlkLlxuICAgKiBAcGFyYW0gW29wdHMuc3RhcnRBdF0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzcHJpbnQgdG8gcmV0dXJuICgwLWJhc2VkKS4gbXVzdCBiZSAwIG9yIGEgbXVsdGlwbGUgb2ZcbiAgICogICAgIG1heFJlc3VsdHNcbiAgICogQHBhcmFtIFtvcHRzLm1heFJlc3VsdHNdIEEgaGludCBhcyB0byB0aGUgdGhlIG1heGltdW0gbnVtYmVyIG9mIHNwcmludHMgdG8gcmV0dXJuIGluIGVhY2ggY2FsbC4gTm90ZSB0aGF0IHRoZVxuICAgKiAgICAgSklSQSBzZXJ2ZXIgcmVzZXJ2ZXMgdGhlIHJpZ2h0IHRvIGltcG9zZSBhIG1heFJlc3VsdHMgbGltaXQgdGhhdCBpcyBsb3dlciB0aGFuIHRoZSB2YWx1ZSB0aGF0IGEgY2xpZW50XG4gICAqICAgICBwcm92aWRlcywgZHVlcyB0byBsYWNrIG9yIHJlc291cmNlcyBvciBhbnkgb3RoZXIgY29uZGl0aW9uLiBXaGVuIHRoaXMgaGFwcGVucywgeW91ciByZXN1bHRzIHdpbGwgYmVcbiAgICogICAgIHRydW5jYXRlZC4gQ2FsbGVycyBzaG91bGQgYWx3YXlzIGNoZWNrIHRoZSByZXR1cm5lZCBtYXhSZXN1bHRzIHRvIGRldGVybWluZSB0aGUgdmFsdWUgdGhhdCBpcyBlZmZlY3RpdmVseVxuICAgKiAgICAgYmVpbmcgdXNlZC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxlZCB3aGVuIHRoZSBzcHJpbnRzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHNwcmludHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICovXG4gIHRoaXMuZ2V0UHJvamVjdHNGb3JCb2FyZCA9IGZ1bmN0aW9uKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEFnaWxlVVJMKFwiL2JvYXJkL1wiICsgb3B0cy5ib2FyZElkICsgXCIvcHJvamVjdFwiKSxcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICBxczoge1xuICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0c1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXJyb3JTdHJpbmdzID0gcmVxdWlyZSgnLi8uLi9saWIvZXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50Q2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL2NvbW1lbnQnXG4gKiBAY29uc3RydWN0b3IgQ29tbWVudENsaWVudFxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIENvbW1lbnRDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBrZXlzIG9mIGFsbCBwcm9wZXJ0aWVzIGZvciB0aGUgY29tbWVudCBpZGVudGlmaWVkIGJ5IHRoZSBrZXkgb3IgYnkgdGhlIGlkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDb21tZW50UHJvcGVydHlLZXlzXG4gICAgICogQG1lbWJlck9mIENvbW1lbnRDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIG9wdGlvbnMgcGFzc2VkIGluIHRoZSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMuY29tbWVudElkIFRoZSBpZCBvZiB0aGUgY29tbWVudCBmcm9tIHdoaWNoIGtleXMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUga2V5cyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGtleXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldENvbW1lbnRQcm9wZXJ0eUtleXMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJycsICdHRVQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgY29tbWVudCdzIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgdGhpcyByZXNvdXJjZSB0byBzdG9yZSBhIGN1c3RvbSBkYXRhIGFnYWluc3QgdGhlIGNvbW1lbnQgaWRlbnRpZmllZCBieSB0aGUga2V5IG9yIGJ5IHRoZSBpZC4gVGhlXG4gICAgICogdXNlciB3aG8gc3RvcmVzIHRoZSBkYXRhIGlzIHJlcXVpcmVkIHRvIGhhdmUgcGVybWlzc2lvbnMgdG8gYWRtaW5pc3RlciB0aGUgY29tbWVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0Q29tbWVudFByb3BlcnR5XG4gICAgICogQG1lbWJlck9mIENvbW1lbnRDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIG9wdGlvbnMgcGFzc2VkIGluIHRoZSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMuY29tbWVudElkIFRoZSBpZCBvZiB0aGUgY29tbWVudCBmcm9tIHdoaWNoIGtleXMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gb3B0cy5wcm9wZXJ0eUtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBlZGl0ZWQuXG4gICAgICogQHBhcmFtIG9wdHMucHJvcGVydHlWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcHJvcGVydHkgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHByb3BlcnR5IGhhcyBiZWVuIGVkaXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLnNldENvbW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMucHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fQ09NTUVOVF9QUk9QRVJUWV9LRVlfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLnByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fQ09NTUVOVF9QUk9QRVJUWV9WQUxVRV9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy8nICsgb3B0cy5wcm9wZXJ0eUtleSwgJ1BVVCcsIG9wdHMucHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdQcm9wZXJ0eSBFZGl0ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHdpdGggYSBnaXZlbiBrZXkgZnJvbSB0aGUgY29tbWVudCBpZGVudGlmaWVkIGJ5IHRoZSBrZXkgb3IgYnkgdGhlIGlkLiBUaGUgdXNlclxuICAgICAqIHdobyByZXRyaWV2ZXMgdGhlIHByb3BlcnR5IGlzIHJlcXVpcmVkIHRvIGhhdmUgcGVybWlzc2lvbnMgdG8gcmVhZCB0aGUgY29tbWVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0Q29tbWVudFByb3BlcnR5XG4gICAgICogQG1lbWJlck9mIENvbW1lbnRDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIG9wdGlvbnMgcGFzc2VkIGluIHRoZSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMuY29tbWVudElkIFRoZSBpZCBvZiB0aGUgY29tbWVudCBmcm9tIHdoaWNoIGtleXMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gb3B0cy5wcm9wZXJ0eUtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBlZGl0ZWQuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHByb3BlcnR5IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwcm9wZXJ0eSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRDb21tZW50UHJvcGVydHkgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLnByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0NPTU1FTlRfUFJPUEVSVFlfS0VZX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnLycgKyBvcHRzLnByb3BlcnR5S2V5LCAnR0VUJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBjb21tZW50IGlkZW50aWZpZWQgYnkgdGhlIGtleSBvciBieSB0aGUgaWQuIFRocyB1c2VyIHJlbW92aW5nIHRoZSBwcm9wZXJ0eSBpc1xuICAgICAqIHJlcXVpcmVkIHRvIGhhdmUgcGVybWlzc2lvbnMgdG8gYWRtaW5pc3RlciB0aGUgY29tbWVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlQ29tbWVudFByb3BlcnR5XG4gICAgICogQG1lbWJlck9mIENvbW1lbnRDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIG9wdGlvbnMgcGFzc2VkIGluIHRoZSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMuY29tbWVudElkIFRoZSBpZCBvZiB0aGUgY29tbWVudCBmcm9tIHdoaWNoIGtleXMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gb3B0cy5wcm9wZXJ0eUtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBlZGl0ZWQuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHByb3BlcnR5IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwcm9wZXJ0eSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5kZWxldGVDb21tZW50UHJvcGVydHkgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLnByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0NPTU1FTlRfUFJPUEVSVFlfS0VZX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnLycgKyBvcHRzLnByb3BlcnR5S2V5LCAnREVMRVRFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdDb21tZW50IHByb3BlcnR5IGRlbGV0ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQnVpbGQgb3V0IHRoZSByZXF1ZXN0IG9wdGlvbnMgbmVjZXNzYXJ5IHRvIG1ha2UgYSBwYXJ0aWN1bGFyIEFQSSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJ1aWxkUmVxdWVzdE9wdGlvbnNcbiAgICAgKiBAbWVtYmVyT2YgQ29tbWVudENsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBlbmRwb2ludCBmb2xsb3dpbmcgL2lzc3VlL3tpZE9yS2V5fVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIHJlcXVlc3QgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYm9keV0gVGhlIHJlcXVlc3QgYm9keSwgaWYgYW55LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcXNdIFRoZSBxdWVyeXN0cmluZywgaWYgYW55LiAgb3B0cy5leHBhbmQgYW5kIG9wdHMuZmllbGRzIGFycmF5cyB3aWxsIGJlIGF1dG9tYWdpY2FsbHkgYWRkZWQuXG4gICAgICogQHJldHVybnMge3t1cmk6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcsIGJvZHk6IE9iamVjdCwgcXM6IE9iamVjdCwgZm9sbG93QWxsUmVkaXJlY3RzOiBib29sZWFuLCBqc29uOiBib29sZWFufX1cbiAgICAgKi9cbiAgICB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0cywgcGF0aCwgbWV0aG9kLCBib2R5LCBxcykge1xuICAgICAgICBpZiAoIW9wdHMuY29tbWVudElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0NPTU1FTlRfSUQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlUGF0aCA9ICcvY29tbWVudC8nICsgb3B0cy5jb21tZW50SWQgKyBcIi9wcm9wZXJ0aWVzXCI7XG4gICAgICAgIGlmICghcXMpIHFzID0ge307XG4gICAgICAgIGlmICghYm9keSkgYm9keSA9IHt9O1xuXG4gICAgICAgIGlmIChvcHRzLmZpZWxkcykge1xuICAgICAgICAgICAgcXMuZmllbGRzID0gJyc7XG4gICAgICAgICAgICBvcHRzLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIHFzLmZpZWxkcyArPSBmaWVsZCArICcsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5leHBhbmQpIHtcbiAgICAgICAgICAgIHFzLmV4cGFuZCA9ICcnO1xuICAgICAgICAgICAgb3B0cy5leHBhbmQuZm9yRWFjaChmdW5jdGlvbiAoZXgpIHtcbiAgICAgICAgICAgICAgICBxcy5leHBhbmQgKz0gZXggKyAnLCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKGJhc2VQYXRoICsgcGF0aCksXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBxczogcXMsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBqc29uOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudENsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9jb21wb25lbnQnXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgQ29tcG9uZW50Q2xpZW50XG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudENsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbXBvbmVudCB2aWEgUE9TVC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlQ29tcG9uZW50XG4gICAgICogQG1lbWJlck9mIENvbXBvbmVudENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIG9wdHMuY29tcG9uZW50IFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMzg3MX1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2NvbXBvbmVudCcpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogb3B0cy5jb21wb25lbnRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IGEgY29tcG9uZW50IHZpYSBQVVQuIEFueSBmaWVsZHMgcHJlc2VudCBpbiB0aGUgUFVUIHdpbGwgb3ZlcnJpZGUgZXhpc3RpbmcgdmFsdWVzLiBBcyBhIGNvbnZlbmllbmNlLCBpZiBhXG4gICAgICogZmllbGQgaXMgbm90IHByZXNlbnQsIGl0IGlzIHNpbGVudGx5IGlnbm9yZWQuIElmIGxlYWRVc2VyTmFtZSBpcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIHRoZSBjb21wb25lbnQgbGVhZCB3aWxsIGJlXG4gICAgICogcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZWRpdENvbXBvbmVudFxuICAgICAqIEBtZW1iZXJPZiBDb21wb25lbnRDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy5pZCBUaGUgaWQgb2YgdGhlIGNvbXBvbmVudCB0byBlZGl0LlxuICAgICAqIEBwYXJhbSBvcHRzLmNvbXBvbmVudCBUaGUgbmV3IGRhdGEgdG8gcGxhY2UgaW4gdGhlIGNvbXBvbmVudC4gIFNlZVxuICAgICAqICAgICAge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTM5Mzl9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlZCBlZGl0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVkIGVkaXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmVkaXRDb21wb25lbnQgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2NvbXBvbmVudC8nICsgb3B0cy5pZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMuY29tcG9uZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHByb2plY3QgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDb21wb25lbnRcbiAgICAgKiBAbWVtYmVyT2YgQ29tcG9uZW50Q2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIG9wdHMuaWQgVGhlIGlkIG9mIHRoZSBjb21wb25lbnQgdG8gZWRpdC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9jb21wb25lbnQvJyArIG9wdHMuaWQpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcHJvamVjdCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlbGV0ZUNvbXBvbmVudFxuICAgICAqIEBtZW1iZXJPZiBDb21wb25lbnRDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy5pZCBUaGUgaWQgb2YgdGhlIGNvbXBvbmVudCB0byBlZGl0LlxuICAgICAqIEBwYXJhbSBbb3B0cy5tb3ZlSXNzdWVzVG9dIFRoZSBuZXcgY29tcG9uZW50IGFwcGxpZWQgdG8gaXNzdWVzIHdob3NlICdpZCcgY29tcG9uZW50IHdpbGwgYmUgZGVsZXRlZC4gSWYgdGhpc1xuICAgICAqICAgICB2YWx1ZSBpcyBudWxsLCB0aGVuIHRoZSAnaWQnIGNvbXBvbmVudCBpcyBzaW1wbHkgcmVtb3ZlZCBmcm9tIHRoZSByZWxhdGVkIGlzdWVzLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvY29tcG9uZW50LycgKyBvcHRzLmlkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ1Byb2plY3QgQ29tcG9uZW50IERlbGV0ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNvdW50cyBvZiBpc3N1ZXMgcmVsYXRlZCB0byB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0UmVsYXRlZElzc3VlQ291bnRzXG4gICAgICogQG1lbWJlck9mIENvbXBvbmVudENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLmlkIFRoZSBpZCBvZiB0aGUgY29tcG9uZW50IHRvIGVkaXQuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGNvdW50IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBjb3VudCBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRSZWxhdGVkSXNzdWVDb3VudHMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2NvbXBvbmVudC8nICsgb3B0cy5pZCArICcvcmVsYXRlZElzc3VlQ291bnRzJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVycm9yU3RyaW5ncyA9IHJlcXVpcmUoJy4vLi4vbGliL2Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ3VzdG9tRmllbGRPcHRpb25DbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvY3VzdG9tRmllbGRPcHRpb25zJ1xuICpcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIEN1c3RvbUZpZWxkT3B0aW9uQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIEN1c3RvbUZpZWxkT3B0aW9uQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bGwgcmVwcmVzZW50YXRpb24gb2YgdGhlIEN1c3RvbSBGaWVsZCBPcHRpb24gdGhhdCBoYXMgdGhlIGdpdmVuIGlkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDdXN0b21GaWVsZE9wdGlvblxuICAgICAqIEBtZW1iZXJPZiBDdXN0b21GaWVsZE9wdGlvbkNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZmllbGRPcHRpb25JZCBBIFN0cmluZyBjb250YWluaW5nIGFuIEN1c3RvbSBGaWVsZCBPcHRpb24gaWRcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiBkYXRhIGhhcyBiZWVuIHJldHJpZXZlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gZGF0YSBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICAgKi9cbiAgICB0aGlzLmdldEN1c3RvbUZpZWxkT3B0aW9uID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5maWVsZE9wdGlvbklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0ZJRUxEX09QVElPTl9JRF9FUlJPUik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvY3VzdG9tRmllbGRPcHRpb24vJyArIG9wdHMuZmllbGRPcHRpb25JZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gRGFzaGJvYXJkQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL2Rhc2hib2FyZCdcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIERhc2hib2FyZENsaWVudFxuICovXG5mdW5jdGlvbiBEYXNoYm9hcmRDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIGFsbCBkYXNoYm9hcmRzLCBvcHRpb25hbGx5IGZpbHRlcmluZyB0aGVtLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRBbGxEYXNoYm9hcmRzXG4gICAgICogQG1lbWJlck9mIERhc2hib2FyZENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHRvIHNlbmQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIFtvcHRzLmZpbHRlcl0gQW4gb3B0aW9uYWwgZmlsdGVyIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgbGlzdCBvZiBkYXNoYm9hcmRzLiBWYWxpZCB2YWx1ZXMgaW5jbHVkZVxuICAgICAqICAgICBcImZhdm91cml0ZVwiIGZvciByZXR1cm5pbmcgb25seSBmYXZvdXJpdGUgZGFzaGJvYXJkcywgYW5kIFwibXlcIiBmb3IgcmV0dXJuaW5nIGRhc2hib2FyZHMgdGhhdCBhcmUgb3duZWQgYnkgdGhlXG4gICAgICogICAgIGNhbGxpbmcgdXNlci5cbiAgICAgKiBAcGFyYW0gW29wdHMuc3RhcnRBdF0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXNoYm9hcmQgdG8gcmV0dXJuICgwLWJhc2VkKS4gbXVzdCBiZSAwIG9yIGEgbXVsdGlwbGUgb2ZcbiAgICAgKiAgICAgbWF4UmVzdWx0c1xuICAgICAqIEBwYXJhbSBbb3B0cy5tYXhSZXN1bHRzXSBBIGhpbnQgYXMgdG8gdGhlIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkYXNoYm9hcmRzIHRvIHJldHVybiBpbiBlYWNoIGNhbGwuIE5vdGUgdGhhdCB0aGVcbiAgICAgKiAgICAgSklSQSBzZXJ2ZXIgcmVzZXJ2ZXMgdGhlIHJpZ2h0IHRvIGltcG9zZSBhIG1heFJlc3VsdHMgbGltaXQgdGhhdCBpcyBsb3dlciB0aGFuIHRoZSB2YWx1ZSB0aGF0IGEgY2xpZW50XG4gICAgICogICAgIHByb3ZpZGVzLCBkdWVzIHRvIGxhY2sgb3IgcmVzb3VyY2VzIG9yIGFueSBvdGhlciBjb25kaXRpb24uIFdoZW4gdGhpcyBoYXBwZW5zLCB5b3VyIHJlc3VsdHMgd2lsbCBiZVxuICAgICAqICAgICB0cnVuY2F0ZWQuIENhbGxlcnMgc2hvdWxkIGFsd2F5cyBjaGVjayB0aGUgcmV0dXJuZWQgbWF4UmVzdWx0cyB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIHRoYXQgaXMgZWZmZWN0aXZlbHlcbiAgICAgKiAgICAgYmVpbmcgdXNlZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgZGFzaGJvYXJkcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGRhc2hib2FyZHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEFsbERhc2hib2FyZHMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2Rhc2hib2FyZCcpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogb3B0cy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgc3RhcnRBdDogb3B0cy5zdGFydEF0LFxuICAgICAgICAgICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0c1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaW5nbGUgZGFzaGJvYXJkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXREYXNoYm9hcmRcbiAgICAgKiBAbWVtYmVyT2YgRGFzaGJvYXJkQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMuZGFzaGJvYXJkSWQgVGhlIGRhc2hib2FyZCBpZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgZGFzaGJvYXJkIGhhcyBiZWVuIHJldHJpZXZlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGRhc2hib2FyZCBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICAgKi9cbiAgICB0aGlzLmdldERhc2hib2FyZCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvZGFzaGJvYXJkLycgKyBvcHRzLmRhc2hib2FyZElkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IG9wdHMuZmlsdGVyLFxuICAgICAgICAgICAgICAgIHN0YXJ0QXQ6IG9wdHMuc3RhcnRBdCxcbiAgICAgICAgICAgICAgICBtYXhSZXN1bHRzOiBvcHRzLm1heFJlc3VsdHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gRmllbGRDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvZmllbGQnXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgRmllbGRDbGllbnRcbiAqL1xuZnVuY3Rpb24gRmllbGRDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgZmllbGRzLCBib3RoIFN5c3RlbSBhbmQgQ3VzdG9tXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEFsbEZpZWxkc1xuICAgICAqIEBtZW1iZXJPZiBGaWVsZENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBJZ25vcmVkXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGZpZWxkcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGZpZWxkcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0QWxsRmllbGRzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9maWVsZCcpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGN1c3RvbSBmaWVsZCB1c2luZyBhIGRlZmluaXRpb24gKG9iamVjdCBlbmNhcHN1bGF0aW5nIGN1c3RvbSBmaWVsZCBkYXRhKVxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVDdXN0b21GaWVsZFxuICAgICAqIEBtZW1iZXJPZiBGaWVsZENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHRvIHNlbmQgdG8gSmlyYVxuICAgICAqIEBwYXJhbSBvcHRzLmZpZWxkIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMzQxMn1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgY3VzdG9tIGZpZWxkIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgY3VzdG9tIGZpZWxkIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVDdXN0b21GaWVsZCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvZmllbGQnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMuZmllbGRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL2ZpbHRlcidcbiAqXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBGaWx0ZXJDbGllbnRcbiAqL1xuZnVuY3Rpb24gRmlsdGVyQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBmaWx0ZXIsIGFuZCByZXR1cm5zIG5ld2x5IGNyZWF0ZWQgZmlsdGVyLiBDdXJyZW50bHkgc2V0cyBwZXJtaXNzaW9ucyBqdXN0IHVzaW5nIHRoZSB1c2VycyBkZWZhdWx0XG4gICAgICogc2hhcmluZyBwZXJtaXNzaW9uc1xuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVGaWx0ZXJcbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0cy5leHBhbmRdIFRoZSBwYXJhbWV0ZXJzIHRvIGV4cGFuZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5maWx0ZXIgVGhlIGZpbHRlciB0byBjcmVhdGUuICBTZWVcbiAgICAgKiAgICAgIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmUzMzQ3fVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBmaWx0ZXIgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBmaWx0ZXIgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZUZpbHRlciA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvZmlsdGVyJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge30sXG4gICAgICAgICAgICBib2R5OiBvcHRzLmZpbHRlclxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRzLmV4cGFuZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5xcy5leHBhbmQgPSAnJztcbiAgICAgICAgICAgIG9wdHMuZXhwYW5kLmZvckVhY2goZnVuY3Rpb24gKGV4KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5xcy5leHBhbmQgKz0gZXggKyAnLCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmaWx0ZXIgZ2l2ZW4gYW4gaWRcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0RmlsdGVyXG4gICAgICogQG1lbWJlck9mIEZpbHRlckNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuZmlsdGVySWQgVGhlIGlkIG9mIHRoZSBmaWx0ZXIgdG8gcmV0cmlldmVcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgZmlsdGVyIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBmaWx0ZXIgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0RmlsdGVyID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcnLCAnR0VUJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBmaWx0ZXJzIGZvciB0aGUgY3VycmVudCB1c2VyKG9ubHkgZm9yIGNsb3VkKVxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRGaWx0ZXJzXG4gICAgICogQG1lbWJlck9mIEZpbHRlckNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGZpbHRlciBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgZmlsdGVyIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEZpbHRlcnMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvZmlsdGVyJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbiBleGlzdGluZyBmaWx0ZXIsIGFuZCByZXR1cm5zIGl0cyBuZXcgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZUZpbHRlclxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLmZpbHRlcklkIFRoZSBpZCBvZiB0aGUgZmlsdGVyIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmZpbHRlciBUaGUgbmV3IGRhdGEgZm9yIHRoZSBmaWx0ZXIuICBTZWVcbiAgICAgKiAgICAgIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmUzNDAxfVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBmaWx0ZXIgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBmaWx0ZXIgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUZpbHRlciA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnJywgJ1BVVCcsIG9wdHMuZmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbHRlci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlRmlsdGVyXG4gICAgICogQG1lbWJlck9mIEZpbHRlckNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuZmlsdGVySWQgVGhlIGlkIG9mIHRoZSBmaWx0ZXIgdG8gZGVsZXRlXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGZpbHRlciBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGZpbHRlciBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlRmlsdGVyID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcnLCAnREVMRVRFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdGaWx0ZXIgRGVsZXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGNvbHVtbnMgZm9yIHRoZSBnaXZlbiBmaWx0ZXIuIEN1cnJlbnRseSBsb2dnZWQgaW4gdXNlciB3aWxsIGJlIHVzZWQgYXMgdGhlIHVzZXIgbWFraW5nIHN1Y2hcbiAgICAgKiByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRGaWx0ZXJDb2x1bW5zXG4gICAgICogQG1lbWJlck9mIEZpbHRlckNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuZmlsdGVySWQgVGhlIGlkIG9mIHRoZSBmaWx0ZXIgZm9yIHdoaWNoIHRvIHJldHJpZXZlIGNvbHVtbnMuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGNvbHVtbnMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBjb2x1bW5zIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRGaWx0ZXJDb2x1bW5zID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvY29sdW1ucycsICdHRVQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRlZmF1bHQgY29sdW1ucyBmb3IgdGhlIGdpdmVuIGZpbHRlclxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXRGaWx0ZXJDb2x1bW5zXG4gICAgICogQG1lbWJlck9mIEZpbHRlckNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuZmlsdGVySWQgVGhlIGlkIG9mIHRoZSBmaWx0ZXIgZm9yIHdoaWNoIHRvIHVwZGF0ZSBjb2x1bW5zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wdHMuY29sdW1ucyBUaGUgbmFtZXMgb2YgdGhlIG5ldyBjb2x1bW5zLlxuICAgICAqICAgICAgU2VlIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmUzNDYwfVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBjb2x1bW5zIGhhdmUgYmVlbiBzZXRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBjb2x1bW5zIGhhdmUgYmVlbiBzZXRcbiAgICAgKi9cbiAgICB0aGlzLnNldEZpbHRlckNvbHVtbnMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGJvZHkgPSB7Y29sdW1uczogb3B0cy5jb2x1bW5zfTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9jb2x1bW5zJywgJ1BVVCcsIGJvZHkpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnQ29sdW1ucyBVcGRhdGVkJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgY29sdW1ucyBmb3IgdGhlIGdpdmVuIGZpbHRlciBzdWNoIHRoYXQgdGhlIGZpbHRlciBubyBsb25nZXIgaGFzIGl0cyBvd24gY29sdW1uIGNvbmZpZy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVzZXRGaWx0ZXJDb2x1bW5zXG4gICAgICogQG1lbWJlck9mIEZpbHRlckNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuZmlsdGVySWQgVGhlIGlkIG9mIHRoZSBmaWx0ZXIgZm9yIHdoaWNoIHRvIHJlc2V0IGNvbHVtbnMuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGNvbHVtbnMgaGF2ZSBiZWVuIHJlc2V0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGNvbHVtbnMgaGF2ZSBiZWVuIHJlc2V0LlxuICAgICAqL1xuICAgIHRoaXMucmVzZXRGaWx0ZXJDb2x1bW5zID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvY29sdW1ucycsICdERUxFVEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ0NvbHVtbnMgUmVzZXQnKTtcbiAgICB9O1xuXG4gICAgIC8qKlxuICAgICAqIEFkZHMgYSBzaGFyZSBwZXJtaXNzaW9uIGZvciB0aGUgZ2l2ZW4gZmlsdGVyXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFNoYXJlUGVybWlzc2lvblxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLmZpbHRlcklkIFRoZSBpZCBvZiB0aGUgZmlsdGVyIGZvciB3aGljaCB0byByZXNldCBjb2x1bW5zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnBlcm1pc3Npb24gVGhlIHNoYXJlIHBlcm1pc3Npb24gdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgY29sdW1ucyBoYXZlIGJlZW4gcmVzZXQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgY29sdW1ucyBoYXZlIGJlZW4gcmVzZXQuXG4gICAgICovXG4gICAgdGhpcy5hZGRTaGFyZVBlcm1pc3Npb24gPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9wZXJtaXNzaW9uJywgJ1BPU1QnLCBvcHRzLnBlcm1pc3Npb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnU2hhcmUgUGVybWlzc2lvbiBBZGRlZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgc2hhcmUgc2NvcGUgb2YgdGhlIGxvZ2dlZC1pbiB1c2VyLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXREZWZhdWx0U2hhcmVTY29yZVxuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgSWdub3JlZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgZGVmYXVsdCBzaGFyZSBzY29wZSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgZGVmYXVsdCBzaGFyZSBzY29wZSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXREZWZhdWx0U2hhcmVTY29yZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvZmlsdGVyL2RlZmF1bHRTaGFyZVNjb3BlJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IHNoYXJlIHNjb3BlIG9mIHRoZSBsb2dnZWQtaW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0RGVmYXVsdFNoYXJlU2NvcGVcbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byBqaXJhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuc2NvcGUgVGhlIG5ldyBkZWZhdWx0IHNoYXJlIHNjb3BlLiBBdmFpbGFibGUgdmFsdWVzIGFyZSBHTE9CQUwgYW5kIFBSSVZBVEUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGRlZmF1bHQgc2hhcmUgc2NvcGUgaGFzIGJlZW4gc2V0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGRlZmF1bHQgc2hhcmUgc2NvcGUgaGFzIGJlZW4gc2V0LlxuICAgICAqL1xuICAgIHRoaXMuc2V0RGVmYXVsdFNoYXJlU2NvcGUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2ZpbHRlci9kZWZhdWx0U2hhcmVTY29wZScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgc2NvcGU6IG9wdHMuc2NvcGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZhdm91cml0ZSBmaWx0ZXJzIG9mIHRoZSBsb2dnZWQtaW4gdXNlci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0RmF2b3VyaXRlRmlsdGVyc1xuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgSWdub3JlZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgbGlzdCBvZiBmYXZvdXJpdGVzIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBsaXN0IG9mIGZhdm91cml0ZXMgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0RmF2b3JpdGVGaWx0ZXJzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9maWx0ZXIvZmF2b3VyaXRlJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQnVpbGQgb3V0IHRoZSByZXF1ZXN0IG9wdGlvbnMgbmVjZXNzYXJ5IHRvIG1ha2UgYSBwYXJ0aWN1bGFyIEFQSSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJ1aWxkUmVxdWVzdE9wdGlvbnNcbiAgICAgKiBAbWVtYmVyT2YgRmlsdGVyQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuZmlsdGVySWQgVGhlIGlkIG9mIHRoZSBmaWx0ZXIgdG8gdXNlIGluIHRoZSBwYXRoLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRzLmZpZWxkc10gVGhlIGZpZWxkcyB0byBpbmNsdWRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdHMuZXhwYW5kXSBUaGUgZmllbGRzIHRvIGV4cGFuZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBlbmRwb2ludCBmb2xsb3dpbmcgL2ZpbHRlci97aWR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgcmVxdWVzdCBtZXRob2QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtib2R5XSBUaGUgcmVxdWVzdCBib2R5LCBpZiBhbnkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtxc10gVGhlIHF1ZXJ5c3RyaW5nLCBpZiBhbnkuICBvcHRzLmV4cGFuZCBhbmQgb3B0cy5maWVsZHMgYXJyYXlzIHdpbGwgYmUgYXV0b21hZ2ljYWxseSBhZGRlZC5cbiAgICAgKiBAcmV0dXJucyB7e3VyaTogc3RyaW5nLCBtZXRob2Q6IHN0cmluZywgYm9keTogT2JqZWN0LCBxczogT2JqZWN0LCBmb2xsb3dBbGxSZWRpcmVjdHM6IGJvb2xlYW4sIGpzb246IGJvb2xlYW59fVxuICAgICAqL1xuICAgIHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzLCBwYXRoLCBtZXRob2QsIGJvZHksIHFzKSB7XG4gICAgICAgIHZhciBiYXNlUGF0aCA9ICcvZmlsdGVyLycgKyBvcHRzLmZpbHRlcklkO1xuICAgICAgICBpZiAoIXFzKSBxcyA9IHt9O1xuICAgICAgICBpZiAoIWJvZHkpIGJvZHkgPSB7fTtcblxuICAgICAgICBpZiAob3B0cy5maWVsZHMpIHtcbiAgICAgICAgICAgIHFzLmZpZWxkcyA9ICcnO1xuICAgICAgICAgICAgb3B0cy5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBxcy5maWVsZHMgKz0gZmllbGQgKyAnLCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcXMuZmllbGRzID0gcXMuZmllbGRzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmV4cGFuZCkge1xuICAgICAgICAgICAgcXMuZXhwYW5kID0gJyc7XG4gICAgICAgICAgICBvcHRzLmV4cGFuZC5mb3JFYWNoKGZ1bmN0aW9uIChleCkge1xuICAgICAgICAgICAgICAgIHFzLmV4cGFuZCArPSBleCArICcsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxcy5leHBhbmQgPSBxcy5leHBhbmQuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKGJhc2VQYXRoICsgcGF0aCksXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBxczogcXMsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBqc29uOiB0cnVlXG4gICAgICAgIH07XG4gICAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL2dyb3VwJ1xuICpcbiAqIFRoZXNlIGFyZSBjb25zaWRlcmVkIGV4cGVyaW1lbnRhbCBhY2NvcmRpbmcgdG8gdGhlIEppcmEgRG9jcywgdXNlIGF0IHlvdXIgb3duIHJpc2suXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgR3JvdXBDbGllbnRcbiAqL1xuZnVuY3Rpb24gR3JvdXBDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZ3JvdXAgYnkgZ2l2ZW4gZ3JvdXAgcGFyYW1ldGVyIFJldHVybnMgUkVTVCByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHJlcXVlc3RlZCBncm91cC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlR3JvdXBcbiAgICAgKiBAbWVtYmVyT2YgR3JvdXBDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIGppcmFcbiAgICAgKiBAcGFyYW0gb3B0cy5ncm91cCBUaGUgZ3JvdXAgdG8gY3JlYXRlLiAgU2VlIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmUyMDExfVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBncm91cCBpcyBjcmVhdGVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgZ3JvdXAgaXMgY3JlYXRlZFxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlR3JvdXAgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2dyb3VwJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBvcHRzLmdyb3VwXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgUkVTVCByZXByZXNlbnRhdGlvbiBmb3IgdGhlIHJlcXVlc3RlZCBncm91cC4gQWxsb3dzIHRvIGdldCBsaXN0IG9mIGFjdGl2ZSB1c2VycyBiZWxvbmdpbmcgdG8gdGhlXG4gICAgICogc3BlY2lmaWVkIGdyb3VwIGFuZCBpdHMgc3ViZ3JvdXBzIGlmIFwidXNlcnNcIiBleHBhbmQgb3B0aW9uIGlzIHByb3ZpZGVkLiBZb3UgY2FuIHBhZ2UgdGhyb3VnaCB1c2VycyBsaXN0IGJ5IHVzaW5nXG4gICAgICogaW5kZXhlcyBpbiBleHBhbmQgcGFyYW0uIEZvciBleGFtcGxlIHRvIGdldCB1c2VycyBmcm9tIGluZGV4IDEwIHRvIGluZGV4IDE1IHVzZSBcInVzZXJzWzEwOjE1XVwiIGV4cGFuZCB2YWx1ZS5cbiAgICAgKiBUaGlzIHdpbGwgcmV0dXJuIDYgdXNlcnMgKGlmIHRoZXJlIGFyZSBhdCBsZWFzdCAxNiB1c2VycyBpbiB0aGlzIGdyb3VwKS4gSW5kZXhlcyBhcmUgMC1iYXNlZCBhbmQgaW5jbHVzaXZlLlxuICAgICAqIERFUFJFQ0FURUQuIFRoaXMgcmVzb3VyY2UgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBncm91cC9tZW1iZXIgQVBJIGluc3RlYWQuICgxNS1GZWItMjAxOClcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0R3JvdXBcbiAgICAgKiBAbWVtYmVyT2YgR3JvdXBDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLmdyb3VwTmFtZSBBIG5hbWUgb2YgcmVxdWVzdGVkIGdyb3VwLlxuICAgICAqIEBwYXJhbSBvcHRzLmV4cGFuZCBBcnJheSBvZiBmaWVsZHMgdG8gZXhwYW5kLiBDdXJyZW50bHkgb25seSBhdmFpbGFibGUgZXhwYW5kIGlzIFwidXNlcnNcIi5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgZ3JvdXAgaXMgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGdyb3VwIGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEdyb3VwID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBxcyA9IHtcbiAgICAgICAgICAgIGdyb3VwbmFtZTogb3B0cy5ncm91cE5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0cy5leHBhbmQpIHtcbiAgICAgICAgICAgIHFzLmV4cGFuZCA9ICcnO1xuICAgICAgICAgICAgb3B0cy5leHBhbmQuZm9yRWFjaChmdW5jdGlvbiAoZXgpIHtcbiAgICAgICAgICAgICAgICBxcy5leHBhbmQgKz0gZXggKyAnLCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2dyb3VwJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiBxc1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHJlc291cmNlIHJldHVybnMgYSBwYWdpbmF0ZWQgbGlzdCBvZiB1c2VycyB3aG8gYXJlIG1lbWJlcnMgb2YgdGhlIHNwZWNpZmllZCBncm91cCBhbmQgaXRzIHN1Ymdyb3Vwcy5cbiAgICAgKiBVc2VycyBpbiB0aGUgcGFnZSBhcmUgb3JkZXJlZCBieSB1c2VyIG5hbWVzLlxuICAgICAqIFVzZXIgb2YgdGhpcyByZXNvdXJjZSBpcyByZXF1aXJlZCB0byBoYXZlIHN5c2FkbWluIG9yIGFkbWluIHBlcm1pc3Npb25zLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRNZW1iZXJzXG4gICAgICogQG1lbWJlck9mIEdyb3VwQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5ncm91cE5hbWUgQSBuYW1lIG9mIHJlcXVlc3RlZCBncm91cC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdHMuaW5jbHVkZUluYWN0aXZlVXNlcnMgaW5hY3RpdmUgdXNlcnMgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UgaWYgc2V0IHRvIHRydWUuIERlZmF1bHQgZmFsc2UuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdHMuc3RhcnRBdCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVzZXIgaW4gZ3JvdXAgdG8gcmV0dXJuICgwIGJhc2VkKS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0cy5tYXhSZXN1bHRzIHRoZSBtYXhpbXVtIG51bWJlciBvZiB1c2VycyB0byByZXR1cm4gKG1heCA1MCkuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGdyb3VwIGlzIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBncm91cCBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRNZW1iZXJzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBxcyA9IHtcbiAgICAgICAgICAgIGdyb3VwbmFtZTogb3B0cy5ncm91cE5hbWUsXG4gICAgICAgICAgICBpbmNsdWRlSW5hY3RpdmVVc2Vyczogb3B0cy5pbmNsdWRlSW5hY3RpdmVVc2VycyxcbiAgICAgICAgICAgIHN0YXJ0QXQ6IG9wdHMuc3RhcnRBdCxcbiAgICAgICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0cyxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvZ3JvdXAvbWVtYmVyJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiBxc1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGdpdmVuIHVzZXIgdG8gYSBncm91cC4gUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ3JvdXAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFVzZXJUb0dyb3VwXG4gICAgICogQG1lbWJlck9mIEdyb3VwQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5ncm91cE5hbWUgQSBuYW1lIG9mIHJlcXVlc3RlZCBncm91cC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy51c2VyTmFtZSBUaGUgbmFtZSBvZiB0aGUgdXNlciB0byBhZGQgdG8gdGhlIGdyb3VwLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBncm91cC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB1c2VyIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICB0aGlzLmFkZFVzZXJUb0dyb3VwID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9ncm91cC91c2VyJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIGdyb3VwbmFtZTogb3B0cy5ncm91cE5hbWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgbmFtZTogb3B0cy51c2VyTmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGdpdmVuIHVzZXIgZnJvbSBhIGdyb3VwLiBSZXR1cm5zIG5vIGNvbnRlbnRcbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlVXNlckZyb21Hcm91cFxuICAgICAqIEBtZW1iZXJPZiBHcm91cENsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZ3JvdXBOYW1lIEEgbmFtZSBvZiByZXF1ZXN0ZWQgZ3JvdXAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMudXNlck5hbWUgVGhlIG5hbWUgb2YgdGhlIHVzZXIgdG8gYWRkIHRvIHRoZSBncm91cC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgYmVlbiBhZGRlZCB0byB0aGUgZ3JvdXAuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgdXNlciBoYXMgYmVlbiBhZGRlZCB0byB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgdGhpcy5yZW1vdmVVc2VyRnJvbUdyb3VwID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9ncm91cC91c2VyJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBuYW1lOiBvcHRzLmdyb3VwTmFtZSxcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogb3B0cy51c2VyTmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdVc2VyIFJlbW92ZWQgZnJvbSBHcm91cCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgZ3JvdXAgYnkgZ2l2ZW4gZ3JvdXAgcGFyYW1ldGVyLiBSZXR1cm5zIG5vIGNvbnRlbnRcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlR3JvdXBcbiAgICAgKiBAbWVtYmVyT2YgR3JvdXBDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmdyb3VwTmFtZSBBIGdyb3VwIHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuc3dhcEdyb3VwXSBBIGdyb3VwIHRvIHRyYW5zZmVyIHZpc2liaWxpdHkgcmVzdHJpY3Rpb25zIG9mIHRoZSBncm91cCB0aGF0IGlzIGJlaW5nIGRlbGV0ZWRcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgZ3JvdXAgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBncm91cCBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlR3JvdXAgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2dyb3VwJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBuYW1lOiBvcHRzLmdyb3VwTmFtZSxcbiAgICAgICAgICAgICAgICBzd2FwR3JvdXA6IG9wdHMuc3dhcEdyb3VwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ0dyb3VwIERlbGV0ZWQnKTtcbiAgICB9O1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwVXNlclBpY2tlckNsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9ncm91cHVzZXJwaWNrZXInXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBHcm91cFVzZXJQaWNrZXJDbGllbnRcbiAqL1xuZnVuY3Rpb24gR3JvdXBVc2VyUGlja2VyQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgdXNlcnMgYW5kIGdyb3VwcyBtYXRjaGluZyBxdWVyeSB3aXRoIGhpZ2hsaWdodGluZy4gVGhpcyByZXNvdXJjZSBjYW5ub3QgYmUgYWNjZXNzZWRcbiAgICAgKiBhbm9ueW1vdXNseS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZmluZFVzZXJzQW5kR3JvdXBzXG4gICAgICogQG1lbWJlck9mIEdyb3VwVXNlclBpY2tlckNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHRvIHNlbmQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnF1ZXJ5IEEgc3RyaW5nIHVzZWQgdG8gc2VhcmNoIHVzZXJuYW1lLCBOYW1lIG9yIGUtbWFpbCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLm1heFJlc3VsdHNdIHRoZSBtYXhpbXVtIG51bWJlciBvZiB1c2VycyB0byByZXR1cm4gKGRlZmF1bHRzIHRvIDUwKS4gVGhlIG1heGltdW0gYWxsb3dlZFxuICAgICAqICAgICB2YWx1ZSBpcyAxMDAwLiBJZiB5b3Ugc3BlY2lmeSBhIHZhbHVlIHRoYXQgaXMgaGlnaGVyIHRoYW4gdGhpcyBudW1iZXIsIHlvdXIgc2VhcmNoIHJlc3VsdHMgd2lsbCBiZVxuICAgICAqICAgICB0cnVuY2F0ZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zaG93QXZhdGFyXSBXaGV0aGVyIHRvIHNob3cgdGhlIGF2YXRhclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5maWVsZElkXSBUaGUgY3VzdG9tIGZpZWxkIGlkLCBpZiB0aGlzIHJlcXVlc3QgY29tZXMgZnJvbSBhIGN1c3RvbSBmaWVsZCwgc3VjaCBhcyBhIHVzZXJcbiAgICAgKiAgICAgcGlja2VyLiBPcHRpb25hbC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucHJvamVjdElkXSBUaGUgbGlzdCBvZiBwcm9qZWN0IGlkcyB0byBmdXJ0aGVyIHJlc3RyaWN0IHRoZSBzZWFyY2ggVGhpcyBwYXJhbWV0ZXIgY2FuIG9jY3VyXG4gICAgICogICAgIG11bHRpcGxlIHRpbWVzIHRvIHBhc3MgaW4gbXVsdGlwbGUgcHJvamVjdCBpZHMuIENvbW1hIHNlcGFyYXRlZCB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkLiBUaGlzIHBhcmFtZXRlciBpc1xuICAgICAqICAgICBvbmx5IHVzZWQgd2hlbiBmaWVsZElkIGlzIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlVHlwZUlkXSBUaGUgbGlzdCBvZiBpc3N1ZSB0eXBlIGlkcyB0byBmdXJ0aGVyIHJlc3RyaWN0IHRoZSBzZWFyY2guIFRoaXMgcGFyYW1ldGVyIGNhblxuICAgICAqICAgICBvY2N1ciBtdWx0aXBsZSB0aW1lcyB0byBwYXNzIGluIG11bHRpcGxlIGlzc3VlIHR5cGUgaWRzLiBDb21tYSBzZXBhcmF0ZWQgdmFsdWUgaXMgbm90IHN1cHBvcnRlZC4gU3BlY2lhbFxuICAgICAqICAgICB2YWx1ZXMgc3VjaCBhcyAtMSAoYWxsIHN0YW5kYXJkIGlzc3VlIHR5cGVzKSwgLTIgKGFsbCBzdWJ0YXNrIGlzc3VlIHR5cGVzKSBhcmUgc3VwcG9ydGVkLiBUaGlzIHBhcmFtZXRlciBpc1xuICAgICAqICAgICBvbmx5IHVzZWQgd2hlbiBmaWVsZElkIGlzIHByZXNlbnQuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHNlYXJjaCBpcyBjb21wbGV0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc2VhcmNoIGlzIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmZpbmRVc2Vyc0FuZEdyb3VwcyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvZ3JvdXB1c2VycGlja2VyJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IG9wdHMucXVlcnksXG4gICAgICAgICAgICAgICAgbWF4UmVzdWx0czogb3B0cy5tYXhSZXN1bHRzLFxuICAgICAgICAgICAgICAgIHNob3dBdmF0YXI6IG9wdHMuc2hvd0F2YXRhcixcbiAgICAgICAgICAgICAgICBmaWVsZElkOiBvcHRzLmZpZWxkSWQsXG4gICAgICAgICAgICAgICAgcHJvamVjdElkOiBvcHRzLnByb2plY3RJZCxcbiAgICAgICAgICAgICAgICBpc3N1ZVR5cGVJZDogb3B0cy5pc3N1ZVR5cGVJZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBzQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL2dyb3VwcydcbiAqXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBHcm91cHNDbGllbnRcbiAqL1xuZnVuY3Rpb24gR3JvdXBzQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBncm91cHMgd2l0aCBzdWJzdHJpbmdzIG1hdGNoaW5nIGEgZ2l2ZW4gcXVlcnkuIFRoaXMgaXMgbWFpbmx5IGZvciB1c2Ugd2l0aCB0aGUgZ3JvdXAgcGlja2VyLCBzbyB0aGVcbiAgICAgKiByZXR1cm5lZCBncm91cHMgY29udGFpbiBodG1sIHRvIGJlIHVzZWQgYXMgcGlja2VyIHN1Z2dlc3Rpb25zLiBUaGUgZ3JvdXBzIGFyZSBhbHNvIHdyYXBwZWQgaW4gYSBzaW5nbGUgcmVzcG9uc2VcbiAgICAgKiBvYmplY3QgdGhhdCBhbHNvIGNvbnRhaW5zIGEgaGVhZGVyIGZvciB1c2UgaW4gdGhlIHBpY2tlciwgc3BlY2lmaWNhbGx5IFNob3dpbmcgWCBvZiBZIG1hdGNoaW5nIGdyb3Vwcy4gVGhlXG4gICAgICogbnVtYmVyIG9mIGdyb3VwcyByZXR1cm5lZCBpcyBsaW1pdGVkIGJ5IHRoZSBzeXN0ZW0gcHJvcGVydHkgXCJqaXJhLmFqYXguYXV0b2NvbXBsZXRlLmxpbWl0XCIgVGhlIGdyb3VwcyB3aWxsIGJlXG4gICAgICogdW5pcXVlIGFuZCBzb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGZpbmRHcm91cHNcbiAgICAgKiBAbWVtYmVyT2YgR3JvdXBzQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgdG8gdXNlIGluIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5xdWVyeSBBIHN0cmluZyBhZ2FpbnN0IHdoaWNoIHRvIG1hdGNoIGdyb3Vwcy4gIExlYXZlIHRoaXMgYmxhbmsgdG8gcmV0dXJuIGFsbCBncm91cHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZXhjbHVkZSBBIHN0cmluZyBzcGVjaWZ5aW5nIGdyb3VwcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLm1heFJlc3VsdHMgVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBncm91cHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBncm91cHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmZpbmRHcm91cHMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2dyb3Vwcy9waWNrZXInKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogb3B0cy5xdWVyeSxcbiAgICAgICAgICAgICAgICBleGNsdWRlOiBvcHRzLmV4Y2x1ZGUsXG4gICAgICAgICAgICAgICAgbWF4UmVzdWx0czogb3B0cy5tYXhSZXN1bHRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXJyb3JTdHJpbmdzID0gcmVxdWlyZSgnLi8uLi9saWIvZXJyb3InKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNzdWVDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvaXNzdWUnIGFuZCAnL3Jlc3QvYWdpbGUvMS4wL2lzc3VlJ1xuICogQGNvbnN0cnVjdG9yIElzc3VlQ2xpZW50XG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqL1xuZnVuY3Rpb24gSXNzdWVDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlc3RpbWF0aW9uIG9mIHRoZSBpc3N1ZSBhbmQgYSBmaWxlZElkIG9mIHRoZSBmaWVsZCB0aGF0IGlzXG4gICAgICogdXNlZCBmb3IgaXQuICBUaGUgYm9hcmRJZCBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQsIGFuZCBkZXRlcm1pbmVzIHdoaWNoXG4gICAgICogZmllbGQgd2lsbCBiZSB1cGRhdGVkIG9uIGFuIGlzc3VlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRJc3N1ZUVzdGltYXRpb25cbiAgICAgKiBAbWVtYmVyT2YgSXNzdWVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJLiAgTm90ZSB0aGF0IHRoaXNcbiAgICAgKiAgICAgICAgb2JqZWN0IG11c3QgY29udGFpbiBFSVRIRVIgYW4gaXNzdWVJZCBvciBpc3N1ZUtleSBwcm9wZXJ0eTtcbiAgICAgKiAgICAgICAgaXNzdWVJZCB3aWxsIGJlIHVzZWQgb3ZlciBpc3N1ZUtleSBpZiBib3RoIGFyZSBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUlkXSBUaGUgaWQgb2YgdGhlIGlzc3VlLiAgRVg6IDEwMDAyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlS2V5XSBUaGUgS2V5IG9mIHRlaCBpc3N1ZS4gIEVYOiBKV1ItM1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5ib2FyZElkXSBUaGUgaWQgb2YgdGhlIGJvYXJkIHJlcXVpcmVkIHRvXG4gICAgICogICAgICAgIGRldGVybWluZSB3aGljaCBmaWVsZCBpcyB1c2VkIGZvciBlc3RpbWF0aW9uLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBpc3N1ZSBlc3RpbWF0aW9uIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBpc3N1ZSBlc3RpbWF0aW9uIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldElzc3VlRXN0aW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZW5kcG9pbnQgPSAnL2lzc3VlLycgKyAob3B0cy5pc3N1ZUlkIHx8IG9wdHMuaXNzdWVLZXkpICsgJy9lc3RpbWF0aW9uJztcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEFnaWxlVVJMKGVuZHBvaW50KSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBib2FyZElkOiBvcHRzLmJvYXJkSWQsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBvcHRzLmZpbHRlcixcbiAgICAgICAgICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgICAgICAgICAgbWF4UmVzdWx0czogb3B0cy5tYXhSZXN1bHRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGVzdGltYXRpb24gb2YgdGhlIGlzc3VlLiAgVGhlIGJvYXJkSWQgcGFyYW1ldGVyIGlzIHJlcXVpcmVkLFxuICAgICAqIGFuZCBkZXRlcm1pbmVzIHdoaWNoIGZpZWxkIHdpbGwgYmUgdXBkYXRlZCBvbiBhbiBpc3N1ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0SXNzdWVFc3RpbWF0aW9uXG4gICAgICogQG1lbWJlck9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzXG4gICAgICogICAgICAgIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3IgaXNzdWVLZXkgcHJvcGVydHk7XG4gICAgICogICAgICAgIGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudmFsdWVdIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGlzc3VlIGVzdGltYXRpb24gYXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGVoIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJvYXJkSWRdIFRoZSBpZCBvZiB0aGUgYm9hcmQgcmVxdWlyZWQgdG9cbiAgICAgKiAgICAgICAgZGV0ZXJtaW5lIHdoaWNoIGZpZWxkIGlzIHVzZWQgZm9yIGVzdGltYXRpb24uXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGlzc3VlIGVzdGltYXRpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBpc3N1ZSBlc3RpbWF0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5zZXRJc3N1ZUVzdGltYXRpb24gPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVuZHBvaW50ID0gJy9pc3N1ZS8nICsgKG9wdHMuaXNzdWVJZCB8fCBvcHRzLmlzc3VlS2V5KSArICcvZXN0aW1hdGlvbic7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRBZ2lsZVVSTChlbmRwb2ludCksXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0cy52YWx1ZSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IG9wdHMuZmlsdGVyLFxuICAgICAgICAgICAgICAgIHN0YXJ0QXQ6IG9wdHMuc3RhcnRBdCxcbiAgICAgICAgICAgICAgICBtYXhSZXN1bHRzOiBvcHRzLm1heFJlc3VsdHNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICBib2FyZElkOiBvcHRzLmJvYXJkSWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW92ZXMgKHJhbmtzKSBpc3N1ZXMgYmVmb3JlIG9yIGFmdGVyIGEgZ2l2ZW4gaXNzdWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldElzc3VlUmFua3NcbiAgICAgKiBAbWVtYmVyT2YgSXNzdWVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJhbmtpbmcgVGhlIHJhbmtpbmcgZGF0YSBpbiB0aGUgZm9ybSBvZiBQVVQgYm9keSB0byB0aGVcbiAgICAgKiAgICAgICAgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGlzc3VlIHJhbmsgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBpc3N1ZSByYW5rIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5zZXRJc3N1ZVJhbmtzID0gZnVuY3Rpb24gKHJhbmtpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRBZ2lsZVVSTCgnL2lzc3VlL3JhbmsnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogcmFua2luZ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGlzc3VlIG9yIGEgc3ViLXRhc2sgZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgZmllbGRzIHRoYXQgY2FuIGJlIHNldCBvbiBjcmVhdGUsIGluIGVpdGhlciB0aGUgZmllbGRzIHBhcmFtZXRlciBvciB0aGUgdXBkYXRlIHBhcmFtZXRlciBjYW4gYmUgZGV0ZXJtaW5lZFxuICAgICAqIHVzaW5nIHRoZSAvcmVzdC9hcGkvMi9pc3N1ZS9jcmVhdGVtZXRhIHJlc291cmNlLiBJZiBhIGZpZWxkIGlzIG5vdCBjb25maWd1cmVkIHRvIGFwcGVhciBvbiB0aGUgY3JlYXRlIHNjcmVlbixcbiAgICAgKiB0aGVuIGl0IHdpbGwgbm90IGJlIGluIHRoZSBjcmVhdGVtZXRhLCBhbmQgYSBmaWVsZCB2YWxpZGF0aW9uIGVycm9yIHdpbGwgb2NjdXIgaWYgaXQgaXMgc3VibWl0dGVkLlxuICAgICAqXG4gICAgICogQ3JlYXRpbmcgYSBzdWItdGFzayBpcyBzaW1pbGFyIHRvIGNyZWF0aW5nIGEgcmVndWxhciBpc3N1ZSwgd2l0aCB0d28gaW1wb3J0YW50IGRpZmZlcmVuY2VzOlxuICAgICAqXG4gICAgICogKiB0aGUgaXNzdWVUeXBlIGZpZWxkIG11c3QgY29ycmVzcG9uZCB0byBhIHN1Yi10YXNrIGlzc3VlIHR5cGUgKHlvdSBjYW4gdXNlIC9pc3N1ZS9jcmVhdGVtZXRhIHRvIGRpc2NvdmVyXG4gICAgICogc3ViLXRhc2sgaXNzdWUgdHlwZXMpLCBhbmRcbiAgICAgKiAqIHlvdSBtdXN0IHByb3ZpZGUgYSBwYXJlbnQgZmllbGQgaW4gdGhlIGlzc3VlIGNyZWF0ZSByZXF1ZXN0IGNvbnRhaW5pbmcgdGhlIGlkIG9yIGtleSBvZiB0aGUgcGFyZW50IGlzc3VlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVJc3N1ZVxuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXNzdWUgVGhlIGlzc3VlIGRhdGEgaW4gdGhlIGZvcm0gb2YgUE9TVCBib2R5IHRvIHRoZSBKSVJBIEFQSS5cbiAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTM5OH1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgaXNzdWUgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBpc3N1ZSBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlSXNzdWUgPSBmdW5jdGlvbiAoaXNzdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9pc3N1ZScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogaXNzdWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWV0YSBkYXRhIGZvciBjcmVhdGluZyBpc3N1ZXMuIFRoaXMgaW5jbHVkZXMgdGhlIGF2YWlsYWJsZSBwcm9qZWN0cywgaXNzdWUgdHlwZXMgYW5kIGZpZWxkcyxcbiAgICAgKiBpbmNsdWRpbmcgZmllbGQgdHlwZXMgYW5kIHdoZXRoZXIgb3Igbm90IHRob3NlIGZpZWxkcyBhcmUgcmVxdWlyZWQuIFByb2plY3RzIHdpbGwgbm90IGJlIHJldHVybmVkIGlmIHRoZSB1c2VyXG4gICAgICogZG9lcyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGNyZWF0ZSBpc3N1ZXMgaW4gdGhhdCBwcm9qZWN0LlxuICAgICAqXG4gICAgICogVGhlIGZpZWxkcyBpbiB0aGUgY3JlYXRlbWV0YSBjb3JyZXNwb25kIHRvIHRoZSBmaWVsZHMgaW4gdGhlIGNyZWF0ZSBzY3JlZW4gZm9yIHRoZSBwcm9qZWN0L2lzc3VldHlwZS4gRmllbGRzIG5vdFxuICAgICAqIGluIHRoZSBzY3JlZW4gd2lsbCBub3QgYmUgaW4gdGhlIGNyZWF0ZW1ldGEuXG4gICAgICpcbiAgICAgKiBGaWVsZHMgd2lsbCBvbmx5IGJlIHJldHVybmVkIGlmIGBgYGV4cGFuZD1wcm9qZWN0cy5pc3N1ZXR5cGVzLmZpZWxkcy5gYGBcbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHRzIGNhbiBiZSBmaWx0ZXJlZCBieSBwcm9qZWN0IGFuZC9vciBpc3N1ZSB0eXBlLCBnaXZlbiBieSB0aGUgcXVlcnkgcGFyYW1zLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRDcmVhdGVNZXRhZGF0YVxuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIFRoZSBvcHRpb25zIGZvciB0aGUgQVBJIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnByb2plY3RJZHNdIGNvbWJpbmVkIHdpdGggdGhlIHByb2plY3RLZXlzIHBhcmFtLCBsaXN0cyB0aGUgcHJvamVjdHMgd2l0aCB3aGljaCB0byBmaWx0ZXJcbiAgICAgKiAgICAgdGhlIHJlc3VsdHMuIElmIGFic2VudCwgYWxsIHByb2plY3RzIGFyZSByZXR1cm5lZC4gVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHNwZWNpZmllZCBtdWx0aXBsZSB0aW1lcywgYW5kL29yIGJlXG4gICAgICogICAgIGEgY29tbWEtc2VwYXJhdGVkIGxpc3QuIFNwZWNpZml5aW5nIGEgcHJvamVjdCB0aGF0IGRvZXMgbm90IGV4aXN0IChvciB0aGF0IHlvdSBjYW5ub3QgY3JlYXRlIGlzc3VlcyBpbikgaXNcbiAgICAgKiAgICAgbm90IGFuIGVycm9yLCBidXQgaXQgd2lsbCBub3QgYmUgaW4gdGhlIHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnByb2plY3RLZXlzXSBjb21iaW5lZCB3aXRoIHRoZSBwcm9qZWN0SWRzIHBhcmFtLCBsaXN0cyB0aGUgcHJvamVjdHMgd2l0aCB3aGljaCB0byBmaWx0ZXJcbiAgICAgKiAgICAgdGhlIHJlc3VsdHMuIElmIG51bGwsIGFsbCBwcm9qZWN0cyBhcmUgcmV0dXJuZWQuIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSBzcGVjaWZpZWQgbXVsdGlwbGUgdGltZXMsIGFuZC9vciBiZSBhXG4gICAgICogICAgIGNvbW1hLXNlcGFyYXRlZCBsaXN0LiBTcGVjaWZpeWluZyBhIHByb2plY3QgdGhhdCBkb2VzIG5vdCBleGlzdCAob3IgdGhhdCB5b3UgY2Fubm90IGNyZWF0ZSBpc3N1ZXMgaW4pIGlzIG5vdFxuICAgICAqICAgICBhbiBlcnJvciwgYnV0IGl0IHdpbGwgbm90IGJlIGluIHRoZSByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZXR5cGVJZHNdIGNvbWJpbmRlZCB3aXRoIGlzc3VldHlwZU5hbWVzLCBsaXN0cyB0aGUgaXNzdWUgdHlwZXMgd2l0aCB3aGljaCB0byBmaWx0ZXJcbiAgICAgKiAgICAgdGhlIHJlc3VsdHMuIElmIG51bGwsIGFsbCBpc3N1ZSB0eXBlcyBhcmUgcmV0dXJuZWQuIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSBzcGVjaWZpZWQgbXVsdGlwbGUgdGltZXMsIGFuZC9vclxuICAgICAqICAgICBiZSBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0LiBTcGVjaWZpeWluZyBhbiBpc3N1ZSB0eXBlIHRoYXQgZG9lcyBub3QgZXhpc3QgaXMgbm90IGFuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZXR5cGVOYW1lc10gY29tYmluZGVkIHdpdGggaXNzdWV0eXBlSWRzLCBsaXN0cyB0aGUgaXNzdWUgdHlwZXMgd2l0aCB3aGljaCB0byBmaWx0ZXJcbiAgICAgKiAgICAgdGhlIHJlc3VsdHMuIElmIG51bGwsIGFsbCBpc3N1ZSB0eXBlcyBhcmUgcmV0dXJuZWQuIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSBzcGVjaWZpZWQgbXVsdGlwbGUgdGltZXMsIGJ1dCBpc1xuICAgICAqICAgICBOT1QgaW50ZXJwcmV0ZWQgYXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdC4gU3BlY2lmaXlpbmcgYW4gaXNzdWUgdHlwZSB0aGF0IGRvZXMgbm90IGV4aXN0IGlzIG5vdCBhbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZXhwYW5kXSBpbiBvcmRlciB0byBnZXQgZXhwYW5kZWQgZmllbGQgZGVzY3JpcHRpb25zLCBzcGVjaWZ5ICdwcm9qZWN0cy5pc3N1ZXR5cGVzLmZpZWxkcycgaGVyZS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgbWV0YWRhdGEgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIG1ldGFkYXRhIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldENyZWF0ZU1ldGFkYXRhID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9pc3N1ZS9jcmVhdGVtZXRhJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiB7XG4gICAgICAgICAgICAgICAgcHJvamVjdElkczogb3B0cy5wcm9qZWN0SWRzLFxuICAgICAgICAgICAgICAgIHByb2plY3RLZXlzOiBvcHRzLnByb2plY3RLZXlzLFxuICAgICAgICAgICAgICAgIGlzc3VldHlwZUlkczogb3B0cy5pc3N1ZXR5cGVJZHMsXG4gICAgICAgICAgICAgICAgaXNzdWV0eXBlTmFtZXM6IG9wdHMuaXNzdWV0eXBlTmFtZXMsXG4gICAgICAgICAgICAgICAgZXhwYW5kOiBvcHRzLmV4cGFuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGlzc3VlcyBvciBzdWItdGFza3MgZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIG1hbnkgaXNzdWVzIGluIG9uZSBidWxrIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIENyZWF0aW5nIGEgc3ViLXRhc2sgaXMgc2ltaWxhciB0byBjcmVhdGluZyBhIHJlZ3VsYXIgaXNzdWUuIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaW4gY3JlYXRlSXNzdWUgc2VjdGlvbjpcbiAgICAgKiB7QGxpbmsgSXNzdWVSZXNvdXJjZSNjcmVhdGVJc3N1ZShJc3N1ZVVwZGF0ZUJlYW4pfX1cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVsa0NyZWF0ZVxuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gaXNzdWVzIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlODI4fVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBpc3N1ZXMgaGF2ZSBiZWVuIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgaXNzdWVzIGhhdmUgYmVlbiBjcmVhdGVkLlxuICAgICAqL1xuICAgIHRoaXMuYnVsa0NyZWF0ZSA9IGZ1bmN0aW9uIChpc3N1ZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9pc3N1ZS9idWxrJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBib2R5OiBpc3N1ZXNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bGwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlzc3VlIGZvciB0aGUgZ2l2ZW4gaXNzdWUga2V5LlxuICAgICAqXG4gICAgICogQW4gaXNzdWUgSlNPTiBjb25zaXN0cyBvZiB0aGUgaXNzdWUga2V5LCBhIGNvbGxlY3Rpb24gb2YgZmllbGRzLCBhIGxpbmsgdG8gdGhlIHdvcmtmbG93IHRyYW5zaXRpb24gc3ViLXJlc291cmNlLFxuICAgICAqIGFuZCAob3B0aW9uYWxseSkgdGhlIEhUTUwgcmVuZGVyZWQgdmFsdWVzIG9mIGFueSBmaWVsZHMgdGhhdCBzdXBwb3J0IGl0IChlLmcuIGlmIHdpa2kgc3ludGF4IGlzIGVuYWJsZWQgZm9yIHRoZVxuICAgICAqIGRlc2NyaXB0aW9uIG9yIGNvbW1lbnRzKS5cbiAgICAgKlxuICAgICAqIFRoZSBmaWVsZHMgcGFyYW0gKHdoaWNoIGNhbiBiZSBzcGVjaWZpZWQgbXVsdGlwbGUgdGltZXMpIGdpdmVzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGRzIHRvIGluY2x1ZGUgaW5cbiAgICAgKiB0aGUgcmVzcG9uc2UuIFRoaXMgY2FuIGJlIHVzZWQgdG8gcmV0cmlldmUgYSBzdWJzZXQgb2YgZmllbGRzLiBBIHBhcnRpY3VsYXIgZmllbGQgY2FuIGJlIGV4Y2x1ZGVkIGJ5IHByZWZpeGluZ1xuICAgICAqIGl0IHdpdGggYSBtaW51cy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGFsbCAoXFwqYWxsKSBmaWVsZHMgYXJlIHJldHVybmVkIGluIHRoaXMgZ2V0LWlzc3VlIHJlc291cmNlLiBOb3RlOiB0aGUgZGVmYXVsdCBpcyBkaWZmZXJlbnQgd2hlbiBkb2luZ1xuICAgICAqIGEganFsIHNlYXJjaCAtLSB0aGUgZGVmYXVsdCB0aGVyZSBpcyBqdXN0IG5hdmlnYWJsZSBmaWVsZHMgKFxcKm5hdmlnYWJsZSkuXG4gICAgICpcbiAgICAgKiAqIFxcKmFsbCAtIGluY2x1ZGUgYWxsIGZpZWxkc1xuICAgICAqICogXFwqbmF2aWdhYmxlIC0gaW5jbHVkZSBqdXN0IG5hdmlnYWJsZSBmaWVsZHNcbiAgICAgKiAqIHN1bW1hcnksY29tbWVudCAtIGluY2x1ZGUganVzdCB0aGUgc3VtbWFyeSBhbmQgY29tbWVudHNcbiAgICAgKiAqIC1jb21tZW50IC0gaW5jbHVkZSBldmVyeXRoaW5nIGV4Y2VwdCBjb21tZW50cyAodGhlIGRlZmF1bHQgaXMgKmFsbCBmb3IgZ2V0LWlzc3VlKVxuICAgICAqICogXFwqYWxsLC1jb21tZW50IC0gaW5jbHVkZSBldmVyeXRoaW5nIGV4Y2VwdCBjb21tZW50c1xuICAgICAqXG4gICAgICogSklSQSB3aWxsIGF0dGVtcHQgdG8gaWRlbnRpZnkgdGhlIGlzc3VlIGJ5IHRoZSBpc3N1ZUlkT3JLZXkgcGF0aCBwYXJhbWV0ZXIuIFRoaXMgY2FuIGJlIGFuIGlzc3VlIGlkLCBvciBhbiBpc3N1ZVxuICAgICAqIGtleS4gSWYgdGhlIGlzc3VlIGNhbm5vdCBiZSBmb3VuZCB2aWEgYW4gZXhhY3QgbWF0Y2gsIEpJUkEgd2lsbCBhbHNvIGxvb2sgZm9yIHRoZSBpc3N1ZSBpbiBhIGNhc2UtaW5zZW5zaXRpdmVcbiAgICAgKiB3YXksIG9yIGJ5IGxvb2tpbmcgdG8gc2VlIGlmIHRoZSBpc3N1ZSB3YXMgbW92ZWQuIEluIGVpdGhlciBvZiB0aGVzZSBjYXNlcywgdGhlIHJlcXVlc3Qgd2lsbCBwcm9jZWVkIGFzIG5vcm1hbFxuICAgICAqIChhIDMwMiBvciBvdGhlciByZWRpcmVjdCB3aWxsIG5vdCBiZSByZXR1cm5lZCkuIFRoZSBpc3N1ZSBrZXkgY29udGFpbmVkIGluIHRoZSByZXNwb25zZSB3aWxsIGluZGljYXRlIHRoZVxuICAgICAqIGN1cnJlbnQgdmFsdWUgb2YgaXNzdWUncyBrZXkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldElzc3VlXG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmFnaWxlXSBXaGV0aGVyIG9yIG5vdCB0byBjYWxsIHRoZSBhZ2lsZSB2ZXJzaW9uIG9mIHRoaXMgZW5kcG9pbnQuICBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHMuZmllbGRzXSBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTYxMX1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHMuZXhwYW5kXSBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTYxMX1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHMucHJvcGVydGllc10gU2VlIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmU2MTF9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gZGF0YSBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkXG4gICAgICovXG4gICAgdGhpcy5nZXRJc3N1ZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMuYWdpbGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcnLCAnR0VUJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZW5kcG9pbnQgPSAnL2lzc3VlLycgKyAob3B0cy5pc3N1ZUlkIHx8IG9wdHMuaXNzdWVLZXkpO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRBZ2lsZVVSTChlbmRwb2ludCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IG9wdHMuZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgICAgICAgICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kOiBvcHRzLmV4cGFuZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGlzc3VlLiBJZiB0aGUgaXNzdWUgaGFzIHN1YnRhc2tzIHlvdSBtdXN0IHNldCB0aGUgcGFyYW1ldGVyIGRlbGV0ZVN1YnRhc2tzPXRydWUgdG8gZGVsZXRlIHRoZSBpc3N1ZS5cbiAgICAgKiBZb3UgY2Fubm90IGRlbGV0ZSBhbiBpc3N1ZSB3aXRob3V0IGl0cyBzdWJ0YXNrcyBhbHNvIGJlaW5nIGRlbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlbGV0ZUlzc3VlXG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZGVsZXRlU3VidGFza3NdIFwiYSBTdHJpbmcgb2YgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHRoYXQgYW55IHN1YnRhc2tzIHNob3VsZCBhbHNvXG4gICAgICogICAgICAgIGJlIGRlbGV0ZWQuIElmIHRoZSBpc3N1ZSBoYXMgbm8gc3VidGFza3MgdGhpcyBwYXJhbWV0ZXIgaXMgaWdub3JlZC4gSWYgdGhlIGlzc3VlIGhhcyBzdWJ0YXNrcyBhbmQgdGhpc1xuICAgICAqICAgICAgICBwYXJhbWV0ZXIgaXMgbWlzc2luZyBvciBmYWxzZSwgdGhlbiB0aGUgaXNzdWUgd2lsbCBub3QgYmUgZGVsZXRlZCBhbmQgYW4gZXJyb3Igd2lsbCBiZSByZXR1cm5lZC5cIlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBkYXRhIGhhcyBiZWVuIHJldHJpZXZlZFxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlSXNzdWUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJycsICdERUxFVEUnLCBudWxsLCB7ZGVsZXRlU3VidGFza3M6IG9wdHMuZGVsZXRlU3VidGFza3N9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnSXNzdWUgRGVsZXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgRWRpdHMgYW4gaXNzdWUgZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgaXNzdWUgY2FuIGVpdGhlciBiZSB1cGRhdGVkIGJ5IHNldHRpbmcgZXhwbGljaXQgdGhlIGZpZWxkIHZhbHVlKHMpIG9yIGJ5IHVzaW5nIGFuIG9wZXJhdGlvbiB0byBjaGFuZ2UgdGhlXG4gICAgICogZmllbGQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGUgZmllbGRzIHRoYXQgY2FuIGJlIHVwZGF0ZWQsIGluIGVpdGhlciB0aGUgZmllbGRzIHBhcmFtZXRlciBvciB0aGUgdXBkYXRlIHBhcmFtZXRlciwgY2FuIGJlIGRldGVybWluZWQgdXNpbmdcbiAgICAgKiB0aGUge0BsaW5rIElzc3VlQ2xpZW50I2dldEVkaXRNZXRhZGF0YX0gbWV0aG9kLiBJZiBhIGZpZWxkIGlzIG5vdCBjb25maWd1cmVkIHRvIGFwcGVhciBvbiB0aGUgZWRpdFxuICAgICAqIHNjcmVlbiwgdGhlbiBpdCB3aWxsIG5vdCBiZSBpbiB0aGUgZWRpdG1ldGEsIGFuZCBhIGZpZWxkIHZhbGlkYXRpb24gZXJyb3Igd2lsbCBvY2N1ciBpZiBpdCBpcyBzdWJtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBTcGVjaWZ5aW5nIGEgXCJmaWVsZF9pZFwiOiBmaWVsZF92YWx1ZSBpbiB0aGUgXCJmaWVsZHNcIiBpcyBhIHNob3J0aGFuZCBmb3IgYSBcInNldFwiIG9wZXJhdGlvbiBpbiB0aGUgXCJ1cGRhdGVcIlxuICAgICAqIHNlY3Rpb24uIEZpZWxkIHNob3VsZCBhcHBlYXIgZWl0aGVyIGluIFwiZmllbGRzXCIgb3IgXCJ1cGRhdGVcIiwgbm90IGluIGJvdGguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVkaXRJc3N1ZVxuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuaXNzdWUgU2VlIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmU2NTZ9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gZGF0YSBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkXG4gICAgICovXG4gICAgdGhpcy5lZGl0SXNzdWUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLmlzc3VlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0lTU1VFX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnJywgJ1BVVCcsIG9wdHMuaXNzdWUsIG9wdHMucXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdJc3N1ZSBVcGRhdGVkJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgYW4gaXNzdWUgdG8gYSB1c2VyLiBZb3UgY2FuIHVzZSB0aGlzIHJlc291cmNlIHRvIGFzc2lnbiBpc3N1ZXMgd2hlbiB0aGUgdXNlciBzdWJtaXR0aW5nIHRoZSByZXF1ZXN0IGhhc1xuICAgICAqIHRoZSBhc3NpZ24gcGVybWlzc2lvbiBidXQgbm90IHRoZSBlZGl0IGlzc3VlIHBlcm1pc3Npb24uIElmIHRoZSBuYW1lIGlzIFwiLTFcIiBhdXRvbWF0aWMgYXNzaWduZWUgaXMgdXNlZC4gQSBudWxsXG4gICAgICogbmFtZSB3aWxsIHJlbW92ZSB0aGUgYXNzaWduZWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFzc2lnbklzc3VlXG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5hc3NpZ25lZSBUaGUgbmFtZSBvZiB0aGUgdXNlciB0byB3aG9tIHRvIGFzc2lnbiB0aGUgaXNzdWUuIC0xIGZvciBkZWZhdWx0LCBudWxsIGZvciBub1xuICAgICAqICAgICBhc3NpZ25lZS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgaXNzdWUgaGFzIGJlZW4gYXNzaWduZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgaXNzdWUgaGFzIGJlZW4gYXNzaWduZWQuXG4gICAgICovXG4gICAgdGhpcy5hc3NpZ25Jc3N1ZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoISh0eXBlb2Ygb3B0cy5hc3NpZ25lZSA9PT0gXCJzdHJpbmdcIiAmJiBvcHRzLmFzc2lnbmVlLmxlbmd0aCB8fCBvcHRzLmFzc2lnbmVlID09PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19BU1NJR05FRV9FUlJPUik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL2Fzc2lnbmVlJywgJ1BVVCcsIHtuYW1lOiBvcHRzLmFzc2lnbmVlfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ0lzc3VlIEFzc2lnbmVkJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdGhlIGNvbW1lbnRzIGZvciBhbiBpc3N1ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0Q29tbWVudHNcbiAgICAgKiBAbWVtYmVyb2YgSXNzdWVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJLiAgTm90ZSB0aGF0IHRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBFSVRIRVIgYW4gaXNzdWVJZCBvclxuICAgICAqICAgICAgICBpc3N1ZUtleSBwcm9wZXJ0eTsgaXNzdWVJZCB3aWxsIGJlIHVzZWQgb3ZlciBpc3N1ZUtleSBpZiBib3RoIGFyZSBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUlkXSBUaGUgaWQgb2YgdGhlIGlzc3VlLiAgRVg6IDEwMDAyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlS2V5XSBUaGUgS2V5IG9mIHRoZSBpc3N1ZS4gIEVYOiBKV1ItM1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmV4cGFuZCBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTQ2MX1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgaXNzdWUgaGFzIGJlZW4gYXNzaWduZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgaXNzdWUgaGFzIGJlZW4gYXNzaWduZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRDb21tZW50cyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL2NvbW1lbnQnLCAnR0VUJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbW1lbnQgdG8gYW4gaXNzdWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkQ29tbWVudFxuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuY29tbWVudCBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTQ4Mn1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiBkYXRhIGhhcyBiZWVuIHJldHJpZXZlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gZGF0YSBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICAgKi9cbiAgICB0aGlzLmFkZENvbW1lbnQgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIGlmKG9wdHMuY29tbWVudC5ib2R5KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvY29tbWVudCcsICdQT1NUJywgb3B0cy5jb21tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9jb21tZW50JywgJ1BPU1QnLCB7Ym9keTogb3B0cy5jb21tZW50fSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3BlY2lmaWMgY29tbWVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0Q29tbWVudFxuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuY29tbWVudElkIFRoZSBpZCBvZiB0aGUgY29tbWVudC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgY29tbWVudCBpcyByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgY29tbWVudCBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRDb21tZW50ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5jb21tZW50SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fQ09NTUVOVF9JRCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9jb21tZW50LycgKyBvcHRzLmNvbW1lbnRJZCwgJ0dFVCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIGNvbW1lbnQgdXNpbmcgaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVkaXRDb21tZW50XG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5jb21tZW50SWQgVGhlIGlkIG9mIHRoZSBjb21tZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmNvbW1lbnQgU2VlIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmU1Mzl9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gZGF0YSBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkXG4gICAgICovXG4gICAgdGhpcy5lZGl0Q29tbWVudCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMuY29tbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19DT01NRU5UX0VSUk9SKTtcbiAgICAgICAgfSBlbHNlIGlmICghb3B0cy5jb21tZW50SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fQ09NTUVOVF9JRCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9jb21tZW50LycgKyBvcHRzLmNvbW1lbnRJZCwgJ1BVVCcsIG9wdHMuY29tbWVudCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbiBleGlzdGluZyBjb21tZW50LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZWxldGVDb21tZW50XG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5jb21tZW50SWQgVGhlIGlkIG9mIHRoZSBjb21tZW50LlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBjb21tZW50IGlzIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBjb21tZW50IGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZUNvbW1lbnQgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLmNvbW1lbnRJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19DT01NRU5UX0lEKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL2NvbW1lbnQvJyArIG9wdHMuY29tbWVudElkLCAnREVMRVRFJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ0NvbW1lbnQgRGVsZXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtZXRhIGRhdGEgZm9yIGVkaXRpbmcgYW4gaXNzdWUuXG4gICAgICpcbiAgICAgKiBUaGUgZmllbGRzIGluIHRoZSBlZGl0bWV0YSBjb3JyZXNwb25kIHRvIHRoZSBmaWVsZHMgaW4gdGhlIGVkaXQgc2NyZWVuIGZvciB0aGUgaXNzdWUuIEZpZWxkcyBub3QgaW4gdGhlIHNjcmVlblxuICAgICAqIHdpbGwgbm90IGJlIGluIHRoZSBlZGl0ZW1ldGEuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEVkaXRNZXRhZGF0YVxuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIG1ldGFkYXRhIGlzIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBtZXRhZGF0YSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRFZGl0TWV0YWRhdGEgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9lZGl0bWV0YScsICdHRVQnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBub3RpZmljYXRpb24gKGVtYWlsKSB0byB0aGUgbGlzdCBvciByZWNpcGllbnRzIGRlZmluZWQgaW4gdGhlIHJlcXVlc3QuXG4gICAgICogQSBjb3VwbGUgb2Ygbm90ZXM6IHRoaXMgbWF5IGNhbGwgYmFjayB3aXRoIHRoZSBlcnJvciAnTm8gcmVjaXBpZW50cyB3ZXJlIGRlZmluZWQgZm9yIG5vdGlmaWNhdGlvbi4nIGlmIGFsbFxuICAgICAqIG9mIHRoZSBpbnRlbmRlZCByZWNpcGllbnRzIGhhdmUgZGlzYWJsZWQgbm90aWZpY2F0aW9ucyBmcm9tIEppcmEuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNlbmRFbWFpbE5vdGlmaWNhdGlvblxuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMubm90aWZpY2F0aW9uIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlNDM1fVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBtZXRhZGF0YSBpcyByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgbWV0YWRhdGEgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuc2VuZEVtYWlsTm90aWZpY2F0aW9uID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5ub3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fTk9USUZJQ0FUSU9OX0VSUk9SKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvbm90aWZ5JywgJ1BPU1QnLCBvcHRzLm5vdGlmaWNhdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ05vdGlmaWNhdGlvbnMgU2VudCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBSRVNUIHN1Yi1yZXNvdXJjZSByZXByZXNlbnRpbmcgdGhlIHJlbW90ZSBpc3N1ZSBsaW5rcyBvbiB0aGUgaXNzdWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFJlbW90ZUxpbmtzXG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5nbG9iYWxJZCBUaGUgaWQgb2YgdGhlIHJlbW90ZSBpc3N1ZSBsaW5rIHRvIGJlIHJldHVybmVkLiBJZiBudWxsIChub3QgcHJvdmlkZWQpIGFsbCByZW1vdGVcbiAgICAgKiAgICAgbGlua3MgZm9yIHRoZSBpc3N1ZSBhcmUgcmV0dXJuZWQuIEZvciBhIGZ1bGwgZXhwbGFuYXRpb24gb2YgSXNzdWUgTGluayBmaWVsZHMgcGxlYXNlIHJlZmVyIHRvXG4gICAgICogICAgIHtAbGluayBodHRwczovL2RldmVsb3Blci5hdGxhc3NpYW4uY29tL2Rpc3BsYXkvSklSQURFVi9GaWVsZHMraW4rUmVtb3RlK0lzc3VlK0xpbmtzfVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSByZW1vdGUgbGlua3MgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSByZW1vdGUgbGlua3MgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFJlbW90ZUxpbmtzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvcmVtb3RlbGluaycsICdHRVQnLCBudWxsLCB7Z2xvYmFsSWQ6IG9wdHMuZ2xvYmFsSWR9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyAob3IgdXBkYXRlcykgYSByZW1vdGUgaXNzdWUgbGluayBmcm9tIGEgSlNPTiByZXByZXNlbnRhdGlvbi4gSWYgYSBnbG9iYWxJZCBpcyBwcm92aWRlZCBhbmQgYSByZW1vdGUgaXNzdWVcbiAgICAgKiBsaW5rIGV4aXN0cyB3aXRoIHRoYXQgZ2xvYmFsSWQsIHRoZSByZW1vdGUgaXNzdWUgbGluayBpcyB1cGRhdGVkLiBPdGhlcndpc2UsIHRoZSByZW1vdGUgaXNzdWUgbGluayBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVSZW1vdGVMaW5rXG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5yZW1vdGVMaW5rIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlOTQ1fVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSByZW1vdGUgbGlua3MgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSByZW1vdGUgbGlua3MgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZVJlbW90ZUxpbmsgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9yZW1vdGVsaW5rJywgJ1BPU1QnLCBvcHRzLnJlbW90ZUxpbmspO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIChvciBjcmVhdGVzKSBhIHJlbW90ZSBpc3N1ZSBsaW5rIGZyb20gYSBKU09OIHJlcHJlc2VudGF0aW9uLiBJZiBhIGdsb2JhbElkIGlzIHByb3ZpZGVkIGFuZCBhIHJlbW90ZSBpc3N1ZVxuICAgICAqIGxpbmsgZXhpc3RzIHdpdGggdGhhdCBnbG9iYWxJZCwgdGhlIHJlbW90ZSBpc3N1ZSBsaW5rIGlzIHVwZGF0ZWQuIE90aGVyd2lzZSwgdGhlIHJlbW90ZSBpc3N1ZSBsaW5rIGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVJlbW90ZUxpbmtcbiAgICAgKiBAbWVtYmVyb2YgSXNzdWVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJLiAgTm90ZSB0aGF0IHRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBFSVRIRVIgYW4gaXNzdWVJZCBvclxuICAgICAqICAgICBpc3N1ZUtleSBwcm9wZXJ0eTsgaXNzdWVJZCB3aWxsIGJlIHVzZWQgb3ZlciBpc3N1ZUtleSBpZiBib3RoIGFyZSBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUlkXSBUaGUgaWQgb2YgdGhlIGlzc3VlLiAgRVg6IDEwMDAyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlS2V5XSBUaGUgS2V5IG9mIHRoZSBpc3N1ZS4gIEVYOiBKV1ItM1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnJlbW90ZUxpbmsgU2VlIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmU5NDV9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHJlbW90ZSBsaW5rcyBhcmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHJlbW90ZSBsaW5rcyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMudXBkYXRlUmVtb3RlTGluayA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBUaGUgb25lIEFQSSBlbmRwb2ludCBoYW5kbGVzIGJvdGggdXBkYXRlcyBhbmQgY3JlYXRpb24uXG4gICAgICAgIHRoaXMuY3JlYXRlUmVtb3RlTGluayhvcHRzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgcmVtb3RlIGlzc3VlIGxpbmsgd2l0aCB0aGUgZ2l2ZW4gZ2xvYmFsIGlkIG9uIHRoZSBpc3N1ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlUmVtb3RlTGlua1xuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZ2xvYmFsSWQgVGhlIGdsb2JhbCBpZCBvZiB0aGUgcmVtb3RlIGlzc3VlIGxpbmtcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcmVtb3RlIGxpbmtzIGFyZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcmVtb3RlIGxpbmtzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5kZWxldGVSZW1vdGVMaW5rID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5nbG9iYWxJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19HTE9CQUxfSURfRVJST1IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9yZW1vdGVsaW5rJywgJ0RFTEVURScsIG51bGwsIHtnbG9iYWxJZDogb3B0cy5nbG9iYWxJZH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdSZW1vdGVMaW5rIERlbGV0ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZW1vdGUgaXNzdWUgbGluayB3aXRoIHRoZSBnaXZlbiBpZCBvbiB0aGUgaXNzdWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFJlbW90ZUxpbmtCeUlkXG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5saW5rSWQgVGhlIGlkIG9mIHRoZSByZW1vdGUgbGlua1xuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSByZW1vdGUgbGlua3MgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSByZW1vdGUgbGlua3MgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFJlbW90ZUxpbmtCeUlkID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5saW5rSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fTElOS19JRF9FUlJPUik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3JlbW90ZWxpbmsvJyArIG9wdHMubGlua0lkLCAnR0VUJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcmVtb3RlIGlzc3VlIGxpbmsgd2l0aCB0aGUgZ2l2ZW4gaWQgb24gdGhlIGlzc3VlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB1cGRhdGVSZW1vdGVMaW5rQnlJZFxuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubGlua0lkIFRoZSBpZCBvZiB0aGUgcmVtb3RlIGxpbmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5yZW1vdGVMaW5rIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMTAzN31cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcmVtb3RlIGxpbmtzIGFyZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcmVtb3RlIGxpbmtzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy51cGRhdGVSZW1vdGVMaW5rQnlJZCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMubGlua0lkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0xJTktfSURfRVJST1IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9yZW1vdGVsaW5rLycgKyBvcHRzLmxpbmtJZCwgJ1BVVCcsIG9wdHMucmVtb3RlTGluayk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ1JlbW90ZUxpbmsgVXBkYXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlbW90ZSBpc3N1ZSBsaW5rIHdpdGggdGhlIGdpdmVuIGlkIG9uIHRoZSBpc3N1ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlUmVtb3RlTGlua0J5SWRcbiAgICAgKiBAbWVtYmVyb2YgSXNzdWVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJLiAgTm90ZSB0aGF0IHRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBFSVRIRVIgYW4gaXNzdWVJZCBvclxuICAgICAqICAgICBpc3N1ZUtleSBwcm9wZXJ0eTsgaXNzdWVJZCB3aWxsIGJlIHVzZWQgb3ZlciBpc3N1ZUtleSBpZiBib3RoIGFyZSBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUlkXSBUaGUgaWQgb2YgdGhlIGlzc3VlLiAgRVg6IDEwMDAyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlS2V5XSBUaGUgS2V5IG9mIHRoZSBpc3N1ZS4gIEVYOiBKV1ItM1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmxpbmtJZCBUaGUgaWQgb2YgdGhlIHJlbW90ZSBsaW5rXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHJlbW90ZSBsaW5rcyBhcmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHJlbW90ZSBsaW5rcyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlUmVtb3RlTGlua0J5SWQgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLmxpbmtJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19MSU5LX0lEX0VSUk9SKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvcmVtb3RlbGluay8nICsgb3B0cy5saW5rSWQsICdERUxFVEUnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnUmVtb3RlTGluayBEZWxldGVkJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdGhlIHRyYW5zaXRpb25zIHBvc3NpYmxlIGZvciB0aGlzIGlzc3VlIGJ5IHRoZSBjdXJyZW50IHVzZXIsIGFsb25nIHdpdGggZmllbGRzIHRoYXQgYXJlIHJlcXVpcmVkXG4gICAgICogYW5kIHRoZWlyIHR5cGVzLlxuICAgICAqXG4gICAgICogRmllbGRzIHdpbGwgb25seSBiZSByZXR1cm5lZCBpZiBgYGBleHBhbmQ9dHJhbnNpdGlvbnMuZmllbGRzLmBgYFxuICAgICAqXG4gICAgICogVGhlIGZpZWxkcyBpbiB0aGUgbWV0YWRhdGEgY29ycmVzcG9uZCB0byB0aGUgZmllbGRzIGluIHRoZSB0cmFuc2l0aW9uIHNjcmVlbiBmb3IgdGhhdCB0cmFuc2l0aW9uLiBGaWVsZHMgbm90IGluXG4gICAgICogdGhlIHNjcmVlbiB3aWxsIG5vdCBiZSBpbiB0aGUgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFRyYW5zaXRpb25zXG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy50cmFuc2l0aW9uSWQgSWYgc3BlY2lmaWVkLCB3aWxsIGNhbGwgYmFjayB3aXRoIG9ubHkgdGhlIHRyYW5zaXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGlkLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9ucyBhcmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHRyYW5zaXRpb25zIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3RyYW5zaXRpb25zJywgJ0dFVCcsIG51bGwsIHt0cmFuc2l0aW9uSWQ6IG9wdHMudHJhbnNpdGlvbklkfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSB0cmFuc2l0aW9uIG9uIGFuIGlzc3VlLiBXaGVuIHBlcmZvcm1pbmcgdGhlIHRyYW5zaXRpb24geW91IGNhbiB1ZGF0ZSBvciBzZXQgb3RoZXIgaXNzdWUgZmllbGRzLlxuICAgICAqXG4gICAgICogVGhlIGZpZWxkcyB0aGF0IGNhbiBiZSBzZXQgb24gdHJhbnN0aW9uLCBpbiBlaXRoZXIgdGhlIGZpZWxkcyBwYXJhbWV0ZXIgb3IgdGhlIHVwZGF0ZSBwYXJhbWV0ZXIgY2FuIGJlXG4gICAgICogZGV0ZXJtaW5lZCB1c2luZyB0aGUqKiAvcmVzdC9hcGkvMi9pc3N1ZS97aXNzdWVJZE9yS2V5fS90cmFuc2l0aW9ucz9leHBhbmQ9dHJhbnNpdGlvbnMuZmllbGRzIHJlc291cmNlKiouIElmIGFcbiAgICAgKiBmaWVsZCBpcyBub3QgY29uZmlndXJlZCB0byBhcHBlYXIgb24gdGhlIHRyYW5zaXRpb24gc2NyZWVuLCB0aGVuIGl0IHdpbGwgbm90IGJlIGluIHRoZSB0cmFuc2l0aW9uIG1ldGFkYXRhLCBhbmRcbiAgICAgKiBhIGZpZWxkIHZhbGlkYXRpb24gZXJyb3Igd2lsbCBvY2N1ciBpZiBpdCBpcyBzdWJtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHRyYW5zaXRpb25Jc3N1ZVxuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMudHJhbnNpdGlvbiBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTY5OH1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbnMgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB0cmFuc2l0aW9ucyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMudHJhbnNpdGlvbklzc3VlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX1RSQU5TSVRJT05fRVJST1IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIGlmKCFvcHRzLnRyYW5zaXRpb24udHJhbnNpdGlvbikgeyAvLyBUbyBrZWVwIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvdHJhbnNpdGlvbnMnLCAnUE9TVCcsIG9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3RyYW5zaXRpb25zJywgJ1BPU1QnLCBvcHRzLnRyYW5zaXRpb24pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ0lzc3VlIFRyYW5zaXRpb25lZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgeW91ciB2b3RlIGZyb20gYW4gaXNzdWUuIChpLmUuIFwidW52b3RlXCIpXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVudm90ZVxuICAgICAqIEBtZW1iZXJvZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIGFmdGVyIHRoZSB2b3RlIGlzIHJlbW92ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgYWZ0ZXIgdGhlIHZvdGUgaXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICB0aGlzLnVudm90ZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3ZvdGVzJywgJ0RFTEVURScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdWb3RlIFJlbW92ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdCB5b3VyIHZvdGUgaW4gZmF2b3VyIG9mIGFuIGlzc3VlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCB2b3RlXG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgYWZ0ZXIgdGhlIHZvdGUgaXMgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBhZnRlciB0aGUgdm90ZSBpcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHRoaXMudm90ZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3ZvdGVzJywgJ1BPU1QnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnVm90ZSBBZGRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBSRVNUIHN1Yi1yZXNvdXJjZSByZXByZXNlbnRpbmcgdGhlIHZvdGVycyBvbiB0aGUgaXNzdWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFZvdGVzXG4gICAgICogQG1lbWJlcm9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgYWZ0ZXIgdGhlIHZvdGVzIGFyZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgYWZ0ZXIgdGhlIHZvdGVzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRWb3RlcyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3ZvdGVzJywgJ0dFVCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHdhdGNoZXJzIGZvciB0aGUgaXNzdWUgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRXYXRjaGVyc1xuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIGFmdGVyIHRoZSB3YXRjaGVycyBhcmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIGFmdGVyIHRoZSB3YXRjaGVycyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0V2F0Y2hlcnMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy93YXRjaGVycycsICdHRVQnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHVzZXIgdG8gYW4gaXNzdWUncyB3YXRjaGVyIGxpc3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZFdhdGNoZXJcbiAgICAgKiBAbWVtYmVyT2YgSXNzdWVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJLiAgTm90ZSB0aGF0IHRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBFSVRIRVIgYW4gaXNzdWVJZCBvclxuICAgICAqICAgICBpc3N1ZUtleSBwcm9wZXJ0eTsgaXNzdWVJZCB3aWxsIGJlIHVzZWQgb3ZlciBpc3N1ZUtleSBpZiBib3RoIGFyZSBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUlkXSBUaGUgaWQgb2YgdGhlIGlzc3VlLiAgRVg6IDEwMDAyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlS2V5XSBUaGUgS2V5IG9mIHRoZSBpc3N1ZS4gIEVYOiBKV1ItM1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndhdGNoZXIgVGhlIHVzZXJuYW1lIG9mIHRoZSB1c2VyIHRvIGFkZCBhcyBhIHdhdGNoZXIuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIGFmdGVyIHRoZSB3YXRjaGVyIGlzIGFkZGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIGFmdGVyIHRoZSB3YXRjaGVyIGlzIGFkZGVkLlxuICAgICAqL1xuICAgIHRoaXMuYWRkV2F0Y2hlciA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMud2F0Y2hlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19XQVRDSEVSX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3dhdGNoZXJzJywgJ1BPU1QnLCBvcHRzLndhdGNoZXIpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdXYXRjaGVyIEFkZGVkJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB1c2VyIHRvIGFuIGlzc3VlJ3Mgd2F0Y2hlciBsaXN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW1vdmVXYXRjaGVyXG4gICAgICogQG1lbWJlck9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53YXRjaGVyIFRoZSB1c2VybmFtZSBvZiB0aGUgdXNlciB0byByZW1vdmUgYXMgYSB3YXRjaGVyLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCBhZnRlciB0aGUgd2F0Y2hlciBpcyByZW1vdmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIGFmdGVyIHRoZSB3YXRjaGVyIGlzIHJlbW92ZWQuXG4gICAgICovXG4gICAgdGhpcy5yZW1vdmVXYXRjaGVyID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy53YXRjaGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX1dBVENIRVJfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvd2F0Y2hlcnMnLCAnREVMRVRFJywgbnVsbCwge3VzZXJuYW1lOiBvcHRzLndhdGNoZXJ9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnV2F0Y2hlciBSZW1vdmVkJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHdvcmsgbG9ncyBmb3IgYW4gaXNzdWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFdvcmtMb2dzXG4gICAgICogQG1lbWJlck9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgYWZ0ZXIgdGhlIHdvcmtsb2dzIGFyZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgYWZ0ZXIgdGhlIHdvcmtsb2dzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRXb3JrTG9ncyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3dvcmtsb2cnLCAnR0VUJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgd29ya2xvZyBlbnRyeSB0byBhbiBpc3N1ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkV29ya0xvZ1xuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmFkanVzdEVzdGltYXRlXSBBbGxvd3MgeW91IHRvIHByb3ZpZGUgc3BlY2lmaWMgaW5zdHJ1Y3Rpb25zIHRvIHVwZGF0ZSB0aGUgcmVtYWluaW5nIHRpbWVcbiAgICAgKiAgICAgZXN0aW1hdGUgb2YgdGhlIGlzc3VlLiBWYWxpZCB2YWx1ZXMgYXJlXG4gICAgICogICAgICogXCJuZXdcIiAtIHNldHMgdGhlIGVzdGltYXRlIHRvIGEgc3BlY2lmaWMgdmFsdWVcbiAgICAgKiAgICAgKiBcImxlYXZlXCItIGxlYXZlcyB0aGUgZXN0aW1hdGUgYXMgaXNcbiAgICAgKiAgICAgKiBcIm1hbnVhbFwiIC0gc3BlY2lmeSBhIHNwZWNpZmljIGFtb3VudCB0byBpbmNyZWFzZSByZW1haW5pbmcgZXN0aW1hdGUgYnlcbiAgICAgKiAgICAgKiBcImF1dG9cIi0gRGVmYXVsdCBvcHRpb24uIFdpbGwgYXV0b21hdGljYWxseSBhZGp1c3QgdGhlIHZhbHVlIGJhc2VkIG9uIHRoZVxuICAgICAqICAgICAgICAgIG5ldyB0aW1lU3BlbnQgc3BlY2lmaWVkIG9uIHRoZSB3b3JrbG9nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm5ld0VzdGltYXRlXSAocmVxdWlyZWQgd2hlbiBcIm5ld1wiIGlzIHNlbGVjdGVkIGZvciBhZGp1c3RFc3RpbWF0ZSkgdGhlIG5ldyB2YWx1ZSBmb3IgdGhlXG4gICAgICogICAgIHJlbWFpbmluZyBlc3RpbWF0ZSBmaWVsZC4gZS5nLiBcIjJkXCJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVkdWNlQnldIChyZXF1aXJlZCB3aGVuIFwibWFudWFsXCIgaXMgc2VsZWN0ZWQgZm9yIGFkanVzdEVzdGltYXRlKSB0aGUgYW1vdW50IHRvIHJlZHVjZSB0aGVcbiAgICAgKiAgICAgcmVtYWluaW5nIGVzdGltYXRlIGJ5IGUuZy4gXCIyZFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMud29ya2xvZyBTZWUge0BsaW5rOiBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmUxMTA2fVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCBhZnRlciB0aGUgd29ya2xvZyBpcyBhZGRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBhZnRlciB0aGUgd29ya2xvZyBpcyBhZGRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmFkZFdvcmtMb2cgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLndvcmtsb2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fV09SS0xPR19FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy93b3JrbG9nJywgJ1BPU1QnLCBvcHRzLndvcmtsb2csIHtcbiAgICAgICAgICAgIG5ld0VzdGltYXRlOiBvcHRzLm5ld0VzdGltYXRlLFxuICAgICAgICAgICAgcmVkdWNlQnk6IG9wdHMucmVkdWNlQnksXG4gICAgICAgICAgICBhZGp1c3RFc3RpbWF0ZTogb3B0cy5hZGp1c3RFc3RpbWF0ZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnV29ya2xvZyBBZGRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc3BlY2lmaWMgd29ya2xvZy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0V29ya0xvZ1xuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud29ya2xvZ0lkIFRoZSBpZCBvZiB0aGUgd29yayBsb2cgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIGFmdGVyIHRoZSB3b3JrbG9nIGlzIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCBhZnRlciB0aGUgd29ya2xvZyBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRXb3JrTG9nID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy53b3JrbG9nSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fV09SS0xPR19JRF9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy93b3JrbG9nLycgKyBvcHRzLndvcmtsb2dJZCwgJ0dFVCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIHdvcmtsb2cgZW50cnkgdXNpbmcgaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVdvcmtMb2dcbiAgICAgKiBAbWVtYmVyT2YgSXNzdWVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJLiAgTm90ZSB0aGF0IHRoaXMgb2JqZWN0IG11c3QgY29udGFpbiBFSVRIRVIgYW4gaXNzdWVJZCBvclxuICAgICAqICAgICBpc3N1ZUtleSBwcm9wZXJ0eTsgaXNzdWVJZCB3aWxsIGJlIHVzZWQgb3ZlciBpc3N1ZUtleSBpZiBib3RoIGFyZSBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUlkXSBUaGUgaWQgb2YgdGhlIGlzc3VlLiAgRVg6IDEwMDAyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlS2V5XSBUaGUgS2V5IG9mIHRoZSBpc3N1ZS4gIEVYOiBKV1ItM1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndvcmtsb2dJZCBUaGUgaWQgb2YgdGhlIHdvcmsgbG9nIHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5hZGp1c3RFc3RpbWF0ZV0gQWxsb3dzIHlvdSB0byBwcm92aWRlIHNwZWNpZmljIGluc3RydWN0aW9ucyB0byB1cGRhdGUgdGhlIHJlbWFpbmluZyB0aW1lXG4gICAgICogICAgIGVzdGltYXRlIG9mIHRoZSBpc3N1ZS4gVmFsaWQgdmFsdWVzIGFyZVxuICAgICAqICAgICAqIFwibmV3XCIgLSBzZXRzIHRoZSBlc3RpbWF0ZSB0byBhIHNwZWNpZmljIHZhbHVlXG4gICAgICogICAgICogXCJsZWF2ZVwiLSBsZWF2ZXMgdGhlIGVzdGltYXRlIGFzIGlzXG4gICAgICogICAgICogXCJhdXRvXCItIERlZmF1bHQgb3B0aW9uLiBXaWxsIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHRoZSB2YWx1ZSBiYXNlZCBvbiB0aGVcbiAgICAgKiAgICAgICAgICBuZXcgdGltZVNwZW50IHNwZWNpZmllZCBvbiB0aGUgd29ya2xvZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5uZXdFc3RpbWF0ZV0gKHJlcXVpcmVkIHdoZW4gXCJuZXdcIiBpcyBzZWxlY3RlZCBmb3IgYWRqdXN0RXN0aW1hdGUpIHRoZSBuZXcgdmFsdWUgZm9yIHRoZVxuICAgICAqICAgICByZW1haW5pbmcgZXN0aW1hdGUgZmllbGQuIGUuZy4gXCIyZFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMud29ya2xvZyBTZWUge0BsaW5rOiBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmUxMTYxfVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCBhZnRlciB0aGUgd29ya2xvZyBpcyB1cGRhdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIGFmdGVyIHRoZSB3b3JrbG9nIGlzIHVwZGF0ZWQuXG4gICAgICovXG4gICAgdGhpcy51cGRhdGVXb3JrTG9nID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy53b3JrbG9nSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fV09SS0xPR19JRF9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMud29ya2xvZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19XT1JLTE9HX0VSUk9SKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvd29ya2xvZy8nICsgb3B0cy53b3JrbG9nSWQsICdQVVQnLCBvcHRzLndvcmtsb2csIHtcbiAgICAgICAgICAgIG5ld0VzdGltYXRlOiBvcHRzLm5ld0VzdGltYXRlLFxuICAgICAgICAgICAgYWRqdXN0RXN0aW1hdGU6IG9wdHMuYWRqdXN0RXN0aW1hdGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gZXhpc3Rpbmcgd29ya2xvZyBlbnRyeVxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZWxldGVXb3JrTG9nXG4gICAgICogQG1lbWJlck9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53b3JrbG9nSWQgVGhlIGlkIG9mIHRoZSB3b3JrIGxvZyB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmFkanVzdEVzdGltYXRlXSBBbGxvd3MgeW91IHRvIHByb3ZpZGUgc3BlY2lmaWMgaW5zdHJ1Y3Rpb25zIHRvIHVwZGF0ZSB0aGUgcmVtYWluaW5nIHRpbWVcbiAgICAgKiAgICAgZXN0aW1hdGUgb2YgdGhlIGlzc3VlLiBWYWxpZCB2YWx1ZXMgYXJlXG4gICAgICogICAgICogXCJuZXdcIiAtIHNldHMgdGhlIGVzdGltYXRlIHRvIGEgc3BlY2lmaWMgdmFsdWVcbiAgICAgKiAgICAgKiBcImxlYXZlXCItIGxlYXZlcyB0aGUgZXN0aW1hdGUgYXMgaXNcbiAgICAgKiAgICAgKiBcIm1hbnVhbFwiIC0gc3BlY2lmeSBhIHNwZWNpZmljIGFtb3VudCB0byBpbmNyZWFzZSByZW1haW5pbmcgZXN0aW1hdGUgYnlcbiAgICAgKiAgICAgKiBcImF1dG9cIi0gRGVmYXVsdCBvcHRpb24uIFdpbGwgYXV0b21hdGljYWxseSBhZGp1c3QgdGhlIHZhbHVlIGJhc2VkIG9uIHRoZVxuICAgICAqICAgICAgICAgIG5ldyB0aW1lU3BlbnQgc3BlY2lmaWVkIG9uIHRoZSB3b3JrbG9nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm5ld0VzdGltYXRlXSAocmVxdWlyZWQgd2hlbiBcIm5ld1wiIGlzIHNlbGVjdGVkIGZvciBhZGp1c3RFc3RpbWF0ZSkgdGhlIG5ldyB2YWx1ZSBmb3IgdGhlXG4gICAgICogICAgIHJlbWFpbmluZyBlc3RpbWF0ZSBmaWVsZC4gZS5nLiBcIjJkXCJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaW5jcmVhc2VCeV0gKHJlcXVpcmVkIHdoZW4gXCJtYW51YWxcIiBpcyBzZWxlY3RlZCBmb3IgYWRqdXN0RXN0aW1hdGUpIHRoZSBhbW91bnQgdG8gcmVkdWNlXG4gICAgICogICAgIHRoZSByZW1haW5pbmcgZXN0aW1hdGUgYnkgZS5nLiBcIjJkXCJcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgYWZ0ZXIgdGhlIHdvcmsgbG9nIGlzIGRlbGV0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgYWZ0ZXIgdGhlIHdvcmsgbG9nIGlzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgdGhpcy5kZWxldGVXb3JrTG9nID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy53b3JrbG9nSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fV09SS0xPR19JRF9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy93b3JrbG9nLycgKyBvcHRzLndvcmtsb2dJZCwgJ0RFTEVURScsIG51bGwsIHtcbiAgICAgICAgICAgIG5ld0VzdGltYXRlOiBvcHRzLm5ld0VzdGltYXRlLFxuICAgICAgICAgICAgaW5jcmVhc2VCeTogb3B0cy5pbmNyZWFzZUJ5LFxuICAgICAgICAgICAgYWRqdXN0RXN0aW1hdGU6IG9wdHMuYWRqdXN0RXN0aW1hdGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdXb3JrIExvZyBEZWxldGVkJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBhdHRhY2htZW50cyB0byBhbiBpc3N1ZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkQXR0YWNobWVudFxuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUNsaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5maWxlbmFtZSBUaGUgZmlsZSBuYW1lIG9mIGF0dGFjaG1lbnQuIElmIHlvdSBwYXNzIGFuIGFycmF5IG9mIGZpbGVuYW1lcywgbXVsdGlwbGUgYXR0YWNobWVudHMgd2lsbCBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgYXR0YWNobWVudCBoYXMgYmVlbiBhdHRhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhdHRhY2htZW50IGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAqL1xuICAgIHRoaXMuYWRkQXR0YWNobWVudCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fRklMRU5BTUVfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvYXR0YWNobWVudHMnLCAnUE9TVCcpO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5ib2R5O1xuICAgICAgICBpZiAob3B0cy5maWxlbmFtZS5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIG9wdHMuZmlsZW5hbWUgPSBbb3B0cy5maWxlbmFtZV07XG4gICAgICAgIHZhciBhdHRhY2htZW50cyA9IG9wdHMuZmlsZW5hbWUubWFwIChmdW5jdGlvbiAoZmlsZW5hbWUpIHtyZXR1cm4gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlbmFtZSl9KTtcbiAgICAgICAgb3B0aW9ucy5mb3JtRGF0YSA9IHtmaWxlOiBhdHRhY2htZW50c307XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgIFwiWC1BdGxhc3NpYW4tVG9rZW5cIjogXCJub2NoZWNrXCJcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUga2V5cyBvZiBhbGwgcHJvcGVydGllcyBmb3IgdGhlIGlzc3VlIGlkZW50aWZpZWQgYnkgdGhlIGtleSBvciBieSB0aGUgaWQuICBUaGlzIGZ1bmN0aW9uIGlzIG1ha2VkIGFzXG4gICAgICogZXhwZXJpbWVudGFsIGluIHRoZSBKaXJhIEFQSSBkb2NzLCB1c2UgYXQgeW91ciBvd24gcmlzay5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0UHJvcGVydGllc1xuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHByb3BlcnRpZXMgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwcm9wZXJ0aWVzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvcHJvcGVydGllcycsICdHRVQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgaXNzdWUncyBwcm9wZXJ0eS4gWW91IGNhbiB1c2UgdGhpcyByZXNvdXJjZSB0byBzdG9yZSBhIGN1c3RvbSBkYXRhIGFnYWluc3QgdGhlXG4gICAgICogaXNzdWUgaWRlbnRpZmllZCBieSB0aGUga2V5IG9yIGJ5IHRoZSBpZC4gVGhlIHVzZXIgd2hvIHN0b3JlcyB0aGUgZGF0YSBpcyByZXF1aXJlZCB0byBoYXZlIHBlcm1pc3Npb25zIHRvIGVkaXRcbiAgICAgKiB0aGUgaXNzdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIG1ha2VkIGFzIGV4cGVyaW1lbnRhbCBpbiB0aGUgSmlyYSBBUEkgZG9jcywgdXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldFByb3BlcnR5XG4gICAgICogQG1lbWJlck9mIElzc3VlQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSS4gIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBtdXN0IGNvbnRhaW4gRUlUSEVSIGFuIGlzc3VlSWQgb3JcbiAgICAgKiAgICAgaXNzdWVLZXkgcHJvcGVydHk7IGlzc3VlSWQgd2lsbCBiZSB1c2VkIG92ZXIgaXNzdWVLZXkgaWYgYm90aCBhcmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVJZF0gVGhlIGlkIG9mIHRoZSBpc3N1ZS4gIEVYOiAxMDAwMlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIEtleSBvZiB0aGUgaXNzdWUuICBFWDogSldSLTNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5wcm9wZXJ0eUtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBzZXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvcGVydHlWYWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGJlaW5nIHNldC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcHJvcGVydHkgaXMgc2V0LlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHByb3BlcnR5IGlzIHNldC5cbiAgICAgKi9cbiAgICB0aGlzLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5wcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19QUk9QRVJUWV9LRVlfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLnByb3BlcnR5VmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fUFJPUEVSVFlfVkFMVUVfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvcHJvcGVydGllcy8nICsgb3B0cy5wcm9wZXJ0eUtleSwgJ1BVVCcsIG9wdHMucHJvcGVydHlWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdQcm9wZXJ0eSBTZXQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHdpdGggYSBnaXZlbiBrZXkgZnJvbSB0aGUgaXNzdWUgaWRlbnRpZmllZCBieSB0aGUga2V5IG9yIGJ5IHRoZSBpZC4gVGhlIHVzZXJcbiAgICAgKiB3aG8gcmV0cmlldmVzIHRoZSBwcm9wZXJ0eSBpcyByZXF1aXJlZCB0byBoYXZlIHBlcm1pc3Npb25zIHRvIHJlYWQgdGhlIGlzc3VlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBtYWtlZCBhcyBleHBlcmltZW50YWwgaW4gdGhlIEppcmEgQVBJIGRvY3MsIHVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRQcm9wZXJ0eVxuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMucHJvcGVydHlLZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgYmVpbmcgc2V0LlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBwcm9wZXJ0eSBpcyByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcHJvcGVydHkgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLnByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX1BST1BFUlRZX0tFWV9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9wcm9wZXJ0aWVzLycgKyBvcHRzLnByb3BlcnR5S2V5LCAnR0VUJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBpc3N1ZSBpZGVudGlmaWVkIGJ5IHRoZSBrZXkgb3IgYnkgdGhlIGlkLiBUaHMgdXNlciByZW1vdmluZyB0aGUgcHJvcGVydHkgaXNcbiAgICAgKiByZXF1aXJlZCB0byBoYXZlIHBlcm1pc3Npb25zIHRvIGVkaXQgdGhlIGlzc3VlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBtYWtlZCBhcyBleHBlcmltZW50YWwgaW4gdGhlIEppcmEgQVBJIGRvY3MsIHVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRQcm9wZXJ0eVxuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBBUEkuICBOb3RlIHRoYXQgdGhpcyBvYmplY3QgbXVzdCBjb250YWluIEVJVEhFUiBhbiBpc3N1ZUlkIG9yXG4gICAgICogICAgIGlzc3VlS2V5IHByb3BlcnR5OyBpc3N1ZUlkIHdpbGwgYmUgdXNlZCBvdmVyIGlzc3VlS2V5IGlmIGJvdGggYXJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlSWRdIFRoZSBpZCBvZiB0aGUgaXNzdWUuICBFWDogMTAwMDJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaXNzdWVLZXldIFRoZSBLZXkgb2YgdGhlIGlzc3VlLiAgRVg6IEpXUi0zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMucHJvcGVydHlLZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgYmVpbmcgc2V0LlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgdGhpcy5kZWxldGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMucHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fUFJPUEVSVFlfS0VZX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3Byb3BlcnRpZXMvJyArIG9wdHMucHJvcGVydHlLZXksICdERUxFVEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ1Byb3BlcnR5IERlbGV0ZWQnKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRXb3JrbG9nUHJvcGVydHkgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLnByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX1BST1BFUlRZX0tFWV9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMucHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19QUk9QRVJUWV9WQUxVRV9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKFxuICAgICAgICBvcHRzLFxuICAgICAgICAnL3dvcmtsb2cvJyArIG9wdHMud29ya2xvZ0lkICsgJy9wcm9wZXJ0aWVzLycgKyBvcHRzLnByb3BlcnR5S2V5LFxuICAgICAgICAnUFVUJyxcbiAgICAgICAgb3B0cy5wcm9wZXJ0eVZhbHVlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ1Byb3BlcnR5IFNldCcpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFdvcmtMb2dQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhcbiAgICAgICAgb3B0cyxcbiAgICAgICAgJy93b3JrbG9nLycgKyBvcHRzLndvcmtsb2dJZCArICcvcHJvcGVydGllcy8nLFxuICAgICAgICAnR0VUJ1xuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFdvcmtMb2dQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFvcHRzLnByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19QUk9QRVJUWV9LRVlfRVJST1IpO1xuICAgICAgfVxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMoXG4gICAgICAgIG9wdHMsXG4gICAgICAgICcvd29ya2xvZy8nICsgb3B0cy53b3JrbG9nSWQgKyAnL3Byb3BlcnRpZXMvJyArIG9wdHMucHJvcGVydHlLZXksXG4gICAgICAgICdHRVQnXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIG91dCB0aGUgcmVxdWVzdCBvcHRpb25zIG5lY2Vzc2FyeSB0byBtYWtlIGEgcGFydGljdWxhciBBUEkgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBidWlsZFJlcXVlc3RPcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgZW5kcG9pbnQgZm9sbG93aW5nIC9pc3N1ZS97aWRPcktleX1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSByZXF1ZXN0IG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2JvZHldIFRoZSByZXF1ZXN0IGJvZHksIGlmIGFueS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3FzXSBUaGUgcXVlcnlzdHJpbmcsIGlmIGFueS4gIG9wdHMuZXhwYW5kIGFuZCBvcHRzLmZpZWxkcyBhcnJheXMgd2lsbCBiZSBhdXRvbWFnaWNhbGx5IGFkZGVkLlxuICAgICAqIEByZXR1cm5zIHt7dXJpOiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nLCBib2R5OiBPYmplY3QsIHFzOiBPYmplY3QsIGZvbGxvd0FsbFJlZGlyZWN0czogYm9vbGVhbiwganNvbjogYm9vbGVhbn19XG4gICAgICovXG4gICAgdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zID0gZnVuY3Rpb24gKG9wdHMsIHBhdGgsIG1ldGhvZCwgYm9keSwgcXMpIHtcbiAgICAgICAgaWYgKCFvcHRzLmlzc3VlSWQgJiYgIW9wdHMuaXNzdWVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fSVNTVUVfSURFTlRJRklFUik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkT3JLZXkgPSBvcHRzLmlzc3VlSWQgfHwgb3B0cy5pc3N1ZUtleTtcbiAgICAgICAgdmFyIGJhc2VQYXRoID0gJy9pc3N1ZS8nICsgaWRPcktleTtcbiAgICAgICAgaWYgKCFxcykgcXMgPSB7fTtcbiAgICAgICAgaWYgKCFib2R5KSBib2R5ID0ge307XG5cbiAgICAgICAgaWYgKG9wdHMuZmllbGRzKSB7XG4gICAgICAgICAgICBxcy5maWVsZHMgPSAnJztcbiAgICAgICAgICAgIG9wdHMuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcXMuZmllbGRzICs9IGZpZWxkICsgJywnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmV4cGFuZCkge1xuICAgICAgICAgICAgcXMuZXhwYW5kID0gJyc7XG4gICAgICAgICAgICBvcHRzLmV4cGFuZC5mb3JFYWNoKGZ1bmN0aW9uIChleCkge1xuICAgICAgICAgICAgICAgIHFzLmV4cGFuZCArPSBleCArICcsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBxcy5wcm9wZXJ0aWVzID0gJyc7XG4gICAgICAgICAgICBvcHRzLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHFzLnByb3BlcnRpZXMgKz0gcHJvcCArICcsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoYmFzZVBhdGggKyBwYXRoKSxcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHFzOiBxcyxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGpzb246IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdWdnZXN0ZWQgaXNzdWVzIHdoaWNoIG1hdGNoIHRoZSBhdXRvLWNvbXBsZXRpb24gcXVlcnkgZm9yIHRoZSBcbiAgICAgKiB1c2VyIHdoaWNoIGV4ZWN1dGVzIHRoaXMgcmVxdWVzdC4gVGhpcyBSRVNUIG1ldGhvZCB3aWxsIGNoZWNrIHRoZSB1c2VyJ3MgXG4gICAgICogaGlzdG9yeSBhbmQgdGhlIHVzZXIncyBicm93c2luZyBjb250ZXh0IGFuZCBzZWxlY3QgdGhpcyBpc3N1ZXMsIHdoaWNoIFxuICAgICAqIG1hdGNoIHRoZSBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0SXNzdWVQaWNrZXJcbiAgICAgKiBAbWVtYmVyT2YgSXNzdWVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5xdWVyeV0gdGhlIHF1ZXJ5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmN1cnJlbnRKUUxdIHRoZSBKUUwgaW4gY29udGV4dCBvZiB3aGljaCB0aGUgcmVxdWVzdCBcbiAgICAgKiAgICAgICAgICAgICAgICAgaXMgZXhlY3V0ZWQuIE9ubHkgaXNzdWVzIHdoaWNoIG1hdGNoIHRoaXMgSlFMIHF1ZXJ5IHdpbGwgYmUgXG4gICAgICogICAgICAgICAgICAgICAgIGluY2x1ZGVkIGluIHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmN1cnJlbnRJc3N1ZUtleV0gdGhlIGtleSBvZiB0aGUgaXNzdWUgaW4gY29udGV4dCBvZiBcbiAgICAgKiAgICAgICAgICAgICAgICAgd2hpY2ggdGhlIHJlcXVlc3QgaXMgZXhlY3V0ZWQuIFRoZSBpc3N1ZSB3aGljaCBpcyBpbiBjb250ZXh0IFxuICAgICAqICAgICAgICAgICAgICAgICB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgYXV0by1jb21wbGV0aW9uIHJlc3VsdCwgZXZlbiBpZiBcbiAgICAgKiAgICAgICAgICAgICAgICAgaXQgbWF0Y2hlcyB0aGUgcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmN1cnJlbnRQcm9qZWN0SWRdIHRoZSBpZCBvZiB0aGUgcHJvamVjdCBpbiBjb250ZXh0IG9mIFxuICAgICAqICAgICAgICAgICAgICAgICB3aGljaCB0aGUgcmVxdWVzdCBpcyBleGVjdXRlZC4gU3VnZ2VzdGVkIGlzc3VlcyB3aWxsIGJlIG9ubHkgXG4gICAgICogICAgICAgICAgICAgICAgIGZyb20gdGhpcyBwcm9qZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2hvd1N1YlRhc2tzXSBpZiBzZXQgdG8gZmFsc2UsIHN1YnRhc2tzIHdpbGwgbm90IGJlIFxuICAgICAqICAgICAgICAgICAgICAgICAgaW5jbHVkZWQgaW4gdGhlIGxpc3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zaG93U3ViVGFza1BhcmVudF0gaWYgc2V0IHRvIGZhbHNlIGFuZCByZXF1ZXN0IGlzIFxuICAgICAqICAgICAgICAgICAgICAgICAgZXhlY3V0ZWQgaW4gY29udGV4dCBvZiBhIHN1YnRhc2ssIHRoZSBwYXJlbnQgaXNzdWUgd2lsbCBcbiAgICAgKiAgICAgICAgICAgICAgICAgIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgYXV0by1jb21wbGV0aW9uIHJlc3VsdCwgZXZlbiBpZiBpdCBcbiAgICAgKiAgICAgICAgICAgICAgICAgIG1hdGNoZXMgdGhlIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBpc3N1ZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBpc3N1ZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldElzc3VlUGlja2VyID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9pc3N1ZS9waWNrZXInKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogb3B0cy5xdWVyeSxcbiAgICAgICAgICAgICAgICBjdXJyZW50SlFMOiBvcHRzLmN1cnJlbnRKUUwsXG4gICAgICAgICAgICAgICAgY3VycmVudElzc3VlS2V5OiBvcHRzLmN1cnJlbnRJc3N1ZUtleSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvamVjdElkOiBvcHRzLmN1cnJlbnRQcm9qZWN0SWQsXG4gICAgICAgICAgICAgICAgc2hvd1N1YlRhc2tzOiBvcHRzLnNob3dTdWJUYXNrcyxcbiAgICAgICAgICAgICAgICBzaG93U3ViVGFza1BhcmVudDogb3B0cy5zaG93U3ViVGFza1BhcmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZXJyb3JTdHJpbmdzID0gcmVxdWlyZSgnLi8uLi9saWIvZXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJc3N1ZUxpbmtDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvaXNzdWVMaW5rJ1xuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgSXNzdWVMaW5rQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIElzc3VlTGlua0NsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaXNzdWUgbGluayBiZXR3ZWVuIHR3byBpc3N1ZXMuIFRoZSB1c2VyIHJlcXVpcmVzIHRoZSBsaW5rIGlzc3VlIHBlcm1pc3Npb24gZm9yIHRoZSBpc3N1ZSB3aGljaCB3aWxsXG4gICAgICogYmUgbGlua2VkIHRvIGFub3RoZXIgaXNzdWUuIFRoZSBzcGVjaWZpZWQgbGluayB0eXBlIGluIHRoZSByZXF1ZXN0IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBsaW5rIGFuZCB3aWxsIGNyZWF0ZSBhXG4gICAgICogbGluayBmcm9tIHRoZSBmaXJzdCBpc3N1ZSB0byB0aGUgc2Vjb25kIGlzc3VlIHVzaW5nIHRoZSBvdXR3YXJkIGRlc2NyaXB0aW9uLiBJdCBhbHNvIGNyZWF0ZSBhIGxpbmsgZnJvbSB0aGVcbiAgICAgKiBzZWNvbmQgaXNzdWUgdG8gdGhlIGZpcnN0IGlzc3VlIHVzaW5nIHRoZSBpbndhcmQgZGVzY3JpcHRpb24gb2YgdGhlIGlzc3VlIGxpbmsgdHlwZS4gSXQgd2lsbCBhZGQgdGhlIHN1cHBsaWVkXG4gICAgICogY29tbWVudCB0byB0aGUgZmlyc3QgaXNzdWUuIFRoZSBjb21tZW50IGNhbiBoYXZlIGEgcmVzdHJpY3Rpb24gd2hvIGNhbiB2aWV3IGl0LiBJZiBncm91cCBpcyBzcGVjaWZpZWQsIG9ubHlcbiAgICAgKiB1c2VycyBvZiB0aGlzIGdyb3VwIGNhbiB2aWV3IHRoaXMgY29tbWVudCwgaWYgcm9sZUxldmVsIGlzIHNwZWNpZmllZCBvbmx5IHVzZXJzIHdobyBoYXZlIHRoZSBzcGVjaWZpZWQgcm9sZSBjYW5cbiAgICAgKiB2aWV3IHRoaXMgY29tbWVudC4gVGhlIHVzZXIgd2hvIGNyZWF0ZXMgdGhlIGlzc3VlIGxpbmsgbmVlZHMgdG8gYmVsb25nIHRvIHRoZSBzcGVjaWZpZWQgZ3JvdXAgb3IgaGF2ZSB0aGVcbiAgICAgKiBzcGVjaWZpZWQgcm9sZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUxpbmtDbGllbnQjXG4gICAgICogQG1ldGhvZCBjcmVhdGVJc3N1ZUxpbmtcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3Qgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy5pc3N1ZUxpbmsgU2VlIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmU1MDEwfVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBsaW5rIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgbGluayBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlSXNzdWVMaW5rID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5pc3N1ZUxpbmspIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fSVNTVUVfTElOS19FUlJPUik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9pc3N1ZUxpbmsnKSxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBvcHRzLmlzc3VlTGlua1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdJc3N1ZSBMaW5rIENyZWF0ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBpc3N1ZSBsaW5rIHdpdGggdGhlIHNwZWNpZmllZCBpZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0SXNzdWVMaW5rXG4gICAgICogQG1lbWJlck9mIElzc3VlTGlua0NsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgb3B0aW9ucyB1c2VkIGluIHRoZSByZXF1ZXN0IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLmxpbmtJZCBUaGUgaWQgb2YgdGhlIGxpbmsgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIElzc3VlIExpbmsgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIElzc3VlIExpbmsgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0SXNzdWVMaW5rID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5saW5rSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fSVNTVUVfTElOS19JRF9FUlJPUik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2lzc3VlTGluay8nICsgb3B0cy5saW5rSWQpLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIGlzc3VlIGxpbmsgd2l0aCB0aGUgc3BlY2lmaWVkIGlkLiBUbyBiZSBhYmxlIHRvIGRlbGV0ZSBhbiBpc3N1ZSBsaW5rIHlvdSBtdXN0IGJlIGFibGUgdG8gdmlldyBib3RoXG4gICAgICogaXNzdWVzIGFuZCBtdXN0IGhhdmUgdGhlIGxpbmsgaXNzdWUgcGVybWlzc2lvbiBmb3IgYXQgbGVhc3Qgb25lIG9mIHRoZSBpc3N1ZXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlbGV0ZUlzc3VlTGlua1xuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUxpbmtDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIG9wdGlvbnMgdXNlZCBpbiB0aGUgcmVxdWVzdCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy5saW5rSWQgVGhlIGlkIG9mIHRoZSBsaW5rIHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgSXNzdWUgTGluayBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIElzc3VlIExpbmsgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZUlzc3VlTGluayA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMubGlua0lkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0lTU1VFX0xJTktfSURfRVJST1IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9pc3N1ZUxpbmsvJyArIG9wdHMubGlua0lkKSxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnSXNzdWUgTGluayBEZWxldGVkJyk7XG4gICAgfTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGVycm9yU3RyaW5ncyA9IHJlcXVpcmUoJy4vLi4vbGliL2Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNzdWVMaW5rVHlwZUNsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9pc3N1ZUxpbmtUeXBlJ1xuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgSXNzdWVMaW5rVHlwZUNsaWVudFxuICovXG5mdW5jdGlvbiBJc3N1ZUxpbmtUeXBlQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiBhdmFpbGFibGUgaXNzdWUgbGluayB0eXBlcywgaWYgaXNzdWUgbGlua2luZyBpcyBlbmFibGVkLiBFYWNoIGlzc3VlIGxpbmsgdHlwZSBoYXMgYW4gaWQsIGEgbmFtZVxuICAgICAqIGFuZCBhIGxhYmVsIGZvciB0aGUgb3V0d2FyZCBhbmQgaW53YXJkIGxpbmsgcmVsYXRpb25zaGlwLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRBdmFpbGFibGVUeXBlc1xuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUxpbmtUeXBlQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgZm9yIHRoZSBBUEkuICBJZ25vcmVkIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGF2YWlsYWJsZSBJc3N1ZUxpbmsgdHlwZXMgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhdmFpbGFibGUgSXNzdWVMaW5rIHR5cGVzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRBdmFpbGFibGVUeXBlcyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvaXNzdWVMaW5rVHlwZScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGlzc3VlIGxpbmsgdHlwZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlSXNzdWVMaW5rVHlwZVxuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUxpbmtUeXBlQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy5saW5rVHlwZSBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTIwMTh9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIElzc3VlTGluayB0eXBlIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgSXNzdWVMaW5rIHR5cGUgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZUlzc3VlTGlua1R5cGUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2lzc3VlTGlua1R5cGUnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMubGlua1R5cGVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBmb3IgYSBnaXZlbiBpc3N1ZSBsaW5rIHR5cGUgaWQgYWxsIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgaXNzdWUgbGluayB0eXBlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRJc3N1ZUxpbmtUeXBlXG4gICAgICogQG1lbWJlck9mIElzc3VlTGlua1R5cGVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLmlzc3VlTGlua1R5cGVJZCBUaGUgaWQgb2YgdGhlIElzc3VlTGluayB0eXBlIHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBJc3N1ZUxpbmsgdHlwZSBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBJc3N1ZUxpbmsgdHlwZSBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICAgKi9cbiAgICB0aGlzLmdldElzc3VlTGlua1R5cGUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFvcHRzLmlzc3VlTGlua1R5cGVJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19JU1NVRV9MSU5LX1RZUEVfSUQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2lzc3VlTGlua1R5cGUvJyArIG9wdHMuaXNzdWVMaW5rVHlwZUlkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgc3BlY2lmaWVkIGlzc3VlIGxpbmsgdHlwZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlSXNzdWVMaW5rVHlwZVxuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUxpbmtUeXBlQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy5pc3N1ZUxpbmtUeXBlSWQgVGhlIGlkIG9mIHRoZSBJc3N1ZUxpbmsgdHlwZSB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIElzc3VlTGluayB0eXBlIGhhcyBiZWVuIGRlbGV0ZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIElzc3VlTGluayB0eXBlIGhhcyBiZWVuIGRlbGV0ZVxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlSXNzdWVMaW5rVHlwZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIW9wdHMuaXNzdWVMaW5rVHlwZUlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0lTU1VFX0xJTktfVFlQRV9JRCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvaXNzdWVMaW5rVHlwZS8nICsgb3B0cy5pc3N1ZUxpbmtUeXBlSWQpLFxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnSXNzdWVMaW5rIHR5cGUgZGVsZXRlZC4nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzcGVjaWZpZWQgaXNzdWUgbGluayB0eXBlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBlZGl0SXNzdWVMaW5rVHlwZVxuICAgICAqIEBtZW1iZXJPZiBJc3N1ZUxpbmtUeXBlQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy5pc3N1ZUxpbmtUeXBlSWQgVGhlIGlkIG9mIHRoZSBJc3N1ZUxpbmsgdHlwZSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gb3B0cy5saW5rVHlwZSBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTIwNzF9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIElzc3VlTGluayB0eXBlIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgSXNzdWVMaW5rIHR5cGUgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmVkaXRJc3N1ZUxpbmtUeXBlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghb3B0cy5pc3N1ZUxpbmtUeXBlSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fSVNTVUVfTElOS19UWVBFX0lEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9pc3N1ZUxpbmtUeXBlLycgKyBvcHRzLmlzc3VlTGlua1R5cGVJZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMuaXNzdWVMaW5rVHlwZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gSXNzdWVUeXBlQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL2lzc3VldHlwZSdcbiAqXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBJc3N1ZVR5cGVDbGllbnRcbiAqL1xuZnVuY3Rpb24gSXNzdWVUeXBlQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGlzc3VlIHR5cGVzIHZpc2libGUgdG8gdGhlIHVzZXJcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0QWxsSXNzdWVUeXBlc1xuICAgICAqIEBtZW1iZXJPZiBJc3N1ZVR5cGVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgSWdub3JlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGlzc3VlIHR5cGVzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgaXNzdWUgdHlwZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEFsbElzc3VlVHlwZXMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2lzc3VldHlwZScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpc3N1ZSB0eXBlIGZyb20gYSBKU09OIHJlcHJlc2VudGF0aW9uIGFuZCBhZGRzIHRoZSBpc3N1ZSBuZXdseVxuICAgICAqIGNyZWF0ZWQgaXNzdWUgdHlwZSB0byB0aGUgZGVmYXVsdCBpc3N1ZSB0eXBlIHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlSXNzdWVUeXBlXG4gICAgICogQG1lbWJlck9mIElzc3VlVHlwZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaXNzdWVUeXBlIE9iamVjdCBjb250YWluaW5nIGRldGFpbHMgb2YgdGhlIG5ldyBpc3N1ZVR5cGUuXG4gICAgICogICAgICBTY2hlbWE6XG4gICAgICogICAgICAqIFwibmFtZVwiIC0gVGhlIG5hbWUgb2YgdGhlIGlzc3VlIHR5cGVcbiAgICAgKiAgICAgICogXCJkZXNjcmlwdGlvblwiIC0gU29tZSBkZXNjcmlwdGlvbiBhYm91dCB0aGUgaXNzdWUgdHlwZVxuICAgICAqICAgICAgKiBcInR5cGVcIiAtIENhbiBoYXZlIGVpdGhlciBcInN1YnRhc2tcIiBvciBcInN0YW5kYXJkXCIgYXMgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBpc3N1ZSB0eXBlIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgaXNzdWUgdHlwZSBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlSXNzdWVUeXBlID0gZnVuY3Rpb24gKGlzc3VlVHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2lzc3VldHlwZScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogaXNzdWVUeXBlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IGEgZnVsbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgaXNzdWUgdHlwZSB0aGF0IGhhcyB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldElzc3VlVHlwZVxuICAgICAqIEBtZW1iZXJPZiBJc3N1ZVR5cGVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5pc3N1ZVR5cGVJZCBBIFN0cmluZyBjb250YWluaW5nIGFuIGlzc3VlIHR5cGUgaWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBpc3N1ZSB0eXBlIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBpc3N1ZSB0eXBlIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldElzc3VlVHlwZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvaXNzdWV0eXBlLycgKyBvcHRzLmlzc3VlVHlwZUlkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCBpc3N1ZSB0eXBlLlxuICAgICAqIElmIHRoZSBpc3N1ZSB0eXBlIGhhcyBhbnkgYXNzb2NpYXRlZCBpc3N1ZXMsIHRoZXNlIGlzc3VlcyB3aWxsIGJlXG4gICAgICogbWlncmF0ZWQgdG8gdGhlIGFsdGVybmF0aXZlIGlzc3VlIHR5cGUgc3BlY2lmaWVkIGluIHRoZSBwYXJhbWV0ZXIuXG4gICAgICogWW91IGNhbiBkZXRlcm1pbmUgdGhlIGFsdGVybmF0aXZlIGlzc3VlIHR5cGVzIGJ5IGNhbGxpbmcgdGhlIC9yZXN0L2FwaS8yL2lzc3VldHlwZS97aWR9L2FsdGVybmF0aXZlcyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlSXNzdWVUeXBlXG4gICAgICogQG1lbWJlck9mIElzc3VlVHlwZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyB0byBzZW5kIHRvIHRoZSBKSVJBIEFQSVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmlzc3VlVHlwZUlkIElEIG9mIHRoZSBpc3N1ZVR5cGUgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5hbHRlcm5hdGl2ZUlzc3VlVHlwZUlkIHRoZSBpZCBvZiBhbiBpc3N1ZSB0eXBlIHRvIHdoaWNoIGlzc3Vlc1xuICAgICAqICAgICAgICAgIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVtb3ZlZCBpc3N1ZSB0eXBlIHdpbGwgYmUgbWlncmF0ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgaXNzdWUgdHlwZSBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGlzc3VlIHR5cGUgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZUlzc3VlVHlwZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvaXNzdWV0eXBlLycgKyBvcHRzLmlzc3VlVHlwZUlkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZUlzc3VlVHlwZUlkOiBvcHRzLmFsdGVybmF0aXZlSXNzdWVUeXBlSWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzcGVjaWZpZWQgaXNzdWUgdHlwZSBmcm9tIGEgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgdXBkYXRlSXNzdWVUeXBlXG4gICAgICogQG1lbWJlck9mIElzc3VlVHlwZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLmlzc3VlVHlwZUlkIElEIG9mIHRoZSBpc3N1ZSB0eXBlIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5pc3N1ZVR5cGUgT2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlscyBvZiB0aGUgaXNzdWVUeXBlIHRvIGJlIHVwZGF0ZWQuXG4gICAgICogICAgICBTY2hlbWE6XG4gICAgICogICAgICAqIFwibmFtZVwiIC0gVGhlIG5hbWUgb2YgdGhlIGlzc3VlIHR5cGVcbiAgICAgKiAgICAgICogXCJkZXNjcmlwdGlvblwiIC0gU29tZSBkZXNjcmlwdGlvbiBhYm91dCB0aGUgaXNzdWUgdHlwZVxuICAgICAqICAgICAgKiBcImF2YXRhcklkXCIgLSBJbnRlZ2VyIGNvbnRhaW5pbmcgdGhlIGF2YXRhciBJRFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGlzc3VlIHR5cGUgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBpc3N1ZSB0eXBlIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICovXG4gICAgdGhpcy51cGRhdGVJc3N1ZVR5cGUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2lzc3VldHlwZS8nICsgb3B0cy5pc3N1ZVR5cGVJZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMuaXNzdWVUeXBlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgYWx0ZXJuYXRpdmUgaXNzdWUgdHlwZXMgZm9yIHRoZSBnaXZlbiBpc3N1ZSB0eXBlIGlkLlxuICAgICAqIFRoZSBsaXN0IHdpbGwgY29udGFpbiB0aGVzZSBpc3N1ZXMgdHlwZXMsIHRvIHdoaWNoIGlzc3VlcyBhc3NpZ25lZCB0byB0aGUgZ2l2ZW5cbiAgICAgKiBpc3N1ZSB0eXBlIGNhbiBiZSBtaWdyYXRlZC4gVGhlIHN1aXRhYmxlIGFsdGVybmF0aXZlcyBhcmUgaXNzdWUgdHlwZXMgd2hpY2ggYXJlXG4gICAgICogYXNzaWduZWQgdG8gdGhlIHNhbWUgd29ya2Zsb3csIHRoZSBzYW1lIGZpZWxkIGNvbmZpZ3VyYXRpb24gYW5kIHRoZSBzYW1lIHNjcmVlbiBzY2hlbWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEFsdGVybmF0aXZlSXNzdWVUeXBlc1xuICAgICAqIEBtZW1iZXJPZiBJc3N1ZVR5cGVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5pc3N1ZVR5cGVJZCBBIFN0cmluZyBjb250YWluaW5nIGFuIGlzc3VlIHR5cGUgaWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBpc3N1ZSB0eXBlIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBpc3N1ZSB0eXBlIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEFsdGVybmF0aXZlSXNzdWVUeXBlcyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvaXNzdWV0eXBlLycgKyBvcHRzLmlzc3VlVHlwZUlkICsgJy9hbHRlcm5hdGl2ZXMnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBKcWxDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvanFsL2F1dG9jb21wbGV0ZWRhdGEnXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgSnFsQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIEpxbENsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF1dG8gY29tcGxldGUgZGF0YSByZXF1aXJlZCBmb3IgSlFMIHNlYXJjaGVzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRBdXRvQ29tcGxldGVEYXRhXG4gICAgICogQG1lbWJlck9mIEpxbENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS4gIElnbm9yZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgYXV0b2NvbXBsZXRlIGRhdGEgaXMgcmV0dXJuZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgYXV0b2NvbXBsZXRlIGRhdGEgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRBdXRvQ29tcGxldGVEYXRhID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9qcWwvYXV0b2NvbXBsZXRlZGF0YScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBMaWNlbnNlUm9sZUNsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9saWNlbnNlcm9sZSdcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIExpY2Vuc2VSb2xlQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIExpY2Vuc2VSb2xlQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgbGljZW5zZSByb2xlcyBpbiB0aGUgc3lzdGVtLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRBbGxMaWNlbnNlUm9sZXNcbiAgICAgKiBAbWVtYmVyT2YgTGljZW5zZVJvbGVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgSWdub3JlZFxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBsaWNlbnNlIHJvbGVzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgbGljZW5zZSByb2xlcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0QWxsTGljZW5zZVJvbGVzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9saWNlbnNlcm9sZScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFzc2VkIGxpY2Vuc2Ugcm9sZSBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldExpY2Vuc2VSb2xlXG4gICAgICogQG1lbWJlck9mIExpY2Vuc2VSb2xlQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMucm9sZUlkIFRoZSBpZCBvZiB0aGUgbGljZW5zZSByb2xlIHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBsaWNlbnNlIHJvbGUgaXMgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGxpY2Vuc2Ugcm9sZSBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRMaWNlbnNlUm9sZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvbGljZW5zZXJvbGUvJyArIG9wdHMucm9sZUlkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxpY2Vuc2Ugcm9sZSB3aXRoIHRoZSBwYXNzZWQgZGF0YS4gT25seSB0aGUgZ3JvdXBzIG9mIHRoZSByb2xlIG1heSBiZSB1cGRhdGVkLiBSZXF1ZXN0cyB0byBjaGFuZ2VcbiAgICAgKiB0aGUgaWQgb3IgdGhlIG5hbWUgb2YgdGhlIHJvbGUgd2lsbCBiZSBzaWxlbnRseSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBlZGl0TGljZW5zZVJvbGVcbiAgICAgKiBAbWVtYmVyT2YgTGljZW5zZVJvbGVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy5yb2xlSWQgVGhlIGlkIG9mIHRoZSBsaWNlbnNlIHJvbGUgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIG9wdHMucm9sZSBUaGUgbmV3IGRhdGEgdG8gcGxhY2UgaW4gdGhlIHJvbGUuICBTZWVcbiAgICAgKiAge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTM2NX1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgbGljZW5zZSByb2xlIGlzIGVkaXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBsaWNlbnNlIHJvbGUgaXMgZWRpdGVkLlxuICAgICAqL1xuICAgIHRoaXMuZWRpdExpY2Vuc2VSb2xlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9saWNlbnNlcm9sZS8nICsgb3B0cy5yb2xlSWQpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBvcHRzLnJvbGVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gTGljZW5zZVZhbGlkYXRvckNsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9saWNlbnNlVmFsaWRhdG9yJ1xuICpcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIExpY2Vuc2VWYWxpZGF0b3JDbGllbnRcbiAqL1xuZnVuY3Rpb24gTGljZW5zZVZhbGlkYXRvckNsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1ldGhvZCB2YWxpZGF0ZUxpY2Vuc2VcbiAgICAgKiBAbWVtYmVyT2YgTGljZW5zZVZhbGlkYXRvckNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLmxpY2Vuc2UgVGhlIGxpY2Vuc2UgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGxpY2Vuc2UgaGFzIGJlZW4gdmFsaWRhdGVkLCBvciBmYWlscyB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBsaWNlbnNlIGhhcyBiZWVuIHZhbGlkYXRlZCwgb3IgZmFpbHMgdG8gdmFsaWRhdGUuXG4gICAgICovXG4gICAgdGhpcy52YWxpZGF0ZUxpY2Vuc2UgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL2xpY2Vuc2VWYWxpZGF0b3InKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMubGljZW5zZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBNeVBlcm1pc3Npb25zQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL215cGVybWlzc2lvbnMnXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgTXlQZXJtaXNzaW9uc0NsaWVudFxuICovXG5mdW5jdGlvbiBNeVBlcm1pc3Npb25zQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgcGVybWlzc2lvbnMgaW4gdGhlIHN5c3RlbSBhbmQgd2hldGhlciB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIGhhcyB0aGVtLiBZb3UgY2FuIG9wdGlvbmFsbHlcbiAgICAgKiBwcm92aWRlIGEgc3BlY2lmaWMgY29udGV4dCB0byBnZXQgcGVybWlzc2lvbnMgZm9yIChwcm9qZWN0S2V5IE9SIHByb2plY3RJZCBPUiBpc3N1ZUtleSBPUiBpc3N1ZUlkKVxuICAgICAqXG4gICAgICogKiBXaGVuIG5vIGNvbnRleHQgc3VwcGxpZWQgdGhlIHByb2plY3QgcmVsYXRlZCBwZXJtaXNzaW9ucyB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSB1c2VyIGhhcyB0aGF0IHBlcm1pc3Npb24gaW5cbiAgICAgKiBBTlkgcHJvamVjdFxuICAgICAqICogSWYgYSBwcm9qZWN0IGNvbnRleHQgaXMgcHJvdmlkZWQsIHByb2plY3QgcmVsYXRlZCBwZXJtaXNzaW9ucyB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSB1c2VyIGhhcyB0aGUgcGVybWlzc2lvbnNcbiAgICAgKiBpbiB0aGUgc3BlY2lmaWVkIHByb2plY3QuIEZvciBwZXJtaXNzaW9ucyB0aGF0IGFyZSBkZXRlcm1pbmVkIHVzaW5nIGlzc3VlIGRhdGEgKGUuZyBDdXJyZW50IEFzc2lnbmVlKSwgdHJ1ZSB3aWxsXG4gICAgICogYmUgcmV0dXJuZWQgaWYgdGhlIHVzZXIgbWVldHMgdGhlIHBlcm1pc3Npb24gY3JpdGVyaWEgaW4gQU5ZIGlzc3VlIGluIHRoYXQgcHJvamVjdFxuICAgICAqICogSWYgYW4gaXNzdWUgY29udGV4dCBpcyBwcm92aWRlZCwgaXQgd2lsbCByZXR1cm4gd2hldGhlciBvciBub3QgdGhlIHVzZXIgaGFzIGVhY2ggcGVybWlzc2lvbiBpbiB0aGF0IHNwZWNpZmljXG4gICAgICogaXNzdWVcbiAgICAgKlxuICAgICAqIE5COiBUaGUgYWJvdmUgbWVhbnMgdGhhdCBmb3IgaXNzdWUtbGV2ZWwgcGVybWlzc2lvbnMgKEVESVRfSVNTVUUgZm9yIGV4YW1wbGUpLCBoYXNQZXJtaXNzaW9uIG1heSBiZSB0cnVlIHdoZW4gbm9cbiAgICAgKiBjb250ZXh0IGlzIHByb3ZpZGVkLCBvciB3aGVuIGEgcHJvamVjdCBjb250ZXh0IGlzIHByb3ZpZGVkLCBidXQgbWF5IGJlIGZhbHNlIGZvciBhbnkgZ2l2ZW4gKG9yIGFsbCkgaXNzdWVzLiBUaGlzXG4gICAgICogd291bGQgb2NjdXIgKGZvciBleGFtcGxlKSBpZiBSZXBvcnRlcnMgd2VyZSBnaXZlbiB0aGUgRURJVF9JU1NVRSBwZXJtaXNzaW9uLiBUaGlzIGlzIGJlY2F1c2UgYW55IHVzZXIgY291bGQgYmUgYVxuICAgICAqIHJlcG9ydGVyLCBleGNlcHQgaW4gdGhlIGNvbnRleHQgb2YgYSBjb25jcmV0ZSBpc3N1ZSwgd2hlcmUgdGhlIHJlcG9ydGVyIGlzIGtub3duLlxuICAgICAqXG4gICAgICogR2xvYmFsIHBlcm1pc3Npb25zIHdpbGwgc3RpbGwgYmUgcmV0dXJuZWQgZm9yIGFsbCBzY29wZXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldE15UGVybWlzc2lvbnNcbiAgICAgKiBAbWVtYmVyT2YgTXlQZXJtaXNzaW9uc0NsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHBlcm1pc3Npb25zIGhhdmUgYmVlbiByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwZXJtaXNzaW9ucyBoYXZlIGJlZW4gcmV0dXJuZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRNeVBlcm1pc3Npb25zID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9teXBlcm1pc3Npb25zJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVJZDogb3B0cy5pc3N1ZUlkLFxuICAgICAgICAgICAgICAgIGlzc3VlS2V5OiBvcHRzLmlzc3VlS2V5LFxuICAgICAgICAgICAgICAgIHByb2plY3RJZDogb3B0cy5wcm9qZWN0SWQsXG4gICAgICAgICAgICAgICAgcHJvamVjdEtleTogb3B0cy5wcm9qZWN0S2V5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBNeVByZWZlcmVuY2VzQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL215cHJlZmVyZW5jZXMnXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgTXlQcmVmZXJlbmNlc0NsaWVudFxuICovXG5mdW5jdGlvbiBNeVByZWZlcmVuY2VzQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBwcmVmZXJlbmNlIG9mIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuIFByZWZlcmVuY2Uga2V5IG11c3QgYmUgcHJvdmlkZWQgYXMgaW5wdXQgcGFyYW1ldGVyIChrZXkpLlxuICAgICAqIFRoZSB2YWx1ZSBpcyByZXR1cm5lZCBleGFjdGx5IGFzIGl0IGlzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRQcmVmZXJlbmNlXG4gICAgICogQG1lbWJlck9mIE15UHJlZmVyZW5jZXNDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW5kIHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy5rZXkgS2V5IG9mIHRoZSBwcmVmZXJlbmNlIHRvIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBwcmVmZXJlbmNlIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwcmVmZXJlbmNlIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFByZWZlcmVuY2UgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL215cHJlZmVyZW5jZXMnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IG9wdHMua2V5XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgcHJlZmVyZW5jZSBvZiB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLiBQcmVmZXJlbmNlIGtleSBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0IHBhcmFtZXRlcnMgKGtleSkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVkaXRQcmVmZXJlbmNlXG4gICAgICogQG1lbWJlck9mIE15UHJlZmVyZW5jZXNDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW5kIHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy5rZXkgS2V5IG9mIHRoZSBwcmVmZXJlbmNlIHRvIGJlIGVkaXRlZC5cbiAgICAgKiBAcGFyYW0gb3B0cy52YWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldCBmb3IgdGhlIHByZWZlcmVuY2UuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHByZWZlcmVuY2UgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHByZWZlcmVuY2UgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqL1xuICAgIHRoaXMuZWRpdFByZWZlcmVuY2UgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL215cHJlZmVyZW5jZXMnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBrZXk6IG9wdHMua2V5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogb3B0cy52YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHByZWZlcmVuY2Ugb2YgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci4gUHJlZmVyZW5jZSBrZXkgbXVzdCBiZSBwcm92aWRlZCBhcyBpbnB1dCBwYXJhbWV0ZXJzIChrZXkpLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZWxldGVQcmVmZXJlbmNlXG4gICAgICogQG1lbWJlck9mIE15UHJlZmVyZW5jZXNDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW5kIHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy5rZXkgS2V5IG9mIHRoZSBwcmVmZXJlbmNlIHRvIGJlIGRlbGV0ZWQuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHByZWZlcmVuY2UgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwcmVmZXJlbmNlIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICovXG4gICAgdGhpcy5kZWxldGVQcmVmZXJlbmNlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9teXByZWZlcmVuY2VzJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiB7XG4gICAgICAgICAgICAgICAga2V5OiBvcHRzLmtleVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBNeXNlbGZDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvbXlzZWxmJ1xuICpcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIE15c2VsZkNsaWVudFxuICovXG5mdW5jdGlvbiBNeXNlbGZDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnRseSBsb2dnZWQgdXNlci4gVGhpcyByZXNvdXJjZSBjYW5ub3QgYmUgYWNjZXNzZWQgYW5vbnltb3VzbHkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldE15c2VsZlxuICAgICAqIEBtZW1iZXJPZiBNeXNlbGZDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgSWdub3JlZFxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBjdXJyZW50IHVzZXIgaXMgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGN1cnJlbnQgdXNlciBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRNeXNlbGYgPSBmdW5jdGlvbiAoZGVidWcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9teXNlbGYnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgZGVidWc6IGRlYnVnLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgY3VycmVudGx5IGxvZ2dlZCB1c2VyLiBUaGUgXCJ2YWx1ZVwiIGZpZWxkcyBwcmVzZW50IHdpbGwgb3ZlcnJpZGUgdGhlIGV4aXN0aW5nIHZhbHVlLiBGaWVsZHMgc2tpcHBlZCBpblxuICAgICAqIHJlcXVlc3Qgd2lsbCBub3QgYmUgY2hhbmdlZC4gT25seSBlbWFpbCBhbmQgZGlzcGxheSBuYW1lIGNhbiBiZSBjaGFuZ2UgdGhhdCB3YXkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVkaXRNeXNlbGZcbiAgICAgKiBAbWVtYmVyT2YgTXlzZWxmQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VuZCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMubmV3RGF0YSBUaGUgbmV3IGRhdGEuICBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTEyNDJ9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHVzZXIncyBkYXRhIGhhcyBiZWVuIG1vZGlmaWVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgdXNlcidzIGRhdGEgaGFzIGJlZW4gbW9kaWZpZWRcbiAgICAgKi9cbiAgICB0aGlzLmVkaXRNeXNlbGYgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL215c2VsZicpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBvcHRzLm5ld0RhdGFcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IGNhbGxlciBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY2hhbmdlUGFzc3dvcmRcbiAgICAgKiBAbWVtYmVyT2YgTXlzZWxmQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMubmV3RGF0YSBUaGUgbmV3IGRhdGFcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcGFzc3dvcmQgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwYXNzd29yZCBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlUGFzc3dvcmQgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL215c2VsZi9wYXNzd29yZCcpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBvcHRzLm5ld0RhdGFcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzd29yZENsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9wYXNzd29yZCdcbiAqXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBQYXNzd29yZENsaWVudFxuICovXG5mdW5jdGlvbiBQYXNzd29yZENsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdXNlci1mcmllbmRseSBzdGF0ZW1lbnRzIGdvdmVybmluZyB0aGUgc3lzdGVtJ3MgcGFzc3dvcmQgcG9saWN5LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRQYXNzd29yZFBvbGljeVxuICAgICAqIEBtZW1iZXJPZiBQYXNzd29yZENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHRvIHNlbmQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5oYXNPbGRQYXNzd29yZD1mYWxzZV0gV2hldGhlciBvciBub3QgdGhlIHVzZXIgd2lsbCBiZSByZXF1aXJlZCB0byBlbnRlciB0aGVpciBjdXJyZW50XG4gICAgICogICAgIHBhc3N3b3JkLiBVc2UgZmFsc2UgKHRoZSBkZWZhdWx0KSBpZiB0aGlzIGlzIGEgbmV3IHVzZXIgb3IgaWYgYW4gYWRtaW5pc3RyYXRvciBpcyBmb3JjaWJseSBjaGFuZ2luZyBhbm90aGVyXG4gICAgICogICAgIHVzZXIncyBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcGFzc3dvcmQgcG9saWN5IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwYXNzd29yZCBwb2xpY3kgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0UGFzc3dvcmRQb2xpY3kgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3Bhc3N3b3JkL3BvbGljeScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIGhhc09sZFBhc3N3b3JkOiBvcHRzLmhhc09sZFBhc3N3b3JkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcm1pc3Npb25TY2hlbWVDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvcGVybWlzc2lvbnNjaGVtZSdcbiAqXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBQZXJtaXNzaW9uU2NoZW1lQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIFBlcm1pc3Npb25TY2hlbWVDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgcGVybWlzc2lvbiBzY2hlbWVzLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCBvbmx5IHNob3J0ZW5lZCBiZWFucyBhcmUgcmV0dXJuZWQuXG4gICAgICogSWYgeW91IHdhbnQgdG8gaW5jbHVkZSBwZXJtaXNzaW9ucyBvZiBhbGwgdGhlIHNjaGVtZXMsIHRoZW4gc3BlY2lmeSB0aGUgcGVybWlzc2lvbnMgZXhwYW5kIHBhcmFtZXRlci5cbiAgICAgKiBQZXJtaXNzaW9ucyB3aWxsIGJlIGluY2x1ZGVkIGFsc28gaWYgeW91IHNwZWNpZnkgYW55IG90aGVyIGV4cGFuZCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEFsbFBlcm1pc3Npb25TY2hlbWVzXG4gICAgICogQG1lbWJlck9mIFBlcm1pc3Npb25TY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gb3B0cy5leHBhbmRcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc2NoZW1lcyBoYXZlIGJlZW4gcmV0dXJuZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc2NoZW1lcyBoYXZlIGJlZW4gcmV0dXJuZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRBbGxQZXJtaXNzaW9uU2NoZW1lcyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZXhwYW5kID0gb3B0cy5leHBhbmRcbiAgICAgICAgaWYgKG9wdHMuZXhwYW5kICYmIG9wdHMuZXhwYW5kIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGV4cGFuZCA9IG9wdHMuZXhwYW5kLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvcGVybWlzc2lvbnNjaGVtZScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIGV4cGFuZDogZXhwYW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHBlcm1pc3Npb24gc2NoZW1lLiBUaGlzIG1ldGhvZCBjYW4gY3JlYXRlIHNjaGVtZXMgd2l0aCBhIGRlZmluZWQgcGVybWlzc2lvbiBzZXQsIG9yIHdpdGhvdXQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVBlcm1pc3Npb25TY2hlbWVcbiAgICAgKiBAbWVtYmVyT2YgUGVybWlzc2lvblNjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLnNjaGVtZSBTZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLmF0bGFzc2lhbi5jb20vY2xvdWQvamlyYS9wbGF0Zm9ybS9yZXN0LyNhcGktYXBpLTItcGVybWlzc2lvbnNjaGVtZS1wb3N0fVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBzY2hlbWUgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBzY2hlbWUgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZVBlcm1pc3Npb25TY2hlbWUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3Blcm1pc3Npb25zY2hlbWUnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMuc2NoZW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgUGVybWlzc2lvblNjaGVtZS4gVGhpcyByZXNvdXJjZSBjYW5ub3QgYmUgYWNjZXNzZWQgYW5vbnltb3VzbHkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFBlcm1pc3Npb25TY2hlbWVcbiAgICAgKiBAbWVtYmVyT2YgUGVybWlzc2lvblNjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIG9wdHMuc2NoZW1lSWQgVGhlIGlkIG9mIHRoZSBzY2hlbWUgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuZXhwYW5kIFRoZSBmaWVsZHMgdG8gYmUgZXhwYW5kZWQuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHNjaGVtZSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc2NoZW1lIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFBlcm1pc3Npb25TY2hlbWUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGV4cGFuZCA9IG9wdHMuZXhwYW5kXG4gICAgICAgIGlmIChvcHRzLmV4cGFuZCAmJiBvcHRzLmV4cGFuZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBleHBhbmQgPSBvcHRzLmV4cGFuZC5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3Blcm1pc3Npb25zY2hlbWUvJyArIG9wdHMuc2NoZW1lSWQpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIGV4cGFuZDogZXhwYW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBwZXJtaXNzaW9uIHNjaGVtZS5cbiAgICAgKiBcbiAgICAgKiBJZiB0aGUgcGVybWlzc2lvbnMgbGlzdCBpcyBwcmVzZW50IHRoZW4gaXQgd2lsbCBiZSBzZXQgaW4gdGhlIHBlcm1pc3Npb24gc2NoZW1lLFxuICAgICAqIHdoaWNoIGJhc2ljYWxseSBtZWFucyBpdCB3aWxsIG92ZXJ3cml0ZSBhbnkgcGVybWlzc2lvbiBncmFudHMgdGhhdCBleGlzdGVkIGluIHRoZSBwZXJtaXNzaW9uIHNjaGVtZS5cbiAgICAgKiBTZW5kaW5nIGFuIGVtcHR5IGxpc3Qgd2lsbCByZW1vdmUgYWxsIHBlcm1pc3Npb24gZ3JhbnRzIGZyb20gdGhlIHBlcm1pc3Npb24gc2NoZW1lLlxuICAgICAqIFxuICAgICAqIFRvIHVwZGF0ZSBqdXN0IHRoZSBuYW1lIGFuZCBkZXNjcmlwdGlvbiwgZG8gbm90IHNlbmQgcGVybWlzc2lvbnMgbGlzdCBhdCBhbGwuXG4gICAgICogVG8gYWRkIG9yIHJlbW92ZSBhIHNpbmdsZSBwZXJtaXNzaW9uIGdyYW50IGluc3RlYWQgb2YgdXBkYXRpbmcgdGhlIHdob2xlIGxpc3RcbiAgICAgKiBhdCBvbmNlIHVzZSB0aGUge3NjaGVtZUlkfS9wZXJtaXNzaW9uLyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZWRpdFBlcm1pc3Npb25TY2hlbWVcbiAgICAgKiBAbWVtYmVyT2YgUGVybWlzc2lvblNjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIG9wdHMuc2NoZW1lSWQgVGhlIGlkIG9mIHRoZSBzY2hlbWUgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIG9wdHMuc2NoZW1lIFRoZSBib2R5IG9mIHRoZSBzY2hlbWUgdG8gZWRpdC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgYmVlbiBlZGl0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgdXNlciBoYXMgYmVlbiBlZGl0ZWQuXG4gICAgICovXG4gICAgdGhpcy5lZGl0UGVybWlzc2lvblNjaGVtZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvcGVybWlzc2lvbnNjaGVtZS8nICsgb3B0cy5zY2hlbWVJZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMuc2NoZW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgUGVybWlzc2lvbiBTY2hlbWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlbGV0ZVBlcm1pc3Npb25TY2hlbWVcbiAgICAgKiBAbWVtYmVyT2YgUGVybWlzc2lvblNjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIG9wdHMuc2NoZW1lSWQgVGhlIG5hbWUgb2YgdGhlIHNjaGVtZSB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHNjaGVtZSBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHNjaGVtZSBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlUGVybWlzc2lvblNjaGVtZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvcGVybWlzc2lvbnNjaGVtZS8nICsgb3B0cy5zY2hlbWVJZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdQZXJtaXNzaW9uIFNjaGVtZSByZW1vdmVkLicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBwZXJtaXNzaW9uIGdyYW50cyBvZiB0aGUgZ2l2ZW4gcGVybWlzc2lvbiBzY2hlbWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFBlcm1pc3Npb25TY2hlbWVHcmFudHNcbiAgICAgKiBAbWVtYmVyT2YgUGVybWlzc2lvblNjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIG9wdHMuc2NoZW1lSWQgVGhlIGlkIG9mIHRoZSBzY2hlbWUgdG8gd2hpY2ggdGhlIHBlcm1pc3Npb24gZ3JhbnQgYmVsb25ncy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5leHBhbmQgVGhlIGZpZWxkcyB0byBiZSBleHBhbmRlZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc2NoZW1lIGdyYW50cyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHNjaGVtZSBncmFudHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFBlcm1pc3Npb25TY2hlbWVHcmFudHMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGV4cGFuZCA9IG9wdHMuZXhwYW5kXG4gICAgICAgIGlmIChvcHRzLmV4cGFuZCAmJiBvcHRzLmV4cGFuZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBleHBhbmQgPSBvcHRzLmV4cGFuZC5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3Blcm1pc3Npb25zY2hlbWUvJyArIG9wdHMuc2NoZW1lSWQgKyAnL3Blcm1pc3Npb24nKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBleHBhbmQ6IGV4cGFuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcGVybWlzc2lvbiBncmFudCBpbiBhIHBlcm1pc3Npb24gc2NoZW1lLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVQZXJtaXNzaW9uR3JhbnRJblNjaGVtZVxuICAgICAqIEBtZW1iZXJPZiBQZXJtaXNzaW9uU2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMuc2NoZW1lSWQgVGhlIGlkIG9mIHRoZSBzY2hlbWUgdG8gd2hpY2ggdGhlIHBlcm1pc3Npb24gZ3JhbnQgYmVsb25ncy5cbiAgICAgKiBAcGFyYW0gb3B0cy5ncmFudCBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL3NvZnR3YXJlL2ppcmEvZG9jcy9hcGkvUkVTVC83LjYuMS8jYXBpLzIvcGVybWlzc2lvbnNjaGVtZS1jcmVhdGVQZXJtaXNzaW9uR3JhbnR9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHBlcm1pc3Npb24gZ3JhbnQgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwZXJtaXNzaW9uIGdyYW50IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVQZXJtaXNzaW9uR3JhbnRJblNjaGVtZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvcGVybWlzc2lvbnNjaGVtZS8nICsgb3B0cy5zY2hlbWVJZCArICcvcGVybWlzc2lvbicpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogb3B0cy5ncmFudFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBwZXJtaXNzaW9uIGdyYW50IGZyb20gYSBwZXJtaXNzaW9uIHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlUGVybWlzc2lvbkdyYW50RnJvbVNjaGVtZVxuICAgICAqIEBtZW1iZXJPZiBQZXJtaXNzaW9uU2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy5zY2hlbWVJZCBUaGUgbmFtZSBvZiB0aGUgc2NoZW1lIHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0gb3B0cy5wZXJtaXNzaW9uSWQgVGhlIGlkIG9mIHRoZSBwZXJtaXNzaW9uIHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc2NoZW1lIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc2NoZW1lIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICovXG4gICAgdGhpcy5kZWxldGVQZXJtaXNzaW9uR3JhbnRGcm9tU2NoZW1lID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9wZXJtaXNzaW9uc2NoZW1lLycgKyBvcHRzLnNjaGVtZUlkICsgJy9wZXJtaXNzaW9uLycgKyBvcHRzLnBlcm1pc3Npb25JZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdQZXJtaXNzaW9uIHJlbW92ZWQgZnJvbSBzY2hlbWUuJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwZXJtaXNzaW9uIGdyYW50IGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIGlkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRQZXJtaXNzaW9uU2NoZW1lR3JhbnRCeUlkXG4gICAgICogQG1lbWJlck9mIFBlcm1pc3Npb25TY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLnNjaGVtZUlkIFRoZSBpZCBvZiB0aGUgc2NoZW1lIHRvIHdoaWNoIHRoZSBwZXJtaXNzaW9uIGdyYW50IGJlbG9uZ3MuXG4gICAgICogQHBhcmFtIG9wdHMucGVybWlzc2lvbklkIFRoZSBpZCBvZiB0aGUgcGVybWlzc2lvbiB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5leHBhbmQgVGhlIGZpZWxkcyB0byBiZSBleHBhbmRlZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc2NoZW1lIGdyYW50cyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHNjaGVtZSBncmFudHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFBlcm1pc3Npb25TY2hlbWVHcmFudEJ5SWQgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGV4cGFuZCA9IG9wdHMuZXhwYW5kXG4gICAgICAgIGlmIChvcHRzLmV4cGFuZCAmJiBvcHRzLmV4cGFuZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBleHBhbmQgPSBvcHRzLmV4cGFuZC5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3Blcm1pc3Npb25zY2hlbWUvJyArIG9wdHMuc2NoZW1lSWQgKyAnL3Blcm1pc3Npb24vJyArIG9wdHMucGVybWlzc2lvbklkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBleHBhbmQ6IGV4cGFuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gUGVybWlzc2lvbnNDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvcGVybWlzc2lvbnMnXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgUGVybWlzc2lvbnNDbGllbnRcbiAqL1xuZnVuY3Rpb24gUGVybWlzc2lvbnNDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBwZXJtaXNzaW9ucyB0aGF0IGFyZSBwcmVzZW50IGluIHRoZSBKSVJBIGluc3RhbmNlXG4gICAgICogLSBHbG9iYWwsIFByb2plY3QgYW5kIHRoZSBnbG9iYWwgb25lcyBhZGRlZCBieSBwbHVnaW5zXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEFsbFBlcm1pc3Npb25zXG4gICAgICogQG1lbWJlck9mIFBlcm1pc3Npb25zQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHBlcm1pc3Npb25zIGhhdmUgYmVlbiByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwZXJtaXNzaW9ucyBoYXZlIGJlZW4gcmV0dXJuZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRBbGxQZXJtaXNzaW9ucyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvcGVybWlzc2lvbnMnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5Q2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL3ByaW9yaXR5J1xuICpcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIFByaW9yaXR5Q2xpZW50XG4gKi9cbmZ1bmN0aW9uIFByaW9yaXR5Q2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHByaW9yaXRpZXMgdmlzaWJsZSB0byB0aGUgdXNlclxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRBbGxQcmlvcml0aWVzXG4gICAgICogQG1lbWJlck9mIFByaW9yaXR5Q2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIElnbm9yZWRcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcHJpb3JpdGllcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHByaW9yaXRpZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEFsbFByaW9yaXRpZXMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3ByaW9yaXR5JyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBmdWxsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcmlvcml0eSB0aGF0IGhhcyB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFByaW9yaXR5XG4gICAgICogQG1lbWJlck9mIFByaW9yaXR5Q2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIG9wdHMucHJpb3JpdHlJZCBBIFN0cmluZyBjb250YWluaW5nIGEgcHJpb3JpdHkgaWRcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcHJpb3JpdHkgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHByaW9yaXR5IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFByaW9yaXR5ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9wcmlvcml0eS8nICsgb3B0cy5wcmlvcml0eUlkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0Q2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL3Byb2plY3QnXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBQcm9qZWN0Q2xpZW50XG4gKi9cbmZ1bmN0aW9uIFByb2plY3RDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBwcm9qZWN0cyB3aGljaCBhcmUgdmlzaWJsZSBmb3IgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci4gSWYgbm8gdXNlciBpcyBsb2dnZWQgaW4sIGl0IHJldHVybnMgdGhlXG4gICAgICogbGlzdCBvZiBwcm9qZWN0cyB0aGF0IGFyZSB2aXNpYmxlIHdoZW4gdXNpbmcgYW5vbnltb3VzIGFjY2Vzcy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0QWxsUHJvamVjdHNcbiAgICAgKiBAbWVtYmVyT2YgUHJvamVjdENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBwcm9qZWN0cyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHByb2plY3RzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRBbGxQcm9qZWN0cyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnJywgJ0dFVCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgcHJvamVjdFxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZWxldGVQcm9qZWN0XG4gICAgICogQG1lbWJlck9mIFByb2plY3RDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy5wcm9qZWN0SWRPcktleSBUaGUgcHJvamVjdCBpZCBvciBwcm9qZWN0IGtleVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBwcm9qZWN0IGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcHJvamVjdCBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlUHJvamVjdCA9IGZ1bmN0aW9uKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcnLCAnREVMRVRFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdQcm9qZWN0IERlbGV0ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByb2plY3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVByb2plY3RcbiAgICAgKiBAbWVtYmVyT2YgUHJvamVjdENsaWVudCNcbiAgICAgKiBAcGFyYW0gcHJvamVjdCBUaGUgcHJvamVjdCBwcm9wZXJ0aWVzLiBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2FwaS8yL3Byb2plY3R9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHByb2plY3QgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwcm9qZWN0IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVQcm9qZWN0ID0gZnVuY3Rpb24gKHByb2plY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9wcm9qZWN0JyksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBib2R5OiBwcm9qZWN0XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgcHJvamVjdCBwcm9wZXJ0ZXMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFByb2plY3RQcm9wZXJ0aWVzXG4gICAgICogQG1lbWJlck9mIFByb2plY3RDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRzLnByb2plY3RJZE9yS2V5IFRoZSBwcm9qZWN0IGlkIG9yIHByb2plY3Qga2V5XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gcHJvcGVydGllcyBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBwcm9wZXJ0aWVzIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFByb2plY3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvcHJvcGVydGllcycsICdHRVQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuXG5cblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIGEgZnVsbCByZXByZXNlbnRhdGlvbiBvZiBhIHByb2plY3QgaW4gSlNPTiBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBBbGwgcHJvamVjdCBrZXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvamVjdCB3aWxsIG9ubHkgYmUgcmV0dXJuZWQgaWYgZXhwYW5kPXByb2plY3RLZXlzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRQcm9qZWN0XG4gICAgICogQG1lbWJlck9mIFByb2plY3RDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy5wcm9qZWN0SWRPcktleSBUaGUgcHJvamVjdCBpZCBvciBwcm9qZWN0IGtleVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBwcm9qZWN0IGlzIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwcm9qZWN0IGlzIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFByb2plY3QgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJycsICdHRVQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIGEgZnVsbCByZXByZXNlbnRhdGlvbiBvZiBhIHRoZSBzcGVjaWZpZWQgcHJvamVjdCdzIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldENvbXBvbmVudHNcbiAgICAgKiBAbWVtYmVyT2YgUHJvamVjdENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLnByb2plY3RJZE9yS2V5IFRoZSBwcm9qZWN0IGlkIG9yIHByb2plY3Qga2V5XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBjb21wb25lbnRzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRDb21wb25lbnRzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvY29tcG9uZW50cycsICdHRVQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgaXNzdWUgdHlwZXMgd2l0aCB2YWxpZCBzdGF0dXMgdmFsdWVzIGZvciBhIHByb2plY3RcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0U3RhdHVzZXNcbiAgICAgKiBAbWVtYmVyT2YgUHJvamVjdENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLnByb2plY3RJZE9yS2V5IFRoZSBwcm9qZWN0IGlkIG9yIHByb2plY3Qga2V5XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHN0YXR1c2VzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc3RhdHVzZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFN0YXR1c2VzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvc3RhdHVzZXMnLCAnR0VUJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyBhIGZ1bGwgcmVwcmVzZW50YXRpb24gb2YgYSB0aGUgc3BlY2lmaWVkIHByb2plY3QncyB2ZXJzaW9ucy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0VmVyc2lvbnNcbiAgICAgKiBAbWVtYmVyT2YgUHJvamVjdENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLnByb2plY3RJZE9yS2V5IFRoZSBwcm9qZWN0IGlkIG9yIHByb2plY3Qga2V5XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHZlcnNpb25zIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgdmVyc2lvbnMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFZlcnNpb25zID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvdmVyc2lvbnMnLCAnR0VUJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyBhIGxpc3Qgb2Ygcm9sZXMgaW4gdGhpcyBwcm9qZWN0IHdpdGggbGlua3MgdG8gZnVsbCBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRSb2xlc1xuICAgICAqIEBtZW1iZXJPZiBQcm9qZWN0Q2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMucHJvamVjdElkT3JLZXkgVGhlIHByb2plY3QgaWQgb3IgcHJvamVjdCBrZXlcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcm9sZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSByb2xlcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0Um9sZXMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9yb2xlJywgJ0dFVCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGV0YWlscyBvbiBhIGdpdmVuIHByb2plY3Qgcm9sZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0Um9sZVxuICAgICAqIEBtZW1iZXJPZiBQcm9qZWN0Q2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMucHJvamVjdElkT3JLZXkgVGhlIHByb2plY3QgaWQgb3IgcHJvamVjdCBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cy5yb2xlSWQgVGhlIGlkIG9mIHRoZSByb2xlIHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSByb2xlcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHJvbGVzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRSb2xlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvcm9sZS8nICsgb3B0cy5yb2xlSWQsICdHRVQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBwcm9qZWN0IHJvbGUgdG8gY29udGFpbiB0aGUgc2VudCBhY3RvcnMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVJvbGVcbiAgICAgKiBAbWVtYmVyT2YgUHJvamVjdENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLnByb2plY3RJZE9yS2V5IFRoZSBwcm9qZWN0IGlkIG9yIHByb2plY3Qga2V5XG4gICAgICogQHBhcmFtIG9wdHMucm9sZUlkIFRoZSBpZCBvZiB0aGUgcm9sZSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gb3B0cy5uZXdSb2xlIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMTA4fVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSByb2xlcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHJvbGVzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy51cGRhdGVSb2xlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvcm9sZS8nICsgb3B0cy5yb2xlSWQsICdQVVQnLCBvcHRzLm5ld1JvbGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGFjdG9yIHRvIGEgcHJvamVjdCByb2xlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBhZGRUb1JvbGVcbiAgICAgKiBAbWVtYmVyT2YgUHJvamVjdENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLnByb2plY3RJZE9yS2V5IFRoZSBwcm9qZWN0IGlkIG9yIHByb2plY3Qga2V5XG4gICAgICogQHBhcmFtIG9wdHMucm9sZUlkIFRoZSBpZCBvZiB0aGUgcm9sZSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gb3B0cy5uZXdSb2xlIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMTM0fVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSByb2xlcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHJvbGVzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5hZGRUb1JvbGUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9yb2xlLycgKyBvcHRzLnJvbGVJZCwgJ1BPU1QnLCBvcHRzLm5ld1JvbGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQnVpbGQgb3V0IHRoZSByZXF1ZXN0IG9wdGlvbnMgbmVjZXNzYXJ5IHRvIG1ha2UgYSBwYXJ0aWN1bGFyIEFQSSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWV0aG9kIGJ1aWxkUmVxdWVzdE9wdGlvbnNcbiAgICAgKiBAbWVtYmVyT2YgUHJvamVjdENsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnByb2plY3RJZE9yS2V5IFRoZSBpZCBvZiB0aGUgcHJvamVjdCB0byB1c2UgaW4gdGhlIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdHMuZmllbGRzXSBUaGUgZmllbGRzIHRvIGluY2x1ZGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0cy5leHBhbmRdIFRoZSBmaWVsZHMgdG8gZXhwYW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIGVuZHBvaW50IGZvbGxvd2luZyAvcHJvamVjdC97aWR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgcmVxdWVzdCBtZXRob2QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtib2R5XSBUaGUgcmVxdWVzdCBib2R5LCBpZiBhbnkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtxc10gVGhlIHF1ZXJ5c3RyaW5nLCBpZiBhbnkuICBvcHRzLmV4cGFuZCBhbmQgb3B0cy5maWVsZHMgYXJyYXlzIHdpbGwgYmUgYXV0b21hZ2ljYWxseSBhZGRlZC5cbiAgICAgKiBAcmV0dXJucyB7e3VyaTogc3RyaW5nLCBtZXRob2Q6IHN0cmluZywgYm9keTogT2JqZWN0LCBxczogT2JqZWN0LCBmb2xsb3dBbGxSZWRpcmVjdHM6IGJvb2xlYW4sIGpzb246IGJvb2xlYW59fVxuICAgICAqL1xuICAgIHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzLCBwYXRoLCBtZXRob2QsIGJvZHksIHFzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIHZhciBiYXNlUGF0aCA9IG9wdHMucHJvamVjdElkT3JLZXkgPyAnL3Byb2plY3QvJyArIG9wdHMucHJvamVjdElkT3JLZXkgOiAnL3Byb2plY3QnO1xuXG4gICAgICAgIGlmICghcXMpIHFzID0ge307XG4gICAgICAgIGlmICghYm9keSkgYm9keSA9IHt9O1xuXG4gICAgICAgIGlmIChvcHRzLmZpZWxkcykge1xuICAgICAgICAgICAgcXMuZmllbGRzID0gJyc7XG4gICAgICAgICAgICBvcHRzLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIHFzLmZpZWxkcyArPSBmaWVsZCArICcsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxcy5maWVsZHMgPSBxcy5maWVsZHMuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuZXhwYW5kKSB7XG4gICAgICAgICAgICBxcy5leHBhbmQgPSAnJztcbiAgICAgICAgICAgIG9wdHMuZXhwYW5kLmZvckVhY2goZnVuY3Rpb24gKGV4KSB7XG4gICAgICAgICAgICAgICAgcXMuZXhwYW5kICs9IGV4ICsgJywnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHFzLmV4cGFuZCA9IHFzLmV4cGFuZC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoYmFzZVBhdGggKyBwYXRoKSxcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHFzOiBxcyxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGpzb246IHRydWVcbiAgICAgICAgfTtcbiAgICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvamVjdENhdGVnb3J5Q2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL3Byb2plY3RDYXRlZ29yeSdcbiAqXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBQcm9qZWN0Q2F0ZWdvcnlDbGllbnRcbiAqL1xuZnVuY3Rpb24gUHJvamVjdENhdGVnb3J5Q2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHByb2plY3RDYXRlZ29yaWVzIHZpc2libGUgdG8gdGhlIHVzZXJcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0QWxsUHJvamVjdENhdGVnb3JpZXNcbiAgICAgKiBAbWVtYmVyT2YgUHJvamVjdENhdGVnb3J5Q2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIElnbm9yZWRcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc3RhdHVzQ2F0ZWdvcmllcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHN0YXR1c0NhdGVnb3JpZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEFsbFByb2plY3RDYXRlZ29yaWVzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9wcm9qZWN0Q2F0ZWdvcnknKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGZ1bGwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb2plY3RDYXRlZ29yeSB0aGF0IGhhcyB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFByb2plY3RDYXRlZ29yeVxuICAgICAqIEBtZW1iZXJPZiBQcm9qZWN0Q2F0ZWdvcnlDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy5wcm9qZWN0Q2F0ZWdvcnlJZCBBIFN0cmluZyBjb250YWluaW5nIGEgcHJvamVjdENhdGVnb3J5IGlkXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHByb2plY3RDYXRlZ29yeSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcHJvamVjdENhdGVnb3J5IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFByb2plY3RDYXRlZ29yeSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvcHJvamVjdENhdGVnb3J5LycgKyBvcHRzLnByb2plY3RDYXRlZ29yeUlkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3RWYWxpZGF0ZUNsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9wcm9qZWN0dmFsaWRhdGUnXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgUHJvamVjdFZhbGlkYXRlQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIFByb2plY3RWYWxpZGF0ZUNsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBhIHByb2plY3Qga2V5LiAgVGhpcyBlbmRwb2ludCBpcyBhIGxpdHRsZSB3b25reSwgYXMgaXQgcmV0dXJucyBhIGxpc3Qgb2YgZXJyb3JzIGFzIGEgdmFsaWQgcmVzcG9uc2U7XG4gICAgICogZXZlbiBpZiB0aGUga2V5IGlzIGludmFsaWQsIGl0IHN0aWxsIHJldHVybnMgYSAyMDAgcmVzcG9uc2UuXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmUyOTd9XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHZhbGlkYXRlUHJvamVjdEtleVxuICAgICAqIEBtZW1iZXJPZiBQcm9qZWN0VmFsaWRhdGVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy5wcm9qZWN0S2V5IFRoZSBrZXkgb2YgdGhlIHByb2plY3QuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGtleSBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUga2V5IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkYXRlUHJvamVjdEtleSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvcHJvamVjdHZhbGlkYXRlL2tleScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIGtleTogb3B0cy5wcm9qZWN0S2V5XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlaW5kZXhDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvcmVpbmRleCdcbiAqXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBSZWluZGV4Q2xpZW50XG4gKi9cbmZ1bmN0aW9uIFJlaW5kZXhDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBLaWNrcyBvZmYgYSByZWluZGV4LiBOZWVkIEFkbWluIHBlcm1pc3Npb25zIHRvIHBlcmZvcm0gdGhpcyByZWluZGV4LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkb1JlaW5kZXhcbiAgICAgKiBAbWVtYmVyT2YgUmVpbmRleENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50eXBlXSBDYXNlIGluc2Vuc2l0aXZlIFN0cmluZyBpbmRpY2F0aW5nIHR5cGUgb2YgcmVpbmRleC4gSWYgb21pdHRlZCwgdGhlbiBkZWZhdWx0cyB0b1xuICAgICAqICAgICBCQUNLR1JPVU5EX1BSRUZFUlJFRFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5kZXhDb21tZW50cz1mYWxzZV0gSW5kaWNhdGVzIHRoYXQgY29tbWVudHMgc2hvdWxkIGFsc28gYmUgcmVpbmRleGVkLiBOb3QgcmVsZXZhbnQgZm9yXG4gICAgICogICAgIGZvcmVncm91bmQgcmVpbmRleCwgd2hlcmUgY29tbWVudHMgYXJlIGFsd2F5cyByZWluZGV4ZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmRleENoYW5nZUhpc3Rvcnk9ZmFsc2VdIEluZGljYXRlcyB0aGF0IGNoYW5nZUhpc3Rvcnkgc2hvdWxkIGFsc28gYmUgcmVpbmRleGVkLiBOb3RcbiAgICAgKiAgICAgcmVsZXZhbnQgZm9yIGZvcmVncm91bmQgcmVpbmRleCwgd2hlcmUgY2hhbmdlSGlzdG9yeSBpcyBhbHdheXMgcmVpbmRleGVkLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSByZWluZGV4IGhhcyBiZWVuIHN0YXJ0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcmVpbmRleCBoYXMgYmVlbiBzdGFydGVkLlxuICAgICAqL1xuICAgIHRoaXMuZG9SZWluZGV4ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9yZWluZGV4JyksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IG9wdHMudHlwZSxcbiAgICAgICAgICAgICAgICBpbmRleENvbW1lbnRzOiBvcHRzLmluZGV4Q29tbWVudHMsXG4gICAgICAgICAgICAgICAgaW5kZXhDaGFuZ2VIaXN0b3J5OiBvcHRzLmluZGV4Q2hhbmdlSGlzdG9yeVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGluZm9ybWF0aW9uIG9uIHRoZSBzeXN0ZW0gcmVpbmRleGVzLiBJZiBhIHJlaW5kZXggaXMgY3VycmVudGx5IHRha2luZyBwbGFjZSB0aGVuIGluZm9ybWF0aW9uIGFib3V0IHRoaXNcbiAgICAgKiByZWluZGV4IGlzIHJldHVybmVkLiBJZiB0aGVyZSBpcyBubyBhY3RpdmUgaW5kZXggdGFzaywgdGhlbiByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsYXRlc3QgcmVpbmRleCB0YXNrXG4gICAgICogcnVuLCBvdGhlcndpc2UgcmV0dXJucyBhIDQwNCBpbmRpY2F0aW5nIHRoYXQgbm8gcmVpbmRleCBoYXMgdGFrZW4gcGxhY2UuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFJlaW5kZXhcbiAgICAgKiBAbWVtYmVyT2YgUmVpbmRleENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBbb3B0cy50YXNrSWRdIFRoZSBpZCBvZiBhbiBpbmRleGluZyB0YXNrIHlvdSB3aXNoIHRvIG9idGFpbiBkZXRhaWxzIG9uLiBJZiBvbWl0dGVkLCB0aGVuIGRlZmF1bHRzIHRvIHRoZVxuICAgICAqICAgICBzdGFuZGFyZCBiZWhhdmlvdXIgYW5kIHJldHVybnMgaW5mb3JtYXRpb24gb24gdGhlIGFjdGl2ZSByZWluZGV4IHRhc2ssIG9yIHRoZSBsYXN0IHRhc2sgdG8gcnVuIGlmIG5vIHJlaW5kZXhcbiAgICAgKiAgICAgaXMgdGFraW5nIHBsYWNlLiAuIElmIHRoZXJlIGlzIG5vIHJlaW5kZXhpbmcgdGFzayB3aXRoIHRoYXQgaWQgdGhlbiBhIDQwNCBpcyByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcmVpbmRleCBkYXRhIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSByZWluZGV4IGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0UmVpbmRleCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvcmVpbmRleCcpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIHRhc2tJZDogb3B0cy50YXNrSWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVzb2x1dGlvbkNsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9yZXNvbHV0aW9uJ1xuICpcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIFJlc29sdXRpb25DbGllbnRcbiAqL1xuZnVuY3Rpb24gUmVzb2x1dGlvbkNsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCByZXNvbHV0aW9ucyB2aXNpYmxlIHRvIHRoZSB1c2VyXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEFsbFJlc29sdXRpb25zXG4gICAgICogQG1lbWJlck9mIFJlc29sdXRpb25DbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgSWdub3JlZFxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSByZXNvbHV0aW9ucyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHJlc29sdXRpb25zIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRBbGxSZXNvbHV0aW9ucyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvcmVzb2x1dGlvbicpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgZnVsbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVzb2x1dGlvbiB0aGF0IGhhcyB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFJlc29sdXRpb25cbiAgICAgKiBAbWVtYmVyT2YgUmVzb2x1dGlvbkNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLnJlc29sdXRpb25JZCBBIFN0cmluZyBjb250YWluaW5nIGEgcmVzb2x1dGlvbiBpZFxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSByZXNvbHV0aW9uIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSByZXNvbHV0aW9uIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFJlc29sdXRpb24gPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3Jlc29sdXRpb24vJyArIG9wdHMucmVzb2x1dGlvbklkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBSb2xlQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL3JvbGUnXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgUm9sZUNsaWVudFxuICovXG5mdW5jdGlvbiBSb2xlQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgUHJvamVjdFJvbGVzIGF2YWlsYWJsZSBpbiBKaXJhLiBDdXJyZW50bHkgdGhpcyBsaXN0IGlzIGdsb2JhbC5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRBbGxcbiAgICogQG1lbWJlck9mIFJvbGVDbGllbnQjXG4gICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBwZXJtaXNzaW9ucyBoYXZlIGJlZW4gcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHBlcm1pc3Npb25zIGhhdmUgYmVlbiByZXR1cm5lZC5cbiAgICovXG4gIHRoaXMuZ2V0QWxsID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3JvbGUnKSxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBqc29uOiB0cnVlLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUHJvamVjdFJvbGUgdG8gYmUgYXZhaWxhYmxlIGluIEppcmEuXG4gICAqIFRoZSBjcmVhdGVkIHJvbGUgZG9lcyBub3QgaGF2ZSBhbnkgZGVmYXVsdCBhY3RvcnMgYXNzaWduZWQuXG4gICAqXG4gICAqIEBtZXRob2QgY3JlYXRlUm9sZVxuICAgKiBAbWVtYmVyT2YgUm9sZUNsaWVudCNcbiAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICogQHBhcmFtIG9wdHMucm9sZSBTZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLmF0bGFzc2lhbi5jb20vY2xvdWQvamlyYS9wbGF0Zm9ybS9yZXN0LyNhcGktYXBpLTItcm9sZS1wb3N0fVxuICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc2NoZW1lIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHNjaGVtZSBoYXMgYmVlbiBjcmVhdGVkLlxuICAgKi9cbiAgdGhpcy5jcmVhdGVSb2xlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3JvbGUnKSxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgIGJvZHk6IG9wdHMucm9sZVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzcGVjaWZpYyBQcm9qZWN0Um9sZSBhdmFpbGFibGUgaW4gSmlyYS5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRSb2xlQnlJZFxuICAgKiBAbWVtYmVyT2YgUm9sZUNsaWVudCNcbiAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHBlcm1pc3Npb25zIGhhdmUgYmVlbiByZXR1cm5lZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcGVybWlzc2lvbnMgaGF2ZSBiZWVuIHJldHVybmVkLlxuICAgKi9cbiAgdGhpcy5nZXRSb2xlQnlJZCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9yb2xlLycgKyBvcHRzLnJvbGVJZCksXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bGx5IHVwZGF0ZXMgYSByb2xlcy4gQm90aCBuYW1lIGFuZCBkZXNjcmlwdGlvbiBtdXN0IGJlIGdpdmVuLlxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVJvbGVcbiAgICogQG1lbWJlck9mIFJvbGVDbGllbnQjXG4gICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAqIEBwYXJhbSBvcHRzLnJvbGRJZCBJZGVudGlmaWVyIGZvciB0ZWggcm9sZS5cbiAgICogQHBhcmFtIG9wdHMucm9sZSBPYmplY3QgY29udGFpbmluZyB0aGUgbmFtZSBhbmQgZGVzY3JpcHRpb24gdG8gYmUgdXBkYXRlZC5cbiAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHBlcm1pc3Npb25zIGhhdmUgYmVlbiByZXR1cm5lZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcGVybWlzc2lvbnMgaGF2ZSBiZWVuIHJldHVybmVkLlxuICAgKi9cbiAgdGhpcy51cGRhdGVSb2xlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3JvbGUvJyArIG9wdHMucm9sZUlkKSxcbiAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICBqc29uOiB0cnVlLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgYm9keTogb3B0cy5yb2xlLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgKiBEZWxldGVzIGEgcm9sZS4gTWF5IHJldHVybiA0MDMgaW4gdGhlIGZ1dHVyZVxuICAqXG4gICogQG1ldGhvZCBkZWxldGVSb2xlXG4gICogQG1lbWJlck9mIFJvbGVDbGllbnQjXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5yb2xkSWQgSWRlbnRpZmllciBmb3IgdGhlIHJvbGUuXG4gICogQHBhcmFtIHtTdHJpbmd9IG9wdHMuc3dhcCBpZiBnaXZlbiwgcmVtb3ZlcyBhIHJvbGUgZXZlbiBpZiBpdCBpcyB1c2VkIGluIHNjaGVtZSBieSByZXBsYWNpbmcgdGhlIHJvbGUgd2l0aCB0aGUgZ2l2ZW4gb25lXG4gICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHBlcm1pc3Npb25zIGhhdmUgYmVlbiByZXR1cm5lZC5cbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwZXJtaXNzaW9ucyBoYXZlIGJlZW4gcmV0dXJuZWQuXG4gICovXG4gIHRoaXMuZGVsZXRlUm9sZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9yb2xlLycgKyBvcHRzLnJvbGVJZCksXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgIHFzOiB7XG4gICAgICAgIHN3YXA6IG9wdHMuc3dhcFxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgKiBHZXRzIGRlZmF1bHQgYWN0b3JzIGZvciB0aGUgZ2l2ZW4gcm9sZS5cbiAgKlxuICAqIEBtZXRob2QgZ2V0QWN0b3JzXG4gICogQG1lbWJlck9mIFJvbGVDbGllbnQjXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5yb2xkSWQgSWRlbnRpZmllciBmb3IgdGhlIHJvbGUuXG4gICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHBlcm1pc3Npb25zIGhhdmUgYmVlbiByZXR1cm5lZC5cbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwZXJtaXNzaW9ucyBoYXZlIGJlZW4gcmV0dXJuZWQuXG4gICovXG4gIHRoaXMuZ2V0QWN0b3JzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3JvbGUvJyArIG9wdHMucm9sZUlkICsgJy9hY3RvcnMnKSxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBqc29uOiB0cnVlLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgKiBBZGRzIGRlZmF1bHQgYWN0b3JzIHRvIHRoZSBnaXZlbiByb2xlLlxuICAqIFRoZSByZXF1ZXN0IGRhdGEgc2hvdWxkIGNvbnRhaW4gYSBsaXN0IG9mIHVzZXJuYW1lcyBvciBhIGxpc3Qgb2YgZ3JvdXBzIHRvIGFkZC5cbiAgKlxuICAqIEBtZXRob2QgYWRkQWN0b3JzXG4gICogQG1lbWJlck9mIFJvbGVDbGllbnQjXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5yb2xkSWQgSWRlbnRpZmllciBmb3IgdGhlIHJvbGUuXG4gICogQHBhcmFtIHtBcnJheX0gb3B0cy5ncm91cCBBcnJheSBvZiBncm91cCBpZHMuXG4gICogQHBhcmFtIHtBcnJheX0gb3B0cy51c2VyIEFycmF5IG9mIHVzZXIgaWRzLlxuICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBwZXJtaXNzaW9ucyBoYXZlIGJlZW4gcmV0dXJuZWQuXG4gICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcGVybWlzc2lvbnMgaGF2ZSBiZWVuIHJldHVybmVkLlxuICAqL1xuICB0aGlzLmFkZEFjdG9ycyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9yb2xlLycgKyBvcHRzLnJvbGVJZCArICcvYWN0b3JzJyksXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHVzZXI6IG9wdHMudXNlcixcbiAgICAgICAgZ3JvdXA6IG9wdHMuZ3JvdXAsXG4gICAgICB9LFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgKiBSZW1vdmVzIGRlZmF1bHQgYWN0b3IgZnJvbSB0aGUgZ2l2ZW4gcm9sZS5cbiAgKlxuICAqIEBtZXRob2QgcmVtb3ZlQWN0b3JcbiAgKiBAbWVtYmVyT2YgUm9sZUNsaWVudCNcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRzLnJvbGRJZCBJZGVudGlmaWVyIGZvciB0aGUgcm9sZS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy5ncm91cCBncm91cCBpZC5cbiAgKiBAcGFyYW0ge1N0cmluZ30gb3B0cy51c2VyIHVzZXIgaWQuXG4gICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHBlcm1pc3Npb25zIGhhdmUgYmVlbiByZXR1cm5lZC5cbiAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBwZXJtaXNzaW9ucyBoYXZlIGJlZW4gcmV0dXJuZWQuXG4gICovXG4gIHRoaXMucmVtb3ZlQWN0b3IgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvcm9sZS8nICsgb3B0cy5yb2xlSWQgKyAnL2FjdG9ycycpLFxuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICBxczoge1xuICAgICAgICB1c2VyOiBvcHRzLnVzZXIsXG4gICAgICAgIGdyb3VwOiBvcHRzLmdyb3VwLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NyZWVuc0NsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9zY3JlZW5zJ1xuICpcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIFNjcmVlbnNDbGllbnRcbiAqL1xuZnVuY3Rpb24gU2NyZWVuc0NsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYXZhaWxhYmxlIGZpZWxkcyBmb3Igc2NyZWVuLiBpLmUgb25lcyB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIGFkZGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRBdmFpbGFibGVGaWVsZHNcbiAgICAgKiBAbWVtYmVyT2YgU2NyZWVuc0NsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gSmlyYVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNjcmVlbklkIFRoZSBpZCBvZiB0aGUgc2NyZWVuIHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBhdmFpbGFibGUgZmllbGRzIGhhdmUgYmVlbiByZXRyaWV2ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhdmFpbGFibGUgZmllbGRzIGhhdmUgYmVlbiByZXRyaWV2ZWRcbiAgICAgKi9cbiAgICB0aGlzLmdldEF2YWlsYWJsZUZpZWxkcyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL2F2YWlsYWJsZUZpZWxkcycsICdHRVQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCB0YWJzIGZvciB0aGUgZ2l2ZW4gc2NyZWVuLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRUYWJzXG4gICAgICogQG1lbWJlck9mIFNjcmVlbnNDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIEppcmFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zY3JlZW5JZCBUaGUgaWQgb2YgdGhlIHNjcmVlbiB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgdGFicyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHRhYnMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFRhYnMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy90YWJzJywgJ0dFVCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0YWIgZm9yIGdpdmVuIHNjcmVlblxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVUYWJcbiAgICAgKiBAbWVtYmVyT2YgU2NyZWVuc0NsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gSmlyYVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNjcmVlbklkIFRoZSBpZCBvZiB0aGUgc2NyZWVuIGluIHdoaWNoIHRvIGNyZWF0ZSBhIHRhYi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5uYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWIgdG8gYWRkLiAgTWluaW11bSByZXF1aXJlZCB0byBjcmVhdGUgYSB0YWIuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHRhYiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHRhYiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlVGFiID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvdGFicycsICdQT1NUJywge25hbWU6IG9wdHMubmFtZX0pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuYW1lcyB0aGUgZ2l2ZW4gdGFiIG9uIHRoZSBnaXZlbiBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbmFtZVRhYlxuICAgICAqIEBtZW1iZXJPZiBTY3JlZW5zQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgamlyYSBBUElcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zY3JlZW5JZCBUaGUgaWQgb2YgdGhlIHNjcmVlbiBjb250YWluaW5nIHRoZSB0YWIgdG8gcmVuYW1lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnRhYklkIFRoZSBpZCBvZiB0aGUgdGFiIHRvIHJlbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm5hbWUgVGhlIG5ldyBuYW1lIG9mIHRoZSB0YWIuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gZGF0YSBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkXG4gICAgICovXG4gICAgdGhpcy5yZW5hbWVUYWIgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy90YWJzLycgKyBvcHRzLnRhYklkLCAnUFVUJywge25hbWU6IG9wdHMubmFtZX0pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgZ2l2ZW4gdGFiIGZyb20gdGhlIGdpdmVuIHNjcmVlbi5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlVGFiXG4gICAgICogQG1lbWJlck9mIFNjcmVlbnNDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBqaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNjcmVlbklkIFRoZSBpZCBvZiB0aGUgc2NyZWVuIGNvbnRhaW5pbmcgdGhlIHRhYiB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMudGFiSWQgVGhlIGlkIG9mIHRoZSB0YWIgdG8gZGVsZXRlXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gZGF0YSBoYXMgYmVlbiByZXRyaWV2ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkXG4gICAgICovXG4gICAgdGhpcy5kZWxldGVUYWIgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy90YWJzLycgKyBvcHRzLnRhYklkLCAnREVMRVRFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdUYWIgRGVsZXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGZpZWxkIHRvIHRoZSBnaXZlbiB0YWJcbiAgICAgKlxuICAgICAqIEBtZXRob2QgYWRkRmllbGRUb1RhYlxuICAgICAqIEBtZW1iZXJPZiBTY3JlZW5zQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zY3JlZW5JZCBUaGUgaWQgb2YgdGhlIHNjcmVlbiBjb250YWluaW5nIHRoZSB0YWIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMudGFiSWQgdGhlIGlkIG9mIHRoZSB0YWIgdG8gd2hpY2ggdGhlIGZpZWxkcyB3aWxsIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZpZWxkSWQgVGhlIGZpZWxkIHRvIGFkZFxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBmaWVsZHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSB0YWIuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgZmllbGRzIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgdGFiLlxuICAgICAqL1xuICAgIHRoaXMuYWRkRmllbGRUb1RhYiA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3RhYnMvJyArIG9wdHMudGFiSWQgKyAnL2ZpZWxkcycsICdQT1NUJywgb3B0cy5maWVsZElkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGZpZWxkcyBmb3IgYSBnaXZlbiB0YWIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEZpZWxkc0luVGFiXG4gICAgICogQG1lbWJlck9mIFNjcmVlbnNDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNjcmVlbklkIFRoZSBpZCBvZiB0aGUgc2NyZWVuIGNvbnRhaW5pbmcgdGhlIHRhYi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy50YWJJZCB0aGUgaWQgb2YgdGhlIHRhYiBmb3Igd2hpY2ggdG8gcmV0cmlldmUgZmllbGRzLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBmaWVsZHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBmaWVsZHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEZpZWxkc0luVGFiID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvdGFicy8nICsgb3B0cy50YWJJZCArICcvZmllbGRzJywgJ0dFVCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBnaXZlbiBmaWVsZCBmcm9tIHRoZSBnaXZlbiB0YWIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUZpZWxkRnJvbVRhYlxuICAgICAqIEBtZW1iZXJPZiBTY3JlZW5zQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zY3JlZW5JZCBUaGUgaWQgb2YgdGhlIHNjcmVlbiBjb250YWluaW5nIHRoZSB0YWIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMudGFiSWQgdGhlIGlkIG9mIHRoZSB0YWIgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGZpZWxkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZpZWxkSWQgVGhlIGlkIG9mIHRoZSBmaWVsZCB0byByZW1vdmUgZnJvbSB0aGUgdGFiLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBmaWVsZCBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGZpZWxkIGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICovXG4gICAgdGhpcy5yZW1vdmVGaWVsZEZyb21UYWIgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy90YWJzLycgKyBvcHRzLnRhYklkICsgJy9maWVsZHMvJyArIG9wdHMuZmllbGRJZCwgJ0RFTEVURScpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnRmllbGQgUmVtb3ZlZCBGcm9tIFRhYicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBnaXZlbiBmaWVsZCBvbiB0aGUgZ2l2ZW4gdGFiXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG1vdmVGaWVsZE9uVGFiXG4gICAgICogQG1lbWJlck9mIFNjcmVlbnNDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNjcmVlbklkIFRoZSBpZCBvZiB0aGUgc2NyZWVuIGNvbnRhaW5pbmcgdGhlIHRhYi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy50YWJJZCB0aGUgaWQgb2YgdGhlIHRhYiBjb250YWluaW5nIHRoZSBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5maWVsZElkIFRoZSBpZCBvZiB0aGUgZmllbGQgdG8gcmVtb3ZlIGZyb20gdGhlIHRhYi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5uZXdQb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gd2hpY2ggdGhlIGZpZWxkIHNob3VsZCBiZSBtb3ZlZC4gIE1heSBiZSBvbmUgb2Y6XG4gICAgICogICogRWFybGllclxuICAgICAqICAqIExhdGVyXG4gICAgICogICogRmlyc3RcbiAgICAgKiAgKiBMYXN0XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGZpZWxkIGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgZmllbGQgaGFzIGJlZW4gcmVtb3ZlZC5cbiAgICAgKi9cbiAgICB0aGlzLm1vdmVGaWVsZE9uVGFiID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvdGFicy8nICsgb3B0cy50YWJJZCArICcvZmllbGRzLycgKyBvcHRzLmZpZWxkSWQgKyAnL21vdmUnLFxuICAgICAgICAgICAgJ1BPU1QnLCB7cG9zaXRpb246IG9wdHMubmV3UG9zaXRpb259KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ0ZpZWxkIE1vdmVkJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRhYiBwb3NpdGlvblxuICAgICAqXG4gICAgICogQG1ldGhvZCBtb3ZlVGFiUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyT2YgU2NyZWVuc0NsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNjcmVlbklkIFRoZSBpZCBvZiB0aGUgc2NyZWVuIGNvbnRhaW5pbmcgdGhlIHRhYi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy50YWJJZCB0aGUgaWQgb2YgdGhlIHRhYiB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLm5ld1Bvc2l0aW9uIFRoZSBuZXcgKHplcm8taW5kZXhlZCkgcG9zaXRpb24gb2YgdGhlIHRhYi5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgdGFiIGhhcyBiZWVuIG1vdmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHRhYiBoYXMgYmVlbiBtb3ZlZC5cbiAgICAgKi9cbiAgICB0aGlzLm1vdmVUYWJQb3NpdGlvbiA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3RhYnMvJyArIG9wdHMudGFiSWQgKyAnL21vdmUvJyArIG9wdHMubmV3UG9zaXRpb24sICdQT1NUJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdUYWIgTW92ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBmaWVsZCBvciBjdXN0b20gZmllbGQgdG8gdGhlIGRlZmF1bHQgdGFiXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFkZEZpZWxkVG9EZWZhdWx0VGFiXG4gICAgICogQG1lbWJlck9mIFNjcmVlbnNDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5maWVsZElkIFRoZSBpZCBvZiB0aGUgZmllbGQgdG8gYWRkIHRvIHRoZSBkZWZhdWx0IHRhYi5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgdGFiIGhhcyBiZWVuIG1vdmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHRhYiBoYXMgYmVlbiBtb3ZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmFkZEZpZWxkVG9EZWZhdWx0VGFiID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9zY3JlZW5zL2FkZFRvRGVmYXVsdC8nICsgb3B0cy5maWVsZElkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCBvdXQgdGhlIHJlcXVlc3Qgb3B0aW9ucyBuZWNlc3NhcnkgdG8gbWFrZSBhIHBhcnRpY3VsYXIgQVBJIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYnVpbGRSZXF1ZXN0T3B0aW9uc1xuICAgICAqIEBtZW1iZXJPZiBGaWx0ZXJDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5zY3JlZW5JZCBUaGUgaWQgb2YgdGhlIHNjcmVlbiB0byB1c2UgaW4gdGhlIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdHMuZmllbGRzXSBUaGUgZmllbGRzIHRvIGluY2x1ZGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0cy5leHBhbmRdIFRoZSBmaWVsZHMgdG8gZXhwYW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIGVuZHBvaW50IGZvbGxvd2luZyAvc2NyZWVuL3tpZH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIFRoZSByZXF1ZXN0IG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2JvZHldIFRoZSByZXF1ZXN0IGJvZHksIGlmIGFueS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3FzXSBUaGUgcXVlcnlzdHJpbmcsIGlmIGFueS4gIG9wdHMuZXhwYW5kIGFuZCBvcHRzLmZpZWxkcyBhcnJheXMgd2lsbCBiZSBhdXRvbWFnaWNhbGx5IGFkZGVkLlxuICAgICAqIEByZXR1cm5zIHt7dXJpOiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nLCBib2R5OiBPYmplY3QsIHFzOiBPYmplY3QsIGZvbGxvd0FsbFJlZGlyZWN0czogYm9vbGVhbiwganNvbjogYm9vbGVhbn19XG4gICAgICovXG4gICAgdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zID0gZnVuY3Rpb24gKG9wdHMsIHBhdGgsIG1ldGhvZCwgYm9keSwgcXMpIHtcbiAgICAgICAgdmFyIGJhc2VQYXRoID0gJy9zY3JlZW5zLycgKyBvcHRzLnNjcmVlbklkO1xuICAgICAgICBpZiAoIXFzKSBxcyA9IHt9O1xuICAgICAgICBpZiAoIWJvZHkpIGJvZHkgPSB7fTtcblxuICAgICAgICBpZiAob3B0cy5maWVsZHMpIHtcbiAgICAgICAgICAgIHFzLmZpZWxkcyA9ICcnO1xuICAgICAgICAgICAgb3B0cy5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBxcy5maWVsZHMgKz0gZmllbGQgKyAnLCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcXMuZmllbGRzID0gcXMuZmllbGRzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRzLmV4cGFuZCkge1xuICAgICAgICAgICAgcXMuZXhwYW5kID0gJyc7XG4gICAgICAgICAgICBvcHRzLmV4cGFuZC5mb3JFYWNoKGZ1bmN0aW9uIChleCkge1xuICAgICAgICAgICAgICAgIHFzLmV4cGFuZCArPSBleCArICcsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxcy5leHBhbmQgPSBxcy5leHBhbmQuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKGJhc2VQYXRoICsgcGF0aCksXG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBxczogcXMsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBqc29uOiB0cnVlXG4gICAgICAgIH07XG4gICAgfTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWFyY2hDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvc2VhcmNoJ1xuICpcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIFNlYXJjaENsaWVudFxuICovXG5mdW5jdGlvbiBTZWFyY2hDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgaXNzdWVzIHVzaW5nIEpRTC5cbiAgICAgKlxuICAgICAqIFNvcnRpbmcgdGhlIGpxbCBwYXJhbWV0ZXIgaXMgYSBmdWxsIEpRTCBleHByZXNzaW9uLCBhbmQgaW5jbHVkZXMgYW4gT1JERVIgQlkgY2xhdXNlLlxuICAgICAqXG4gICAgICogVGhlIGZpZWxkcyBwYXJhbSAod2hpY2ggY2FuIGJlIHNwZWNpZmllZCBtdWx0aXBsZSB0aW1lcykgZ2l2ZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBmaWVsZHMgdG8gaW5jbHVkZSBpblxuICAgICAqIHRoZSByZXNwb25zZS4gVGhpcyBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSBhIHN1YnNldCBvZiBmaWVsZHMuIEEgcGFydGljdWxhciBmaWVsZCBjYW4gYmUgZXhjbHVkZWQgYnkgcHJlZml4aW5nXG4gICAgICogaXQgd2l0aCBhIG1pbnVzLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgb25seSBuYXZpZ2FibGUgKCpuYXZpZ2FibGUpIGZpZWxkcyBhcmUgcmV0dXJuZWQgaW4gdGhpcyBzZWFyY2ggcmVzb3VyY2UuIE5vdGU6IHRoZSBkZWZhdWx0IGlzXG4gICAgICogZGlmZmVyZW50IGluIHRoZSBnZXQtaXNzdWUgcmVzb3VyY2UgLS0gdGhlIGRlZmF1bHQgdGhlcmUgYWxsIGZpZWxkcyAoKmFsbCkuXG4gICAgICpcbiAgICAgKiAqICphbGwgLSBpbmNsdWRlIGFsbCBmaWVsZHNcbiAgICAgKiAqIG5hdmlnYWJsZSAtIGluY2x1ZGUganVzdCBuYXZpZ2FibGUgZmllbGRzXG4gICAgICogKiBzdW1tYXJ5LGNvbW1lbnQgLSBpbmNsdWRlIGp1c3QgdGhlIHN1bW1hcnkgYW5kIGNvbW1lbnRzXG4gICAgICogKiAtZGVzY3JpcHRpb24gLSBpbmNsdWRlIG5hdmlnYWJsZSBmaWVsZHMgZXhjZXB0IHRoZSBkZXNjcmlwdGlvbiAodGhlIGRlZmF1bHQgaXMgKm5hdmlnYWJsZSBmb3Igc2VhcmNoKVxuICAgICAqICogKmFsbCwtY29tbWVudCAtIGluY2x1ZGUgZXZlcnl0aGluZyBleGNlcHQgY29tbWVudHNcbiAgICAgKlxuICAgICAqIEV4cGFuZGluZyBJc3N1ZXMgaW4gdGhlIFNlYXJjaCBSZXN1bHQ6IEl0IGlzIHBvc3NpYmxlIHRvIGV4cGFuZCB0aGUgaXNzdWVzIHJldHVybmVkIGJ5IGRpcmVjdGx5IHNwZWNpZnlpbmcgdGhlXG4gICAgICogZXhwYW5zaW9uIG9uIHRoZSBleHBhbmQgcGFyYW1ldGVyIHBhc3NlZCBpbiB0byB0aGlzIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSwgdG8gZXhwYW5kIHRoZSBcImNoYW5nZWxvZ1wiIGZvciBhbGwgdGhlIGlzc3VlcyBvbiB0aGUgc2VhcmNoIHJlc3VsdCwgaXQgaXMgbmVjY2VzYXJ5IHRvIHNwZWNpZnlcbiAgICAgKiBcImNoYW5nZWxvZ1wiIGFzIG9uZSBvZiB0aGUgdmFsdWVzIHRvIGV4cGFuZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VhcmNoXG4gICAgICogQG1lbWJlck9mIFNlYXJjaENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgb3B0aW9ucyBmb3IgdGhlIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5qcWwgVGhlIEpRTCBxdWVyeSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMuc3RhcnRBdF0gVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpc3N1ZSB0byByZXR1cm4gKDAtYmFzZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLm1heFJlc3VsdHNdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpc3N1ZXMgdG8gcmV0dXJuIChkZWZhdWx0cyB0byA1MCkuIFRoZSBtYXhpbXVtIGFsbG93YWJsZVxuICAgICAqICAgICB2YWx1ZSBpcyBkaWN0YXRlZCBieSB0aGUgSklSQSBwcm9wZXJ0eSAnamlyYS5zZWFyY2gudmlld3MuZGVmYXVsdC5tYXgnLiBJZiB5b3Ugc3BlY2lmeSBhIHZhbHVlIHRoYXQgaXNcbiAgICAgKiAgICAgaGlnaGVyIHRoYW4gdGhpcyBudW1iZXIsIHlvdXIgc2VhcmNoIHJlc3VsdHMgd2lsbCBiZSB0cnVuY2F0ZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy52YWxpZGF0ZVF1ZXJ5PXRydWVdIFdoZXRoZXIgdG8gdmFsaWRhdGUgdGhlIEpRTCBxdWVyeVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IFtvcHRzLmZpZWxkc10gVGhlIGxpc3Qgb2YgZmllbGRzIHRvIHJldHVybiBmb3IgZWFjaCBpc3N1ZS4gQnkgZGVmYXVsdCwgYWxsIG5hdmlnYWJsZSBmaWVsZHMgYXJlXG4gICAgICogICAgIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IFtvcHRzLmV4cGFuZF0gQSBsaXN0IG9mIHRoZSBwYXJhbWV0ZXJzIHRvIGV4cGFuZC5cbiAgICAgKiBAcGFyYW0ge2FycmF5fSBbb3B0cy5wcm9wZXJ0aWVzXSBBIGxpc3Qgb2YgdGhlIHByb3BlcnRpZXMgdG8gaW5jbHVkZSAoNSBtYXgpLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aXRoIHRoZSBzZWFyY2ggcmVzdWx0cy5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIHRoZSBzZWFyY2ggcmVzdWx0cy5cbiAgICAgKi9cbiAgICB0aGlzLnNlYXJjaCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBvcHRzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdQT1NUJztcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvc2VhcmNoJyksXG4gICAgICAgICAgICBtZXRob2Q6IG9wdHMubWV0aG9kLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHRpbWVvdXQ6IG9wdHMudGltZW91dCB8fCAxMDAwMCxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2VhcmNoX29wdGlvbnMgPSB7XG4gICAgICAgICAgICBqcWw6IG9wdHMuanFsLFxuICAgICAgICAgICAgc3RhcnRBdDogb3B0cy5zdGFydEF0LFxuICAgICAgICAgICAgbWF4UmVzdWx0czogb3B0cy5tYXhSZXN1bHRzLFxuICAgICAgICAgICAgdmFsaWRhdGVRdWVyeTogb3B0cy52YWxpZGF0ZVF1ZXJ5LFxuICAgICAgICAgICAgZmllbGRzOiBvcHRzLmZpZWxkcyxcbiAgICAgICAgICAgIGV4cGFuZDogb3B0cy5leHBhbmQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBvcHRzLnByb3BlcnRpZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0cy5tZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gc2VhcmNoX29wdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLnFzID0gc2VhcmNoX29wdGlvbnM7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlY3VyaXR5TGV2ZWxDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvc2VjdXJpdHlsZXZlbCdcbiAqXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBTZWN1cml0eUxldmVsQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIFNlY3VyaXR5TGV2ZWxDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBmdWxsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZWN1cml0eSBsZXZlbCB0aGF0IGhhcyB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFNlY3VyaXR5TGV2ZWxcbiAgICAgKiBAbWVtYmVyT2YgU2VjdXJpdHlMZXZlbENsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHRvIHNlbmQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLnNlY3VyaXR5TGV2ZWxJZCBUaGUgaWQgb2YgdGhlIHNlY3VyaXR5IGxldmVsIHRvIHJldHJpZXZlXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHNlY3VyaXR5IGxldmVsIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBzZWN1cml0eSBsZXZlbCBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRTZWN1cml0eUxldmVsID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9zZWN1cml0eWxldmVsLycgKyBvcHRzLnNlY3VyaXR5TGV2ZWxJZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXJJbmZvQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL3NlcnZlckluZm8nXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBTZXJ2ZXJJbmZvQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIFNlcnZlckluZm9DbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGdlbmVyYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgSklSQSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFNlcnZlckluZm9cbiAgICAgKiBAbWVtYmVyT2YgU2VydmVySW5mb0NsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZG9IZWFsdGhDaGVja10gV2hldGhlciB0byBwZXJmb3JtIGEgaGVhbHRoIGNoZWNrIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHNlcnZlciBpbmZvIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBzZXJ2ZXIgaW5mbyBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRTZXJ2ZXJJbmZvID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy9zZXJ2ZXJJbmZvJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiB7XG4gICAgICAgICAgICAgICAgZG9IZWFsdGhDaGVjazogb3B0cy5kb0hlYWx0aENoZWNrXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxufSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldHRpbmdzQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL3NldHRpbmdzJ1xuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgU2V0dGluZ3NDbGllbnRcbiAqL1xuZnVuY3Rpb24gU2V0dGluZ3NDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBiYXNlIFVSTCB0aGF0IGlzIGNvbmZpZ3VyZWQgZm9yIHRoaXMgSklSQSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0QmFzZVVybFxuICAgICAqIEBtZW1iZXJPZiBTZXR0aW5nc0NsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLm5ld1VybCBUaGUgbmV3IGJhc2UgdXJsLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBiYXNlIHVybCBoYXMgYmVlbiBzZXQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgYmFzZSB1cmwgaGFzIGJlZW4gc2V0LlxuICAgICAqL1xuICAgIHRoaXMuc2V0QmFzZVVybCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvc2V0dGluZ3MvYmFzZVVybCcpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBib2R5OiBvcHRzLm5ld1VybFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHN5c3RlbSBjb2x1bW5zIGZvciBpc3N1ZSBuYXZpZ2F0b3IuIEFkbWluIHBlcm1pc3Npb24gd2lsbCBiZSByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0SXNzdWVOYXZDb2x1bW5zXG4gICAgICogQG1lbWJlck9mIFNldHRpbmdzQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIElnbm9yZWRcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgY29sdW1ucyBoYXZlIGJlZW4gcmV0cmlldmVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgY29sdW1ucyBoYXZlIGJlZW4gcmV0cmlldmVkXG4gICAgICovXG4gICAgdGhpcy5nZXRJc3N1ZU5hdkNvbHVtbnMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3NldHRpbmdzL2NvbHVtbnMnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2lsZVNwcmludENsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hZ2lsZS8xLjAvc3ByaW50J1xuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgQWdpbGVTcHJpbnRDbGllbnRcbiAqL1xuZnVuY3Rpb24gQWdpbGVTcHJpbnRDbGllbnQoamlyYUNsaWVudCkge1xuICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3ByaW50IGZyb20gYSBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIGNyZWF0ZVNwcmludFxuICAgKiBAbWVtYmVyT2YgQWdpbGVTcHJpbnRDbGllbnQjXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcHJpbnQgVGhlIHNwcmludCBkYXRhIGluIHRoZSBmb3JtIG9mIFBPU1QgYm9keSB0byB0aGVcbiAgICogICBKaXJhIEFQSS5cbiAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHNwcmludCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBzcHJpbnQgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICovXG4gIHRoaXMuY3JlYXRlU3ByaW50ID0gZnVuY3Rpb24gKHNwcmludCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkQWdpbGVVUkwoJy9zcHJpbnQnKSxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGJvZHk6IHNwcmludFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGEgc2luZ2xlIHNwcmludC5cbiAgICpcbiAgICogQG1ldGhvZCBnZXRTcHJpbnRcbiAgICogQG1lbWJlck9mIEFnaWxlU3ByaW50Q2xpZW50I1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgKiBAcGFyYW0gb3B0cy5zcHJpbnRJZCBUaGUgc3ByaW50IGlkLlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc3ByaW50IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc3ByaW50IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICovXG4gIHRoaXMuZ2V0U3ByaW50ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEFnaWxlVVJMKCcvc3ByaW50LycgKyBvcHRzLnNwcmludElkKSxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBqc29uOiB0cnVlLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgcXM6IHtcbiAgICAgICAgZmlsdGVyOiBvcHRzLmZpbHRlcixcbiAgICAgICAgc3RhcnRBdDogb3B0cy5zdGFydEF0LFxuICAgICAgICBtYXhSZXN1bHRzOiBvcHRzLm1heFJlc3VsdHNcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYSBmdWxsIHVwZGF0ZSBvZiBhIHNwcmludC5cbiAgICpcbiAgICogQG1ldGhvZCB1cGRhdGVTcHJpbnRcbiAgICogQG1lbWJlck9mIEFnaWxlU3ByaW50Q2xpZW50I1xuICAgKiBAcGFyYW0ge09iamVjdH0gc3ByaW50IFRoZSBzcHJpbnQgZGF0YSBpbiB0aGUgZm9ybSBvZiBQVVQgYm9keSB0byB0aGVcbiAgICogICBKaXJhIEFQSS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzcHJpbnQuc3ByaW50SWRdIFRoZSBpZCBvZiB0aGUgc3ByaW50LiAgRVg6IDMzMVxuICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc3ByaW50IGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHNwcmludCBoYXMgYmVlbiB1cGRhdGVkLlxuICAgKi9cbiAgdGhpcy51cGRhdGVTcHJpbnQgPSBmdW5jdGlvbiAoc3ByaW50LCBjYWxsYmFjaykge1xuICAgIHZhciBzcHJpbnRJZCA9IHNwcmludC5zcHJpbnRJZDtcbiAgICBkZWxldGUgc3ByaW50LnNwcmludElkO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEFnaWxlVVJMKCcvc3ByaW50LycgKyBzcHJpbnRJZCksXG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGJvZHk6IHNwcmludFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogUGVyZm9ybSBhIHBhcnRpYWwgdXBkYXRlIG9mIGEgc3ByaW50LlxuICAgKlxuICAgKiBAbWV0aG9kIHBhcnRpYWxseVVwZGF0ZVNwcmludFxuICAgKiBAbWVtYmVyT2YgQWdpbGVTcHJpbnRDbGllbnQjXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzcHJpbnQgVGhlIHNwcmludCBkYXRhIGluIHRoZSBmb3JtIG9mIFBPU1QgYm9keSB0byB0aGVcbiAgICogICBKaXJhIEFQSS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzcHJpbnQuc3ByaW50SWRdIFRoZSBpZCBvZiB0aGUgc3ByaW50LiAgRVg6IDMzMS5cbiAgICogQHBhcmFtIGNhbGxiYWNrIENhbGxlZCB3aGVuIHRoZSBzcHJpbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc3ByaW50IGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqL1xuICB0aGlzLnBhcnRpYWxseVVwZGF0ZVNwcmludCA9IGZ1bmN0aW9uIChzcHJpbnQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNwcmludElkID0gc3ByaW50LnNwcmludElkO1xuICAgIGRlbGV0ZSBzcHJpbnQuc3ByaW50SWQ7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkQWdpbGVVUkwoJy9zcHJpbnQvJyArIHNwcmludElkKSxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGJvZHk6IHNwcmludFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvKipcbiAgICogRGVsZXRlIGFuIGV4aXN0aW5nIHNwcmludC5cbiAgICpcbiAgICogQG1ldGhvZCBkZWxldGVTcHJpbnRcbiAgICogQG1lbWJlck9mIEFnaWxlU3ByaW50Q2xpZW50I1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5zcHJpbnRJZCBUaGUgaWQgb2YgdGhlIHNwcmludC4gIEVYOiAzMzFcbiAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHNwcmludCBpcyBkZWxldGVkLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBzcHJpbnQgaXMgZGVsZXRlZC5cbiAgICovXG4gIHRoaXMuZGVsZXRlU3ByaW50ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEFnaWxlVVJMKCcvc3ByaW50LycgKyBvcHRzLnNwcmludElkKSxcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBqc29uOiB0cnVlLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgcXM6IHtcbiAgICAgICAgZmlsdGVyOiBvcHRzLmZpbHRlcixcbiAgICAgICAgc3RhcnRBdDogb3B0cy5zdGFydEF0LFxuICAgICAgICBtYXhSZXN1bHRzOiBvcHRzLm1heFJlc3VsdHNcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbGwgaXNzdWVzIGluIGEgc3ByaW50LCBmb3IgYSBnaXZlbiBzcHJpbnQgaWQuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0U3ByaW50SXNzdWVzXG4gICAqIEBtZW1iZXJPZiBBZ2lsZVNwcmludENsaWVudCNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICogQHBhcmFtIG9wdHMuc3ByaW50SWQgVGhlIHNwcmludCBpZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGpxbCBGaWx0ZXJzIHJlc3VsdHMgdXNpbmcgYSBKUUwgcXVlcnkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsaWRhdGVRdWVyeSBTcGVjaWZpZXMgd2hldGhlciB0byB2YWxpZGUgdGhlIEpRTCBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkcyBUaGUgbGlzdCBvZiBmaWVsZHMgdG8gcmV0dXJuIGZvciBlYWNoIGlzc3VlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwYW5kIEEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIHBhcmFtZXRlcnMgdG8gZXhwYW5kLlxuICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgaXNzdWVzIGFyZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgaXNzdWVzIGFyZSByZXR1cm5lZC5cbiAgICovXG4gIHRoaXMuZ2V0U3ByaW50SXNzdWVzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEFnaWxlVVJMKCcvc3ByaW50LycgKyBvcHRzLnNwcmludElkICsgJy9pc3N1ZScpLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGpzb246IHRydWUsXG4gICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICBxczoge1xuICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0cyxcbiAgICAgICAganFsOiBvcHRzLmpxbCxcbiAgICAgICAgdmFsaWRhdGVRdWVyeTogb3B0cy52YWxpZGF0ZVF1ZXJ5LFxuICAgICAgICBmaWVsZHM6IG9wdHMuZmllbGRzLFxuICAgICAgICBleHBhbmQ6IG9wdHMuZXhwYW5kXG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNb3ZlIGlzc3VlcyB0byBhIHNwcmludCwgZm9yIGEgZ2l2ZW4gc3ByaW50IGlkLlxuICAgKlxuICAgKiBAbWV0aG9kIG1vdmVTcHJpbnRJc3N1ZXNcbiAgICogQG1lbWJlck9mIEFnaWxlU3ByaW50Q2xpZW50I1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgaXNzdWUgZGF0YSBpbiB0aGUgZm9ybSBvZiBQT1NUIGJvZHkgdG8gdGhlXG4gICAqICAgSmlyYSBBUEkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5zcHJpbnRJZF0gVGhlIHNwcmludCBpZC5cbiAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHNwcmludCBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHNwcmludCBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAqL1xuICB0aGlzLm1vdmVTcHJpbnRJc3N1ZXMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICB2YXIgc3ByaW50SWQgPSBvcHRzLnNwcmludElkO1xuICAgIGRlbGV0ZSBvcHRzLnNwcmludElkO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEFnaWxlVVJMKCcvc3ByaW50LycgKyBzcHJpbnRJZCArICcvaXNzdWUnKSxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGJvZHk6IG9wdHNcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN3YXAgdGhlIHBvc2l0aW9uIG9mIHRoZSBzcHJpbnQgKGdpdmVuIGJ5IHNwcmludCBpZCkgd2l0aCB0aGUgc2Vjb25kXG4gICAqIHNwcmludC5cbiAgICpcbiAgICogQG1ldGhvZCBzd2FwU3ByaW50XG4gICAqIEBtZW1iZXJPZiBBZ2lsZVNwcmludENsaWVudCNcbiAgICogQHBhcmFtIHtPYmplY3R9IHN3YXBwZWQgVGhlIGRhdGEgaW4gdGhlIGZvcm0gb2YgUE9TVCBib2R5IHRvIHRoZSBKaXJhIEFQSS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzd2FwcGVkLnNwcmludElkXSBUaGUgaWQgb2YgdGhlIHNwcmludC4gIEVYOiAzMTFcbiAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHNwcmludCBoYXMgYmVlbiByZXRyaXZlZC5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc3ByaW50IGhhcyBiZWVuIHJldHJpdmVkLlxuICAgKi9cbiAgdGhpcy5zd2FwU3ByaW50ID0gZnVuY3Rpb24gKHN3YXBwZWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNwcmludElkID0gc3dhcHBlZC5zcHJpbnRJZDtcbiAgICBkZWxldGUgc3dhcHBlZC5zcHJpbnRJZDtcblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRBZ2lsZVVSTCgnL3NwcmludC8nICsgc3ByaW50SWQgKyAnL3N3YXAnKSxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAganNvbjogdHJ1ZSxcbiAgICAgIGJvZHk6IHN3YXBwZWRcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gIH07XG5cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXR1c0NsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi9zdGF0dXMnXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgU3RhdHVzQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIFN0YXR1c0NsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBzdGF0dXNlcyB2aXNpYmxlIHRvIHRoZSB1c2VyXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEFsbFN0YXR1c2VzXG4gICAgICogQG1lbWJlck9mIFN0YXR1c0NsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBJZ25vcmVkXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gc3RhdHVzZXMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHN0YXR1c2VzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRBbGxTdGF0dXNlcyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvc3RhdHVzJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBmdWxsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGF0dXMgdGhhdCBoYXMgdGhlIGdpdmVuIGlkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRTdGF0dXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhdHVzQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIG9wdHMuc3RhdHVzSWQgQSBTdHJpbmcgY29udGFpbmluZyBhIHN0YXR1cyBpZFxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBzdGF0dXMgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHN0YXR1cyBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRTdGF0dXMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3N0YXR1cy8nICsgb3B0cy5zdGF0dXNJZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdHVzQ2F0ZWdvcnlDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvc3RhdHVzY2F0ZWdvcnknXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgU3RhdHVzQ2F0ZWdvcnlDbGllbnRcbiAqL1xuZnVuY3Rpb24gU3RhdHVzQ2F0ZWdvcnlDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgc3RhdHVzQ2F0ZWdvcmllcyB2aXNpYmxlIHRvIHRoZSB1c2VyXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEFsbFN0YXR1c0NhdGVnb3JpZXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhdHVzQ2F0ZWdvcnlDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgSWdub3JlZFxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBzdGF0dXNDYXRlZ29yaWVzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc3RhdHVzQ2F0ZWdvcmllcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0QWxsU3RhdHVzQ2F0ZWdvcmllcyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvc3RhdHVzY2F0ZWdvcnknKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGZ1bGwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0YXR1c0NhdGVnb3J5IHRoYXQgaGFzIHRoZSBnaXZlbiBpZCBvciBrZXkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFN0YXR1c0NhdGVnb3J5XG4gICAgICogQG1lbWJlck9mIFN0YXR1c0NhdGVnb3J5Q2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIG9wdHMuc3RhdHVzQ2F0ZWdvcnlJZE9yS2V5IEEgU3RyaW5nIGNvbnRhaW5pbmcgYSBzdGF0dXNDYXRlZ29yeSBpZFxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBzdGF0dXNDYXRlZ29yeSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc3RhdHVzQ2F0ZWdvcnkgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0U3RhdHVzQ2F0ZWdvcnkgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3N0YXR1c2NhdGVnb3J5LycgKyBvcHRzLnN0YXR1c0NhdGVnb3J5SWRPcktleSksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBVc2VyQ2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL3VzZXInXG4gKlxuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgVXNlckNsaWVudFxuICovXG5mdW5jdGlvbiBVc2VyQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgdXNlci4gVGhpcyByZXNvdXJjZSBjYW5ub3QgYmUgYWNjZXNzZWQgYW5vbnltb3VzbHkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFVzZXJcbiAgICAgKiBAbWVtYmVyT2YgVXNlckNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIG9wdHMudXNlcm5hbWUgVGhlIG5hbWUgb2YgdGhlIHVzZXIgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIG9wdHMudXNlcktleSBUaGUga2V5IG9mIHRoZSB1c2VyIHRvIHJldHJpZXZlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmV4cGFuZCBUaGUgZmllbGRzIHRvIGJlIGV4cGFuZGVkLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB1c2VyIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFVzZXIgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3VzZXInKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogb3B0cy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBrZXk6IG9wdHMudXNlcktleSxcbiAgICAgICAgICAgICAgICBleHBhbmQ6IG9wdHMuZXhwYW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdHMuZXhwYW5kKSB7XG4gICAgICAgICAgICBvcHRpb25zLnFzLmV4cGFuZCA9ICcnO1xuICAgICAgICAgICAgb3B0cy5leHBhbmQuZm9yRWFjaChmdW5jdGlvbiAoZXgpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnFzLmV4cGFuZCArPSBleCArICcsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB1c2VyLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZWxldGVVc2VyXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLnVzZXJuYW1lIFRoZSBuYW1lIG9mIHRoZSB1c2VyIHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0gb3B0cy51c2VyS2V5IFRoZSBrZXkgb2YgdGhlIHVzZXIgdG8gZGVsZXRlLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgdXNlciBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlVXNlciA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvdXNlcicpLFxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBvcHRzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIGtleTogb3B0cy51c2VyS2V5XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ1VzZXIgcmVtb3ZlZC4nKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHVzZXIuIEJ5IGRlZmF1bHQgY3JlYXRlZCB1c2VyIHdpbGwgbm90IGJlIG5vdGlmaWVkIHdpdGggZW1haWwuIElmIHBhc3N3b3JkIGZpZWxkIGlzIG5vdCBzZXQgdGhlbiBwYXNzd29yZFxuICAgICAqIHdpbGwgYmUgcmFuZG9tbHkgZ2VuZXJhdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVVc2VyXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy51c2VyIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlNDA0OX1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHVzZXIgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZVVzZXIgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3VzZXInKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMudXNlclxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdXNlci4gVGhlIFwidmFsdWVcIiBmaWVsZHMgcHJlc2VudCB3aWxsIG92ZXJyaWRlIHRoZSBleGlzdGluZyB2YWx1ZS4gRmllbGRzIHNraXBwZWQgaW4gcmVxdWVzdCB3aWxsIG5vdCBiZVxuICAgICAqIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGVkaXRVc2VyXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLnVzZXIgU2VlIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmU0MDgxfVxuICAgICAqIEBwYXJhbSBvcHRzLnVzZXJuYW1lIFRoZSBuYW1lIG9mIHRoZSB1c2VyIHRvIGVkaXQuXG4gICAgICogQHBhcmFtIG9wdHMudXNlcktleSBUaGUga2V5IG9mIHRoZSB1c2VyIHRvIGVkaXQuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHVzZXIgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHVzZXIgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqL1xuICAgIHRoaXMuZWRpdFVzZXIgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3VzZXInKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogb3B0cy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBrZXk6IG9wdHMudXNlcktleVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMudXNlclxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB1c2VycyB0aGF0IG1hdGNoIHRoZSBzZWFyY2ggc3RyaW5nIGFuZCBjYW4gYmUgYXNzaWduZWQgaXNzdWVzIGZvciBhbGwgdGhlIGdpdmVuIHByb2plY3RzLiBUaGlzXG4gICAgICogcmVzb3VyY2UgY2Fubm90IGJlIGFjY2Vzc2VkIGFub255bW91c2x5LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBtdWx0aVByb2plY3RTZWFyY2hBc3NpZ25hYmxlXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnVzZXJuYW1lIFRoZSBuYW1lIG9mIHRoZSB1c2VyIHRvIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvcHRzLnByb2plY3RLZXlzIFRoZSBrZXlzIG9mIHRoZSBwcm9qZWN0cyB3ZSBhcmUgZmluZGluZyBhc3NpZ25hYmxlIHVzZXJzIGZvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5zdGFydEF0XSBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IHVzZXIgdG8gcmV0dXJuICgwLWJhc2VkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5tYXhSZXN1bHRzXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgdXNlcnMgdG8gcmV0dXJuIChkZWZhdWx0cyB0byA1MCkuIFRoZSBtYXhpbXVtIGFsbG93ZWRcbiAgICAgKiAgICAgdmFsdWUgaXMgMTAwMC4gSWYgeW91IHNwZWNpZnkgYSB2YWx1ZSB0aGF0IGlzIGhpZ2hlciB0aGFuIHRoaXMgbnVtYmVyLCB5b3VyIHNlYXJjaCByZXN1bHRzIHdpbGwgYmVcbiAgICAgKiAgICAgdHJ1bmNhdGVkLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBzZWFyY2ggcmVzdWx0cyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHNlYXJjaCByZXN1bHRzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5tdWx0aVByb2plY3RTZWFyY2hBc3NpZ25hYmxlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBwcm9qZWN0S2V5U3RyaW5nID0gJyc7XG4gICAgICAgIGlmIChvcHRzLnByb2plY3RLZXlzKSB7XG4gICAgICAgICAgICBvcHRzLnByb2plY3RLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHByb2plY3RLZXlTdHJpbmcgKz0ga2V5ICsgJywnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9qZWN0S2V5U3RyaW5nID0gcHJvamVjdEtleVN0cmluZy5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3VzZXIvYXNzaWduYWJsZS9tdWx0aVByb2plY3RTZWFyY2gnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogb3B0cy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0S2V5czogcHJvamVjdEtleVN0cmluZyxcbiAgICAgICAgICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgICAgICAgICAgbWF4UmVzdWx0czogb3B0cy5tYXhSZXN1bHRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB1c2VycyB0aGF0IG1hdGNoIHRoZSBzZWFyY2ggc3RyaW5nLiBUaGlzIHJlc291cmNlIGNhbm5vdCBiZSBhY2Nlc3NlZCBhbm9ueW1vdXNseS4gUGxlYXNlIG5vdGVcbiAgICAgKiB0aGF0IHRoaXMgcmVzb3VyY2Ugc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGFuIGlzc3VlIGtleSB3aGVuIGEgbGlzdCBvZiBhc3NpZ25hYmxlIHVzZXJzIGlzIHJldHJpZXZlZCBmb3IgZWRpdGluZy5cbiAgICAgKiBGb3IgY3JlYXRlIG9ubHkgYSBwcm9qZWN0IGtleSBzaG91bGQgYmUgc3VwcGxpZWQuIFRoZSBsaXN0IG9mIGFzc2lnbmFibGUgdXNlcnMgbWF5IGJlIGluY29ycmVjdCBpZiBpdCdzIGNhbGxlZFxuICAgICAqIHdpdGggdGhlIHByb2plY3Qga2V5IGZvciBlZGl0aW5nLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWFyY2hBc3NpZ25hYmxlXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnVzZXJuYW1lIFRoZSB1c2VybmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnByb2plY3QgVGhlIGtleSBvZiB0aGUgcHJvamVjdCB3ZSBhcmUgZmluZGluZyBhc3NpZ25hYmxlIHVzZXJzIGZvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gVGhlIGlzc3VlIGtleSBmb3IgdGhlIGlzc3VlIGJlaW5nIGVkaXRlZCB3ZSBuZWVkIHRvIGZpbmQgYXNzaWduYWJsZSB1c2VycyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnN0YXJ0QXRdIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdXNlciB0byByZXR1cm4gKDAtYmFzZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLm1heFJlc3VsdHNdIFRoZSBtYXhpbXVtIG51bWJlciBvZiB1c2VycyB0byByZXR1cm4gKGRlZmF1bHRzIHRvIDUwKS4gVGhlIG1heGltdW0gYWxsb3dlZFxuICAgICAqICAgICB2YWx1ZSBpcyAxMDAwLiBJZiB5b3Ugc3BlY2lmeSBhIHZhbHVlIHRoYXQgaXMgaGlnaGVyIHRoYW4gdGhpcyBudW1iZXIsIHlvdXIgc2VhcmNoIHJlc3VsdHMgd2lsbCBiZVxuICAgICAqICAgICB0cnVuY2F0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmFjdGlvbkRlc2NyaXB0b3JJZF1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc2VhcmNoIHJlc3VsdHMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBzZWFyY2ggcmVzdWx0cyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuc2VhcmNoQXNzaWduYWJsZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvdXNlci9hc3NpZ25hYmxlL3NlYXJjaCcpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBvcHRzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIHByb2plY3Q6IG9wdHMucHJvamVjdCxcbiAgICAgICAgICAgICAgICBpc3N1ZUtleTogb3B0cy5pc3N1ZUtleSxcbiAgICAgICAgICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgICAgICAgICAgbWF4UmVzdWx0czogb3B0cy5tYXhSZXN1bHRzLFxuICAgICAgICAgICAgICAgIGFjdGlvbkRlc2NyaXB0b3JJZDogb3B0cy5hY3Rpb25EZXNjcmlwdG9ySWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGVtcG9yYXJ5IGF2YXRhci4gQ3JlYXRpbmcgYSB0ZW1wb3JhcnkgYXZhdGFyIGlzIHBhcnQgb2YgYSAzLXN0ZXAgcHJvY2VzcyBpbiB1cGxvYWRpbmcgYSBuZXcgYXZhdGFyIGZvclxuICAgICAqIGEgdXNlcjogdXBsb2FkLCBjcm9wLCBjb25maXJtLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVUZW1wb3JhcnlBdmF0YXJcbiAgICAgKiBAbWVtYmVyT2YgVXNlckNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMudXNlcm5hbWUgVGhlIHVzZXJuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZmlsZXBhdGggVGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB0ZW1wb3JhcnkgYXZhdGFyIGhhcyBiZWVuIHVwbG9hZGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHRlbXBvcmFyeSBhdmF0YXIgaGFzIGJlZW4gdXBsb2FkZWQuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVUZW1wb3JhcnlBdmF0YXIgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShvcHRzLmZpbGVwYXRoKS5zbGljZSgxKTtcbiAgICAgICAgdmFyIGJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShvcHRzLmZpbGVwYXRoKTtcbiAgICAgICAgdmFyIGZpbGVTaXplID0gZnMuc3RhdFN5bmMob3B0cy5maWxlcGF0aCkuc2l6ZTtcblxuICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24gPT0gJ2pwZycgPyAnanBlZycgOiBleHRlbnNpb247XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3VzZXIvYXZhdGFyL3RlbXBvcmFyeScpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBvcHRzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBiYXNlTmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBmaWxlU2l6ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IGZzLnJlYWRGaWxlU3luYyhvcHRzLmZpbGVwYXRoKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIlgtQXRsYXNzaWFuLVRva2VuXCI6ICduby1jaGVjaycsXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogJ2ltYWdlLycgKyBleHRlbnNpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRlbXBvcmFyeSBhdmF0YXIgaW50byBhIHJlYWwgYXZhdGFyXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNvbnZlcnRUZW1wb3JhcnlBdmF0YXJcbiAgICAgKiBAbWVtYmVyT2YgVXNlckNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMudXNlcm5hbWUgVGhlIHVzZXJuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMuYXZhdGFySWQgVGhlIGlkIG9mIHRoZSB0ZW1wb3JhcnkgYXZhdGFyIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGF2YXRhciBoYXMgYmVlbiBjb252ZXJ0ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhdmF0YXIgaGFzIGJlZW4gY29udmVydGVkXG4gICAgICovXG4gICAgdGhpcy5jb252ZXJ0VGVtcG9yYXJ5QXZhdGFyID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy91c2VyL2F2YXRhci8nKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogb3B0cy51c2VybmFtZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IHtpZDogb3B0cy5hdmF0YXJJZH0sXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJYLUF0bGFzc2lhbi1Ub2tlblwiOiAnbm8tY2hlY2snXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdBdmF0YXIgQ29udmVydGVkJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYXZhdGFyXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlbGV0ZUF2YXRhclxuICAgICAqIEBtZW1iZXJPZiBVc2VyQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy51c2VybmFtZSBUaGUgdXNlcm5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5hdmF0YXJJZCBUaGUgaWQgb2YgdGhlIHRlbXBvcmFyeSBhdmF0YXIgdG8gZGVsZXRlLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBhdmF0YXIgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBhdmF0YXIgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZUF2YXRhciA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvdXNlci9hdmF0YXIvJyArIG9wdHMuYXZhdGFySWQpLFxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBvcHRzLnVzZXJuYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdBdmF0YXIgRGVsZXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBhdmF0YXJzIHdoaWNoIGFyZSB2aXNpYmxlIGZvciB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRBdmF0YXJzXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnVzZXJuYW1lIFRoZSB1c2VybmFtZVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBhdmF0YXJzIGhhdmUgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgYXZhdGFycyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0QXZhdGFycyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvdXNlci9hdmF0YXJzJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIHFzOiB7XG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IG9wdHMudXNlcm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgY29sdW1ucyBmb3IgdGhlIGdpdmVuIHVzZXIuIEFkbWluIHBlcm1pc3Npb24gd2lsbCBiZSByZXF1aXJlZCB0byBnZXQgY29sdW1ucyBmb3IgYSB1c2VyXG4gICAgICogb3RoZXIgdGhhbiB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXREZWZhdWx0Q29sdW1uc1xuICAgICAqIEBtZW1iZXJPZiBVc2VyQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy51c2VybmFtZSBUaGUgdXNlcm5hbWVcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgY29sdW1ucyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGNvbHVtbnMgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldERlZmF1bHRDb2x1bW5zID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy91c2VyL2NvbHVtbnMnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogb3B0cy51c2VybmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCBjb2x1bW5zIGZvciB0aGUgZ2l2ZW4gdXNlci4gQWRtaW4gcGVybWlzc2lvbiB3aWxsIGJlIHJlcXVpcmVkIHRvIGdldCBjb2x1bW5zIGZvciBhIHVzZXIgb3RoZXJcbiAgICAgKiB0aGFuIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldERlZmF1bHRDb2x1bW5zXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnVzZXJuYW1lIFRoZSB1c2VybmFtZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wdHMuY29sdW1ucyBUaGUgbmFtZXMgb2YgdGhlIG5ldyBjb2x1bW5zLiAgU2VlIHtAbGlua1xuICAgICAgICAqICAgICBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmU0NTY2fVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBjb2x1bW5zIGhhdmUgYmVlbiBzZXQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgY29sdW1ucyBoYXZlIGJlZW4gc2V0LlxuICAgICAqL1xuICAgIHRoaXMuc2V0RGVmYXVsdENvbHVtbnMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3VzZXIvY29sdW1ucycpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBvcHRzLnVzZXJuYW1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgIGNvbHVtbnM6IG9wdHMuY29sdW1uc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnRGVmYXVsdCBDb2x1bW5zIFNldCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgZGVmYXVsdCBjb2x1bW5zIGZvciB0aGUgZ2l2ZW4gdXNlciB0byB0aGUgc3lzdGVtIGRlZmF1bHQuIEFkbWluIHBlcm1pc3Npb24gd2lsbCBiZSByZXF1aXJlZCB0byBnZXRcbiAgICAgKiBjb2x1bW5zIGZvciBhIHVzZXIgb3RoZXIgdGhhbiB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZXNldERlZmF1bHRDb2x1bW5zXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnVzZXJuYW1lIFRoZSB1c2VybmFtZVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBjb2x1bW5zIGhhdmUgYmVlbiByZXNldC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBjb2x1bW5zIGhhdmUgYmVlbiByZXNldC5cbiAgICAgKi9cbiAgICB0aGlzLnJlc2V0RGVmYXVsdENvbHVtbnMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3VzZXIvY29sdW1ucycpLFxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBvcHRzLnVzZXJuYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdEZWZhdWx0IENvbHVtbnMgUmVzZXQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHVzZXIgcGFzc3dvcmQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGNoYW5nZVBhc3N3b3JkXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLnVzZXJuYW1lIFRoZSBuYW1lIG9mIHRoZSB1c2VyIGZvciB3aGljaCB0byBjaGFuZ2UgdGhlIHBhc3N3b3JkLlxuICAgICAqIEBwYXJhbSBvcHRzLnVzZXJLZXkgVGhlIGtleSBvZiB0aGUgdXNlciBmb3Igd2hpY2ggdG8gY2hhbmdlIHRoZSBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0gb3B0cy5wYXNzd29yZCBUaGUgbmV3IHBhc3N3b3JkLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBwYXNzd29yZCBoYXMgYmVlbiBzZXQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcGFzc3dvcmQgaGFzIGJlZW4gc2V0LlxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlUGFzc3dvcmQgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3VzZXIvcGFzc3dvcmQnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogb3B0cy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBrZXk6IG9wdHMudXNlcktleVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogb3B0cy5wYXNzd29yZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnUGFzc3dvcmQgQ2hhbmdlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhY3RpdmUgdXNlcnMgdGhhdCBtYXRjaCB0aGUgc2VhcmNoIHN0cmluZyBhbmQgaGF2ZSBhbGwgc3BlY2lmaWVkIHBlcm1pc3Npb25zIGZvciB0aGUgcHJvamVjdFxuICAgICAqIG9yIGlzc3VlLlxuICAgICAqXG4gICAgICogVGhpcyByZXNvdXJjZSBjYW4gYmUgYWNjZXNzZWQgYnkgdXNlcnMgd2l0aCBBRE1JTklTVEVSX1BST0pFQ1QgcGVybWlzc2lvbiBmb3IgdGhlIHByb2plY3Qgb3IgZ2xvYmFsXG4gICAgICogQURNSU4gb3IgU1lTQURNSU4gcmlnaHRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZWFyY2hQZXJtaXNzaW9uc1xuICAgICAqIEBtZW1iZXJPZiBVc2VyQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgamlyYSBBUElcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy51c2VybmFtZSBUaGUgdXNlcm5hbWUgZmlsdGVyLCBsaXN0IGluY2x1ZGVzIGFsbCB1c2VycyBpZiB1bnNwZWNpZmllZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wdHMucGVybWlzc2lvbnMgQXJyYXkgb2YgcGVybWlzc2lvbnMgZm9yIHByb2plY3Qgb3IgaXNzdWUgcmV0dXJuZWQgdXNlcnMgbXVzdCBoYXZlLCBzZWVcbiAgICAgKiAgICAgW1Blcm1pc3Npb25zXXtAbGlua1xuICAgICAgICAqICAgICBodHRwczovL2RldmVsb3Blci5hdGxhc3NpYW4uY29tL3N0YXRpYy9qYXZhZG9jL2ppcmEvNi4wL3JlZmVyZW5jZS9jb20vYXRsYXNzaWFuL2ppcmEvc2VjdXJpdHkvUGVybWlzc2lvbnMuUGVybWlzc2lvbi5odG1sfVxuICAgICAgICAqICAgICBKYXZhRG9jIGZvciB0aGUgbGlzdCBvZiBhbGwgcG9zc2libGUgcGVybWlzc2lvbnMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmlzc3VlS2V5XSB0aGUgaXNzdWUga2V5IGZvciB0aGUgaXNzdWUgZm9yIHdoaWNoIHJldHVybmVkIHVzZXJzIGhhdmUgc3BlY2lmaWVkIHBlcm1pc3Npb25zLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5wcm9qZWN0S2V5XSB0aGUgb3B0aW9uYWwgcHJvamVjdCBrZXkgdG8gc2VhcmNoIGZvciB1c2VycyB3aXRoIGlmIG5vIGlzc3VlS2V5IGlzIHN1cHBsaWVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5zdGFydEF0XSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVzZXIgdG8gcmV0dXJuICgwLWJhc2VkKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5tYXhSZXN1bHRzXSB0aGUgbWF4aW11bSBudW1iZXIgb2YgdXNlcnMgdG8gcmV0dXJuIChkZWZhdWx0cyB0byA1MCkuIFRoZSBtYXhpbXVtIGFsbG93ZWRcbiAgICAgKiAgICAgdmFsdWUgaXMgMTAwMC4gSWYgeW91IHNwZWNpZnkgYSB2YWx1ZSB0aGF0IGlzIGhpZ2hlciB0aGFuIHRoaXMgbnVtYmVyLCB5b3VyIHNlYXJjaCByZXN1bHRzIHdpbGwgYmVcbiAgICAgKiAgICAgdHJ1bmNhdGVkLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBzZWFyY2ggcmVzdWx0cyBhcmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHNlYXJjaCByZXN1bHRzIGFyZSByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5zZWFyY2hQZXJtaXNzaW9ucyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcGVybWlzc2lvbnMgPSAnJztcbiAgICAgICAgaWYgKG9wdHMucGVybWlzc2lvbnMpIHtcbiAgICAgICAgICAgIG9wdHMucGVybWlzc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zICs9IHMgKyAnLCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGVybWlzc2lvbnMgPSBwZXJtaXNzaW9ucy5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFVSTCgnL3VzZXIvcGVybWlzc2lvbi9zZWFyY2gnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogb3B0cy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogcGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgaXNzdWVLZXk6IG9wdHMuaXNzdWVLZXksXG4gICAgICAgICAgICAgICAgcHJvamVjdEtleTogb3B0cy5wcm9qZWN0S2V5LFxuICAgICAgICAgICAgICAgIHN0YXJ0QXQ6IG9wdHMuc3RhcnRBdCxcbiAgICAgICAgICAgICAgICBtYXhSZXN1bHRzOiBvcHRzLm1heFJlc3VsdHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHVzZXJzIG1hdGNoaW5nIHF1ZXJ5IHdpdGggaGlnaGxpZ2h0aW5nLiBUaGlzIHJlc291cmNlIGNhbm5vdCBiZSBhY2Nlc3NlZCBhbm9ueW1vdXNseS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VhcmNoUGlja2VyXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5xdWVyeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5tYXhSZXN1bHRzPTUwXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2hvd0F2YXRhcj1mYWxzZV1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZXhjbHVkZV1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc2VhcmNoIHJlc3VsdHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBzZWFyY2ggcmVzdWx0cyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuc2VhcmNoUGlja2VyID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy91c2VyL3BpY2tlcicpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBvcHRzLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0cyxcbiAgICAgICAgICAgICAgICBzaG93QXZhdGFyOiBvcHRzLnNob3dBdmF0YXIsXG4gICAgICAgICAgICAgICAgZXhjbHVkZTogb3B0cy5leGNsdWRlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB1c2VycyB0aGF0IG1hdGNoIHRoZSBzZWFyY2ggc3RyaW5nLiBUaGlzIHJlc291cmNlIGNhbm5vdCBiZSBhY2Nlc3NlZCBhbm9ueW1vdXNseS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2VhcmNoXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy51c2VybmFtZSBBIHF1ZXJ5IHN0cmluZyB1c2VkIHRvIHNlYXJjaCB1c2VybmFtZSwgbmFtZSBvciBlLW1haWwgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5zdGFydEF0PTBdIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdXNlciB0byByZXR1cm4gKDAtYmFzZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLm1heFJlc3VsdHM9NTBdIHRoZSBtYXhpbXVtIG51bWJlciBvZiB1c2VycyB0byByZXR1cm4gKGRlZmF1bHRzIHRvIDUwKS4gVGhlIG1heGltdW0gYWxsb3dlZFxuICAgICAqICAgICB2YWx1ZSBpcyAxMDAwLiBJZiB5b3Ugc3BlY2lmeSBhIHZhbHVlIHRoYXQgaXMgaGlnaGVyIHRoYW4gdGhpcyBudW1iZXIsIHlvdXIgc2VhcmNoIHJlc3VsdHMgd2lsbCBiZVxuICAgICAqICAgICB0cnVuY2F0ZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlQWN0aXZlPXRydWVdIElmIHRydWUsIHRoZW4gYWN0aXZlIHVzZXJzIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0cyAoZGVmYXVsdCB0cnVlKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUluYWN0aXZlPWZhbHNlXSBJZiB0cnVlLCB0aGVuIGluYWN0aXZlIHVzZXJzIGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0cyAoZGVmYXVsdFxuICAgICAqICAgICBmYWxzZSlcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc2VhcmNoIHJlc3VsdHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBzZWFyY2ggcmVzdWx0cyBhcmUgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuc2VhcmNoID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy91c2VyL3NlYXJjaCcpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBvcHRzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0cyxcbiAgICAgICAgICAgICAgICBzdGFydEF0OiBvcHRzLnN0YXJ0QXQsXG4gICAgICAgICAgICAgICAgaW5jbHVkZUFjdGl2ZTogb3B0cy5pbmNsdWRlQWN0aXZlLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVJbmFjdGl2ZTogb3B0cy5pbmNsdWRlSW5hY3RpdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFjdGl2ZSB1c2VycyB0aGF0IG1hdGNoIHRoZSBzZWFyY2ggc3RyaW5nLiBUaGlzIHJlc291cmNlIGNhbm5vdCBiZSBhY2Nlc3NlZCBhbm9ueW1vdXNseS4gR2l2ZW5cbiAgICAgKiBhbiBpc3N1ZSBrZXkgdGhpcyByZXNvdXJjZSB3aWxsIHByb3ZpZGUgYSBsaXN0IG9mIHVzZXJzIHRoYXQgbWF0Y2ggdGhlIHNlYXJjaCBzdHJpbmcgYW5kIGhhdmUgdGhlIGJyb3dzZSBpc3N1ZVxuICAgICAqIHBlcm1pc3Npb24gZm9yIHRoZSBpc3N1ZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgdmlld0lzc3VlU2VhcmNoXG4gICAgICogQG1lbWJlck9mIFVzZXJDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy51c2VybmFtZSBBIHF1ZXJ5IHN0cmluZyB1c2VkIHRvIHNlYXJjaCB1c2VybmFtZSwgbmFtZSBvciBlLW1haWwgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5pc3N1ZUtleV0gdGhlIGlzc3VlIGtleSBmb3IgdGhlIGlzc3VlIGJlaW5nIGVkaXRlZCB3ZSBuZWVkIHRvIGZpbmQgdmlld2FibGUgdXNlcnMgZm9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5wcm9qZWN0S2V5XSB0aGUgb3B0aW9uYWwgcHJvamVjdCBrZXkgdG8gc2VhcmNoIGZvciB1c2VycyB3aXRoIGlmIG5vIGlzc3VlS2V5IGlzIHN1cHBsaWVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5zdGFydEF0PTBdIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdXNlciB0byByZXR1cm4gKDAtYmFzZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLm1heFJlc3VsdHM9NTBdIHRoZSBtYXhpbXVtIG51bWJlciBvZiB1c2VycyB0byByZXR1cm4gKGRlZmF1bHRzIHRvIDUwKS4gVGhlIG1heGltdW0gYWxsb3dlZFxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIGRhdGEgaGFzIGJlZW4gcmV0cmlldmVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBkYXRhIGhhcyBiZWVuIHJldHJpZXZlZFxuICAgICAqL1xuICAgIHRoaXMudmlld0lzc3VlU2VhcmNoID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy91c2VyL3ZpZXdpc3N1ZS9zZWFyY2gnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogb3B0cy51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBpc3N1ZUtleTogb3B0cy5pc3N1ZUtleSxcbiAgICAgICAgICAgICAgICBwcm9qZWN0S2V5OiBvcHRzLnByb2plY3RLZXksXG4gICAgICAgICAgICAgICAgc3RhcnRBdDogb3B0cy5zdGFydEF0LFxuICAgICAgICAgICAgICAgIG1heFJlc3VsdHM6IG9wdHMubWF4UmVzdWx0c1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVyc2lvbkNsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC9hcGkvMi92ZXJzaW9uJ1xuICogQHBhcmFtIHtKaXJhQ2xpZW50fSBqaXJhQ2xpZW50XG4gKiBAY29uc3RydWN0b3IgVmVyc2lvbkNsaWVudFxuICovXG5mdW5jdGlvbiBWZXJzaW9uQ2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHZlcnNpb25cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlVmVyc2lvblxuICAgICAqIEBtZW1iZXJPZiBWZXJzaW9uQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byBKaXJhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLnZlcnNpb24gU2VlIHtAbGluayBodHRwczovL2RvY3MuYXRsYXNzaWFuLmNvbS9qaXJhL1JFU1QvbGF0ZXN0LyNkMmUzNTQ5fVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB2ZXJzaW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgdmVyc2lvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlVmVyc2lvbiA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvdmVyc2lvbicpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgYm9keTogb3B0cy52ZXJzaW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSBhIHZlcnNpb24ncyBzZXF1ZW5jZSB3aXRoaW4gYSBwcm9qZWN0LiBUaGUgbW92ZSB2ZXJzaW9uIGJlYW4gaGFzIDIgYWx0ZXJuYXRpdmUgZmllbGQgdmFsdWUgcGFpcnNcbiAgICAgKiAob3B0cy5wb3NpdGlvbiBvciBvcHRzLmFmdGVyKS4gIE9uZSBhbmQgb25seSBvbmUgb2YgdGhlc2UgdHdvIG11c3QgYmUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG1vdmVWZXJzaW9uXG4gICAgICogQG1lbWJlck9mIFZlcnNpb25DbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy52ZXJzaW9uSWQgVGhlIGlkIG9mIHRoZSB2ZXJzaW9uIHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnBvc2l0aW9uXSBBbiBhYnNvbHV0ZSBwb3NpdGlvbiwgd2hpY2ggbWF5IGhhdmUgYSB2YWx1ZSBvZiAnRmlyc3QnLCAnTGFzdCcsICdFYXJsaWVyJyBvclxuICAgICAqICAgICAnTGF0ZXInLiBNdXN0IGJlIHByb3ZpZGVkIGlmIG9wdHMuYWZ0ZXIgaXMgbWlzc2luZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYWZ0ZXJdIEEgdmVyc2lvbiB0byBwbGFjZSB0aGlzIHZlcnNpb24gYWZ0ZXIuIFRoZSB2YWx1ZSBzaG91bGQgYmUgdGhlIHNlbGYgbGluayBvZiBhbm90aGVyXG4gICAgICogICAgIHZlcnNpb24uIE11c3QgYmUgcHJvdmlkZWQgaWYgb3B0cy5wb3NpdGlvbiBpcyBtaXNzaW5nXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHZlcnNpb24gaGFzIGJlZW4gbW92ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgdmVyc2lvbiBoYXMgYmVlbiBtb3ZlZC5cbiAgICAgKi9cbiAgICB0aGlzLm1vdmVWZXJzaW9uID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvbW92ZScsICdQT1NUJywge3Bvc2l0aW9uOiBvcHRzLnBvc2l0aW9uLCBhZnRlcjogb3B0cy5hZnRlcn0pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFxuICAgICAvKipcbiAgICAgKiBHZXQgYSBhbGwgdmVyc2lvbnMgZnJvbSBzcGVjaWZpYyBib2FyZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0QWxsVmVyc2lvbnNcbiAgICAgKiBAbWVtYmVyT2YgVmVyc2lvbkNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gb3B0cy5ib2FyZElkIFRoZSBpZCBvZiB0aGUgYm9hcmQgd2hpY2ggY29udGFpbnMgdmVyc2lvbnMgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gYWxsIHZlcnNpb25zIGFyZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiBhbGwgdmVyc2lvbnMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEFsbFZlcnNpb25zID0gZnVuY3Rpb24ob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZEFnaWxlVVJMKGAvYm9hcmQvJHtvcHRzLmJvYXJkSWR9L3ZlcnNpb25gKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IG9wdHMuZmlsdGVyLFxuICAgICAgICAgICAgICAgIHN0YXJ0QXQ6IG9wdHMuc3RhcnRBdCxcbiAgICAgICAgICAgICAgICBtYXhSZXN1bHRzOiBvcHRzLm1heFJlc3VsdHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IGEgcHJvamVjdCB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRWZXJzaW9uXG4gICAgICogQG1lbWJlck9mIFZlcnNpb25DbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG9wdHMudmVyc2lvbklkIFRoZSBpZCBvZiB0aGUgdmVyc2lvbiB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgdmVyc2lvbiBpcyByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgdmVyc2lvbiBpcyByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRWZXJzaW9uID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcnLCAnR0VUJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgYW4gZXhpc3RpbmcgdmVyc2lvbjsgYW55IG9taXR0ZWQgZmllbGRzIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZWRpdFZlcnNpb25cbiAgICAgKiBAbWVtYmVyT2YgVmVyc2lvbkNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gSmlyYS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy52ZXJzaW9uSWQgVGhlIGlkIG9mIHRoZSB2ZXJzaW9uIHRvIGVkaXQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudmVyc2lvbiBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTM2MTl9XG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHZlcnNpb24gaGFzIGJlZW4gbW9kaWZpZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgdmVyc2lvbiBoYXMgYmVlbiBtb2RpZmllZC5cbiAgICAgKi9cbiAgICB0aGlzLmVkaXRWZXJzaW9uID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcnLCAnUFVUJywgb3B0cy52ZXJzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGJlYW4gY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIGZpeGVkIGluIGFuZCBhZmZlY3RlZCBpc3N1ZXMgZm9yIHRoZSBnaXZlbiB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRSZWxhdGVkSXNzdWVDb3VudHNcbiAgICAgKiBAbWVtYmVyT2YgVmVyc2lvbkNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLnZlcnNpb25JZCBUaGUgdmVyc2lvbiBmb3Igd2hpY2ggdG8gcmV0cmlldmUgcmVsYXRlZCBpc3N1ZXMuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGNvdW50IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBjb3VudCBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRSZWxhdGVkSXNzdWVDb3VudHMgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9yZWxhdGVkSXNzdWVDb3VudHMnLCAnR0VUJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiB1bnJlc29sdmVkIGlzc3VlcyBmb3IgdGhlIGdpdmVuIHZlcnNpb25cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0VW5yZXNvbHZlZElzc3VlQ291bnRcbiAgICAgKiBAbWVtYmVyT2YgVmVyc2lvbkNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLnZlcnNpb25JZCBUaGUgdmVyc2lvbiBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdW5yZXNvbHZlZCBpc3N1ZXMuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGNvdW50IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBjb3VudCBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRVbnJlc29sdmVkSXNzdWVDb3VudCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3VucmVzb2x2ZWRJc3N1ZUNvdW50JywgJ0dFVCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZW1vdGUgdmVyc2lvbiBsaW5rcyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHZlcnNpb24gaWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFJlbW90ZUxpbmtzXG4gICAgICogQG1lbWJlck9mIFZlcnNpb25DbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy52ZXJzaW9uSWQgVGhlIHZlcnNpb24gZm9yIHdoaWNoIHRvIHJldHJpZXZlIHJlbW90ZSBsaW5rcy5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgbGlua3MgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBsaW5rcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0UmVtb3RlTGlua3MgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9yZW1vdGVsaW5rJywgJ0dFVCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgcmVtb3RlIHZlcnNpb24gbGluayB2aWEgUE9TVC4gVGhlIGxpbmsncyBnbG9iYWwgaWQgd2lsbCBiZSB0YWtlbiBmcm9tIHRoZSBKU09OIHBheWxvYWQgaWYgcHJvdmlkZWQ7XG4gICAgICogb3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlUmVtb3RlTGlua1xuICAgICAqIEBtZW1iZXJPZiBWZXJzaW9uQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMudmVyc2lvbklkIFRoZSB2ZXJzaW9uIGZvciB3aGljaCB0byByZXRyaWV2ZSB1bnJlc29sdmVkIGlzc3Vlcy5cbiAgICAgKiBAcGFyYW0gb3B0cy5yZW1vdGVMaW5rIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMzc1M31cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcmVtb3RlIGxpbmsgaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSByZW1vdGUgbGluayBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlUmVtb3RlTGluayA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3JlbW90ZWxpbmsnLCAnUE9TVCcsIG9wdHMucmVtb3RlTGluayk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdSZW1vdGVsaW5rIENyZWF0ZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgUkVTVCBzdWItcmVzb3VyY2UgcmVwcmVzZW50aW5nIGEgcmVtb3RlIHZlcnNpb24gbGluay5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0UmVtb3RlTGlua3NcbiAgICAgKiBAbWVtYmVyT2YgVmVyc2lvbkNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLnZlcnNpb25JZCBUaGUgdmVyc2lvbiBmb3Igd2hpY2ggdG8gcmV0cmlldmUgdGhlIHJlbW90ZSBsaW5rXG4gICAgICogQHBhcmFtIG9wdHMucmVtb3RlTGlua0lkIFRoZSBnbG9iYWwgaWQgb2YgdGhlIHJlbW90ZSBsaW5rXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGxpbmsgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGxpbmsgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0UmVtb3RlTGluayA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3JlbW90ZWxpbmsvJyArIG9wdHMucmVtb3RlTGlua0lkLCAnR0VUJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSByZW1vdGUgdmVyc2lvbiBsaW5rLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZWxldGVSZW1vdGVMaW5rXG4gICAgICogQG1lbWJlck9mIFZlcnNpb25DbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy52ZXJzaW9uSWQgVGhlIHZlcnNpb24gaWRcbiAgICAgKiBAcGFyYW0gb3B0cy5yZW1vdGVMaW5rSWQgVGhlIGdsb2JhbCBpZCBvZiB0aGUgcmVtb3RlIGxpbmtcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgbGluayBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGxpbmsgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZVJlbW90ZUxpbmsgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9yZW1vdGVsaW5rLycgKyBvcHRzLnJlbW90ZUxpbmtJZCwgJ0RFTEVURScpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCAnUmVtb3RlIExpbmsgRGVsZXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBwcm9qZWN0IHZlcnNpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlbGV0ZVZlcnNpb25cbiAgICAgKiBAbWVtYmVyT2YgVmVyc2lvbkNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gb3B0cy52ZXJzaW9uSWQgVGhlIGlkIG9mIHRoZSB2ZXJzaW9uIHRvIGRlbGV0ZS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgdmVyc2lvbiBpcyBkZWxldGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHZlcnNpb24gaXMgZGVsZXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZVZlcnNpb24gPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJycsICdERUxFVEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaywgJ1ZlcnNpb24gRGVsZXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYWxsIHJlbW90ZSB2ZXJzaW9uIGxpbmtzIGZvciBhIGdpdmVuIHZlcnNpb24gaWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRlbGV0ZUFsbFJlbW90ZUxpbmtzXG4gICAgICogQG1lbWJlck9mIFZlcnNpb25DbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG9wdHMudmVyc2lvbklkIFRoZSBpZCBvZiB0aGUgdmVyc2lvbiB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHZlcnNpb24gaXMgZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB2ZXJzaW9uIGlzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgdGhpcy5kZWxldGVBbGxSZW1vdGVMaW5rcyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3JlbW90ZWxpbmsnLCAnREVMRVRFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdSZW1vdGUgTGlua3MgRGVsZXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZW1vdGUgdmVyc2lvbiBsaW5rcyBmb3IgYSBnaXZlbiBnbG9iYWwgaWQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldEdsb2JhbFJlbW90ZUxpbmtcbiAgICAgKiBAbWVtYmVyT2YgVmVyc2lvbkNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLmdsb2JhbElkIFRoZSBnbG9iYWwgaWQgb2YgdGhlIHJlbW90ZSByZXNvdXJjZSB0aGF0IGlzIGxpbmtlZCB0byB0aGUgdmVyc2lvbnNcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgcmVtb3RlIGxpbmsgaXMgcmV0dXJuZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgcmVtb3RlIGxpbmsgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRHbG9iYWxSZW1vdGVMaW5rID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy92ZXJzaW9uL3JlbW90ZWxpbmsnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtnbG9iYWxJZDogb3B0cy5nbG9iYWxJZH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIG91dCB0aGUgcmVxdWVzdCBvcHRpb25zIG5lY2Vzc2FyeSB0byBtYWtlIGEgcGFydGljdWxhciBBUEkgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1ldGhvZCBidWlsZFJlcXVlc3RPcHRpb25zXG4gICAgICogQG1lbWJlck9mIEZpbHRlckNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnZlcnNpb25JZCBUaGUgaWQgb2YgdGhlIHNjcmVlbiB0byB1c2UgaW4gdGhlIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdHMuZmllbGRzXSBUaGUgZmllbGRzIHRvIGluY2x1ZGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0cy5leHBhbmRdIFRoZSBmaWVsZHMgdG8gZXhwYW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIGVuZHBvaW50IGZvbGxvd2luZyAvdmVyc2lvbi97aWR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgcmVxdWVzdCBtZXRob2QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtib2R5XSBUaGUgcmVxdWVzdCBib2R5LCBpZiBhbnkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtxc10gVGhlIHF1ZXJ5c3RyaW5nLCBpZiBhbnkuICBvcHRzLmV4cGFuZCBhbmQgb3B0cy5maWVsZHMgYXJyYXlzIHdpbGwgYmUgYXV0b21hZ2ljYWxseSBhZGRlZC5cbiAgICAgKiBAcmV0dXJucyB7e3VyaTogc3RyaW5nLCBtZXRob2Q6IHN0cmluZywgYm9keTogT2JqZWN0LCBxczogT2JqZWN0LCBmb2xsb3dBbGxSZWRpcmVjdHM6IGJvb2xlYW4sIGpzb246IGJvb2xlYW59fVxuICAgICAqL1xuICAgIHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRzLCBwYXRoLCBtZXRob2QsIGJvZHksIHFzKSB7XG4gICAgICAgIHZhciBiYXNlUGF0aCA9ICcvdmVyc2lvbi8nICsgb3B0cy52ZXJzaW9uSWQ7XG4gICAgICAgIGlmICghcXMpIHFzID0ge307XG4gICAgICAgIGlmICghYm9keSkgYm9keSA9IHt9O1xuXG4gICAgICAgIGlmIChvcHRzLmZpZWxkcykge1xuICAgICAgICAgICAgcXMuZmllbGRzID0gJyc7XG4gICAgICAgICAgICBvcHRzLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIHFzLmZpZWxkcyArPSBmaWVsZCArICcsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxcy5maWVsZHMgPSBxcy5maWVsZHMuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuZXhwYW5kKSB7XG4gICAgICAgICAgICBxcy5leHBhbmQgPSAnJztcbiAgICAgICAgICAgIG9wdHMuZXhwYW5kLmZvckVhY2goZnVuY3Rpb24gKGV4KSB7XG4gICAgICAgICAgICAgICAgcXMuZXhwYW5kICs9IGV4ICsgJywnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHFzLmV4cGFuZCA9IHFzLmV4cGFuZC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoYmFzZVBhdGggKyBwYXRoKSxcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHFzOiBxcyxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGpzb246IHRydWVcbiAgICAgICAgfTtcbiAgICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViaG9va0NsaWVudDtcblxuLyoqXG4gKiBVc2VkIHRvIGFjY2VzcyBKaXJhIFJFU1QgZW5kcG9pbnRzIGluICcvcmVzdC93ZWJob29rLzEuMC93ZWJob29rJ1xuICpcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIFdlYmhvb2tDbGllbnRcbiAqL1xuZnVuY3Rpb24gV2ViaG9va0NsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCByZWdpc3RlcmVkIHdlYmhvb2tzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRBbGxXZWJob29rc1xuICAgICAqIEBtZW1iZXJPZiBXZWJob29rQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIElnbm9yZWRcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgd2ViaG9va3MgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB3ZWJob29rcyBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0QWxsV2ViaG9va3MgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFdlYmhvb2tVUkwoJy93ZWJob29rJyksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgd2ViaG9vayB3aXRoIGEgc3BlY2lmaWMgSUQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFdlYmhvb2tcbiAgICAgKiBAbWVtYmVyT2YgV2ViaG9va0NsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgb3B0aW9ucyBzZW50IHRvIHRoZSBKSVJBIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy53ZWJob29rSWQgVGhlIG51bWVyaWNhbCB3ZWJob29rIElELlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB3ZWJob29rIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB3ZWJob29rIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFdlYmhvb2sgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmk6IHRoaXMuamlyYUNsaWVudC5idWlsZFdlYmhvb2tVUkwoJy93ZWJob29rLycgKyBvcHRzLndlYmhvb2tJZCksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgd2ViaG9vay5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlV2ViaG9va1xuICAgICAqIEBtZW1iZXJPZiBXZWJob29rQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBvcHRpb25zIHNlbnQgdG8gdGhlIEpJUkEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLm5hbWUgVGhlIG5hbWUgb2YgdGhlIHdlYmhvb2suXG4gICAgICogQHBhcmFtIG9wdHMudXJsIFRoZSBVUkwgb2YgdGhlIHdlYmhvb2suXG4gICAgICogQHBhcmFtIG9wdHMuZXZlbnRzIEFuIGFycmF5IG9mIGV2ZW50cyB3aXRoIHdoaWNoIHRoZSB3ZWJob29rIHNob3VsZCBiZSByZWdpc3RlcmVkLiBTZWVcbiAgICAgKiAgIHtAbGluayBodHRwczovL2RldmVsb3Blci5hdGxhc3NpYW4uY29tL2ppcmFkZXYvamlyYS1hcGlzL3dlYmhvb2tzI1dlYmhvb2tzLWNvbmZpZ3VyZUNvbmZpZ3VyaW5nYXdlYmhvb2t9LlxuICAgICAqIEBwYXJhbSBvcHRzLmVuYWJsZWQgV2hldGhlciB0aGUgd2ViaG9vayBpcyBlbmFibGVkLlxuICAgICAqIEBwYXJhbSBvcHRzLmZpbHRlciBBbiBvYmplY3QgY29udGFpbmluZyBmaWx0ZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0cy5maWx0ZXIuaXNzdWUtcmVsYXRlZC1ldmVudHMtc2VjdGlvbiBBIGZpbHRlciBmb3IgaXNzdWVzLCB3cml0dGVuIGluIEpRTC5cbiAgICAgKiBAcGFyYW0gb3B0cy5leGNsdWRlQm9keSBXaGV0aGVyIHRvIHNlbmQgYW4gZW1wdHkgYm9keSB0byB0aGUgd2ViaG9vayBVUkwuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHdlYmhvb2sgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHdlYmhvb2sgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuY3JlYXRlV2ViaG9vayA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkV2ViaG9va1VSTCgnL3dlYmhvb2snKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHJlZ2lzdGVyZWQgd2ViaG9vay5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlV2ViaG9va1xuICAgICAqIEBtZW1iZXJPZiBXZWJob29rQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBvcHRpb25zIHNlbnQgdG8gdGhlIEpJUkEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLndlYmhvb2tJZCBUaGUgbnVtZXJpY2FsIHdlYmhvb2sgSUQuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHdlYmhvb2sgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHdlYmhvb2sgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlV2ViaG9vayA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkV2ViaG9va1VSTCgnL3dlYmhvb2svJyArIG9wdHMud2ViaG9va0lkKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtmbG93Q2xpZW50O1xuXG4vKipcbiAqIFVzZWQgdG8gYWNjZXNzIEppcmEgUkVTVCBlbmRwb2ludHMgaW4gJy9yZXN0L2FwaS8yL3dvcmtmbG93J1xuICpcbiAqIEBwYXJhbSB7SmlyYUNsaWVudH0gamlyYUNsaWVudFxuICogQGNvbnN0cnVjdG9yIFdvcmtmbG93Q2xpZW50XG4gKi9cbmZ1bmN0aW9uIFdvcmtmbG93Q2xpZW50KGppcmFDbGllbnQpIHtcbiAgICB0aGlzLmppcmFDbGllbnQgPSBqaXJhQ2xpZW50O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgd29ya2Zsb3dzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRXb3JrZmxvd3NcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy53b3JrZmxvd05hbWVdIFRoZSBuYW1lIG9mIHRoZSB3b3JrZmxvdyB0byByZXRyaWV2ZS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgd29ya2Zsb3cocykgaGF2ZSBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB3b3JrZmxvdyhzKSBoYXZlIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0V29ya2Zsb3dzID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBxcyA9IHt9O1xuICAgICAgICBpZiAob3B0cyAmJiB0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgb3B0cy5oYXNPd25Qcm9wZXJ0eSgnd29ya2Zsb3dOYW1lJykpIHtcbiAgICAgICAgICAgIHFzLndvcmtmbG93TmFtZSA9IG9wdHMud29ya2Zsb3dOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy93b3JrZmxvdycpLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBxczogcXNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gV29ya2Zsb3dTY2hlbWVDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvd29ya2Zsb3dzY2hlbWUnXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBXb3JrZmxvd1NjaGVtZUNsaWVudFxuICovXG5mdW5jdGlvbiBXb3JrZmxvd1NjaGVtZUNsaWVudChqaXJhQ2xpZW50KSB7XG4gICAgdGhpcy5qaXJhQ2xpZW50ID0gamlyYUNsaWVudDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB3b3JrZmxvdyBzY2hlbWUuIFRoZSBib2R5IGNvbnRhaW5zIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5ldyBzY2hlbWUuIFZhbHVlcyBub3QgcGFzc2VkIGFyZVxuICAgICAqIGFzc3VtZWQgdG8gYmUgc2V0IHRvIHRoZWlyIGRlZmF1bHRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBjcmVhdGVXb3JrZmxvd1NjaGVtZVxuICAgICAqIEBtZW1iZXJPZiBXb3JrZmxvd1NjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93U2NoZW1lIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMjE5Nn1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgd29ya2Zsb3cgc2NoZW1lIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgd29ya2Zsb3cgc2NoZW1lIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVXb3JrZmxvd1NjaGVtZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvd29ya2Zsb3dzY2hlbWUnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMud29ya2Zsb3dTY2hlbWVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgcGFzc2VkIHdvcmtmbG93IHNjaGVtZS4gVGhlIGJvZHkgb2YgdGhlIHJlcXVlc3QgaXMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLiBWYWx1ZXNcbiAgICAgKiBub3QgcGFzc2VkIGFyZSBhc3N1bWVkIHRvIGluZGljYXRlIG5vIGNoYW5nZSBmb3IgdGhhdCBmaWVsZC4gVGhlIHBhc3NlZCByZXByZXNlbnRhdGlvbiBjYW4gaGF2ZSBpdHNcbiAgICAgKiB1cGRhdGVEcmFmdElmTmVlZGVkIGZsYWcgc2V0IHRvIHRydWUgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZHJhZnQgc2hvdWxkIGJlIGNyZWF0ZWQgYW5kL29yIHVwZGF0ZWQgd2hlbiB0aGUgYWN0dWFsXG4gICAgICogc2NoZW1lIGNhbm5vdCBiZSBlZGl0ZWQgKGUuZy4gd2hlbiB0aGUgc2NoZW1lIGlzIGJlaW5nIHVzZWQgYnkgYSBwcm9qZWN0KS4gVmFsdWVzIG5vdCBhcHBlYXJpbmcgdGhlIGJvZHkgd2lsbFxuICAgICAqIG5vdCBiZSB0b3VjaGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBlZGl0V29ya2Zsb3dTY2hlbWVcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dTY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy53b3JrZmxvd1NjaGVtZUlkIFRoZSBpZCBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93U2NoZW1lIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMjMwNX1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgd29ya2Zsb3cgc2NoZW1lIGhhcyBiZWVuIGVkaXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB3b3JrZmxvdyBzY2hlbWUgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqL1xuICAgIHRoaXMuZWRpdFdvcmtmbG93U2NoZW1lID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcnLCAnUFVUJywgb3B0cy53b3JrZmxvd1NjaGVtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlcXVlc3RlZCB3b3JrZmxvdyBzY2hlbWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0V29ya2Zsb3dTY2hlbWVcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dTY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy53b3JrZmxvd1NjaGVtZUlkIFRoZSBpZCBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqIEBwYXJhbSBbb3B0cy5yZXR1cm5EcmFmdElmRXhpc3RzPWZhbHNlXSB3aGVuIHRydWUgaW5kaWNhdGVzIHRoYXQgYSBzY2hlbWUncyBkcmFmdCwgaWYgaXQgZXhpc3RzLCBzaG91bGQgYmVcbiAgICAgKiAgICAgcXVlcmllZCBpbnN0ZWFkIG9mIHRoZSBzY2hlbWUgaXRzZWxmLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB3b3JrZmxvdyBzY2hlbWUgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHdvcmtmbG93IHNjaGVtZSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXRXb3JrZmxvd1NjaGVtZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnJywgJ0dFVCcsIG51bGwsIHtyZXR1cm5EcmFmdElmRXhpc3RzOiBvcHRzLnJldHVybkRyYWZ0SWZFeGlzdHN9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgcGFzc2VkIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlV29ya2Zsb3dTY2hlbWVcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dTY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy53b3JrZmxvd1NjaGVtZUlkIFRoZSBpZCBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB3b3JrZmxvdyBzY2hlbWUgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB3b3JrZmxvdyBzY2hlbWUgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZVdvcmtmbG93U2NoZW1lID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcnLCAnREVMRVRFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssICdXb3JrZmxvdyBTY2hlbWUgRGVsZXRlZCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkcmFmdCBmb3IgdGhlIHBhc3NlZCBzY2hlbWUuIFRoZSBkcmFmdCB3aWxsIGJlIGEgY29weSBvZiB0aGUgc3RhdGUgb2YgdGhlIHBhcmVudC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgY3JlYXRlRHJhZnRcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dTY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy53b3JrZmxvd1NjaGVtZUlkIFRoZSBpZCBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBkcmFmdCBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGRyYWZ0IGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICovXG4gICAgdGhpcy5jcmVhdGVEcmFmdCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL2NyZWF0ZWRyYWZ0JywgJ1BPU1QnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCB3b3JrZmxvdyBmcm9tIHRoZSBwYXNzZWQgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXREZWZhdWx0V29ya2Zsb3dcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dTY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy53b3JrZmxvd1NjaGVtZUlkIFRoZSBpZCBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqIEBwYXJhbSBvcHRzLnJldHVybkRyYWZ0SWZFeGlzdHMgd2hlbiB0cnVlIGluZGljYXRlcyB0aGF0IGEgc2NoZW1lJ3MgZHJhZnQsIGlmIGl0IGV4aXN0cywgc2hvdWxkIGJlIHF1ZXJpZWRcbiAgICAgKiAgICAgaW5zdGVhZCBvZiB0aGUgc2NoZW1lIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgZGVmYXVsdCB3b3JrZmxvdyBpcyByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBkZWZhdWx0IHdvcmtmbG93IGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0RGVmYXVsdFdvcmtmbG93ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvZGVmYXVsdCcsICdHRVQnLCBudWxsLCB7cmV0dXJuRHJhZnRJZkV4aXN0czogb3B0cy5yZXR1cm5EcmFmdElmRXhpc3RzfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGRlZmF1bHQgd29ya2Zsb3cgZnJvbSB0aGUgcGFzc2VkIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlRGVmYXVsdFdvcmtmbG93XG4gICAgICogQG1lbWJlck9mIFdvcmtmbG93U2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMud29ya2Zsb3dTY2hlbWVJZCBUaGUgaWQgb2YgdGhlIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKiBAcGFyYW0gb3B0cy51cGRhdGVEcmFmdElmTmVlZGVkIHdoZW4gdHJ1ZSB3aWxsIGNyZWF0ZSBhbmQgcmV0dXJuIGEgZHJhZnQgd2hlbiB0aGUgd29ya2Zsb3cgc2NoZW1lIGNhbm5vdCBiZVxuICAgICAqICAgICBlZGl0ZWQgKGUuZy4gd2hlbiBpdCBpcyBiZWluZyB1c2VkIGJ5IGEgcHJvamVjdCkuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGRlZmF1bCB3b3JrZmxvdyBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGRlZmF1bCB3b3JrZmxvdyBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlRGVmYXVsdFdvcmtmbG93ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvZGVmYXVsdCcsICdERUxFVEUnLCBudWxsLCB7dXBkYXRlRHJhZnRJZk5lZWRlZDogb3B0cy51cGRhdGVEcmFmdElmTmVlZGVkfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGRlZmF1bHQgd29ya2Zsb3cgZnJvbSB0aGUgcGFzc2VkIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2Qgc2V0RGVmYXVsdFdvcmtmbG93XG4gICAgICogQG1lbWJlck9mIFdvcmtmbG93U2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMud29ya2Zsb3dTY2hlbWVJZCBUaGUgaWQgb2YgdGhlIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKiBAcGFyYW0gb3B0cy53b3JrZmxvd05hbWUgVGhlIG5hbWUgb2YgdGhlIG5ldyBkZWFmYXVsdCB3b3JrZmxvd1xuICAgICAqIEBwYXJhbSBvcHRzLnVwZGF0ZURyYWZ0SWZOZWVkZWQgd2hlbiB0cnVlIHdpbGwgY3JlYXRlIGFuZCByZXR1cm4gYSBkcmFmdCB3aGVuIHRoZSB3b3JrZmxvdyBzY2hlbWUgY2Fubm90IGJlXG4gICAgICogICAgIGVkaXRlZCAoZS5nLiB3aGVuIGl0IGlzIGJlaW5nIHVzZWQgYnkgYSBwcm9qZWN0KS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgZGVmYXVsdCB3b3JrZmxvdyBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGRlZmF1bHQgd29ya2Zsb3cgaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLnNldERlZmF1bHRXb3JrZmxvdyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL2RlZmF1bHQnLCAnUFVUJywge1xuICAgICAgICAgICAgd29ya2Zsb3c6IG9wdHMud29ya2Zsb3dOYW1lLFxuICAgICAgICAgICAgdXBkYXRlRHJhZnRJZk5lZWRlZDogb3B0cy51cGRhdGVEcmFmdElmTmVlZGVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZXF1ZXN0ZWQgZHJhZnQgd29ya2Zsb3cgc2NoZW1lXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldERyYWZ0XG4gICAgICogQG1lbWJlck9mIFdvcmtmbG93U2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMud29ya2Zsb3dTY2hlbWVJZCBUaGUgaWQgb2YgdGhlIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgZHJhZnQgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGRyYWZ0IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldERyYWZ0ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvZHJhZnQnLCAnR0VUJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYSBkcmFmdCB3b3JrZmxvdyBzY2hlbWUuIFRoZSBkcmFmdCB3aWxsIGNyZWF0ZWQgaWYgbmVjZXNzYXJ5LiBUaGUgYm9keSBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgICAqIHdvcmtmbG93IHNjaGVtZS4gVmFsdWVzIG5vdCBwYXNzZWQgYXJlIGFzc3VtZWQgdG8gaW5kaWNhdGUgbm8gY2hhbmdlIGZvciB0aGF0IGZpZWxkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBlZGl0RHJhZnRcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dTY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0cy53b3JrZmxvd1NjaGVtZUlkIFRoZSBpZCBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqIEBwYXJhbSBvcHRzLmRyYWZ0IFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMjU3NX1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgZHJhZnQgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGRyYWZ0IGhhcyBiZWVuIGVkaXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmVkaXREcmFmdCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL2RyYWZ0JywgJ1BVVCcsIG9wdHMuZHJhZnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBwYXNzZWQgZHJhZnQgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBkZWxldGVEcmFmdFxuICAgICAqIEBtZW1iZXJPZiBXb3JrZmxvd1NjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93U2NoZW1lSWQgVGhlIGlkIG9mIHRoZSB3b3JrZmxvdyBzY2hlbWUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGRyYWZ0IGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgZHJhZnQgaGFzIGJlZW4gZGVsZXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZURyYWZ0ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvZHJhZnQnLCAnREVMRVRFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlZmF1bHQgd29ya2Zsb3cgZnJvbSB0aGUgcGFzc2VkIGRyYWZ0IHdvcmtmbG93IHNjaGVtZVxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXREcmFmdERlZmF1bHRXb3JrZmxvd1xuICAgICAqIEBtZW1iZXJPZiBXb3JrZmxvd1NjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93U2NoZW1lSWQgVGhlIGlkIG9mIHRoZSB3b3JrZmxvdyBzY2hlbWUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGRlZmF1bHQgd29ya2Zsb3cgaXMgcmV0dXJuZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgZGVmYXVsdCB3b3JrZmxvdyBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldERyYWZ0RGVmYXVsdFdvcmtmbG93ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvZHJhZnQvZGVmYXVsdCcsICdHRVQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgZGVmYXVsdCB3b3JrZmxvdyBmcm9tIHRoZSBwYXNzZWQgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBzZXREcmFmdERlZmF1bHRXb3JrZmxvd1xuICAgICAqIEBtZW1iZXJPZiBXb3JrZmxvd1NjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93U2NoZW1lSWQgVGhlIGlkIG9mIHRoZSB3b3JrZmxvdyBzY2hlbWUuXG4gICAgICogQHBhcmFtIG9wdHMud29ya2Zsb3dOYW1lIFRoZSBuYW1lIG9mIHRoZSBuZXcgZGVmYXVsdCB3b3JrZmxvd1xuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSBkZWZhdWx0IHdvcmtmbG93IGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgZGVmYXVsdCB3b3JrZmxvdyBoYXMgYmVlbiB1cGRhdGVkLlxuICAgICAqL1xuICAgIHRoaXMuc2V0RHJhZnREZWZhdWx0V29ya2Zsb3cgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9kcmFmdC9kZWZhdWx0JywgJ1BVVCcsIHtcbiAgICAgICAgICAgIHdvcmtmbG93OiBvcHRzLndvcmtmbG93TmFtZSxcbiAgICAgICAgICAgIHVwZGF0ZURyYWZ0SWZOZWVkZWQ6IG9wdHMudXBkYXRlRHJhZnRJZk5lZWRlZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgZGVmYXVsdCB3b3JrZmxvdyBmcm9tIHRoZSBwYXNzZWQgZHJhZnQgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW1vdmVEcmFmdERlZmF1bHRXb3JrZmxvd1xuICAgICAqIEBtZW1iZXJPZiBXb3JrZmxvd1NjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93U2NoZW1lSWQgVGhlIGlkIG9mIHRoZSB3b3JrZmxvdyBzY2hlbWUuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGRlZmF1bCB3b3JrZmxvdyBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGRlZmF1bCB3b3JrZmxvdyBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlRHJhZnREZWZhdWx0V29ya2Zsb3cgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9kcmFmdC9kZWZhdWx0JywgJ0RFTEVURScpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXNzdWUgdHlwZSBtYXBwaW5nIGZvciB0aGUgcGFzc2VkIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0SXNzdWVUeXBlXG4gICAgICogQG1lbWJlck9mIFdvcmtmbG93U2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMud29ya2Zsb3dTY2hlbWVJZCBUaGUgaWQgb2YgdGhlIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKiBAcGFyYW0gb3B0cy5pc3N1ZVR5cGUgVGhlIGlzc3VlIHR5cGVcbiAgICAgKiBAcGFyYW0gb3B0cy5yZXR1cm5EcmFmdElmRXhpc3RzIHdoZW4gdHJ1ZSBpbmRpY2F0ZXMgdGhhdCBhIHNjaGVtZSdzIGRyYWZ0LCBpZiBpdCBleGlzdHMsIHNob3VsZCBiZSBxdWVyaWVkXG4gICAgICogICAgIGluc3RlYWQgb2YgdGhlIHNjaGVtZSBpdHNlbGYuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGlzc3VlIHR5cGUgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGlzc3VlIHR5cGUgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0SXNzdWVUeXBlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvaXNzdWV0eXBlLycgKyBvcHRzLmlzc3VlVHlwZSwgJ0dFVCcsIG51bGwsXG4gICAgICAgICAgICB7cmV0dXJuRHJhZnRJZkV4aXN0czogb3B0cy5yZXR1cm5EcmFmdElmRXhpc3RzfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGlzc3VlIHR5cGUgbWFwcGluZyBmb3IgdGhlIHBhc3NlZCBzY2hlbWUuIFRoZSBwYXNzZWQgcmVwcmVzZW50YXRpb24gY2FuIGhhdmUgaXRzIHVwZGF0ZURyYWZ0SWZOZWVkZWRcbiAgICAgKiBmbGFnIHNldCB0byB0cnVlIHRvIGluZGljYXRlIHRoYXQgdGhlIGRyYWZ0IHNob3VsZCBiZSBjcmVhdGVkL3VwZGF0ZWQgd2hlbiB0aGUgYWN0dWFsIHNjaGVtZSBjYW5ub3QgYmUgZWRpdGVkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBlZGl0SXNzdWVUeXBlXG4gICAgICogQG1lbWJlck9mIFdvcmtmbG93U2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy53b3JrZmxvd1NjaGVtZUlkIFRoZSBpZCBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqIEBwYXJhbSBvcHRzLmlzc3VlVHlwZSBUaGUgaXNzdWUgdHlwZVxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93IFRoZSBuZXcgd29ya2Zsb3dcbiAgICAgKiBAcGFyYW0gb3B0cy51cGRhdGVEcmFmdElmTmVlZGVkIHdoZW4gdHJ1ZSB3aWxsIGNyZWF0ZSBhbmQgcmV0dXJuIGEgZHJhZnQgd2hlbiB0aGUgd29ya2Zsb3cgc2NoZW1lIGNhbm5vdCBiZVxuICAgICAqICAgICBlZGl0ZWQgKGUuZy4gd2hlbiBpdCBpcyBiZWluZyB1c2VkIGJ5IGEgcHJvamVjdCkuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGlzc3VlIHR5cGUgaGFzIGJlZW4gZWRpdGVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgaXNzdWUgdHlwZSBoYXMgYmVlbiBlZGl0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmVkaXRJc3N1ZVR5cGUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9pc3N1ZXR5cGUvJyArIG9wdHMuaXNzdWVUeXBlLCAnUFVUJywge1xuICAgICAgICAgICAgd29ya2Zsb3c6IG9wdHMud29ya2Zsb3csXG4gICAgICAgICAgICB1cGRhdGVEcmFmdElmTmVlZGVkOiBvcHRzLnVwZGF0ZURyYWZ0SWZOZWVkZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHNwZWNpZmllZCBpc3N1ZSB0eXBlIG1hcHBpbmcgZnJvbSB0aGUgc2NoZW1lLlxuICAgICAqXG4gICAgICogQG1ldGhvZCByZW1vdmVJc3N1ZVR5cGVcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dTY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93U2NoZW1lSWQgVGhlIGlkIG9mIHRoZSB3b3JrZmxvdyBzY2hlbWUuXG4gICAgICogQHBhcmFtIG9wdHMuaXNzdWVUeXBlIFRoZSBpc3N1ZSB0eXBlXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGlzc3VlIHR5cGUgbWFwcGluZyBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGlzc3VlIHR5cGUgbWFwcGluZyBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlSXNzdWVUeXBlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvaXNzdWV0eXBlLycgKyBvcHRzLmlzc3VlVHlwZSwgJ0RFTEVURScsIG51bGwsIHtcbiAgICAgICAgICAgIHVwZGF0ZURyYWZ0SWZOZWVkZWQ6IG9wdHMudXBkYXRlRHJhZnRJZk5lZWRlZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlzc3VlIHR5cGUgbWFwcGluZyBmb3IgdGhlIHBhc3NlZCBkcmFmdCB3b3JrZmxvdyBzY2hlbWUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldERyYWZ0SXNzdWVUeXBlXG4gICAgICogQG1lbWJlck9mIFdvcmtmbG93U2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUEkuXG4gICAgICogQHBhcmFtIG9wdHMud29ya2Zsb3dTY2hlbWVJZCBUaGUgaWQgb2YgdGhlIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKiBAcGFyYW0gb3B0cy5pc3N1ZVR5cGUgVGhlIGlzc3VlIHR5cGVcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgaXNzdWUgdHlwZSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgaXNzdWUgdHlwZSBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXREcmFmdElzc3VlVHlwZSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL2RyYWZ0L2lzc3VldHlwZS8nICsgb3B0cy5pc3N1ZVR5cGUsICdHRVQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaXNzdWUgdHlwZSBtYXBwaW5nIGZvciB0aGUgcGFzc2VkIGRyYWZ0IHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZWRpdERyYWZ0SXNzdWVUeXBlXG4gICAgICogQG1lbWJlck9mIFdvcmtmbG93U2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy53b3JrZmxvd1NjaGVtZUlkIFRoZSBpZCBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqIEBwYXJhbSBvcHRzLmlzc3VlVHlwZSBUaGUgaXNzdWUgdHlwZVxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93IFRoZSBuZXcgd29ya2Zsb3dcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgaXNzdWUgdHlwZSBoYXMgYmVlbiBlZGl0ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBpc3N1ZSB0eXBlIGhhcyBiZWVuIGVkaXRlZFxuICAgICAqL1xuICAgIHRoaXMuZWRpdERyYWZ0SXNzdWVUeXBlID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvZHJhZnQvaXNzdWV0eXBlLycgKyBvcHRzLmlzc3VlVHlwZSwgJ1BVVCcsIHt3b3JrZmxvdzogb3B0cy53b3JrZmxvd30pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBzcGVjaWZpZWQgaXNzdWUgdHlwZSBtYXBwaW5nIGZyb20gdGhlIHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgcmVtb3ZlRHJhZnRJc3N1ZVR5cGVcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dTY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93U2NoZW1lSWQgVGhlIGlkIG9mIHRoZSB3b3JrZmxvdyBzY2hlbWUuXG4gICAgICogQHBhcmFtIG9wdHMuaXNzdWVUeXBlIFRoZSBpc3N1ZSB0eXBlXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIGlzc3VlIHR5cGUgbWFwcGluZyBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIGlzc3VlIHR5cGUgbWFwcGluZyBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlRHJhZnRJc3N1ZVR5cGUgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9kcmFmdC9pc3N1ZXR5cGUvJyArIG9wdHMuaXNzdWVUeXBlLCAnREVMRVRFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3b3JrZmxvdyBtYXBwaW5ncyBvciByZXF1ZXN0ZWQgbWFwcGluZyB0byB0aGUgY2FsbGVyIGZvciB0aGUgcGFzc2VkIHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0V29ya2Zsb3dcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dTY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93U2NoZW1lSWQgVGhlIGlkIG9mIHRoZSB3b3JrZmxvdyBzY2hlbWUuXG4gICAgICogQHBhcmFtIG9wdHMud29ya2Zsb3dOYW1lIFRoZSBuYW1lIG9mIHRoZSB3b3JrZmxvdy5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgd29ya2Zsb3cgaGFzIGJlZW4gcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHdvcmtmbG93IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFdvcmtmbG93ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvd29ya2Zsb3cnLCAnR0VUJywgbnVsbCwge1xuICAgICAgICAgICAgd29ya2Zsb3dOYW1lOiBvcHRzLndvcmtmbG93TmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdvcmtmbG93IG1hcHBpbmdzIG9yIHJlcXVlc3RlZCBtYXBwaW5nIHRvIHRoZSBjYWxsZXIgZm9yIHRoZSBwYXNzZWQgZHJhZnQgc2NoZW1lLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXREcmFmdFdvcmtmbG93XG4gICAgICogQG1lbWJlck9mIFdvcmtmbG93U2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0gb3B0cy53b3JrZmxvd1NjaGVtZUlkIFRoZSBpZCBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqIEBwYXJhbSBvcHRzLndvcmtmbG93TmFtZSBUaGUgbmFtZSBvZiB0aGUgd29ya2Zsb3cuXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHdvcmtmbG93IGhhcyBiZWVuIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSB3b3JrZmxvdyBoYXMgYmVlbiByZXRyaWV2ZWQuXG4gICAgICovXG4gICAgdGhpcy5nZXREcmFmdFdvcmtmbG93ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvZHJhZnQvd29ya2Zsb3cnLCAnR0VUJywgbnVsbCwge1xuICAgICAgICAgICAgd29ya2Zsb3dOYW1lOiBvcHRzLndvcmtmbG93TmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgc2NoZW1lIHRvIGluY2x1ZGUgdGhlIHBhc3NlZCBtYXBwaW5nLiBUaGUgYm9keSBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB3b3JrZmxvdyBtYXBwaW5nLiBWYWx1ZXNcbiAgICAgKiBub3QgcGFzc2VkIGFyZSBhc3N1bWVkIHRvIGluZGljYXRlIG5vIGNoYW5nZSBmb3IgdGhhdCBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZWRpdFdvcmtmbG93XG4gICAgICogQG1lbWJlck9mIFdvcmtmbG93U2NoZW1lQ2xpZW50I1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFRoZSByZXF1ZXN0IG9wdGlvbnMgc2VudCB0byB0aGUgSmlyYSBBUElcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy53b3JrZmxvd1NjaGVtZUlkIFRoZSBpZCBvZiB0aGUgd29ya2Zsb3cgc2NoZW1lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLndvcmtmbG93TmFtZSBUaGUgbmFtZSBvZiB0aGUgd29ya2Zsb3cuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3B0cy5pc3N1ZVR5cGVzIFRoZSBuZXcgaXNzdWUgdHlwZXMgdG8gaW5jbHVlIGluIHRoZSB3b3JrZmxvdy5cbiAgICAgKiAgICAgIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLmF0bGFzc2lhbi5jb20vamlyYS9SRVNUL2xhdGVzdC8jZDJlMjUwOX1cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgd29ya2Zsb3cgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHdvcmtmbG93IGhhcyBiZWVuIGVkaXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmVkaXRXb3JrZmxvdyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL3dvcmtmbG93JywgJ1BVVCcsIHtcbiAgICAgICAgICAgIHdvcmtmbG93OiBvcHRzLndvcmtmbG93TmFtZSxcbiAgICAgICAgICAgIGlzc3VlVHlwZXM6IG9wdHMuaXNzdWVUeXBlc1xuICAgICAgICB9LCB7d29ya2Zsb3dOYW1lOiBvcHRzLndvcmtmbG93TmFtZX0pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBkcmFmdCBzY2hlbWUgdG8gaW5jbHVkZSB0aGUgcGFzc2VkIG1hcHBpbmcuIFRoZSBib2R5IGlzIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHdvcmtmbG93IG1hcHBpbmcuXG4gICAgICogVmFsdWVzIG5vdCBwYXNzZWQgYXJlIGFzc3VtZWQgdG8gaW5kaWNhdGUgbm8gY2hhbmdlIGZvciB0aGF0IGZpZWxkLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBlZGl0RHJhZnRXb3JrZmxvd1xuICAgICAqIEBtZW1iZXJPZiBXb3JrZmxvd1NjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMud29ya2Zsb3dTY2hlbWVJZCBUaGUgaWQgb2YgdGhlIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53b3JrZmxvd05hbWUgVGhlIG5hbWUgb2YgdGhlIHdvcmtmbG93LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9wdHMuaXNzdWVUeXBlcyBUaGUgbmV3IGlzc3VlIHR5cGVzIHRvIGluY2x1ZSBpbiB0aGUgd29ya2Zsb3cuXG4gICAgICogICAgICBTZWUge0BsaW5rIGh0dHBzOi8vZG9jcy5hdGxhc3NpYW4uY29tL2ppcmEvUkVTVC9sYXRlc3QvI2QyZTI2NzAgfVxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB3b3JrZmxvdyBoYXMgYmVlbiBlZGl0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgd29ya2Zsb3cgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqL1xuICAgIHRoaXMuZWRpdERyYWZ0V29ya2Zsb3cgPSBmdW5jdGlvbiAob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMob3B0cywgJy9kcmFmdC93b3JrZmxvdycsICdQVVQnLCB7XG4gICAgICAgICAgICB3b3JrZmxvdzogb3B0cy53b3JrZmxvd05hbWUsXG4gICAgICAgICAgICBpc3N1ZVR5cGVzOiBvcHRzLmlzc3VlVHlwZXNcbiAgICAgICAgfSwge3dvcmtmbG93TmFtZTogb3B0cy53b3JrZmxvd05hbWV9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgcGFzc2VkIHdvcmtmbG93IGZyb20gdGhlIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlV29ya2Zsb3dcbiAgICAgKiBAbWVtYmVyT2YgV29ya2Zsb3dTY2hlbWVDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLndvcmtmbG93U2NoZW1lSWQgVGhlIGlkIG9mIHRoZSB3b3JrZmxvdyBzY2hlbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMud29ya2Zsb3dOYW1lIFRoZSBuYW1lIG9mIHRoZSB3b3JrZmxvdy5cbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgd29ya2Zsb3cgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFJlc29sdmVkIHdoZW4gdGhlIHdvcmtmbG93IGhhcyBiZWVuIGVkaXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZVdvcmtmbG93ID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5idWlsZFJlcXVlc3RPcHRpb25zKG9wdHMsICcvd29ya2Zsb3cnLCAnREVMRVRFJywgbnVsbCwge3dvcmtmbG93TmFtZTogb3B0cy53b3JrZmxvd05hbWV9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuamlyYUNsaWVudC5tYWtlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgcGFzc2VkIHdvcmtmbG93IGZyb20gdGhlIHdvcmtmbG93IGRyYWZ0IHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZGVsZXRlRHJhZnRXb3JrZmxvd1xuICAgICAqIEBtZW1iZXJPZiBXb3JrZmxvd1NjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgcmVxdWVzdCBvcHRpb25zIHNlbnQgdG8gdGhlIEppcmEgQVBJXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMud29ya2Zsb3dTY2hlbWVJZCBUaGUgaWQgb2YgdGhlIHdvcmtmbG93IHNjaGVtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy53b3JrZmxvd05hbWUgVGhlIG5hbWUgb2YgdGhlIHdvcmtmbG93LlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aGVuIHRoZSB3b3JrZmxvdyBoYXMgYmVlbiBlZGl0ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgd29ya2Zsb3cgaGFzIGJlZW4gZWRpdGVkLlxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlRHJhZnRXb3JrZmxvdyA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYnVpbGRSZXF1ZXN0T3B0aW9ucyhvcHRzLCAnL2RyYWZ0L3dvcmtmbG93JywgJ0RFTEVURScsIG51bGwsIHt3b3JrZmxvd05hbWU6IG9wdHMud29ya2Zsb3dOYW1lfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppcmFDbGllbnQubWFrZVJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCBvdXQgdGhlIHJlcXVlc3Qgb3B0aW9ucyBuZWNlc3NhcnkgdG8gbWFrZSBhIHBhcnRpY3VsYXIgQVBJIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgYnVpbGRSZXF1ZXN0T3B0aW9uc1xuICAgICAqIEBtZW1iZXJPZiBXb3JrZmxvd1NjaGVtZUNsaWVudCNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLndvcmtmbG93U2NoZW1lSWQgVGhlIGlkIG9mIHRoZSB3b3JrZmxvd1NjaGVtZSB0byB1c2UgaW4gdGhlIHBhdGguXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdHMuZmllbGRzXSBUaGUgZmllbGRzIHRvIGluY2x1ZGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0cy5leHBhbmRdIFRoZSBmaWVsZHMgdG8gZXhwYW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIGVuZHBvaW50IGZvbGxvd2luZyAvd29ya2Zsb3dTY2hlbWUve2lkfVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIHJlcXVlc3QgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbYm9keV0gVGhlIHJlcXVlc3QgYm9keSwgaWYgYW55LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcXNdIFRoZSBxdWVyeXN0cmluZywgaWYgYW55LiAgb3B0cy5leHBhbmQgYW5kIG9wdHMuZmllbGRzIGFycmF5cyB3aWxsIGJlIGF1dG9tYWdpY2FsbHkgYWRkZWQuXG4gICAgICogQHJldHVybnMge3t1cmk6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcsIGJvZHk6IE9iamVjdCwgcXM6IE9iamVjdCwgZm9sbG93QWxsUmVkaXJlY3RzOiBib29sZWFuLCBqc29uOiBib29sZWFufX1cbiAgICAgKi9cbiAgICB0aGlzLmJ1aWxkUmVxdWVzdE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0cywgcGF0aCwgbWV0aG9kLCBib2R5LCBxcykge1xuICAgICAgICB2YXIgYmFzZVBhdGggPSAnL3dvcmtmbG93c2NoZW1lLycgKyBvcHRzLndvcmtmbG93U2NoZW1lSWQ7XG4gICAgICAgIGlmICghcXMpIHFzID0ge307XG4gICAgICAgIGlmICghYm9keSkgYm9keSA9IHt9O1xuXG4gICAgICAgIGlmIChvcHRzLmZpZWxkcykge1xuICAgICAgICAgICAgcXMuZmllbGRzID0gJyc7XG4gICAgICAgICAgICBvcHRzLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIHFzLmZpZWxkcyArPSBmaWVsZCArICcsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxcy5maWVsZHMgPSBxcy5maWVsZHMuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuZXhwYW5kKSB7XG4gICAgICAgICAgICBxcy5leHBhbmQgPSAnJztcbiAgICAgICAgICAgIG9wdHMuZXhwYW5kLmZvckVhY2goZnVuY3Rpb24gKGV4KSB7XG4gICAgICAgICAgICAgICAgcXMuZXhwYW5kICs9IGV4ICsgJywnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHFzLmV4cGFuZCA9IHFzLmV4cGFuZC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoYmFzZVBhdGggKyBwYXRoKSxcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHFzOiBxcyxcbiAgICAgICAgICAgIGZvbGxvd0FsbFJlZGlyZWN0czogdHJ1ZSxcbiAgICAgICAgICAgIGpzb246IHRydWVcbiAgICAgICAgfTtcbiAgICB9O1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtsb2dDbGllbnQ7XG5cbi8qKlxuICogVXNlZCB0byBhY2Nlc3MgSmlyYSBSRVNUIGVuZHBvaW50cyBpbiAnL3Jlc3QvYXBpLzIvd29ya2xvZydcbiAqXG4gKiBAcGFyYW0ge0ppcmFDbGllbnR9IGppcmFDbGllbnRcbiAqIEBjb25zdHJ1Y3RvciBXb3JrTG9nQ2xpZW50XG4gKi9cbmZ1bmN0aW9uIFdvcmtsb2dDbGllbnQoamlyYUNsaWVudCkge1xuICAgIHRoaXMuamlyYUNsaWVudCA9IGppcmFDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdvcmtsb2dzIGlkIGFuZCBkZWxldGUgdGltZSBvZiB3b3JrbG9ncyB0aGF0IHdlcmUgZGVsZXRlZCBzaW5jZSBnaXZlbiB0aW1lLiBUaGUgcmV0dXJucyBzZXQgb2Ygd29ya2xvZ3MgaXMgXG4gICAgICogbGltaXRlZCB0byAxMDAwIGVsZW1lbnRzLiBUaGlzIEFQSSB3aWxsIG5vdCByZXR1cm4gd29ya2xvZ3MgZGVsZXRlZCBkdXJpbmcgbGFzdCBtaW51dGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFdvcmtsb2dEZWxldGVkXG4gICAgICogQG1lbWJlck9mIFdvcmtsb2dDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNpbmNlIEEgZGF0ZSB0aW1lIGluIHVuaXggdGltZXN0YW1wIGZvcm1hdCBzaW5jZSB3aGVuIGRlbGV0ZWQgd29ya2xvZ3Mgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiAgICAgIERlZmF1bHQ6IDBcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc2VhcmNoIHJlc3VsdHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBzZWFyY2ggcmVzdWx0cyBhcmUgcmV0cmlldmVkLlxuICAgICAqLyBcbiAgICB0aGlzLmdldFdvcmtsb2dEZWxldGVkID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy93b3JrbG9nL2RlbGV0ZWQnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBzaW5jZTogb3B0cy5zaW5jZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFJldHVybnMgd29ya2xvZ3MgZm9yIGdpdmVuIHdvcmtsb2cgaWRzLiBPbmx5IHdvcmtsb2dzIHRvIHdoaWNoIHRoZSBjYWxsaW5nIHVzZXIgaGFzIHBlcm1pc3Npb25zLCBcbiAgICAgKiB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQuIFRoZSByZXR1cm5zIHNldCBvZiB3b3JrbG9ncyBpcyBsaW1pdGVkIHRvIDEwMDAgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHdvcmtsb2dMaXN0XG4gICAgICogQG1lbWJlck9mIFdvcmtsb2dDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7YXJyYXl9IFtvcHRzLmlkc10gYSBKU09OIGFycmF5IG5hbWVkIGlkcyB3aGljaCBjb250YWlucyBhIGxpc3Qgb2YgaXNzdWUgSURzXG4gICAgICogQHBhcmFtIFtjYWxsYmFja10gQ2FsbGVkIHdoZW4gdGhlIHNlYXJjaCByZXN1bHRzIGFyZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZWQgd2hlbiB0aGUgc2VhcmNoIHJlc3VsdHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKi8gXG4gICAgdGhpcy53b3JrbG9nTGlzdCA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVyaTogdGhpcy5qaXJhQ2xpZW50LmJ1aWxkVVJMKCcvd29ya2xvZy9saXN0JyksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICBmb2xsb3dBbGxSZWRpcmVjdHM6IHRydWUsXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgaWRzOiBvcHRzLmlkc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdvcmtsb2dzIGlkIGFuZCB1cGRhdGUgdGltZSBvZiB3b3JrbG9ncyB0aGF0IHdlcmUgdXBkYXRlZCBzaW5jZSBnaXZlbiB0aW1lLiBUaGUgcmV0dXJucyBzZXQgb2Ygd29ya2xvZ3MgaXMgXG4gICAgICogbGltaXRlZCB0byAxMDAwIGVsZW1lbnRzLiBUaGlzIEFQSSB3aWxsIG5vdCByZXR1cm4gd29ya2xvZ3MgZGVsZXRlZCBkdXJpbmcgbGFzdCBtaW51dGUuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldFdvcmtsb2dEZWxldGVkXG4gICAgICogQG1lbWJlck9mIFdvcmtsb2dDbGllbnQjXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgVGhlIHJlcXVlc3Qgb3B0aW9ucyBzZW50IHRvIHRoZSBKaXJhIEFQSVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnNpbmNlIEEgZGF0ZSB0aW1lIGluIHVuaXggdGltZXN0YW1wIGZvcm1hdCBzaW5jZSB3aGVuIHVwZGF0ZWQgd29ya2xvZ3Mgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiAgICAgIERlZmF1bHQ6IDBcbiAgICAgKiBAcGFyYW0gW2NhbGxiYWNrXSBDYWxsZWQgd2hlbiB0aGUgc2VhcmNoIHJlc3VsdHMgYXJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aGVuIHRoZSBzZWFyY2ggcmVzdWx0cyBhcmUgcmV0cmlldmVkLlxuICAgICAqLyBcbiAgICB0aGlzLmdldFdvcmtsb2dVcGRhdGVkID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJpOiB0aGlzLmppcmFDbGllbnQuYnVpbGRVUkwoJy93b3JrbG9nL3VwZGF0ZWQnKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBqc29uOiB0cnVlLFxuICAgICAgICAgICAgZm9sbG93QWxsUmVkaXJlY3RzOiB0cnVlLFxuICAgICAgICAgICAgcXM6IHtcbiAgICAgICAgICAgICAgICBzaW5jZTogb3B0cy5zaW5jZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5qaXJhQ2xpZW50Lm1ha2VSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBDb3JlIHBhY2thZ2VzXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbi8vIE5wbSBwYWNrYWdlc1xudmFyIHJlcXVlc3QgPSByZXF1aXJlKCdyZXF1ZXN0Jyk7XG5cbi8vIEN1c3RvbSBwYWNrYWdlc1xudmFyIGFwcGxpY2F0aW9uUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vYXBpL2FwcGxpY2F0aW9uLXByb3BlcnRpZXMnKTtcbnZhciBhdHRhY2htZW50ID0gcmVxdWlyZSgnLi9hcGkvYXR0YWNobWVudCcpO1xudmFyIGF1ZGl0aW5nID0gcmVxdWlyZSgnLi9hcGkvYXVkaXRpbmcnKTtcbnZhciBhdXRoID0gcmVxdWlyZSgnLi9hcGkvYXV0aCcpO1xudmFyIGF2YXRhciA9IHJlcXVpcmUoJy4vYXBpL2F2YXRhcicpO1xudmFyIGJvYXJkID0gcmVxdWlyZSgnLi9hcGkvYm9hcmQnKTtcbnZhciBjb21tZW50ID0gcmVxdWlyZSgnLi9hcGkvY29tbWVudCcpO1xudmFyIGNvbXBvbmVudCA9IHJlcXVpcmUoJy4vYXBpL2NvbXBvbmVudCcpO1xudmFyIGN1c3RvbUZpZWxkT3B0aW9uID0gcmVxdWlyZSgnLi9hcGkvY3VzdG9tRmllbGRPcHRpb24nKTtcbnZhciBkYXNoYm9hcmQgPSByZXF1aXJlKCcuL2FwaS9kYXNoYm9hcmQnKTtcbnZhciBlcnJvclN0cmluZ3MgPSByZXF1aXJlKCcuL2xpYi9lcnJvcicpO1xudmFyIGZpZWxkID0gcmVxdWlyZSgnLi9hcGkvZmllbGQnKTtcbnZhciBmaWx0ZXIgPSByZXF1aXJlKCcuL2FwaS9maWx0ZXInKTtcbnZhciBncm91cCA9IHJlcXVpcmUoJy4vYXBpL2dyb3VwJyk7XG52YXIgZ3JvdXBVc2VyUGlja2VyID0gcmVxdWlyZSgnLi9hcGkvZ3JvdXBVc2VyUGlja2VyJyk7XG52YXIgZ3JvdXBzID0gcmVxdWlyZSgnLi9hcGkvZ3JvdXBzJyk7XG52YXIgaXNzdWUgPSByZXF1aXJlKCcuL2FwaS9pc3N1ZScpO1xudmFyIGlzc3VlTGluayA9IHJlcXVpcmUoJy4vYXBpL2lzc3VlTGluaycpO1xudmFyIGlzc3VlTGlua1R5cGUgPSByZXF1aXJlKCcuL2FwaS9pc3N1ZUxpbmtUeXBlJyk7XG52YXIgaXNzdWVUeXBlID0gcmVxdWlyZSgnLi9hcGkvaXNzdWVUeXBlJyk7XG52YXIganFsID0gcmVxdWlyZSgnLi9hcGkvanFsJyk7XG52YXIgbGljZW5zZVJvbGUgPSByZXF1aXJlKCcuL2FwaS9saWNlbnNlUm9sZScpO1xudmFyIGxpY2Vuc2VWYWxpZGF0b3IgPSByZXF1aXJlKCcuL2FwaS9saWNlbnNlVmFsaWRhdG9yJyk7XG52YXIgbXlQZXJtaXNzaW9ucyA9IHJlcXVpcmUoJy4vYXBpL215UGVybWlzc2lvbnMnKTtcbnZhciBteVByZWZlcmVuY2VzID0gcmVxdWlyZSgnLi9hcGkvbXlQcmVmZXJlbmNlcycpO1xudmFyIG15c2VsZiA9IHJlcXVpcmUoJy4vYXBpL215c2VsZicpO1xudmFyIG9hdXRoX3V0aWwgPSByZXF1aXJlKCcuL2xpYi9vYXV0aF91dGlsJyk7XG52YXIgcGFzc3dvcmQgPSByZXF1aXJlKCcuL2FwaS9wYXNzd29yZCcpO1xudmFyIHBlcm1pc3Npb25zID0gcmVxdWlyZSgnLi9hcGkvcGVybWlzc2lvbnMnKTtcbnZhciBwZXJtaXNzaW9uU2NoZW1lID0gcmVxdWlyZSgnLi9hcGkvcGVybWlzc2lvbi1zY2hlbWUnKTtcbnZhciBwcmlvcml0eSA9IHJlcXVpcmUoJy4vYXBpL3ByaW9yaXR5Jyk7XG52YXIgcHJvamVjdCA9IHJlcXVpcmUoJy4vYXBpL3Byb2plY3QnKTtcbnZhciBwcm9qZWN0Q2F0ZWdvcnkgPSByZXF1aXJlKCcuL2FwaS9wcm9qZWN0Q2F0ZWdvcnknKTtcbnZhciBwcm9qZWN0VmFsaWRhdGUgPSByZXF1aXJlKCcuL2FwaS9wcm9qZWN0VmFsaWRhdGUnKTtcbnZhciByZWluZGV4ID0gcmVxdWlyZSgnLi9hcGkvcmVpbmRleCcpO1xudmFyIHJlc29sdXRpb24gPSByZXF1aXJlKCcuL2FwaS9yZXNvbHV0aW9uJyk7XG52YXIgcm9sZXMgPSByZXF1aXJlKCcuL2FwaS9yb2xlcycpO1xudmFyIHNjcmVlbnMgPSByZXF1aXJlKCcuL2FwaS9zY3JlZW5zJyk7XG52YXIgc2VhcmNoID0gcmVxdWlyZSgnLi9hcGkvc2VhcmNoJyk7XG52YXIgc2VjdXJpdHlMZXZlbCA9IHJlcXVpcmUoJy4vYXBpL3NlY3VyaXR5TGV2ZWwnKTtcbnZhciBzZXJ2ZXJJbmZvID0gcmVxdWlyZSgnLi9hcGkvc2VydmVySW5mbycpO1xudmFyIHNldHRpbmdzID0gcmVxdWlyZSgnLi9hcGkvc2V0dGluZ3MnKTtcbnZhciBzcHJpbnQgPSByZXF1aXJlKCcuL2FwaS9zcHJpbnQnKTtcbnZhciBzdGF0dXMgPSByZXF1aXJlKCcuL2FwaS9zdGF0dXMnKTtcbnZhciBzdGF0dXNDYXRlZ29yeSA9IHJlcXVpcmUoJy4vYXBpL3N0YXR1c0NhdGVnb3J5Jyk7XG52YXIgdXNlciA9IHJlcXVpcmUoJy4vYXBpL3VzZXInKTtcbnZhciB2ZXJzaW9uID0gcmVxdWlyZSgnLi9hcGkvdmVyc2lvbicpO1xudmFyIHdlYmhvb2sgPSByZXF1aXJlKCcuL2FwaS93ZWJob29rJyk7XG52YXIgd29ya2Zsb3cgPSByZXF1aXJlKCcuL2FwaS93b3JrZmxvdycpO1xudmFyIHdvcmtmbG93U2NoZW1lID0gcmVxdWlyZSgnLi9hcGkvd29ya2Zsb3dTY2hlbWUnKTtcbnZhciB3b3JrbG9nID0gcmVxdWlyZSgnLi9hcGkvd29ya2xvZycpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGllbnQgZm9yIHRoZSBKaXJhIFJFU1QgQVBJXG4gKlxuICogQGNvbnN0cnVjdG9yIEppcmFDbGllbnRcbiAqIEBwcm9wZXJ0eSB7QWdpbGVCb2FyZENsaWVudH0gYm9hcmRcbiAqIEBwcm9wZXJ0eSB7QWdpbGVTcHJpbnRDbGllbnR9IHNwcmludFxuICpcbiAqIEBwcm9wZXJ0eSB7QXBwbGljYXRpb25Qcm9wZXJ0aWVzQ2xpZW50fSBhcHBsaWNhdGlvblByb3BlcnRpZXNcbiAqIEBwcm9wZXJ0eSB7QXR0YWNobWVudENsaWVudH0gYXR0YWNobWVudFxuICogQHByb3BlcnR5IHtBdWRpdGluZ0NsaWVudH0gYXVkaXRpbmdcbiAqIEBwcm9wZXJ0eSB7QXV0aENsaWVudH0gYXV0aFxuICogQHByb3BlcnR5IHtBdmF0YXJDbGllbnR9IGF2YXRhclxuICogQHByb3BlcnR5IHtDb21tZW50Q2xpZW50fSBjb21tZW50XG4gKiBAcHJvcGVydHkge0NvbXBvbmVudENsaWVudH0gY29tcG9uZW50XG4gKiBAcHJvcGVydHkge0N1c3RvbUZpZWxkT3B0aW9uQ2xpZW50fSBjdXN0b21GaWVsZE9wdGlvblxuICogQHByb3BlcnR5IHtEYXNoYm9hcmRDbGllbnR9IGRhc2hib2FyZFxuICogQHByb3BlcnR5IHtGaWVsZENsaWVudH0gZmllbGRcbiAqIEBwcm9wZXJ0eSB7RmlsdGVyQ2xpZW50fSBmaWx0ZXJcbiAqIEBwcm9wZXJ0eSB7R3JvdXBDbGllbnR9IGdyb3VwXG4gKiBAcHJvcGVydHkge0dyb3VwVXNlclBpY2tlckNsaWVudH0gZ3JvdXBVc2VyUGlja2VyXG4gKiBAcHJvcGVydHkge0dyb3Vwc0NsaWVudH0gZ3JvdXBzXG4gKiBAcHJvcGVydHkge0lzc3VlQ2xpZW50fSBpc3N1ZVxuICogQHByb3BlcnR5IHtJc3N1ZUxpbmtDbGllbnR9IGlzc3VlTGlua1xuICogQHByb3BlcnR5IHtJc3N1ZUxpbmtUeXBlQ2xpZW50fSBpc3N1ZUxpbmtUeXBlXG4gKiBAcHJvcGVydHkge0lzc3VlVHlwZUNsaWVudH0gaXNzdWVUeXBlXG4gKiBAcHJvcGVydHkge0pxbENsaWVudH0ganFsXG4gKiBAcHJvcGVydHkge0xpY2Vuc2VSb2xlQ2xpZW50fSBsaWNlbnNlUm9sZVxuICogQHByb3BlcnR5IHtMaWNlbnNlVmFsaWRhdG9yQ2xpZW50fSBsaWNlbnNlVmFsaWRhdG9yXG4gKiBAcHJvcGVydHkge015UGVybWlzc2lvbnNDbGllbnR9IG15UGVybWlzc2lvbnNcbiAqIEBwcm9wZXJ0eSB7TXlQcmVmZXJlbmNlc0NsaWVudH0gbXlQcmVmZXJlbmNlc1xuICogQHByb3BlcnR5IHtNeXNlbGZDbGllbnR9IG15c2VsZlxuICogQHByb3BlcnR5IHtQYXNzd29yZENsaWVudH0gcGFzc3dvcmRcbiAqIEBwcm9wZXJ0eSB7UGVybWlzc2lvbnNDbGllbnR9IHBlcm1pc3Npb25zXG4gKiBAcHJvcGVydHkge1Blcm1pc3Npb25TY2hlbWVDbGllbnR9IHBlcm1pc3Npb25TY2hlbWVcbiAqIEBwcm9wZXJ0eSB7UHJpb3JpdHlDbGllbnR9IHByaW9yaXR5XG4gKiBAcHJvcGVydHkge1Byb2plY3RDYXRlZ29yeUNsaWVudH0gcHJvamVjdENhdGVnb3J5XG4gKiBAcHJvcGVydHkge1Byb2plY3RDbGllbnR9IHByb2plY3RcbiAqIEBwcm9wZXJ0eSB7UHJvamVjdFZhbGlkYXRlQ2xpZW50fSBwcm9qZWN0VmFsaWRhdGVcbiAqIEBwcm9wZXJ0eSB7UmVpbmRleENsaWVudH0gcmVpbmRleFxuICogQHByb3BlcnR5IHtSZXNvbHV0aW9uQ2xpZW50fSByZXNvbHV0aW9uXG4gKiBAcHJvcGVydHkge1JvbGVDbGllbnR9IHJvbGVzXG4gKiBAcHJvcGVydHkge1NjcmVlbnNDbGllbnR9IHNjcmVlbnNcbiAqIEBwcm9wZXJ0eSB7U2VhcmNoQ2xpZW50fSBzZWFyY2hcbiAqIEBwcm9wZXJ0eSB7U2VjdXJpdHlMZXZlbENsaWVudH0gc2VjdXJpdHlMZXZlbFxuICogQHByb3BlcnR5IHtTZXJ2ZXJJbmZvQ2xpZW50fSBzZXJ2ZXJJbmZvXG4gKiBAcHJvcGVydHkge1NldHRpbmdzQ2xpZW50fSBzZXR0aW5nc1xuICogQHByb3BlcnR5IHtTdGF0dXNDYXRlZ29yeUNsaWVudH0gc3RhdHVzQ2F0ZWdvcnlcbiAqIEBwcm9wZXJ0eSB7U3RhdHVzQ2xpZW50fSBzdGF0dXNcbiAqIEBwcm9wZXJ0eSB7VXNlckNsaWVudH0gdXNlclxuICogQHByb3BlcnR5IHtWZXJzaW9uQ2xpZW50fSB2ZXJzaW9uXG4gKiBAcHJvcGVydHkge1dlYmhvb2tDbGllbnR9IHdlYmhvb2tcbiAqIEBwcm9wZXJ0eSB7V29ya2Zsb3dDbGllbnR9IHdvcmtmbG93XG4gKiBAcHJvcGVydHkge1dvcmtmbG93U2NoZW1lQ2xpZW50fSB3b3JrZmxvd1NjaGVtZVxuICogQHByb3BlcnR5IHtXb3JrbG9nQ2xpZW50fSB3b3JrbG9nXG4gKlxuICogQHBhcmFtIGNvbmZpZyBUaGUgaW5mb3JtYXRpb24gbmVlZGVkIHRvIGFjY2VzcyB0aGUgSmlyYSBBUElcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcuaG9zdCBUaGUgaG9zdG5hbWUgb2YgdGhlIEppcmEgQVBJLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcucHJvdG9jb2w9aHR0cHNdIFRoZSBwcm90b2NvbCB1c2VkIHRvIGFjY3NlcyB0aGUgSmlyYSBBUEkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5wb3J0PTQ0M10gVGhlIHBvcnQgbnVtYmVyIHVzZWQgdG8gY29ubmVjdCB0byBKaXJhLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcucGF0aF9wcmVmaXg9XCIvXCJdIFRoZSBwcmVmaXggdG8gdXNlIGluIGZyb250IG9mIHRoZSBwYXRoLCBpZiBKaXJhIGlzbid0IGF0IFwiL1wiXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy52ZXJzaW9uPTJdIFRoZSB2ZXJzaW9uIG9mIHRoZSBKaXJhIEFQSSB0byB3aGljaCB5b3Ugd2lsbCBiZSBjb25uZWN0aW5nLiAgQ3VycmVudGx5LCBvbmx5XG4gKiAgICAgdmVyc2lvbiAyIGlzIHN1cHBvcnRlZC5cbiAqIEBwYXJhbSBjb25maWcuYXV0aCBUaGUgYXV0aGVudGljYXRpb24gaW5mb3JtYXRpb24gdXNlZCB0cCBjb25uZWN0IHRvIEppcmEuIE11c3QgY29udGFpbiBFSVRIRVIgdXNlcm5hbWUgYW5kIHBhc3N3b3JkXG4gKiAgICAgT1Igb2F1dGggaW5mb3JtYXRpb24uICBPYXV0aCBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgb3ZlciB1c2VybmFtZS9wYXNzd29yZCBhdXRoZW50aWNhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmJhc2ljX2F1dGgudXNlcm5hbWVdIFRoZSB1c2VybmFtZSBvZiB0aGUgdXNlciB0aGF0IHdpbGwgYmUgYXV0aGVudGljYXRlZC4gTVVTVCBiZSBpbmNsdWRlZFxuICogICAgIGlmIHVzaW5nIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBhdXRoZW50aWNhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmJhc2ljX2F1dGgucGFzc3dvcmRdIFRoZSBwYXNzd29yZCBvZiB0aGUgdXNlciB0aGF0IHdpbGwgYmUgYXV0aGVudGljYXRlZC4gTVVTVCBiZSBpbmNsdWRlZFxuICogICAgIGlmIHVzaW5nIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBhdXRoZW50aWNhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm9hdXRoLmNvbnN1bWVyX2tleV0gVGhlIGNvbnN1bWVyIGtleSB1c2VkIGluIHRoZSBKaXJhIEFwcGxpY2F0aW9uIExpbmsgZm9yIG9hdXRoXG4gKiAgICAgYXV0aGVudGljYXRpb24uICBNVVNUIGJlIGluY2x1ZGVkIGlmIHVzaW5nIE9BdXRoLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcub2F1dGgucHJpdmF0ZV9rZXldIFRoZSBwcml2YXRlIGtleSB1c2VkIGZvciBPQXV0aCBzZWN1cml0eS4gTVVTVCBiZSBpbmNsdWRlZCBpZiB1c2luZyBPQXV0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm9hdXRoLnRva2VuXSBUaGUgVkVSSUZJRUQgdG9rZW4gdXNlZCB0byBjb25uZWN0IHRvIHRoZSBKaXJhIEFQSS4gIE1VU1QgYmUgaW5jbHVkZWQgaWYgdXNpbmdcbiAqICAgICBPQXV0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm9hdXRoLnRva2VuX3NlY3JldF0gVGhlIHNlY3JldCBmb3IgdGhlIGFib3ZlIHRva2VuLiAgTVVTVCBiZSBpbmNsdWRlZCBpZiB1c2luZyBPYXV0aC5cbiAqIEBwYXJhbSB7Q29va2llSmFyfSBbY29uZmlnLmNvb2tpZV9qYXJdIFRoZSBDb29raWVKYXIgdG8gdXNlIGZvciBldmVyeSByZXF1ZXN0cy5cbiAqIEBwYXJhbSB7UHJvbWlzZX0gW2NvbmZpZy5wcm9taXNlXSBBbnkgZnVuY3Rpb24gKGNvbnN0cnVjdG9yKSBjb21wYXRpYmxlIHdpdGggUHJvbWlzZSAoYmx1ZWJpcmQsIFEsLi4uKS5cbiAqICAgICAgRGVmYXVsdCAtIG5hdGl2ZSBQcm9taXNlLlxuICogQHBhcmFtIHtSZXF1ZXN0fSBbY29uZmlnLnJlcXVlc3RdIEFueSBmdW5jdGlvbiAoY29uc3RydWN0b3IpIGNvbXBhdGlibGUgd2l0aCBSZXF1ZXN0IChyZXF1ZXN0LCBzdXBlcnRlc3QsLi4uKS5cbiAqICAgICAgRGVmYXVsdCAtIHJlcXVpcmUoJ3JlcXVlc3QnKS5cbiAqL1xuXG52YXIgSmlyYUNsaWVudCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgIGlmKCFjb25maWcuaG9zdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0hPU1RfRVJST1IpO1xuICAgIH1cbiAgICB0aGlzLmhvc3QgPSBjb25maWcuaG9zdDtcbiAgICB0aGlzLnByb3RvY29sID0gY29uZmlnLnByb3RvY29sID8gY29uZmlnLnByb3RvY29sIDogJ2h0dHBzJztcbiAgICB0aGlzLnBhdGhfcHJlZml4ID0gY29uZmlnLnBhdGhfcHJlZml4ID8gY29uZmlnLnBhdGhfcHJlZml4IDogJy8nO1xuICAgIHRoaXMucG9ydCA9IGNvbmZpZy5wb3J0O1xuICAgIHRoaXMuYXBpVmVyc2lvbiA9IDI7IC8vIFRPRE8gQWRkIHN1cHBvcnQgZm9yIG90aGVyIHZlcnNpb25zLlxuICAgIHRoaXMuYWdpbGVBcGlWZXJzaW9uID0gJzEuMCc7XG4gICAgdGhpcy5hdXRoQXBpVmVyc2lvbiA9ICcxJztcbiAgICB0aGlzLndlYmhvb2tBcGlWZXJzaW9uID0gJzEuMCc7XG4gICAgdGhpcy5wcm9taXNlID0gY29uZmlnLnByb21pc2UgfHwgUHJvbWlzZTtcbiAgICB0aGlzLnJlcXVlc3RMaWIgPSBjb25maWcucmVxdWVzdCB8fCByZXF1ZXN0O1xuICAgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gY29uZmlnLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICAgIGlmIChjb25maWcub2F1dGgpIHtcbiAgICAgICAgaWYgKCFjb25maWcub2F1dGguY29uc3VtZXJfa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX0NPTlNVTUVSX0tFWV9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZy5vYXV0aC5wcml2YXRlX2tleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19QUklWQVRFX0tFWV9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZy5vYXV0aC50b2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19PQVVUSF9UT0tFTl9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZy5vYXV0aC50b2tlbl9zZWNyZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fT0FVVEhfVE9LRU5fU0VDUkVUX0VSUk9SKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub2F1dGhDb25maWcgPSBjb25maWcub2F1dGg7XG4gICAgICAgIHRoaXMub2F1dGhDb25maWcuc2lnbmF0dXJlX21ldGhvZCA9ICdSU0EtU0hBMSc7XG5cbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5iYXNpY19hdXRoKSB7XG4gICAgICAgIGlmIChjb25maWcuYmFzaWNfYXV0aC5iYXNlNjQpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzaWNfYXV0aCA9IHtcbiAgICAgICAgICAgICAgYmFzZTY0OiBjb25maWcuYmFzaWNfYXV0aC5iYXNlNjRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY29uZmlnLmJhc2ljX2F1dGgudXNlcm5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmdzLk5PX1VTRVJOQU1FX0VSUk9SKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbmZpZy5iYXNpY19hdXRoLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19QQVNTV09SRF9FUlJPUik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYmFzaWNfYXV0aCA9IHtcbiAgICAgICAgICAgICAgICB1c2VyOiBjb25maWcuYmFzaWNfYXV0aC51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBwYXNzOiBjb25maWcuYmFzaWNfYXV0aC5wYXNzd29yZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb25maWcuY29va2llX2phcikge1xuICAgICAgICB0aGlzLmNvb2tpZV9qYXIgPSBjb25maWcuY29va2llX2phcjtcbiAgICB9XG5cbiAgICB0aGlzLmFwcGxpY2F0aW9uUHJvcGVydGllcyA9IG5ldyBhcHBsaWNhdGlvblByb3BlcnRpZXModGhpcyk7XG4gICAgdGhpcy5hdHRhY2htZW50ID0gbmV3IGF0dGFjaG1lbnQodGhpcyk7XG4gICAgdGhpcy5hdWRpdGluZyA9IG5ldyBhdWRpdGluZyh0aGlzKTtcbiAgICB0aGlzLmF1dGggPSBuZXcgYXV0aCh0aGlzKTtcbiAgICB0aGlzLmF2YXRhciA9IG5ldyBhdmF0YXIodGhpcyk7XG4gICAgdGhpcy5ib2FyZCA9IG5ldyBib2FyZCh0aGlzKTtcbiAgICB0aGlzLmNvbW1lbnQgPSBuZXcgY29tbWVudCh0aGlzKTtcbiAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBjb21wb25lbnQodGhpcyk7XG4gICAgdGhpcy5jdXN0b21GaWVsZE9wdGlvbiA9IG5ldyBjdXN0b21GaWVsZE9wdGlvbih0aGlzKTtcbiAgICB0aGlzLmRhc2hib2FyZCA9IG5ldyBkYXNoYm9hcmQodGhpcyk7XG4gICAgdGhpcy5maWVsZCA9IG5ldyBmaWVsZCh0aGlzKTtcbiAgICB0aGlzLmZpbHRlciA9IG5ldyBmaWx0ZXIodGhpcyk7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBncm91cCh0aGlzKTtcbiAgICB0aGlzLmdyb3VwVXNlclBpY2tlciA9IG5ldyBncm91cFVzZXJQaWNrZXIodGhpcyk7XG4gICAgdGhpcy5ncm91cHMgPSBuZXcgZ3JvdXBzKHRoaXMpO1xuICAgIHRoaXMuaXNzdWUgPSBuZXcgaXNzdWUodGhpcyk7XG4gICAgdGhpcy5pc3N1ZUxpbmsgPSBuZXcgaXNzdWVMaW5rKHRoaXMpO1xuICAgIHRoaXMuaXNzdWVMaW5rVHlwZSA9IG5ldyBpc3N1ZUxpbmtUeXBlKHRoaXMpO1xuICAgIHRoaXMuaXNzdWVUeXBlID0gbmV3IGlzc3VlVHlwZSh0aGlzKTtcbiAgICB0aGlzLmpxbCA9IG5ldyBqcWwodGhpcyk7XG4gICAgdGhpcy5saWNlbnNlUm9sZSA9IG5ldyBsaWNlbnNlUm9sZSh0aGlzKTtcbiAgICB0aGlzLmxpY2Vuc2VWYWxpZGF0b3IgPSBuZXcgbGljZW5zZVZhbGlkYXRvcih0aGlzKTtcbiAgICB0aGlzLm15UGVybWlzc2lvbnMgPSBuZXcgbXlQZXJtaXNzaW9ucyh0aGlzKTtcbiAgICB0aGlzLm15UHJlZmVyZW5jZXMgPSBuZXcgbXlQcmVmZXJlbmNlcyh0aGlzKTtcbiAgICB0aGlzLm15c2VsZiA9IG5ldyBteXNlbGYodGhpcyk7XG4gICAgdGhpcy5wYXNzd29yZCA9IG5ldyBwYXNzd29yZCh0aGlzKTtcbiAgICB0aGlzLnBlcm1pc3Npb25zID0gbmV3IHBlcm1pc3Npb25zKHRoaXMpO1xuICAgIHRoaXMucGVybWlzc2lvblNjaGVtZSA9IG5ldyBwZXJtaXNzaW9uU2NoZW1lKHRoaXMpO1xuICAgIHRoaXMucHJpb3JpdHkgPSBuZXcgcHJpb3JpdHkodGhpcyk7XG4gICAgdGhpcy5wcm9qZWN0ID0gbmV3IHByb2plY3QodGhpcyk7XG4gICAgdGhpcy5wcm9qZWN0Q2F0ZWdvcnkgPSBuZXcgcHJvamVjdENhdGVnb3J5KHRoaXMpO1xuICAgIHRoaXMucHJvamVjdFZhbGlkYXRlID0gbmV3IHByb2plY3RWYWxpZGF0ZSh0aGlzKTtcbiAgICB0aGlzLnJlaW5kZXggPSBuZXcgcmVpbmRleCh0aGlzKTtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBuZXcgcmVzb2x1dGlvbih0aGlzKTtcbiAgICB0aGlzLnJvbGVzID0gbmV3IHJvbGVzKHRoaXMpO1xuICAgIHRoaXMuc2NyZWVucyA9IG5ldyBzY3JlZW5zKHRoaXMpO1xuICAgIHRoaXMuc2VhcmNoID0gbmV3IHNlYXJjaCh0aGlzKTtcbiAgICB0aGlzLnNlY3VyaXR5TGV2ZWwgPSBuZXcgc2VjdXJpdHlMZXZlbCh0aGlzKTtcbiAgICB0aGlzLnNlcnZlckluZm8gPSBuZXcgc2VydmVySW5mbyh0aGlzKTtcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IHNldHRpbmdzKHRoaXMpO1xuICAgIHRoaXMuc3ByaW50ID0gbmV3IHNwcmludCh0aGlzKTtcbiAgICB0aGlzLnN0YXR1cyA9IG5ldyBzdGF0dXModGhpcyk7XG4gICAgdGhpcy5zdGF0dXNDYXRlZ29yeSA9IG5ldyBzdGF0dXNDYXRlZ29yeSh0aGlzKTtcbiAgICB0aGlzLnVzZXIgPSBuZXcgdXNlcih0aGlzKTtcbiAgICB0aGlzLnZlcnNpb24gPSBuZXcgdmVyc2lvbih0aGlzKTtcbiAgICB0aGlzLndlYmhvb2sgPSBuZXcgd2ViaG9vayh0aGlzKTtcbiAgICB0aGlzLndvcmtmbG93ID0gbmV3IHdvcmtmbG93KHRoaXMpO1xuICAgIHRoaXMud29ya2Zsb3dTY2hlbWUgPSBuZXcgd29ya2Zsb3dTY2hlbWUodGhpcyk7XG4gICAgdGhpcy53b3JrbG9nID0gbmV3IHdvcmtsb2codGhpcyk7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogU2ltcGxlIHV0aWxpdHkgdG8gYnVpbGQgYSBSRVNUIGVuZHBvaW50IFVSTCBmb3IgdGhlIEppcmEgQVBJLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZFVSTFxuICAgICAqIEBtZW1iZXJPZiBKaXJhQ2xpZW50I1xuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBVUkwgd2l0aG91dCBjb25jZXJuIGZvciB0aGUgcm9vdCBvZiB0aGUgUkVTVCBBUEkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbnN0cnVjdGVkIFVSTC5cbiAgICAgKi9cbiAgICB0aGlzLmJ1aWxkVVJMID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIGFwaUJhc2VQYXRoID0gdGhpcy5wYXRoX3ByZWZpeCArICdyZXN0L2FwaS8nO1xuICAgICAgICB2YXIgdmVyc2lvbiA9IHRoaXMuYXBpVmVyc2lvbjtcbiAgICAgICAgdmFyIHJlcXVlc3RVcmwgPSB1cmwuZm9ybWF0KHtcbiAgICAgICAgICAgIHByb3RvY29sOiB0aGlzLnByb3RvY29sLFxuICAgICAgICAgICAgaG9zdG5hbWU6IHRoaXMuaG9zdCxcbiAgICAgICAgICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBhcGlCYXNlUGF0aCArIHZlcnNpb24gKyBwYXRoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVxdWVzdFVybCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSB1dGlsaXR5IHRvIGJ1aWxkIGEgUkVTVCBlbmRwb2ludCBVUkwgZm9yIHRoZSBKaXJhIEFnaWxlIEFQSS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVpbGRBZ2lsZVVSTFxuICAgICAqIEBtZW1iZXJPZiBKaXJhQ2xpZW50I1xuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBVUkwgd2l0aG91dCBjb25jZXJuIGZvciB0aGUgcm9vdCBvZiB0aGUgUkVTVCBBUEkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbnN0cnVjdGVkIFVSTC5cbiAgICAgKi9cbiAgICB0aGlzLmJ1aWxkQWdpbGVVUkwgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgYXBpQmFzZVBhdGggPSB0aGlzLnBhdGhfcHJlZml4ICsgJ3Jlc3QvYWdpbGUvJztcbiAgICAgICAgdmFyIHZlcnNpb24gPSB0aGlzLmFnaWxlQXBpVmVyc2lvbjtcbiAgICAgICAgdmFyIHJlcXVlc3RVcmwgPSB1cmwuZm9ybWF0KHtcbiAgICAgICAgICAgIHByb3RvY29sOiB0aGlzLnByb3RvY29sLFxuICAgICAgICAgICAgaG9zdG5hbWU6IHRoaXMuaG9zdCxcbiAgICAgICAgICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBhcGlCYXNlUGF0aCArIHZlcnNpb24gKyBwYXRoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVxdWVzdFVybCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNpbXBsZSB1dGlsaXR5IHRvIGJ1aWxkIGEgUkVTVCBlbmRwb2ludCBVUkwgZm9yIHRoZSBKaXJhIEF1dGggQVBJLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBidWlsZEF1dGhVUkxcbiAgICAgKiBAbWVtYmVyT2YgSmlyYUNsaWVudCNcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBvZiB0aGUgVVJMIHdpdGhvdXQgY29uY2VybiBmb3IgdGhlIHJvb3Qgb2YgdGhlIFJFU1QgQVBJLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBVUkwuXG4gICAgICovXG4gICAgdGhpcy5idWlsZEF1dGhVUkwgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgYXBpQmFzZVBhdGggPSB0aGlzLnBhdGhfcHJlZml4ICsgJ3Jlc3QvYXV0aC8nO1xuICAgICAgICB2YXIgdmVyc2lvbiA9IHRoaXMuYXV0aEFwaVZlcnNpb247XG4gICAgICAgIHZhciByZXF1ZXN0VXJsID0gdXJsLmZvcm1hdCh7XG4gICAgICAgICAgICBwcm90b2NvbDogdGhpcy5wcm90b2NvbCxcbiAgICAgICAgICAgIGhvc3RuYW1lOiB0aGlzLmhvc3QsXG4gICAgICAgICAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgICAgICAgICBwYXRobmFtZTogYXBpQmFzZVBhdGggKyB2ZXJzaW9uICsgcGF0aFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHJlcXVlc3RVcmwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgdXRpbGl0eSB0byBidWlsZCBhIFJFU1QgZW5kcG9pbnQgVVJMIGZvciB0aGUgSmlyYSB3ZWJob29rIEFQSS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgYnVpbGRXZWJob29rVVJMXG4gICAgICogQG1lbWJlck9mIEppcmFDbGllbnQjXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggb2YgdGhlIFVSTCB3aXRob3V0IGNvbmNlcm4gZm9yIHRoZSByb290IG9mIHRoZSBSRVNUIEFQSS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29uc3RydWN0ZWQgVVJMLlxuICAgICAqL1xuICAgIHRoaXMuYnVpbGRXZWJob29rVVJMID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIGFwaUJhc2VQYXRoID0gdGhpcy5wYXRoX3ByZWZpeCArICdyZXN0L3dlYmhvb2tzLyc7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gdGhpcy53ZWJob29rQXBpVmVyc2lvbjtcbiAgICAgICAgdmFyIHJlcXVlc3RVcmwgPSB1cmwuZm9ybWF0KHtcbiAgICAgICAgICAgIHByb3RvY29sOiB0aGlzLnByb3RvY29sLFxuICAgICAgICAgICAgaG9zdG5hbWU6IHRoaXMuaG9zdCxcbiAgICAgICAgICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBhcGlCYXNlUGF0aCArIHZlcnNpb24gKyBwYXRoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVxdWVzdFVybCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYSByZXF1ZXN0IHRvIHRoZSBKaXJhIEFQSSBhbmQgY2FsbCBiYWNrIHdpdGggaXQncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbWFrZVJlcXVlc3RcbiAgICAgKiBAbWVtYmVyT2YgSmlyYUNsaWVudCNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBbY2FsbGJhY2tdIENhbGxlZCB3aXRoIHRoZSBBUElzIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3VjY2Vzc1N0cmluZ10gSWYgc3VwcGxpZWQsIHRoaXMgaXMgcmVwb3J0ZWQgaW5zdGVhZCBvZiB0aGUgcmVzcG9uc2UgYm9keS5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlZCB3aXRoIEFQSXMgcmVzcG9uc2Ugb3IgcmVqZWN0ZWQgd2l0aCBlcnJvclxuICAgICAqL1xuICAgIHRoaXMubWFrZVJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2ssIHN1Y2Nlc3NTdHJpbmcpIHtcbiAgICAgICAgbGV0IHJlcXVlc3RMaWIgPSB0aGlzLnJlcXVlc3RMaWI7XG4gICAgICAgIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMub2F1dGhDb25maWcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMub2F1dGggPSB0aGlzLm9hdXRoQ29uZmlnO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYmFzaWNfYXV0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFzaWNfYXV0aC5iYXNlNjQpIHtcbiAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0Jhc2ljICcgKyB0aGlzLmJhc2ljX2F1dGguYmFzZTY0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcHRpb25zLmF1dGggPSB0aGlzLmJhc2ljX2F1dGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29va2llX2phcikge1xuICAgICAgICAgICAgb3B0aW9ucy5qYXIgPSB0aGlzLmNvb2tpZV9qYXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJlcXVlc3RMaWIob3B0aW9ucywgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIGJvZHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUudG9TdHJpbmcoKVswXSAhPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIgPyBlcnIgOiBib2R5LCBudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChqc29uRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhqc29uRXJyLCBudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHN1Y2Nlc3NTdHJpbmcgPyBzdWNjZXNzU3RyaW5nIDogYm9keSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMucHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVxID0gcmVxdWVzdExpYihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdE9iaiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICByZXEub24oJ3JlcXVlc3QnLCBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXF1ZXN0T2JqID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJlcS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmluZyBlcnJvclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSByZXNwb25zZS5zdGF0dXNDb2RlLnRvU3RyaW5nKClbMF0gIT09ICcyJztcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsZWN0aW5nIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB1c2ggPSBib2R5LnB1c2guYmluZChib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2RhdGEnLCBwdXNoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEYXRhIGNvbGxlY3RlZFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYm9keS5qb2luKCcnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2luZyBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzBdID09PSAnWycgfHwgcmVzdWx0WzBdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVxdWVzdE9iai5faGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0T2JqLl9oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXEub24oJ2Vycm9yJywgcmVqZWN0KTtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbn0pLmNhbGwoSmlyYUNsaWVudC5wcm90b3R5cGUpO1xuXG5KaXJhQ2xpZW50Lm9hdXRoX3V0aWwgPSByZXF1aXJlKCcuL2xpYi9vYXV0aF91dGlsJyk7XG5cbmV4cG9ydHMub2F1dGhfdXRpbCA9IG9hdXRoX3V0aWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5OT19IT1NUX0VSUk9SID0gJ01pc3NpbmcgXFwnaG9zdFxcJyBwcm9wZXJ0eS4nO1xuZXhwb3J0cy5OT19DT05TVU1FUl9LRVlfRVJST1IgPSAnTWlzc2luZyBcXCdvYXV0aF9jb25zdW1lcl9rZXlcXCcgcHJvcGVydHkuJztcbmV4cG9ydHMuTk9fUFJJVkFURV9LRVlfRVJST1IgPSAnTWlzc2luZyBcXCdvYXV0aF9wcml2YXRlX2tleVxcJyBwcm9wZXJ0eS4nO1xuZXhwb3J0cy5OT19PQVVUSF9UT0tFTl9FUlJPUiA9ICdNaXNzaW5nIFxcJ29hdXRoX3Rva2VuXFwnIHByb3BlcnR5Lic7XG5leHBvcnRzLk5PX09BVVRIX1RPS0VOX1NFQ1JFVF9FUlJPUiA9ICdNaXNzaW5nIFxcJ29hdXRoX3Rva2VuX3NlY3JldFxcJyBwcm9wZXJ0eS4nO1xuZXhwb3J0cy5OT19VU0VSTkFNRV9FUlJPUiA9ICdNaXNzaW5nIFxcJ3VzZXJuYW1lXFwnIHByb3BlcnR5Lic7XG5leHBvcnRzLk5PX1BBU1NXT1JEX0VSUk9SID0gJ01pc3NpbmcgXFwncGFzc3dvcmRcXCcgcHJvcGVydHkuJztcbmV4cG9ydHMuTk9fQVVUSEVOVElDQVRJT05fRVJST1IgPSAnTWlzc2luZyBcXCdhdXRoXFwnIHByb3BlcnR5Lic7XG5leHBvcnRzLk5PX1ZFUklGSUVSX0VSUk9SID0gJ01pc3NpbmcgXFwnb2F1dGhfdmVyaWZpZXJcXCcgcHJvcGVydHkuJztcbmV4cG9ydHMuSU5WQUxJRF9BVVRIRU5USUNBVElPTl9QUk9QRVJUWV9FUlJPUiA9ICdJbnZhbGlkIFxcJ2F1dGhcXCcgcHJvcGVydHkuJztcbmV4cG9ydHMuTk9fSVNTVUVfSURFTlRJRklFUiA9ICdNaXNzaW5nIElzc3VlIElEIG9yIEtleSc7XG5leHBvcnRzLk5PX0NPTU1FTlRfSUQgPSAnTWlzc2luZyBcXCdjb21tZW50SURcXCcgcHJvcGVydHkuJztcbmV4cG9ydHMuTk9fQ09NTUVOVF9FUlJPUiA9ICdNaXNzaW5nIFxcJ2NvbW1lbnRcXCcgcHJvcGVydHkuJztcbmV4cG9ydHMuTk9fTk9USUZJQ0FUSU9OX0VSUk9SID0gJ01pc3NpbmcgXFwnbm90aWZpY2F0aW9uXFwnIHByb3BlcnR5JztcbmV4cG9ydHMuTk9fR0xPQkFMX0lEX0VSUk9SID0gJ01pc3NpbmcgXFwnZ2xvYmFsSWRcXCcgcHJvcGVydHkuJztcbmV4cG9ydHMuTk9fTElOS19JRF9FUlJPUiA9ICdNaXNzaW5nIFxcJ2xpbmtJZFxcJyBwcm9wZXJ0eS4nO1xuZXhwb3J0cy5OT19UUkFOU0lUSU9OX0VSUk9SID0gJ01pc3NpbmcgXFwndHJhbnNpdGlvblxcJyBwcm9wZXJ0eS4nO1xuZXhwb3J0cy5OT19JU1NVRV9FUlJPUiA9ICdNaXNzaW5nIFxcJ2lzc3VlXFwnIHByb3BlcnR5JztcbmV4cG9ydHMuTk9fQVNTSUdORUVfRVJST1IgPSAnTWlzc2luZyBcXCdhc3NpZ25lZVxcJyBwcm9wZXJ0eSc7XG5leHBvcnRzLk5PX1dBVENIRVJfRVJST1IgPSAnTWlzc2luZyBcXCd3YXRjaGVyXFwnIHByb3BlcnR5JztcbmV4cG9ydHMuTk9fV09SS0xPR19FUlJPUiA9ICdNaXNzaW5nIFxcJ3dvcmtsb2dcXCcgcHJvcGVydHknO1xuZXhwb3J0cy5OT19XT1JLTE9HX0lEX0VSUk9SID0gJ01pc3NpbmcgXFwnd29ya2xvZ0lkXFwnIHByb3BlcnR5JztcbmV4cG9ydHMuTk9fRklMRU5BTUVfRVJST1IgPSAnTWlzc2luZyBcXCdmaWxlbmFtZVxcJyBwcm9wZXJ0eSc7XG5leHBvcnRzLk5PX1BST1BFUlRZX0tFWV9FUlJPUiA9ICdNaXNzaW5nIFxcJ3Byb3BlcnR5S2V5XFwnIHByb3BlcnR5JztcbmV4cG9ydHMuTk9fUFJPUEVSVFlfVkFMVUVfRVJST1IgPSAnTWlzc2luZyBcXCdwcm9wZXJ0eVZhbHVlXFwnIHByb3BlcnR5JztcbmV4cG9ydHMuTk9fQVRUQUNITUVOVF9JRF9FUlJPUiA9ICdNaXNzaW5nIFxcJ2F0dGFjaG1lbnRJZFxcJyBwcm9wZXJ0eSc7XG5leHBvcnRzLk5PX0FVRElUX0VSUk9SID0gJ01pc3NpbmcgXFwnYXVkaXRcXCcgcHJvcGVydHknO1xuZXhwb3J0cy5OT19BVkFUQVJfVFlQRV9FUlJPUiA9ICdNaXNzaW5nIFxcJ2F2YXRhclR5cGVcXCcgcHJvcGVydHknO1xuZXhwb3J0cy5OT19DT01NRU5UX1BST1BFUlRZX0tFWV9FUlJPUiA9ICdNaXNzaW5nIFxcJ3Byb3BlcnR5S2V5XFwnIHByb3BlcnR5JztcbmV4cG9ydHMuTk9fQ09NTUVOVF9QUk9QRVJUWV9WQUxVRV9FUlJPUiA9ICdNaXNzaW5nIFxcJ3Byb3BlcnR5VmFsdWVcXCcgcHJvcGVydHknO1xuZXhwb3J0cy5OT19JU1NVRV9MSU5LX0VSUk9SID0gJ01pc3NpbmdcXCdpc3N1ZUxpbmtcXCcgcHJvcGVydHknO1xuZXhwb3J0cy5OT19JU1NVRV9MSU5LX0lEX0VSUk9SID0gJ01pc3NpbmdcXCdsaW5rSWRcXCcgcHJvcGVydHknO1xuZXhwb3J0cy5OT19JU1NVRV9MSU5LX1RZUEVfSUQgPSAnTWlzc2luZyBcXCdpc3N1ZUxpbmtUeXBlSWRcXCcgcHJvcGVydHkuJztcbmV4cG9ydHMuTk9fRklFTERfT1BUSU9OX0lEX0VSUk9SID0gJ01pc3NpbmcgXFwnZmllbGRPcHRpb25JZFxcJyBwcm9wZXJ0eS4nOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBucG0gcGFja2FnZXNcbnZhciBPYXV0aCA9IHJlcXVpcmUoJ29hdXRoJyk7XG5cbi8vIENvcmUgcGFja2FnZXNcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxuLy8gQ3VzdG9tIFBhY2thZ2VzXG52YXIgZXJyb3JTdHJpbmdzID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgT2F1dGhVdGlsXG4gKi9cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBnZXQgYW4gT0F1dGggdmVyaWZpY2F0aW9uIFVSTCB1c2luZyB0aGUgZ2l2ZW4gQVBJIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQG1lbWJlck9mIE9hdXRoVXRpbFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgaW5mb3JtYXRpb24gbmVlZGVkIHRvIGFjY2VzcyB0aGUgSmlyYSBBUElcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcuaG9zdCBUaGUgaG9zdG5hbWUgb2YgdGhlIEppcmEgQVBJLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcucHJvdG9jb2w9aHR0cHNdIC0gVGhlIHByb3RvY29sIHVzZWQgdG8gYWNjc2VzIHRoZSBKaXJhIEFQSS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLnBvcnQ9NDQzXSAtIFRoZSBwb3J0IG51bWJlciB1c2VkIHRvIGNvbm5lY3QgdG8gSmlyYS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLnBhdGhfcHJlZml4PVwiL1wiXSBUaGUgcHJlZml4IHRvIHVzZSBpbiBmcm9udCBvZiB0aGUgcGF0aCwgaWYgSmlyYSBpc24ndCBhdCBcIi9cIlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcudmVyc2lvbj0yXSAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBKaXJhIEFQSSB0byB3aGljaCB5b3Ugd2lsbCBiZSBjb25uZWN0aW5nLiAgQ3VycmVudGx5LCBvbmx5XG4gKiAgICAgdmVyc2lvbiAyIGlzIHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcub2F1dGggVGhlIG9hdXRoIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLm9hdXRoLmNvbnN1bWVyX2tleSBUaGUgY29uc3VtZXIga2V5IG9mIHRoZSBhcHBsaWNhdGlvbiBhY2Nlc3NpbmcgSmlyYS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcub2F1dGgucHJpdmF0ZV9rZXkgVGhlIHByaXZhdGUga2V5IG9mIHRoZSBhcHBsaWNhdGlvbiBhY2Nlc3NpbmcgSmlyYS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm9hdXRoLmNhbGxiYWNrX3VybF0gVGhlIGNhbGxiYWNrIFVSTCB0byBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRva2VuIGlzIGdlbmVyYXRlZC4gIElmIHRoaXMgaXNcbiAqICAgICBub3QgaW5jbHVkZWQsIHRoZSB1c2VyIHdpbGwgYmUgZ2l2ZW4gYSB2ZXJpZmljYXRpb24gY29kZSBhZnRlciBhdXRob3JpemluZyB0aGUgdG9rZW4sIGluc3RlYWQgb2YgSmlyYSBtYWtpbmcgYVxuICogICAgIGNhbGxiYWNrIHRvIHRoZSBhcHBsaWNhdGlvbi5cbiAqIEBwYXJhbSB7T2F1dGhVdGlsfmdldE9hdXRoVXJsQ2FsbGJhY2t9IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgVVJMIGhhcyBiZWVuIHJldHJpZXZlZC5cbiAqL1xuZXhwb3J0cy5nZXRBdXRob3JpemVVUkwgPSBmdW5jdGlvbiAoY29uZmlnLCBjYWxsYmFjaykge1xuICAgIHZhciBwcmVmaXggPSBjb25maWcucGF0aF9wcmVmaXggPyBjb25maWcucGF0aF9wcmVmaXggOiAnJztcbiAgICB2YXIgQVVUSF9UT0tFTl9BUFBFTkQgPSAnL29hdXRoL2F1dGhvcml6ZSc7XG4gICAgdmFyIFNFUlZMRVRfQkFTRV9VUkwgPSBwcmVmaXggKyAnL3BsdWdpbnMvc2VydmxldCc7XG5cbiAgICB2YXIgYXV0aFVSTCA9IHVybC5mb3JtYXQoe1xuICAgICAgICBwcm90b2NvbDogY29uZmlnLnByb3RvY29sID8gY29uZmlnLnByb3RvY29sIDogJ2h0dHBzJyxcbiAgICAgICAgaG9zdG5hbWU6IGNvbmZpZy5ob3N0LFxuICAgICAgICBwb3J0OiBjb25maWcucG9ydCA/IGNvbmZpZy5wb3J0IDogbnVsbCxcbiAgICAgICAgcGF0aG5hbWU6IFNFUlZMRVRfQkFTRV9VUkwgKyBBVVRIX1RPS0VOX0FQUEVORFxuICAgIH0pO1xuXG4gICAgdmFyIG9hdXRoID0gZ2VuZXJhdGVPQXV0aE9iamVjdChjb25maWcpO1xuXG4gICAgb2F1dGguZ2V0T0F1dGhSZXF1ZXN0VG9rZW4oZnVuY3Rpb24gKGVyciwgdG9rZW4sIHRva2VuX3NlY3JldCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge3VybDogYXV0aFVSTCArIFwiP29hdXRoX3Rva2VuPVwiICsgdG9rZW4sIHRva2VuOiB0b2tlbiwgdG9rZW5fc2VjcmV0OiB0b2tlbl9zZWNyZXR9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gT0F1dGggdG9rZW4sIHRoZSB0b2tlbiBzZWNyZXQsIGFuZCBhbiBhY2Nlc3MgdmVyaWZpY2F0aW9uIGNvZGUgKHByb3ZpZGVkIGJ5IEppcmEpLCBzd2FwIGFuIE9BdXRoIHJlcXVlc3RcbiAqIHRva2VuIHdpdGggYW4gT0F1dGggYWNjZXNzIHRva2VuLlxuICpcbiAqIEBtZW1iZXJPZiBPYXV0aFV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGluZm9ybWF0aW9uIG5lZWRlZCB0byBhY2Nlc3MgdGhlIEppcmEgQVBJXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLmhvc3QgVGhlIGhvc3RuYW1lIG9mIHRoZSBKaXJhIEFQSS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLnByb3RvY29sPWh0dHBzXSAtIFRoZSBwcm90b2NvbCB1c2VkIHRvIGFjY3NlcyB0aGUgSmlyYSBBUEkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5wb3J0PTQ0M10gLSBUaGUgcG9ydCBudW1iZXIgdXNlZCB0byBjb25uZWN0IHRvIEppcmEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy52ZXJzaW9uPTJdIC0gVGhlIHZlcnNpb24gb2YgdGhlIEppcmEgQVBJIHRvIHdoaWNoIHlvdSB3aWxsIGJlIGNvbm5lY3RpbmcuICBDdXJyZW50bHksIG9ubHlcbiAqICAgICB2ZXJzaW9uIDIgaXMgc3VwcG9ydGVkLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5vYXV0aCBUaGUgb2F1dGggaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcub2F1dGguY29uc3VtZXJfa2V5IFRoZSBjb25zdW1lciBrZXkgb2YgdGhlIGFwcGxpY2F0aW9uIGFjY2Vzc2luZyBKaXJhLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5vYXV0aC5wcml2YXRlX2tleSBUaGUgcHJpdmF0ZSBrZXkgb2YgdGhlIGFwcGxpY2F0aW9uIGFjY2Vzc2luZyBKaXJhLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5vYXV0aC50b2tlbiBUaGUgT0F1dGggVG9rZW4gc3VwcGxpZWQgYnkgSmlyYS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcub2F1dGgudG9rZW5fc2VjcmV0IFRoZSBPQXV0aCBUb2tlbiBzZWNyZXQgc3VwcGxpZWQgYnkgSmlyYS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcub2F1dGgub2F1dGhfdmVyaWZpZXIgVGhlIHZlcmlmaWVkIGNvZGUgZ2l2ZW4gdG8gdGhlIHVzZXIgYWZ0ZXIgYXV0aG9yaXppbmcgdGhlIE9BdXRoIHRva2VuLlxuICogQHBhcmFtIHtPYXV0aFV0aWx+c3dhcFJlcXVlc3RUb2tlbkNhbGxiYWNrfSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIHRva2VuIGhhcyBiZWVuIHN3YXBwZWQuXG4gKi9cbmV4cG9ydHMuc3dhcFJlcXVlc3RUb2tlbldpdGhBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgICBpZighY29uZmlnLm9hdXRoLm9hdXRoX3ZlcmlmaWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fVkVSSUZJRVJfRVJST1IpO1xuICAgIH1cblxuICAgIHZhciBvYXV0aCA9IGdlbmVyYXRlT0F1dGhPYmplY3QoY29uZmlnKTtcblxuICAgIHZhciB0b2tlbiA9IGNvbmZpZy5vYXV0aC50b2tlbjtcbiAgICB2YXIgc2VjcmV0ID0gY29uZmlnLm9hdXRoLnRva2VuX3NlY3JldDtcbiAgICB2YXIgdmVyaWZpZXIgPSBjb25maWcub2F1dGgub2F1dGhfdmVyaWZpZXI7XG5cbiAgICBvYXV0aC5nZXRPQXV0aEFjY2Vzc1Rva2VuKHRva2VuLCBzZWNyZXQsIHZlcmlmaWVyLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYW4gT0F1dGggb2JqZWN0LlxuICpcbiAqIEBtZW1iZXJPZiBPYXV0aFV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGluZm9ybWF0aW9uIG5lZWRlZCB0byBhY2Nlc3MgdGhlIEppcmEgQVBJXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLmhvc3QgVGhlIGhvc3RuYW1lIG9mIHRoZSBKaXJhIEFQSS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLnByb3RvY29sPWh0dHBzXSAtIFRoZSBwcm90b2NvbCB1c2VkIHRvIGFjY3NlcyB0aGUgSmlyYSBBUEkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5wb3J0PTQ0M10gLSBUaGUgcG9ydCBudW1iZXIgdXNlZCB0byBjb25uZWN0IHRvIEppcmEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5wYXRoX3ByZWZpeD1cIi9cIl0gVGhlIHByZWZpeCB0byB1c2UgaW4gZnJvbnQgb2YgdGhlIHBhdGgsIGlmIEppcmEgaXNuJ3QgYXQgXCIvXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLnZlcnNpb249Ml0gLSBUaGUgdmVyc2lvbiBvZiB0aGUgSmlyYSBBUEkgdG8gd2hpY2ggeW91IHdpbGwgYmUgY29ubmVjdGluZy4gIEN1cnJlbnRseSwgb25seVxuICogICAgIHZlcnNpb24gMiBpcyBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLm9hdXRoIFRoZSBvYXV0aCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNvbmZpZy5vYXV0aC5jb25zdW1lcl9rZXkgVGhlIGNvbnN1bWVyIGtleSBvZiB0aGUgYXBwbGljYXRpb24gYWNjZXNzaW5nIEppcmEuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLm9hdXRoLnByaXZhdGVfa2V5IFRoZSBwcml2YXRlIGtleSBvZiB0aGUgYXBwbGljYXRpb24gYWNjZXNzaW5nIEppcmEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5vYXV0aC5jYWxsYmFja191cmxdIFRoZSBjYWxsYmFjayBVUkwgdG8gYmUgY2FsbGVkIGFmdGVyIHRoZSB0b2tlbiBpcyBnZW5lcmF0ZWQuICBJZiB0aGlzIGlzXG4gKiAgICAgbm90IGluY2x1ZGVkLCB0aGUgdXNlciB3aWxsIGJlIGdpdmVuIGEgdmVyaWZpY2F0aW9uIGNvZGUgYWZ0ZXIgYXV0aG9yaXppbmcgdGhlIHRva2VuLCBpbnN0ZWFkIG9mIEppcmEgbWFraW5nIGFcbiAqICAgICBjYWxsYmFjayB0byB0aGUgYXBwbGljYXRpb24uXG4gKlxuICogQHJldHVybnMge2V4cG9ydHMuT0F1dGh9IFRoZSBnZW5lcmF0ZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZU9BdXRoT2JqZWN0KGNvbmZpZykge1xuICAgIHZhciBwcmVmaXggPSBjb25maWcucGF0aF9wcmVmaXggPyBjb25maWcucGF0aF9wcmVmaXggOiAnJztcbiAgICB2YXIgU0VSVkxFVF9CQVNFX1VSTCA9IHByZWZpeCArICcvcGx1Z2lucy9zZXJ2bGV0JztcbiAgICB2YXIgUkVRX1RPS0VOX0FQUEVORCA9ICcvb2F1dGgvcmVxdWVzdC10b2tlbic7XG5cbiAgICB2YXIgQUNDRVNTX1RPS0VOX0FQUEVORCA9ICcvb2F1dGgvYWNjZXNzLXRva2VuJztcbiAgICB2YXIgc2lnID0gJ1JTQS1TSEExJztcblxuICAgIGlmICghY29uZmlnLmhvc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19IT1NUX0VSUk9SKTtcbiAgICB9IGVsc2UgaWYgKCFjb25maWcub2F1dGguY29uc3VtZXJfa2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZ3MuTk9fQ09OU1VNRVJfS0VZX0VSUk9SKTtcbiAgICB9IGVsc2UgaWYgKCFjb25maWcub2F1dGgucHJpdmF0ZV9rZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yU3RyaW5ncy5OT19QUklWQVRFX0tFWV9FUlJPUik7XG4gICAgfVxuXG4gICAgdmFyIGNvbnN1bWVyX2tleSA9IGNvbmZpZy5vYXV0aC5jb25zdW1lcl9rZXk7XG4gICAgdmFyIHByaXZhdGVfa2V5ID0gY29uZmlnLm9hdXRoLnByaXZhdGVfa2V5O1xuXG4gICAgdmFyIHJlcVVSTCA9IHVybC5mb3JtYXQoe1xuICAgICAgICBwcm90b2NvbDogY29uZmlnLnByb3RvY29sID8gY29uZmlnLnByb3RvY29sIDogJ2h0dHBzJyxcbiAgICAgICAgaG9zdG5hbWU6IGNvbmZpZy5ob3N0LFxuICAgICAgICBwb3J0OiBjb25maWcucG9ydCA/IGNvbmZpZy5wb3J0IDogbnVsbCxcbiAgICAgICAgcGF0aG5hbWU6IFNFUlZMRVRfQkFTRV9VUkwgKyBSRVFfVE9LRU5fQVBQRU5EXG4gICAgfSk7XG5cbiAgICB2YXIgYWNjZXNzVVJMID0gdXJsLmZvcm1hdCh7XG4gICAgICAgIHByb3RvY29sOiBjb25maWcucHJvdG9jb2wgPyBjb25maWcucHJvdG9jb2wgOiAnaHR0cHMnLFxuICAgICAgICBob3N0bmFtZTogY29uZmlnLmhvc3QsXG4gICAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0ID8gY29uZmlnLnBvcnQgOiBudWxsLFxuICAgICAgICBwYXRobmFtZTogU0VSVkxFVF9CQVNFX1VSTCArIEFDQ0VTU19UT0tFTl9BUFBFTkRcbiAgICB9KTtcblxuICAgIHZhciBjYiA9IGNvbmZpZy5vYXV0aC5jYWxsYmFja191cmwgPyBjb25maWcub2F1dGguY2FsbGJhY2tfdXJsIDogJ29vYic7XG5cbiAgICByZXR1cm4gbmV3IE9hdXRoLk9BdXRoKHJlcVVSTCwgYWNjZXNzVVJMLCBjb25zdW1lcl9rZXksIHByaXZhdGVfa2V5LCAnMS4wJywgY2IsIHNpZyk7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgdXNlZCBieSBnZXRPYXV0aFVybC5cbiAqIEBjYWxsYmFjayBPYXV0aFV0aWx+Z2V0T2F1dGhVcmxDYWxsYmFja1xuICogQHBhcmFtIHsqfSBlcnJvciBUaGUgZXJyb3Igd2hpY2ggb2NjdXJyZWQsIGlmIGFueS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYXV0aCBUaGUgT0F1dGggaW5mb3JtYXRpb24gcmV0cmlldmVkIGZyb20gdGhlIEppcmEgQVBJLlxuICogQHBhcmFtIHtTdHJpbmd9IG9hdXRoLnVybCBUaGUgVVJMIHRoYXQgc2hvdWxkIGJlIHZpc2l0ZWQgYnkgdGhlIHVzZXIgdG8gdmVyaWZ5IHRoZSBPQXV0aCBhY2Nlc3MuXG4gKiBAcGFyYW0ge1N0cmluZ30gb2F1dGgudG9rZW4gVGhlIE9BdXRoIFRva2VuIHJldHJpZXZlZCBmcm9tIHRoZSBKaXJhIEFQSS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvYXV0aC50b2tlbl9zZWNyZXQgVGhlIE9BdXRoIFRva2VuIFNlY3JldCByZXRyaWV2ZWQgZnJvbSB0aGUgSmlyYSBBUEkuXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayB1c2VkIGJ5IHN3YXBSZXF1ZXN0VG9rZW5XaXRoQWNjZXNzVG9rZW5cbiAqIEBjYWxsYmFjayBPYXV0aFV0aWx+c3dhcFJlcXVlc3RUb2tlbkNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGVycm9yIFRoZSBlcnJvciB3aGljaCBvY2N1cnJlZCwgaWYgYW55LlxuICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc190b2tlbiBUaGUgYWNjZXNzIHRva2VuIHJldHJpZXZlZCBmcm9tIEppcmEuXG4gKi9cbiIsIihmdW5jdGlvbigpe1xuXG4gICAgLy8gQ29weXJpZ2h0IChjKSAyMDA1ICBUb20gV3VcbiAgICAvLyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgIC8vIFNlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscy5cblxuICAgIC8vIEJhc2ljIEphdmFTY3JpcHQgQk4gbGlicmFyeSAtIHN1YnNldCB1c2VmdWwgZm9yIFJTQSBlbmNyeXB0aW9uLlxuXG4gICAgLy8gQml0cyBwZXIgZGlnaXRcbiAgICB2YXIgZGJpdHM7XG5cbiAgICAvLyBKYXZhU2NyaXB0IGVuZ2luZSBhbmFseXNpc1xuICAgIHZhciBjYW5hcnkgPSAweGRlYWRiZWVmY2FmZTtcbiAgICB2YXIgal9sbSA9ICgoY2FuYXJ5JjB4ZmZmZmZmKT09MHhlZmNhZmUpO1xuXG4gICAgLy8gKHB1YmxpYykgQ29uc3RydWN0b3JcbiAgICBmdW5jdGlvbiBCaWdJbnRlZ2VyKGEsYixjKSB7XG4gICAgICBpZihhICE9IG51bGwpXG4gICAgICAgIGlmKFwibnVtYmVyXCIgPT0gdHlwZW9mIGEpIHRoaXMuZnJvbU51bWJlcihhLGIsYyk7XG4gICAgICAgIGVsc2UgaWYoYiA9PSBudWxsICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIGEpIHRoaXMuZnJvbVN0cmluZyhhLDI1Nik7XG4gICAgICAgIGVsc2UgdGhpcy5mcm9tU3RyaW5nKGEsYik7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIG5ldywgdW5zZXQgQmlnSW50ZWdlclxuICAgIGZ1bmN0aW9uIG5iaSgpIHsgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG51bGwpOyB9XG5cbiAgICAvLyBhbTogQ29tcHV0ZSB3X2ogKz0gKHgqdGhpc19pKSwgcHJvcGFnYXRlIGNhcnJpZXMsXG4gICAgLy8gYyBpcyBpbml0aWFsIGNhcnJ5LCByZXR1cm5zIGZpbmFsIGNhcnJ5LlxuICAgIC8vIGMgPCAzKmR2YWx1ZSwgeCA8IDIqZHZhbHVlLCB0aGlzX2kgPCBkdmFsdWVcbiAgICAvLyBXZSBuZWVkIHRvIHNlbGVjdCB0aGUgZmFzdGVzdCBvbmUgdGhhdCB3b3JrcyBpbiB0aGlzIGVudmlyb25tZW50LlxuXG4gICAgLy8gYW0xOiB1c2UgYSBzaW5nbGUgbXVsdCBhbmQgZGl2aWRlIHRvIGdldCB0aGUgaGlnaCBiaXRzLFxuICAgIC8vIG1heCBkaWdpdCBiaXRzIHNob3VsZCBiZSAyNiBiZWNhdXNlXG4gICAgLy8gbWF4IGludGVybmFsIHZhbHVlID0gMipkdmFsdWVeMi0yKmR2YWx1ZSAoPCAyXjUzKVxuICAgIGZ1bmN0aW9uIGFtMShpLHgsdyxqLGMsbikge1xuICAgICAgd2hpbGUoLS1uID49IDApIHtcbiAgICAgICAgdmFyIHYgPSB4KnRoaXNbaSsrXSt3W2pdK2M7XG4gICAgICAgIGMgPSBNYXRoLmZsb29yKHYvMHg0MDAwMDAwKTtcbiAgICAgICAgd1tqKytdID0gdiYweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgLy8gYW0yIGF2b2lkcyBhIGJpZyBtdWx0LWFuZC1leHRyYWN0IGNvbXBsZXRlbHkuXG4gICAgLy8gTWF4IGRpZ2l0IGJpdHMgc2hvdWxkIGJlIDw9IDMwIGJlY2F1c2Ugd2UgZG8gYml0d2lzZSBvcHNcbiAgICAvLyBvbiB2YWx1ZXMgdXAgdG8gMipoZHZhbHVlXjItaGR2YWx1ZS0xICg8IDJeMzEpXG4gICAgZnVuY3Rpb24gYW0yKGkseCx3LGosYyxuKSB7XG4gICAgICB2YXIgeGwgPSB4JjB4N2ZmZiwgeGggPSB4Pj4xNTtcbiAgICAgIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgICAgIHZhciBsID0gdGhpc1tpXSYweDdmZmY7XG4gICAgICAgIHZhciBoID0gdGhpc1tpKytdPj4xNTtcbiAgICAgICAgdmFyIG0gPSB4aCpsK2gqeGw7XG4gICAgICAgIGwgPSB4bCpsKygobSYweDdmZmYpPDwxNSkrd1tqXSsoYyYweDNmZmZmZmZmKTtcbiAgICAgICAgYyA9IChsPj4+MzApKyhtPj4+MTUpK3hoKmgrKGM+Pj4zMCk7XG4gICAgICAgIHdbaisrXSA9IGwmMHgzZmZmZmZmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICAvLyBBbHRlcm5hdGVseSwgc2V0IG1heCBkaWdpdCBiaXRzIHRvIDI4IHNpbmNlIHNvbWVcbiAgICAvLyBicm93c2VycyBzbG93IGRvd24gd2hlbiBkZWFsaW5nIHdpdGggMzItYml0IG51bWJlcnMuXG4gICAgZnVuY3Rpb24gYW0zKGkseCx3LGosYyxuKSB7XG4gICAgICB2YXIgeGwgPSB4JjB4M2ZmZiwgeGggPSB4Pj4xNDtcbiAgICAgIHdoaWxlKC0tbiA+PSAwKSB7XG4gICAgICAgIHZhciBsID0gdGhpc1tpXSYweDNmZmY7XG4gICAgICAgIHZhciBoID0gdGhpc1tpKytdPj4xNDtcbiAgICAgICAgdmFyIG0gPSB4aCpsK2gqeGw7XG4gICAgICAgIGwgPSB4bCpsKygobSYweDNmZmYpPDwxNCkrd1tqXStjO1xuICAgICAgICBjID0gKGw+PjI4KSsobT4+MTQpK3hoKmg7XG4gICAgICAgIHdbaisrXSA9IGwmMHhmZmZmZmZmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHZhciBpbkJyb3dzZXIgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIGlmKGluQnJvd3NlciAmJiBqX2xtICYmIChuYXZpZ2F0b3IuYXBwTmFtZSA9PSBcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclwiKSkge1xuICAgICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW0gPSBhbTI7XG4gICAgICBkYml0cyA9IDMwO1xuICAgIH1cbiAgICBlbHNlIGlmKGluQnJvd3NlciAmJiBqX2xtICYmIChuYXZpZ2F0b3IuYXBwTmFtZSAhPSBcIk5ldHNjYXBlXCIpKSB7XG4gICAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5hbSA9IGFtMTtcbiAgICAgIGRiaXRzID0gMjY7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBNb3ppbGxhL05ldHNjYXBlIHNlZW1zIHRvIHByZWZlciBhbTNcbiAgICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFtID0gYW0zO1xuICAgICAgZGJpdHMgPSAyODtcbiAgICB9XG5cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5EQiA9IGRiaXRzO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkRNID0gKCgxPDxkYml0cyktMSk7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuRFYgPSAoMTw8ZGJpdHMpO1xuXG4gICAgdmFyIEJJX0ZQID0gNTI7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuRlYgPSBNYXRoLnBvdygyLEJJX0ZQKTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5GMSA9IEJJX0ZQLWRiaXRzO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkYyID0gMipkYml0cy1CSV9GUDtcblxuICAgIC8vIERpZ2l0IGNvbnZlcnNpb25zXG4gICAgdmFyIEJJX1JNID0gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbiAgICB2YXIgQklfUkMgPSBuZXcgQXJyYXkoKTtcbiAgICB2YXIgcnIsdnY7XG4gICAgcnIgPSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuICAgIGZvcih2diA9IDA7IHZ2IDw9IDk7ICsrdnYpIEJJX1JDW3JyKytdID0gdnY7XG4gICAgcnIgPSBcImFcIi5jaGFyQ29kZUF0KDApO1xuICAgIGZvcih2diA9IDEwOyB2diA8IDM2OyArK3Z2KSBCSV9SQ1tycisrXSA9IHZ2O1xuICAgIHJyID0gXCJBXCIuY2hhckNvZGVBdCgwKTtcbiAgICBmb3IodnYgPSAxMDsgdnYgPCAzNjsgKyt2dikgQklfUkNbcnIrK10gPSB2djtcblxuICAgIGZ1bmN0aW9uIGludDJjaGFyKG4pIHsgcmV0dXJuIEJJX1JNLmNoYXJBdChuKTsgfVxuICAgIGZ1bmN0aW9uIGludEF0KHMsaSkge1xuICAgICAgdmFyIGMgPSBCSV9SQ1tzLmNoYXJDb2RlQXQoaSldO1xuICAgICAgcmV0dXJuIChjPT1udWxsKT8tMTpjO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIGNvcHkgdGhpcyB0byByXG4gICAgZnVuY3Rpb24gYm5wQ29weVRvKHIpIHtcbiAgICAgIGZvcih2YXIgaSA9IHRoaXMudC0xOyBpID49IDA7IC0taSkgcltpXSA9IHRoaXNbaV07XG4gICAgICByLnQgPSB0aGlzLnQ7XG4gICAgICByLnMgPSB0aGlzLnM7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgc2V0IGZyb20gaW50ZWdlciB2YWx1ZSB4LCAtRFYgPD0geCA8IERWXG4gICAgZnVuY3Rpb24gYm5wRnJvbUludCh4KSB7XG4gICAgICB0aGlzLnQgPSAxO1xuICAgICAgdGhpcy5zID0gKHg8MCk/LTE6MDtcbiAgICAgIGlmKHggPiAwKSB0aGlzWzBdID0geDtcbiAgICAgIGVsc2UgaWYoeCA8IC0xKSB0aGlzWzBdID0geCt0aGlzLkRWO1xuICAgICAgZWxzZSB0aGlzLnQgPSAwO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBiaWdpbnQgaW5pdGlhbGl6ZWQgdG8gdmFsdWVcbiAgICBmdW5jdGlvbiBuYnYoaSkgeyB2YXIgciA9IG5iaSgpOyByLmZyb21JbnQoaSk7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSBzZXQgZnJvbSBzdHJpbmcgYW5kIHJhZGl4XG4gICAgZnVuY3Rpb24gYm5wRnJvbVN0cmluZyhzLGIpIHtcbiAgICAgIHZhciBrO1xuICAgICAgaWYoYiA9PSAxNikgayA9IDQ7XG4gICAgICBlbHNlIGlmKGIgPT0gOCkgayA9IDM7XG4gICAgICBlbHNlIGlmKGIgPT0gMjU2KSBrID0gODsgLy8gYnl0ZSBhcnJheVxuICAgICAgZWxzZSBpZihiID09IDIpIGsgPSAxO1xuICAgICAgZWxzZSBpZihiID09IDMyKSBrID0gNTtcbiAgICAgIGVsc2UgaWYoYiA9PSA0KSBrID0gMjtcbiAgICAgIGVsc2UgeyB0aGlzLmZyb21SYWRpeChzLGIpOyByZXR1cm47IH1cbiAgICAgIHRoaXMudCA9IDA7XG4gICAgICB0aGlzLnMgPSAwO1xuICAgICAgdmFyIGkgPSBzLmxlbmd0aCwgbWkgPSBmYWxzZSwgc2ggPSAwO1xuICAgICAgd2hpbGUoLS1pID49IDApIHtcbiAgICAgICAgdmFyIHggPSAoaz09OCk/c1tpXSYweGZmOmludEF0KHMsaSk7XG4gICAgICAgIGlmKHggPCAwKSB7XG4gICAgICAgICAgaWYocy5jaGFyQXQoaSkgPT0gXCItXCIpIG1pID0gdHJ1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtaSA9IGZhbHNlO1xuICAgICAgICBpZihzaCA9PSAwKVxuICAgICAgICAgIHRoaXNbdGhpcy50KytdID0geDtcbiAgICAgICAgZWxzZSBpZihzaCtrID4gdGhpcy5EQikge1xuICAgICAgICAgIHRoaXNbdGhpcy50LTFdIHw9ICh4JigoMTw8KHRoaXMuREItc2gpKS0xKSk8PHNoO1xuICAgICAgICAgIHRoaXNbdGhpcy50KytdID0gKHg+Pih0aGlzLkRCLXNoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXNbdGhpcy50LTFdIHw9IHg8PHNoO1xuICAgICAgICBzaCArPSBrO1xuICAgICAgICBpZihzaCA+PSB0aGlzLkRCKSBzaCAtPSB0aGlzLkRCO1xuICAgICAgfVxuICAgICAgaWYoayA9PSA4ICYmIChzWzBdJjB4ODApICE9IDApIHtcbiAgICAgICAgdGhpcy5zID0gLTE7XG4gICAgICAgIGlmKHNoID4gMCkgdGhpc1t0aGlzLnQtMV0gfD0gKCgxPDwodGhpcy5EQi1zaCkpLTEpPDxzaDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xhbXAoKTtcbiAgICAgIGlmKG1pKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyx0aGlzKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSBjbGFtcCBvZmYgZXhjZXNzIGhpZ2ggd29yZHNcbiAgICBmdW5jdGlvbiBibnBDbGFtcCgpIHtcbiAgICAgIHZhciBjID0gdGhpcy5zJnRoaXMuRE07XG4gICAgICB3aGlsZSh0aGlzLnQgPiAwICYmIHRoaXNbdGhpcy50LTFdID09IGMpIC0tdGhpcy50O1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gaW4gZ2l2ZW4gcmFkaXhcbiAgICBmdW5jdGlvbiBiblRvU3RyaW5nKGIpIHtcbiAgICAgIGlmKHRoaXMucyA8IDApIHJldHVybiBcIi1cIit0aGlzLm5lZ2F0ZSgpLnRvU3RyaW5nKGIpO1xuICAgICAgdmFyIGs7XG4gICAgICBpZihiID09IDE2KSBrID0gNDtcbiAgICAgIGVsc2UgaWYoYiA9PSA4KSBrID0gMztcbiAgICAgIGVsc2UgaWYoYiA9PSAyKSBrID0gMTtcbiAgICAgIGVsc2UgaWYoYiA9PSAzMikgayA9IDU7XG4gICAgICBlbHNlIGlmKGIgPT0gNCkgayA9IDI7XG4gICAgICBlbHNlIHJldHVybiB0aGlzLnRvUmFkaXgoYik7XG4gICAgICB2YXIga20gPSAoMTw8ayktMSwgZCwgbSA9IGZhbHNlLCByID0gXCJcIiwgaSA9IHRoaXMudDtcbiAgICAgIHZhciBwID0gdGhpcy5EQi0oaSp0aGlzLkRCKSVrO1xuICAgICAgaWYoaS0tID4gMCkge1xuICAgICAgICBpZihwIDwgdGhpcy5EQiAmJiAoZCA9IHRoaXNbaV0+PnApID4gMCkgeyBtID0gdHJ1ZTsgciA9IGludDJjaGFyKGQpOyB9XG4gICAgICAgIHdoaWxlKGkgPj0gMCkge1xuICAgICAgICAgIGlmKHAgPCBrKSB7XG4gICAgICAgICAgICBkID0gKHRoaXNbaV0mKCgxPDxwKS0xKSk8PChrLXApO1xuICAgICAgICAgICAgZCB8PSB0aGlzWy0taV0+PihwKz10aGlzLkRCLWspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGQgPSAodGhpc1tpXT4+KHAtPWspKSZrbTtcbiAgICAgICAgICAgIGlmKHAgPD0gMCkgeyBwICs9IHRoaXMuREI7IC0taTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihkID4gMCkgbSA9IHRydWU7XG4gICAgICAgICAgaWYobSkgciArPSBpbnQyY2hhcihkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG0/cjpcIjBcIjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSAtdGhpc1xuICAgIGZ1bmN0aW9uIGJuTmVnYXRlKCkgeyB2YXIgciA9IG5iaSgpOyBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyxyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHx0aGlzfFxuICAgIGZ1bmN0aW9uIGJuQWJzKCkgeyByZXR1cm4gKHRoaXMuczwwKT90aGlzLm5lZ2F0ZSgpOnRoaXM7IH1cblxuICAgIC8vIChwdWJsaWMpIHJldHVybiArIGlmIHRoaXMgPiBhLCAtIGlmIHRoaXMgPCBhLCAwIGlmIGVxdWFsXG4gICAgZnVuY3Rpb24gYm5Db21wYXJlVG8oYSkge1xuICAgICAgdmFyIHIgPSB0aGlzLnMtYS5zO1xuICAgICAgaWYociAhPSAwKSByZXR1cm4gcjtcbiAgICAgIHZhciBpID0gdGhpcy50O1xuICAgICAgciA9IGktYS50O1xuICAgICAgaWYociAhPSAwKSByZXR1cm4gKHRoaXMuczwwKT8tcjpyO1xuICAgICAgd2hpbGUoLS1pID49IDApIGlmKChyPXRoaXNbaV0tYVtpXSkgIT0gMCkgcmV0dXJuIHI7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGJpdCBsZW5ndGggb2YgdGhlIGludGVnZXIgeFxuICAgIGZ1bmN0aW9uIG5iaXRzKHgpIHtcbiAgICAgIHZhciByID0gMSwgdDtcbiAgICAgIGlmKCh0PXg+Pj4xNikgIT0gMCkgeyB4ID0gdDsgciArPSAxNjsgfVxuICAgICAgaWYoKHQ9eD4+OCkgIT0gMCkgeyB4ID0gdDsgciArPSA4OyB9XG4gICAgICBpZigodD14Pj40KSAhPSAwKSB7IHggPSB0OyByICs9IDQ7IH1cbiAgICAgIGlmKCh0PXg+PjIpICE9IDApIHsgeCA9IHQ7IHIgKz0gMjsgfVxuICAgICAgaWYoKHQ9eD4+MSkgIT0gMCkgeyB4ID0gdDsgciArPSAxOyB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm4gdGhlIG51bWJlciBvZiBiaXRzIGluIFwidGhpc1wiXG4gICAgZnVuY3Rpb24gYm5CaXRMZW5ndGgoKSB7XG4gICAgICBpZih0aGlzLnQgPD0gMCkgcmV0dXJuIDA7XG4gICAgICByZXR1cm4gdGhpcy5EQioodGhpcy50LTEpK25iaXRzKHRoaXNbdGhpcy50LTFdXih0aGlzLnMmdGhpcy5ETSkpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzIDw8IG4qREJcbiAgICBmdW5jdGlvbiBibnBETFNoaWZ0VG8obixyKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvcihpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByW2krbl0gPSB0aGlzW2ldO1xuICAgICAgZm9yKGkgPSBuLTE7IGkgPj0gMDsgLS1pKSByW2ldID0gMDtcbiAgICAgIHIudCA9IHRoaXMudCtuO1xuICAgICAgci5zID0gdGhpcy5zO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzID4+IG4qREJcbiAgICBmdW5jdGlvbiBibnBEUlNoaWZ0VG8obixyKSB7XG4gICAgICBmb3IodmFyIGkgPSBuOyBpIDwgdGhpcy50OyArK2kpIHJbaS1uXSA9IHRoaXNbaV07XG4gICAgICByLnQgPSBNYXRoLm1heCh0aGlzLnQtbiwwKTtcbiAgICAgIHIucyA9IHRoaXMucztcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyA8PCBuXG4gICAgZnVuY3Rpb24gYm5wTFNoaWZ0VG8obixyKSB7XG4gICAgICB2YXIgYnMgPSBuJXRoaXMuREI7XG4gICAgICB2YXIgY2JzID0gdGhpcy5EQi1icztcbiAgICAgIHZhciBibSA9ICgxPDxjYnMpLTE7XG4gICAgICB2YXIgZHMgPSBNYXRoLmZsb29yKG4vdGhpcy5EQiksIGMgPSAodGhpcy5zPDxicykmdGhpcy5ETSwgaTtcbiAgICAgIGZvcihpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHJbaStkcysxXSA9ICh0aGlzW2ldPj5jYnMpfGM7XG4gICAgICAgIGMgPSAodGhpc1tpXSZibSk8PGJzO1xuICAgICAgfVxuICAgICAgZm9yKGkgPSBkcy0xOyBpID49IDA7IC0taSkgcltpXSA9IDA7XG4gICAgICByW2RzXSA9IGM7XG4gICAgICByLnQgPSB0aGlzLnQrZHMrMTtcbiAgICAgIHIucyA9IHRoaXMucztcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gdGhpcyA+PiBuXG4gICAgZnVuY3Rpb24gYm5wUlNoaWZ0VG8obixyKSB7XG4gICAgICByLnMgPSB0aGlzLnM7XG4gICAgICB2YXIgZHMgPSBNYXRoLmZsb29yKG4vdGhpcy5EQik7XG4gICAgICBpZihkcyA+PSB0aGlzLnQpIHsgci50ID0gMDsgcmV0dXJuOyB9XG4gICAgICB2YXIgYnMgPSBuJXRoaXMuREI7XG4gICAgICB2YXIgY2JzID0gdGhpcy5EQi1icztcbiAgICAgIHZhciBibSA9ICgxPDxicyktMTtcbiAgICAgIHJbMF0gPSB0aGlzW2RzXT4+YnM7XG4gICAgICBmb3IodmFyIGkgPSBkcysxOyBpIDwgdGhpcy50OyArK2kpIHtcbiAgICAgICAgcltpLWRzLTFdIHw9ICh0aGlzW2ldJmJtKTw8Y2JzO1xuICAgICAgICByW2ktZHNdID0gdGhpc1tpXT4+YnM7XG4gICAgICB9XG4gICAgICBpZihicyA+IDApIHJbdGhpcy50LWRzLTFdIHw9ICh0aGlzLnMmYm0pPDxjYnM7XG4gICAgICByLnQgPSB0aGlzLnQtZHM7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgLSBhXG4gICAgZnVuY3Rpb24gYm5wU3ViVG8oYSxyKSB7XG4gICAgICB2YXIgaSA9IDAsIGMgPSAwLCBtID0gTWF0aC5taW4oYS50LHRoaXMudCk7XG4gICAgICB3aGlsZShpIDwgbSkge1xuICAgICAgICBjICs9IHRoaXNbaV0tYVtpXTtcbiAgICAgICAgcltpKytdID0gYyZ0aGlzLkRNO1xuICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgfVxuICAgICAgaWYoYS50IDwgdGhpcy50KSB7XG4gICAgICAgIGMgLT0gYS5zO1xuICAgICAgICB3aGlsZShpIDwgdGhpcy50KSB7XG4gICAgICAgICAgYyArPSB0aGlzW2ldO1xuICAgICAgICAgIHJbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGMgKz0gdGhpcy5zO1xuICAgICAgICB3aGlsZShpIDwgYS50KSB7XG4gICAgICAgICAgYyAtPSBhW2ldO1xuICAgICAgICAgIHJbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgICAgICBjID4+PSB0aGlzLkRCO1xuICAgICAgICB9XG4gICAgICAgIGMgLT0gYS5zO1xuICAgICAgfVxuICAgICAgci5zID0gKGM8MCk/LTE6MDtcbiAgICAgIGlmKGMgPCAtMSkgcltpKytdID0gdGhpcy5EVitjO1xuICAgICAgZWxzZSBpZihjID4gMCkgcltpKytdID0gYztcbiAgICAgIHIudCA9IGk7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgKiBhLCByICE9IHRoaXMsYSAoSEFDIDE0LjEyKVxuICAgIC8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbiAgICBmdW5jdGlvbiBibnBNdWx0aXBseVRvKGEscikge1xuICAgICAgdmFyIHggPSB0aGlzLmFicygpLCB5ID0gYS5hYnMoKTtcbiAgICAgIHZhciBpID0geC50O1xuICAgICAgci50ID0gaSt5LnQ7XG4gICAgICB3aGlsZSgtLWkgPj0gMCkgcltpXSA9IDA7XG4gICAgICBmb3IoaSA9IDA7IGkgPCB5LnQ7ICsraSkgcltpK3gudF0gPSB4LmFtKDAseVtpXSxyLGksMCx4LnQpO1xuICAgICAgci5zID0gMDtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICAgIGlmKHRoaXMucyAhPSBhLnMpIEJpZ0ludGVnZXIuWkVSTy5zdWJUbyhyLHIpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzXjIsIHIgIT0gdGhpcyAoSEFDIDE0LjE2KVxuICAgIGZ1bmN0aW9uIGJucFNxdWFyZVRvKHIpIHtcbiAgICAgIHZhciB4ID0gdGhpcy5hYnMoKTtcbiAgICAgIHZhciBpID0gci50ID0gMip4LnQ7XG4gICAgICB3aGlsZSgtLWkgPj0gMCkgcltpXSA9IDA7XG4gICAgICBmb3IoaSA9IDA7IGkgPCB4LnQtMTsgKytpKSB7XG4gICAgICAgIHZhciBjID0geC5hbShpLHhbaV0sciwyKmksMCwxKTtcbiAgICAgICAgaWYoKHJbaSt4LnRdKz14LmFtKGkrMSwyKnhbaV0sciwyKmkrMSxjLHgudC1pLTEpKSA+PSB4LkRWKSB7XG4gICAgICAgICAgcltpK3gudF0gLT0geC5EVjtcbiAgICAgICAgICByW2kreC50KzFdID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoci50ID4gMCkgcltyLnQtMV0gKz0geC5hbShpLHhbaV0sciwyKmksMCwxKTtcbiAgICAgIHIucyA9IDA7XG4gICAgICByLmNsYW1wKCk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgZGl2aWRlIHRoaXMgYnkgbSwgcXVvdGllbnQgYW5kIHJlbWFpbmRlciB0byBxLCByIChIQUMgMTQuMjApXG4gICAgLy8gciAhPSBxLCB0aGlzICE9IG0uICBxIG9yIHIgbWF5IGJlIG51bGwuXG4gICAgZnVuY3Rpb24gYm5wRGl2UmVtVG8obSxxLHIpIHtcbiAgICAgIHZhciBwbSA9IG0uYWJzKCk7XG4gICAgICBpZihwbS50IDw9IDApIHJldHVybjtcbiAgICAgIHZhciBwdCA9IHRoaXMuYWJzKCk7XG4gICAgICBpZihwdC50IDwgcG0udCkge1xuICAgICAgICBpZihxICE9IG51bGwpIHEuZnJvbUludCgwKTtcbiAgICAgICAgaWYociAhPSBudWxsKSB0aGlzLmNvcHlUbyhyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYociA9PSBudWxsKSByID0gbmJpKCk7XG4gICAgICB2YXIgeSA9IG5iaSgpLCB0cyA9IHRoaXMucywgbXMgPSBtLnM7XG4gICAgICB2YXIgbnNoID0gdGhpcy5EQi1uYml0cyhwbVtwbS50LTFdKTsgICAvLyBub3JtYWxpemUgbW9kdWx1c1xuICAgICAgaWYobnNoID4gMCkgeyBwbS5sU2hpZnRUbyhuc2gseSk7IHB0LmxTaGlmdFRvKG5zaCxyKTsgfVxuICAgICAgZWxzZSB7IHBtLmNvcHlUbyh5KTsgcHQuY29weVRvKHIpOyB9XG4gICAgICB2YXIgeXMgPSB5LnQ7XG4gICAgICB2YXIgeTAgPSB5W3lzLTFdO1xuICAgICAgaWYoeTAgPT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHl0ID0geTAqKDE8PHRoaXMuRjEpKygoeXM+MSk/eVt5cy0yXT4+dGhpcy5GMjowKTtcbiAgICAgIHZhciBkMSA9IHRoaXMuRlYveXQsIGQyID0gKDE8PHRoaXMuRjEpL3l0LCBlID0gMTw8dGhpcy5GMjtcbiAgICAgIHZhciBpID0gci50LCBqID0gaS15cywgdCA9IChxPT1udWxsKT9uYmkoKTpxO1xuICAgICAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgICAgIGlmKHIuY29tcGFyZVRvKHQpID49IDApIHtcbiAgICAgICAgcltyLnQrK10gPSAxO1xuICAgICAgICByLnN1YlRvKHQscik7XG4gICAgICB9XG4gICAgICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oeXMsdCk7XG4gICAgICB0LnN1YlRvKHkseSk7ICAvLyBcIm5lZ2F0aXZlXCIgeSBzbyB3ZSBjYW4gcmVwbGFjZSBzdWIgd2l0aCBhbSBsYXRlclxuICAgICAgd2hpbGUoeS50IDwgeXMpIHlbeS50KytdID0gMDtcbiAgICAgIHdoaWxlKC0taiA+PSAwKSB7XG4gICAgICAgIC8vIEVzdGltYXRlIHF1b3RpZW50IGRpZ2l0XG4gICAgICAgIHZhciBxZCA9IChyWy0taV09PXkwKT90aGlzLkRNOk1hdGguZmxvb3IocltpXSpkMSsocltpLTFdK2UpKmQyKTtcbiAgICAgICAgaWYoKHJbaV0rPXkuYW0oMCxxZCxyLGosMCx5cykpIDwgcWQpIHsgICAvLyBUcnkgaXQgb3V0XG4gICAgICAgICAgeS5kbFNoaWZ0VG8oaix0KTtcbiAgICAgICAgICByLnN1YlRvKHQscik7XG4gICAgICAgICAgd2hpbGUocltpXSA8IC0tcWQpIHIuc3ViVG8odCxyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYocSAhPSBudWxsKSB7XG4gICAgICAgIHIuZHJTaGlmdFRvKHlzLHEpO1xuICAgICAgICBpZih0cyAhPSBtcykgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHEscSk7XG4gICAgICB9XG4gICAgICByLnQgPSB5cztcbiAgICAgIHIuY2xhbXAoKTtcbiAgICAgIGlmKG5zaCA+IDApIHIuclNoaWZ0VG8obnNoLHIpOyAvLyBEZW5vcm1hbGl6ZSByZW1haW5kZXJcbiAgICAgIGlmKHRzIDwgMCkgQmlnSW50ZWdlci5aRVJPLnN1YlRvKHIscik7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyBtb2QgYVxuICAgIGZ1bmN0aW9uIGJuTW9kKGEpIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICB0aGlzLmFicygpLmRpdlJlbVRvKGEsbnVsbCxyKTtcbiAgICAgIGlmKHRoaXMucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIGEuc3ViVG8ocixyKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIE1vZHVsYXIgcmVkdWN0aW9uIHVzaW5nIFwiY2xhc3NpY1wiIGFsZ29yaXRobVxuICAgIGZ1bmN0aW9uIENsYXNzaWMobSkgeyB0aGlzLm0gPSBtOyB9XG4gICAgZnVuY3Rpb24gY0NvbnZlcnQoeCkge1xuICAgICAgaWYoeC5zIDwgMCB8fCB4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHJldHVybiB4Lm1vZCh0aGlzLm0pO1xuICAgICAgZWxzZSByZXR1cm4geDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY1JldmVydCh4KSB7IHJldHVybiB4OyB9XG4gICAgZnVuY3Rpb24gY1JlZHVjZSh4KSB7IHguZGl2UmVtVG8odGhpcy5tLG51bGwseCk7IH1cbiAgICBmdW5jdGlvbiBjTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG4gICAgZnVuY3Rpb24gY1NxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4gICAgQ2xhc3NpYy5wcm90b3R5cGUuY29udmVydCA9IGNDb252ZXJ0O1xuICAgIENsYXNzaWMucHJvdG90eXBlLnJldmVydCA9IGNSZXZlcnQ7XG4gICAgQ2xhc3NpYy5wcm90b3R5cGUucmVkdWNlID0gY1JlZHVjZTtcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5tdWxUbyA9IGNNdWxUbztcbiAgICBDbGFzc2ljLnByb3RvdHlwZS5zcXJUbyA9IGNTcXJUbztcblxuICAgIC8vIChwcm90ZWN0ZWQpIHJldHVybiBcIi0xL3RoaXMgJSAyXkRCXCI7IHVzZWZ1bCBmb3IgTW9udC4gcmVkdWN0aW9uXG4gICAgLy8ganVzdGlmaWNhdGlvbjpcbiAgICAvLyAgICAgICAgIHh5ID09IDEgKG1vZCBtKVxuICAgIC8vICAgICAgICAgeHkgPSAgMStrbVxuICAgIC8vICAgeHkoMi14eSkgPSAoMStrbSkoMS1rbSlcbiAgICAvLyB4W3koMi14eSldID0gMS1rXjJtXjJcbiAgICAvLyB4W3koMi14eSldID09IDEgKG1vZCBtXjIpXG4gICAgLy8gaWYgeSBpcyAxL3ggbW9kIG0sIHRoZW4geSgyLXh5KSBpcyAxL3ggbW9kIG1eMlxuICAgIC8vIHNob3VsZCByZWR1Y2UgeCBhbmQgeSgyLXh5KSBieSBtXjIgYXQgZWFjaCBzdGVwIHRvIGtlZXAgc2l6ZSBib3VuZGVkLlxuICAgIC8vIEpTIG11bHRpcGx5IFwib3ZlcmZsb3dzXCIgZGlmZmVyZW50bHkgZnJvbSBDL0MrKywgc28gY2FyZSBpcyBuZWVkZWQgaGVyZS5cbiAgICBmdW5jdGlvbiBibnBJbnZEaWdpdCgpIHtcbiAgICAgIGlmKHRoaXMudCA8IDEpIHJldHVybiAwO1xuICAgICAgdmFyIHggPSB0aGlzWzBdO1xuICAgICAgaWYoKHgmMSkgPT0gMCkgcmV0dXJuIDA7XG4gICAgICB2YXIgeSA9IHgmMzsgICAgICAgLy8geSA9PSAxL3ggbW9kIDJeMlxuICAgICAgeSA9ICh5KigyLSh4JjB4ZikqeSkpJjB4ZjsgLy8geSA9PSAxL3ggbW9kIDJeNFxuICAgICAgeSA9ICh5KigyLSh4JjB4ZmYpKnkpKSYweGZmOyAgIC8vIHkgPT0gMS94IG1vZCAyXjhcbiAgICAgIHkgPSAoeSooMi0oKCh4JjB4ZmZmZikqeSkmMHhmZmZmKSkpJjB4ZmZmZjsgICAgLy8geSA9PSAxL3ggbW9kIDJeMTZcbiAgICAgIC8vIGxhc3Qgc3RlcCAtIGNhbGN1bGF0ZSBpbnZlcnNlIG1vZCBEViBkaXJlY3RseTtcbiAgICAgIC8vIGFzc3VtZXMgMTYgPCBEQiA8PSAzMiBhbmQgYXNzdW1lcyBhYmlsaXR5IHRvIGhhbmRsZSA0OC1iaXQgaW50c1xuICAgICAgeSA9ICh5KigyLXgqeSV0aGlzLkRWKSkldGhpcy5EVjsgICAgICAgLy8geSA9PSAxL3ggbW9kIDJeZGJpdHNcbiAgICAgIC8vIHdlIHJlYWxseSB3YW50IHRoZSBuZWdhdGl2ZSBpbnZlcnNlLCBhbmQgLURWIDwgeSA8IERWXG4gICAgICByZXR1cm4gKHk+MCk/dGhpcy5EVi15Oi15O1xuICAgIH1cblxuICAgIC8vIE1vbnRnb21lcnkgcmVkdWN0aW9uXG4gICAgZnVuY3Rpb24gTW9udGdvbWVyeShtKSB7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5tcCA9IG0uaW52RGlnaXQoKTtcbiAgICAgIHRoaXMubXBsID0gdGhpcy5tcCYweDdmZmY7XG4gICAgICB0aGlzLm1waCA9IHRoaXMubXA+PjE1O1xuICAgICAgdGhpcy51bSA9ICgxPDwobS5EQi0xNSkpLTE7XG4gICAgICB0aGlzLm10MiA9IDIqbS50O1xuICAgIH1cblxuICAgIC8vIHhSIG1vZCBtXG4gICAgZnVuY3Rpb24gbW9udENvbnZlcnQoeCkge1xuICAgICAgdmFyIHIgPSBuYmkoKTtcbiAgICAgIHguYWJzKCkuZGxTaGlmdFRvKHRoaXMubS50LHIpO1xuICAgICAgci5kaXZSZW1Ubyh0aGlzLm0sbnVsbCxyKTtcbiAgICAgIGlmKHgucyA8IDAgJiYgci5jb21wYXJlVG8oQmlnSW50ZWdlci5aRVJPKSA+IDApIHRoaXMubS5zdWJUbyhyLHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8geC9SIG1vZCBtXG4gICAgZnVuY3Rpb24gbW9udFJldmVydCh4KSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgeC5jb3B5VG8ocik7XG4gICAgICB0aGlzLnJlZHVjZShyKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIHggPSB4L1IgbW9kIG0gKEhBQyAxNC4zMilcbiAgICBmdW5jdGlvbiBtb250UmVkdWNlKHgpIHtcbiAgICAgIHdoaWxlKHgudCA8PSB0aGlzLm10MikgLy8gcGFkIHggc28gYW0gaGFzIGVub3VnaCByb29tIGxhdGVyXG4gICAgICAgIHhbeC50KytdID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLm0udDsgKytpKSB7XG4gICAgICAgIC8vIGZhc3RlciB3YXkgb2YgY2FsY3VsYXRpbmcgdTAgPSB4W2ldKm1wIG1vZCBEVlxuICAgICAgICB2YXIgaiA9IHhbaV0mMHg3ZmZmO1xuICAgICAgICB2YXIgdTAgPSAoaip0aGlzLm1wbCsoKChqKnRoaXMubXBoKyh4W2ldPj4xNSkqdGhpcy5tcGwpJnRoaXMudW0pPDwxNSkpJnguRE07XG4gICAgICAgIC8vIHVzZSBhbSB0byBjb21iaW5lIHRoZSBtdWx0aXBseS1zaGlmdC1hZGQgaW50byBvbmUgY2FsbFxuICAgICAgICBqID0gaSt0aGlzLm0udDtcbiAgICAgICAgeFtqXSArPSB0aGlzLm0uYW0oMCx1MCx4LGksMCx0aGlzLm0udCk7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBjYXJyeVxuICAgICAgICB3aGlsZSh4W2pdID49IHguRFYpIHsgeFtqXSAtPSB4LkRWOyB4Wysral0rKzsgfVxuICAgICAgfVxuICAgICAgeC5jbGFtcCgpO1xuICAgICAgeC5kclNoaWZ0VG8odGhpcy5tLnQseCk7XG4gICAgICBpZih4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xuICAgIH1cblxuICAgIC8vIHIgPSBcInheMi9SIG1vZCBtXCI7IHggIT0gclxuICAgIGZ1bmN0aW9uIG1vbnRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuICAgIC8vIHIgPSBcInh5L1IgbW9kIG1cIjsgeCx5ICE9IHJcbiAgICBmdW5jdGlvbiBtb250TXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5jb252ZXJ0ID0gbW9udENvbnZlcnQ7XG4gICAgTW9udGdvbWVyeS5wcm90b3R5cGUucmV2ZXJ0ID0gbW9udFJldmVydDtcbiAgICBNb250Z29tZXJ5LnByb3RvdHlwZS5yZWR1Y2UgPSBtb250UmVkdWNlO1xuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLm11bFRvID0gbW9udE11bFRvO1xuICAgIE1vbnRnb21lcnkucHJvdG90eXBlLnNxclRvID0gbW9udFNxclRvO1xuXG4gICAgLy8gKHByb3RlY3RlZCkgdHJ1ZSBpZmYgdGhpcyBpcyBldmVuXG4gICAgZnVuY3Rpb24gYm5wSXNFdmVuKCkgeyByZXR1cm4gKCh0aGlzLnQ+MCk/KHRoaXNbMF0mMSk6dGhpcy5zKSA9PSAwOyB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0aGlzXmUsIGUgPCAyXjMyLCBkb2luZyBzcXIgYW5kIG11bCB3aXRoIFwiclwiIChIQUMgMTQuNzkpXG4gICAgZnVuY3Rpb24gYm5wRXhwKGUseikge1xuICAgICAgaWYoZSA+IDB4ZmZmZmZmZmYgfHwgZSA8IDEpIHJldHVybiBCaWdJbnRlZ2VyLk9ORTtcbiAgICAgIHZhciByID0gbmJpKCksIHIyID0gbmJpKCksIGcgPSB6LmNvbnZlcnQodGhpcyksIGkgPSBuYml0cyhlKS0xO1xuICAgICAgZy5jb3B5VG8ocik7XG4gICAgICB3aGlsZSgtLWkgPj0gMCkge1xuICAgICAgICB6LnNxclRvKHIscjIpO1xuICAgICAgICBpZigoZSYoMTw8aSkpID4gMCkgei5tdWxUbyhyMixnLHIpO1xuICAgICAgICBlbHNlIHsgdmFyIHQgPSByOyByID0gcjI7IHIyID0gdDsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXNeZSAlIG0sIDAgPD0gZSA8IDJeMzJcbiAgICBmdW5jdGlvbiBibk1vZFBvd0ludChlLG0pIHtcbiAgICAgIHZhciB6O1xuICAgICAgaWYoZSA8IDI1NiB8fCBtLmlzRXZlbigpKSB6ID0gbmV3IENsYXNzaWMobSk7IGVsc2UgeiA9IG5ldyBNb250Z29tZXJ5KG0pO1xuICAgICAgcmV0dXJuIHRoaXMuZXhwKGUseik7XG4gICAgfVxuXG4gICAgLy8gcHJvdGVjdGVkXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY29weVRvID0gYm5wQ29weVRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21JbnQgPSBibnBGcm9tSW50O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21TdHJpbmcgPSBibnBGcm9tU3RyaW5nO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsYW1wID0gYm5wQ2xhbXA7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGxTaGlmdFRvID0gYm5wRExTaGlmdFRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRyU2hpZnRUbyA9IGJucERSU2hpZnRUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sU2hpZnRUbyA9IGJucExTaGlmdFRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnJTaGlmdFRvID0gYm5wUlNoaWZ0VG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3ViVG8gPSBibnBTdWJUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseVRvID0gYm5wTXVsdGlwbHlUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmVUbyA9IGJucFNxdWFyZVRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdlJlbVRvID0gYm5wRGl2UmVtVG87XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaW52RGlnaXQgPSBibnBJbnZEaWdpdDtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW4gPSBibnBJc0V2ZW47XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZXhwID0gYm5wRXhwO1xuXG4gICAgLy8gcHVibGljXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmcgPSBiblRvU3RyaW5nO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5lZ2F0ZSA9IGJuTmVnYXRlO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGJuQWJzO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IGJuQ29tcGFyZVRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aCA9IGJuQml0TGVuZ3RoO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZCA9IGJuTW9kO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvd0ludCA9IGJuTW9kUG93SW50O1xuXG4gICAgLy8gXCJjb25zdGFudHNcIlxuICAgIEJpZ0ludGVnZXIuWkVSTyA9IG5idigwKTtcbiAgICBCaWdJbnRlZ2VyLk9ORSA9IG5idigxKTtcblxuICAgIC8vIENvcHlyaWdodCAoYykgMjAwNS0yMDA5ICBUb20gV3VcbiAgICAvLyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgIC8vIFNlZSBcIkxJQ0VOU0VcIiBmb3IgZGV0YWlscy5cblxuICAgIC8vIEV4dGVuZGVkIEphdmFTY3JpcHQgQk4gZnVuY3Rpb25zLCByZXF1aXJlZCBmb3IgUlNBIHByaXZhdGUgb3BzLlxuXG4gICAgLy8gVmVyc2lvbiAxLjE6IG5ldyBCaWdJbnRlZ2VyKFwiMFwiLCAxMCkgcmV0dXJucyBcInByb3BlclwiIHplcm9cbiAgICAvLyBWZXJzaW9uIDEuMjogc3F1YXJlKCkgQVBJLCBpc1Byb2JhYmxlUHJpbWUgZml4XG5cbiAgICAvLyAocHVibGljKVxuICAgIGZ1bmN0aW9uIGJuQ2xvbmUoKSB7IHZhciByID0gbmJpKCk7IHRoaXMuY29weVRvKHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGludGVnZXJcbiAgICBmdW5jdGlvbiBibkludFZhbHVlKCkge1xuICAgICAgaWYodGhpcy5zIDwgMCkge1xuICAgICAgICBpZih0aGlzLnQgPT0gMSkgcmV0dXJuIHRoaXNbMF0tdGhpcy5EVjtcbiAgICAgICAgZWxzZSBpZih0aGlzLnQgPT0gMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZih0aGlzLnQgPT0gMSkgcmV0dXJuIHRoaXNbMF07XG4gICAgICBlbHNlIGlmKHRoaXMudCA9PSAwKSByZXR1cm4gMDtcbiAgICAgIC8vIGFzc3VtZXMgMTYgPCBEQiA8IDMyXG4gICAgICByZXR1cm4gKCh0aGlzWzFdJigoMTw8KDMyLXRoaXMuREIpKS0xKSk8PHRoaXMuREIpfHRoaXNbMF07XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIGJ5dGVcbiAgICBmdW5jdGlvbiBibkJ5dGVWYWx1ZSgpIHsgcmV0dXJuICh0aGlzLnQ9PTApP3RoaXMuczoodGhpc1swXTw8MjQpPj4yNDsgfVxuXG4gICAgLy8gKHB1YmxpYykgcmV0dXJuIHZhbHVlIGFzIHNob3J0IChhc3N1bWVzIERCPj0xNilcbiAgICBmdW5jdGlvbiBiblNob3J0VmFsdWUoKSB7IHJldHVybiAodGhpcy50PT0wKT90aGlzLnM6KHRoaXNbMF08PDE2KT4+MTY7IH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHJldHVybiB4IHMudC4gcl54IDwgRFZcbiAgICBmdW5jdGlvbiBibnBDaHVua1NpemUocikgeyByZXR1cm4gTWF0aC5mbG9vcihNYXRoLkxOMip0aGlzLkRCL01hdGgubG9nKHIpKTsgfVxuXG4gICAgLy8gKHB1YmxpYykgMCBpZiB0aGlzID09IDAsIDEgaWYgdGhpcyA+IDBcbiAgICBmdW5jdGlvbiBiblNpZ051bSgpIHtcbiAgICAgIGlmKHRoaXMucyA8IDApIHJldHVybiAtMTtcbiAgICAgIGVsc2UgaWYodGhpcy50IDw9IDAgfHwgKHRoaXMudCA9PSAxICYmIHRoaXNbMF0gPD0gMCkpIHJldHVybiAwO1xuICAgICAgZWxzZSByZXR1cm4gMTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSBjb252ZXJ0IHRvIHJhZGl4IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGJucFRvUmFkaXgoYikge1xuICAgICAgaWYoYiA9PSBudWxsKSBiID0gMTA7XG4gICAgICBpZih0aGlzLnNpZ251bSgpID09IDAgfHwgYiA8IDIgfHwgYiA+IDM2KSByZXR1cm4gXCIwXCI7XG4gICAgICB2YXIgY3MgPSB0aGlzLmNodW5rU2l6ZShiKTtcbiAgICAgIHZhciBhID0gTWF0aC5wb3coYixjcyk7XG4gICAgICB2YXIgZCA9IG5idihhKSwgeSA9IG5iaSgpLCB6ID0gbmJpKCksIHIgPSBcIlwiO1xuICAgICAgdGhpcy5kaXZSZW1UbyhkLHkseik7XG4gICAgICB3aGlsZSh5LnNpZ251bSgpID4gMCkge1xuICAgICAgICByID0gKGErei5pbnRWYWx1ZSgpKS50b1N0cmluZyhiKS5zdWJzdHIoMSkgKyByO1xuICAgICAgICB5LmRpdlJlbVRvKGQseSx6KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB6LmludFZhbHVlKCkudG9TdHJpbmcoYikgKyByO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIGNvbnZlcnQgZnJvbSByYWRpeCBzdHJpbmdcbiAgICBmdW5jdGlvbiBibnBGcm9tUmFkaXgocyxiKSB7XG4gICAgICB0aGlzLmZyb21JbnQoMCk7XG4gICAgICBpZihiID09IG51bGwpIGIgPSAxMDtcbiAgICAgIHZhciBjcyA9IHRoaXMuY2h1bmtTaXplKGIpO1xuICAgICAgdmFyIGQgPSBNYXRoLnBvdyhiLGNzKSwgbWkgPSBmYWxzZSwgaiA9IDAsIHcgPSAwO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHggPSBpbnRBdChzLGkpO1xuICAgICAgICBpZih4IDwgMCkge1xuICAgICAgICAgIGlmKHMuY2hhckF0KGkpID09IFwiLVwiICYmIHRoaXMuc2lnbnVtKCkgPT0gMCkgbWkgPSB0cnVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHcgPSBiKncreDtcbiAgICAgICAgaWYoKytqID49IGNzKSB7XG4gICAgICAgICAgdGhpcy5kTXVsdGlwbHkoZCk7XG4gICAgICAgICAgdGhpcy5kQWRkT2Zmc2V0KHcsMCk7XG4gICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgdyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGogPiAwKSB7XG4gICAgICAgIHRoaXMuZE11bHRpcGx5KE1hdGgucG93KGIsaikpO1xuICAgICAgICB0aGlzLmRBZGRPZmZzZXQodywwKTtcbiAgICAgIH1cbiAgICAgIGlmKG1pKSBCaWdJbnRlZ2VyLlpFUk8uc3ViVG8odGhpcyx0aGlzKTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSBhbHRlcm5hdGUgY29uc3RydWN0b3JcbiAgICBmdW5jdGlvbiBibnBGcm9tTnVtYmVyKGEsYixjKSB7XG4gICAgICBpZihcIm51bWJlclwiID09IHR5cGVvZiBiKSB7XG4gICAgICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxpbnQsUk5HKVxuICAgICAgICBpZihhIDwgMikgdGhpcy5mcm9tSW50KDEpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZyb21OdW1iZXIoYSxjKTtcbiAgICAgICAgICBpZighdGhpcy50ZXN0Qml0KGEtMSkpXHQvLyBmb3JjZSBNU0Igc2V0XG4gICAgICAgICAgICB0aGlzLmJpdHdpc2VUbyhCaWdJbnRlZ2VyLk9ORS5zaGlmdExlZnQoYS0xKSxvcF9vcix0aGlzKTtcbiAgICAgICAgICBpZih0aGlzLmlzRXZlbigpKSB0aGlzLmRBZGRPZmZzZXQoMSwwKTsgLy8gZm9yY2Ugb2RkXG4gICAgICAgICAgd2hpbGUoIXRoaXMuaXNQcm9iYWJsZVByaW1lKGIpKSB7XG4gICAgICAgICAgICB0aGlzLmRBZGRPZmZzZXQoMiwwKTtcbiAgICAgICAgICAgIGlmKHRoaXMuYml0TGVuZ3RoKCkgPiBhKSB0aGlzLnN1YlRvKEJpZ0ludGVnZXIuT05FLnNoaWZ0TGVmdChhLTEpLHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG5ldyBCaWdJbnRlZ2VyKGludCxSTkcpXG4gICAgICAgIHZhciB4ID0gbmV3IEFycmF5KCksIHQgPSBhJjc7XG4gICAgICAgIHgubGVuZ3RoID0gKGE+PjMpKzE7XG4gICAgICAgIGIubmV4dEJ5dGVzKHgpO1xuICAgICAgICBpZih0ID4gMCkgeFswXSAmPSAoKDE8PHQpLTEpOyBlbHNlIHhbMF0gPSAwO1xuICAgICAgICB0aGlzLmZyb21TdHJpbmcoeCwyNTYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIGNvbnZlcnQgdG8gYmlnZW5kaWFuIGJ5dGUgYXJyYXlcbiAgICBmdW5jdGlvbiBiblRvQnl0ZUFycmF5KCkge1xuICAgICAgdmFyIGkgPSB0aGlzLnQsIHIgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHJbMF0gPSB0aGlzLnM7XG4gICAgICB2YXIgcCA9IHRoaXMuREItKGkqdGhpcy5EQiklOCwgZCwgayA9IDA7XG4gICAgICBpZihpLS0gPiAwKSB7XG4gICAgICAgIGlmKHAgPCB0aGlzLkRCICYmIChkID0gdGhpc1tpXT4+cCkgIT0gKHRoaXMucyZ0aGlzLkRNKT4+cClcbiAgICAgICAgICByW2srK10gPSBkfCh0aGlzLnM8PCh0aGlzLkRCLXApKTtcbiAgICAgICAgd2hpbGUoaSA+PSAwKSB7XG4gICAgICAgICAgaWYocCA8IDgpIHtcbiAgICAgICAgICAgIGQgPSAodGhpc1tpXSYoKDE8PHApLTEpKTw8KDgtcCk7XG4gICAgICAgICAgICBkIHw9IHRoaXNbLS1pXT4+KHArPXRoaXMuREItOCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZCA9ICh0aGlzW2ldPj4ocC09OCkpJjB4ZmY7XG4gICAgICAgICAgICBpZihwIDw9IDApIHsgcCArPSB0aGlzLkRCOyAtLWk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoKGQmMHg4MCkgIT0gMCkgZCB8PSAtMjU2O1xuICAgICAgICAgIGlmKGsgPT0gMCAmJiAodGhpcy5zJjB4ODApICE9IChkJjB4ODApKSArK2s7XG4gICAgICAgICAgaWYoayA+IDAgfHwgZCAhPSB0aGlzLnMpIHJbaysrXSA9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJuRXF1YWxzKGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPT0wKTsgfVxuICAgIGZ1bmN0aW9uIGJuTWluKGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPDApP3RoaXM6YTsgfVxuICAgIGZ1bmN0aW9uIGJuTWF4KGEpIHsgcmV0dXJuKHRoaXMuY29tcGFyZVRvKGEpPjApP3RoaXM6YTsgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgciA9IHRoaXMgb3AgYSAoYml0d2lzZSlcbiAgICBmdW5jdGlvbiBibnBCaXR3aXNlVG8oYSxvcCxyKSB7XG4gICAgICB2YXIgaSwgZiwgbSA9IE1hdGgubWluKGEudCx0aGlzLnQpO1xuICAgICAgZm9yKGkgPSAwOyBpIDwgbTsgKytpKSByW2ldID0gb3AodGhpc1tpXSxhW2ldKTtcbiAgICAgIGlmKGEudCA8IHRoaXMudCkge1xuICAgICAgICBmID0gYS5zJnRoaXMuRE07XG4gICAgICAgIGZvcihpID0gbTsgaSA8IHRoaXMudDsgKytpKSByW2ldID0gb3AodGhpc1tpXSxmKTtcbiAgICAgICAgci50ID0gdGhpcy50O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGYgPSB0aGlzLnMmdGhpcy5ETTtcbiAgICAgICAgZm9yKGkgPSBtOyBpIDwgYS50OyArK2kpIHJbaV0gPSBvcChmLGFbaV0pO1xuICAgICAgICByLnQgPSBhLnQ7XG4gICAgICB9XG4gICAgICByLnMgPSBvcCh0aGlzLnMsYS5zKTtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzICYgYVxuICAgIGZ1bmN0aW9uIG9wX2FuZCh4LHkpIHsgcmV0dXJuIHgmeTsgfVxuICAgIGZ1bmN0aW9uIGJuQW5kKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF9hbmQscik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIHwgYVxuICAgIGZ1bmN0aW9uIG9wX29yKHgseSkgeyByZXR1cm4geHx5OyB9XG4gICAgZnVuY3Rpb24gYm5PcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuYml0d2lzZVRvKGEsb3Bfb3Iscik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIF4gYVxuICAgIGZ1bmN0aW9uIG9wX3hvcih4LHkpIHsgcmV0dXJuIHheeTsgfVxuICAgIGZ1bmN0aW9uIGJuWG9yKGEpIHsgdmFyIHIgPSBuYmkoKTsgdGhpcy5iaXR3aXNlVG8oYSxvcF94b3Iscik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzICYgfmFcbiAgICBmdW5jdGlvbiBvcF9hbmRub3QoeCx5KSB7IHJldHVybiB4Jn55OyB9XG4gICAgZnVuY3Rpb24gYm5BbmROb3QoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmJpdHdpc2VUbyhhLG9wX2FuZG5vdCxyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIH50aGlzXG4gICAgZnVuY3Rpb24gYm5Ob3QoKSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudDsgKytpKSByW2ldID0gdGhpcy5ETSZ+dGhpc1tpXTtcbiAgICAgIHIudCA9IHRoaXMudDtcbiAgICAgIHIucyA9IH50aGlzLnM7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIDw8IG5cbiAgICBmdW5jdGlvbiBiblNoaWZ0TGVmdChuKSB7XG4gICAgICB2YXIgciA9IG5iaSgpO1xuICAgICAgaWYobiA8IDApIHRoaXMuclNoaWZ0VG8oLW4scik7IGVsc2UgdGhpcy5sU2hpZnRUbyhuLHIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyA+PiBuXG4gICAgZnVuY3Rpb24gYm5TaGlmdFJpZ2h0KG4pIHtcbiAgICAgIHZhciByID0gbmJpKCk7XG4gICAgICBpZihuIDwgMCkgdGhpcy5sU2hpZnRUbygtbixyKTsgZWxzZSB0aGlzLnJTaGlmdFRvKG4scik7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gaW5kZXggb2YgbG93ZXN0IDEtYml0IGluIHgsIHggPCAyXjMxXG4gICAgZnVuY3Rpb24gbGJpdCh4KSB7XG4gICAgICBpZih4ID09IDApIHJldHVybiAtMTtcbiAgICAgIHZhciByID0gMDtcbiAgICAgIGlmKCh4JjB4ZmZmZikgPT0gMCkgeyB4ID4+PSAxNjsgciArPSAxNjsgfVxuICAgICAgaWYoKHgmMHhmZikgPT0gMCkgeyB4ID4+PSA4OyByICs9IDg7IH1cbiAgICAgIGlmKCh4JjB4ZikgPT0gMCkgeyB4ID4+PSA0OyByICs9IDQ7IH1cbiAgICAgIGlmKCh4JjMpID09IDApIHsgeCA+Pj0gMjsgciArPSAyOyB9XG4gICAgICBpZigoeCYxKSA9PSAwKSArK3I7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvLyAocHVibGljKSByZXR1cm5zIGluZGV4IG9mIGxvd2VzdCAxLWJpdCAob3IgLTEgaWYgbm9uZSlcbiAgICBmdW5jdGlvbiBibkdldExvd2VzdFNldEJpdCgpIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnQ7ICsraSlcbiAgICAgICAgaWYodGhpc1tpXSAhPSAwKSByZXR1cm4gaSp0aGlzLkRCK2xiaXQodGhpc1tpXSk7XG4gICAgICBpZih0aGlzLnMgPCAwKSByZXR1cm4gdGhpcy50KnRoaXMuREI7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIG51bWJlciBvZiAxIGJpdHMgaW4geFxuICAgIGZ1bmN0aW9uIGNiaXQoeCkge1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgd2hpbGUoeCAhPSAwKSB7IHggJj0geC0xOyArK3I7IH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHJldHVybiBudW1iZXIgb2Ygc2V0IGJpdHNcbiAgICBmdW5jdGlvbiBibkJpdENvdW50KCkge1xuICAgICAgdmFyIHIgPSAwLCB4ID0gdGhpcy5zJnRoaXMuRE07XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50OyArK2kpIHIgKz0gY2JpdCh0aGlzW2ldXngpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgdHJ1ZSBpZmYgbnRoIGJpdCBpcyBzZXRcbiAgICBmdW5jdGlvbiBiblRlc3RCaXQobikge1xuICAgICAgdmFyIGogPSBNYXRoLmZsb29yKG4vdGhpcy5EQik7XG4gICAgICBpZihqID49IHRoaXMudCkgcmV0dXJuKHRoaXMucyE9MCk7XG4gICAgICByZXR1cm4oKHRoaXNbal0mKDE8PChuJXRoaXMuREIpKSkhPTApO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHRoaXMgb3AgKDE8PG4pXG4gICAgZnVuY3Rpb24gYm5wQ2hhbmdlQml0KG4sb3ApIHtcbiAgICAgIHZhciByID0gQmlnSW50ZWdlci5PTkUuc2hpZnRMZWZ0KG4pO1xuICAgICAgdGhpcy5iaXR3aXNlVG8ocixvcCxyKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgfCAoMTw8bilcbiAgICBmdW5jdGlvbiBiblNldEJpdChuKSB7IHJldHVybiB0aGlzLmNoYW5nZUJpdChuLG9wX29yKTsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyAmIH4oMTw8bilcbiAgICBmdW5jdGlvbiBibkNsZWFyQml0KG4pIHsgcmV0dXJuIHRoaXMuY2hhbmdlQml0KG4sb3BfYW5kbm90KTsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyBeICgxPDxuKVxuICAgIGZ1bmN0aW9uIGJuRmxpcEJpdChuKSB7IHJldHVybiB0aGlzLmNoYW5nZUJpdChuLG9wX3hvcik7IH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSB0aGlzICsgYVxuICAgIGZ1bmN0aW9uIGJucEFkZFRvKGEscikge1xuICAgICAgdmFyIGkgPSAwLCBjID0gMCwgbSA9IE1hdGgubWluKGEudCx0aGlzLnQpO1xuICAgICAgd2hpbGUoaSA8IG0pIHtcbiAgICAgICAgYyArPSB0aGlzW2ldK2FbaV07XG4gICAgICAgIHJbaSsrXSA9IGMmdGhpcy5ETTtcbiAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgIH1cbiAgICAgIGlmKGEudCA8IHRoaXMudCkge1xuICAgICAgICBjICs9IGEucztcbiAgICAgICAgd2hpbGUoaSA8IHRoaXMudCkge1xuICAgICAgICAgIGMgKz0gdGhpc1tpXTtcbiAgICAgICAgICByW2krK10gPSBjJnRoaXMuRE07XG4gICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgfVxuICAgICAgICBjICs9IHRoaXMucztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjICs9IHRoaXMucztcbiAgICAgICAgd2hpbGUoaSA8IGEudCkge1xuICAgICAgICAgIGMgKz0gYVtpXTtcbiAgICAgICAgICByW2krK10gPSBjJnRoaXMuRE07XG4gICAgICAgICAgYyA+Pj0gdGhpcy5EQjtcbiAgICAgICAgfVxuICAgICAgICBjICs9IGEucztcbiAgICAgIH1cbiAgICAgIHIucyA9IChjPDApPy0xOjA7XG4gICAgICBpZihjID4gMCkgcltpKytdID0gYztcbiAgICAgIGVsc2UgaWYoYyA8IC0xKSByW2krK10gPSB0aGlzLkRWK2M7XG4gICAgICByLnQgPSBpO1xuICAgICAgci5jbGFtcCgpO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXMgKyBhXG4gICAgZnVuY3Rpb24gYm5BZGQoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLmFkZFRvKGEscik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzIC0gYVxuICAgIGZ1bmN0aW9uIGJuU3VidHJhY3QoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLnN1YlRvKGEscik7IHJldHVybiByOyB9XG5cbiAgICAvLyAocHVibGljKSB0aGlzICogYVxuICAgIGZ1bmN0aW9uIGJuTXVsdGlwbHkoYSkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLm11bHRpcGx5VG8oYSxyKTsgcmV0dXJuIHI7IH1cblxuICAgIC8vIChwdWJsaWMpIHRoaXNeMlxuICAgIGZ1bmN0aW9uIGJuU3F1YXJlKCkgeyB2YXIgciA9IG5iaSgpOyB0aGlzLnNxdWFyZVRvKHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyAvIGFcbiAgICBmdW5jdGlvbiBibkRpdmlkZShhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuZGl2UmVtVG8oYSxyLG51bGwpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgdGhpcyAlIGFcbiAgICBmdW5jdGlvbiBiblJlbWFpbmRlcihhKSB7IHZhciByID0gbmJpKCk7IHRoaXMuZGl2UmVtVG8oYSxudWxsLHIpOyByZXR1cm4gcjsgfVxuXG4gICAgLy8gKHB1YmxpYykgW3RoaXMvYSx0aGlzJWFdXG4gICAgZnVuY3Rpb24gYm5EaXZpZGVBbmRSZW1haW5kZXIoYSkge1xuICAgICAgdmFyIHEgPSBuYmkoKSwgciA9IG5iaSgpO1xuICAgICAgdGhpcy5kaXZSZW1UbyhhLHEscik7XG4gICAgICByZXR1cm4gbmV3IEFycmF5KHEscik7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyAqPSBuLCB0aGlzID49IDAsIDEgPCBuIDwgRFZcbiAgICBmdW5jdGlvbiBibnBETXVsdGlwbHkobikge1xuICAgICAgdGhpc1t0aGlzLnRdID0gdGhpcy5hbSgwLG4tMSx0aGlzLDAsMCx0aGlzLnQpO1xuICAgICAgKyt0aGlzLnQ7XG4gICAgICB0aGlzLmNsYW1wKCk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyArPSBuIDw8IHcgd29yZHMsIHRoaXMgPj0gMFxuICAgIGZ1bmN0aW9uIGJucERBZGRPZmZzZXQobix3KSB7XG4gICAgICBpZihuID09IDApIHJldHVybjtcbiAgICAgIHdoaWxlKHRoaXMudCA8PSB3KSB0aGlzW3RoaXMudCsrXSA9IDA7XG4gICAgICB0aGlzW3ddICs9IG47XG4gICAgICB3aGlsZSh0aGlzW3ddID49IHRoaXMuRFYpIHtcbiAgICAgICAgdGhpc1t3XSAtPSB0aGlzLkRWO1xuICAgICAgICBpZigrK3cgPj0gdGhpcy50KSB0aGlzW3RoaXMudCsrXSA9IDA7XG4gICAgICAgICsrdGhpc1t3XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBIFwibnVsbFwiIHJlZHVjZXJcbiAgICBmdW5jdGlvbiBOdWxsRXhwKCkge31cbiAgICBmdW5jdGlvbiBuTm9wKHgpIHsgcmV0dXJuIHg7IH1cbiAgICBmdW5jdGlvbiBuTXVsVG8oeCx5LHIpIHsgeC5tdWx0aXBseVRvKHkscik7IH1cbiAgICBmdW5jdGlvbiBuU3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IH1cblxuICAgIE51bGxFeHAucHJvdG90eXBlLmNvbnZlcnQgPSBuTm9wO1xuICAgIE51bGxFeHAucHJvdG90eXBlLnJldmVydCA9IG5Ob3A7XG4gICAgTnVsbEV4cC5wcm90b3R5cGUubXVsVG8gPSBuTXVsVG87XG4gICAgTnVsbEV4cC5wcm90b3R5cGUuc3FyVG8gPSBuU3FyVG87XG5cbiAgICAvLyAocHVibGljKSB0aGlzXmVcbiAgICBmdW5jdGlvbiBiblBvdyhlKSB7IHJldHVybiB0aGlzLmV4cChlLG5ldyBOdWxsRXhwKCkpOyB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSByID0gbG93ZXIgbiB3b3JkcyBvZiBcInRoaXMgKiBhXCIsIGEudCA8PSBuXG4gICAgLy8gXCJ0aGlzXCIgc2hvdWxkIGJlIHRoZSBsYXJnZXIgb25lIGlmIGFwcHJvcHJpYXRlLlxuICAgIGZ1bmN0aW9uIGJucE11bHRpcGx5TG93ZXJUbyhhLG4scikge1xuICAgICAgdmFyIGkgPSBNYXRoLm1pbih0aGlzLnQrYS50LG4pO1xuICAgICAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICAgICAgci50ID0gaTtcbiAgICAgIHdoaWxlKGkgPiAwKSByWy0taV0gPSAwO1xuICAgICAgdmFyIGo7XG4gICAgICBmb3IoaiA9IHIudC10aGlzLnQ7IGkgPCBqOyArK2kpIHJbaSt0aGlzLnRdID0gdGhpcy5hbSgwLGFbaV0scixpLDAsdGhpcy50KTtcbiAgICAgIGZvcihqID0gTWF0aC5taW4oYS50LG4pOyBpIDwgajsgKytpKSB0aGlzLmFtKDAsYVtpXSxyLGksMCxuLWkpO1xuICAgICAgci5jbGFtcCgpO1xuICAgIH1cblxuICAgIC8vIChwcm90ZWN0ZWQpIHIgPSBcInRoaXMgKiBhXCIgd2l0aG91dCBsb3dlciBuIHdvcmRzLCBuID4gMFxuICAgIC8vIFwidGhpc1wiIHNob3VsZCBiZSB0aGUgbGFyZ2VyIG9uZSBpZiBhcHByb3ByaWF0ZS5cbiAgICBmdW5jdGlvbiBibnBNdWx0aXBseVVwcGVyVG8oYSxuLHIpIHtcbiAgICAgIC0tbjtcbiAgICAgIHZhciBpID0gci50ID0gdGhpcy50K2EudC1uO1xuICAgICAgci5zID0gMDsgLy8gYXNzdW1lcyBhLHRoaXMgPj0gMFxuICAgICAgd2hpbGUoLS1pID49IDApIHJbaV0gPSAwO1xuICAgICAgZm9yKGkgPSBNYXRoLm1heChuLXRoaXMudCwwKTsgaSA8IGEudDsgKytpKVxuICAgICAgICByW3RoaXMudCtpLW5dID0gdGhpcy5hbShuLWksYVtpXSxyLDAsMCx0aGlzLnQraS1uKTtcbiAgICAgIHIuY2xhbXAoKTtcbiAgICAgIHIuZHJTaGlmdFRvKDEscik7XG4gICAgfVxuXG4gICAgLy8gQmFycmV0dCBtb2R1bGFyIHJlZHVjdGlvblxuICAgIGZ1bmN0aW9uIEJhcnJldHQobSkge1xuICAgICAgLy8gc2V0dXAgQmFycmV0dFxuICAgICAgdGhpcy5yMiA9IG5iaSgpO1xuICAgICAgdGhpcy5xMyA9IG5iaSgpO1xuICAgICAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKDIqbS50LHRoaXMucjIpO1xuICAgICAgdGhpcy5tdSA9IHRoaXMucjIuZGl2aWRlKG0pO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiYXJyZXR0Q29udmVydCh4KSB7XG4gICAgICBpZih4LnMgPCAwIHx8IHgudCA+IDIqdGhpcy5tLnQpIHJldHVybiB4Lm1vZCh0aGlzLm0pO1xuICAgICAgZWxzZSBpZih4LmNvbXBhcmVUbyh0aGlzLm0pIDwgMCkgcmV0dXJuIHg7XG4gICAgICBlbHNlIHsgdmFyIHIgPSBuYmkoKTsgeC5jb3B5VG8ocik7IHRoaXMucmVkdWNlKHIpOyByZXR1cm4gcjsgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuXG4gICAgLy8geCA9IHggbW9kIG0gKEhBQyAxNC40MilcbiAgICBmdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbiAgICAgIHguZHJTaGlmdFRvKHRoaXMubS50LTEsdGhpcy5yMik7XG4gICAgICBpZih4LnQgPiB0aGlzLm0udCsxKSB7IHgudCA9IHRoaXMubS50KzE7IHguY2xhbXAoKTsgfVxuICAgICAgdGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMix0aGlzLm0udCsxLHRoaXMucTMpO1xuICAgICAgdGhpcy5tLm11bHRpcGx5TG93ZXJUbyh0aGlzLnEzLHRoaXMubS50KzEsdGhpcy5yMik7XG4gICAgICB3aGlsZSh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLHRoaXMubS50KzEpO1xuICAgICAgeC5zdWJUbyh0aGlzLnIyLHgpO1xuICAgICAgd2hpbGUoeC5jb21wYXJlVG8odGhpcy5tKSA+PSAwKSB4LnN1YlRvKHRoaXMubSx4KTtcbiAgICB9XG5cbiAgICAvLyByID0geF4yIG1vZCBtOyB4ICE9IHJcbiAgICBmdW5jdGlvbiBiYXJyZXR0U3FyVG8oeCxyKSB7IHguc3F1YXJlVG8ocik7IHRoaXMucmVkdWNlKHIpOyB9XG5cbiAgICAvLyByID0geCp5IG1vZCBtOyB4LHkgIT0gclxuICAgIGZ1bmN0aW9uIGJhcnJldHRNdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuICAgIEJhcnJldHQucHJvdG90eXBlLmNvbnZlcnQgPSBiYXJyZXR0Q29udmVydDtcbiAgICBCYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0O1xuICAgIEJhcnJldHQucHJvdG90eXBlLnJlZHVjZSA9IGJhcnJldHRSZWR1Y2U7XG4gICAgQmFycmV0dC5wcm90b3R5cGUubXVsVG8gPSBiYXJyZXR0TXVsVG87XG4gICAgQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG87XG5cbiAgICAvLyAocHVibGljKSB0aGlzXmUgJSBtIChIQUMgMTQuODUpXG4gICAgZnVuY3Rpb24gYm5Nb2RQb3coZSxtKSB7XG4gICAgICB2YXIgaSA9IGUuYml0TGVuZ3RoKCksIGssIHIgPSBuYnYoMSksIHo7XG4gICAgICBpZihpIDw9IDApIHJldHVybiByO1xuICAgICAgZWxzZSBpZihpIDwgMTgpIGsgPSAxO1xuICAgICAgZWxzZSBpZihpIDwgNDgpIGsgPSAzO1xuICAgICAgZWxzZSBpZihpIDwgMTQ0KSBrID0gNDtcbiAgICAgIGVsc2UgaWYoaSA8IDc2OCkgayA9IDU7XG4gICAgICBlbHNlIGsgPSA2O1xuICAgICAgaWYoaSA8IDgpXG4gICAgICAgIHogPSBuZXcgQ2xhc3NpYyhtKTtcbiAgICAgIGVsc2UgaWYobS5pc0V2ZW4oKSlcbiAgICAgICAgeiA9IG5ldyBCYXJyZXR0KG0pO1xuICAgICAgZWxzZVxuICAgICAgICB6ID0gbmV3IE1vbnRnb21lcnkobSk7XG5cbiAgICAgIC8vIHByZWNvbXB1dGF0aW9uXG4gICAgICB2YXIgZyA9IG5ldyBBcnJheSgpLCBuID0gMywgazEgPSBrLTEsIGttID0gKDE8PGspLTE7XG4gICAgICBnWzFdID0gei5jb252ZXJ0KHRoaXMpO1xuICAgICAgaWYoayA+IDEpIHtcbiAgICAgICAgdmFyIGcyID0gbmJpKCk7XG4gICAgICAgIHouc3FyVG8oZ1sxXSxnMik7XG4gICAgICAgIHdoaWxlKG4gPD0ga20pIHtcbiAgICAgICAgICBnW25dID0gbmJpKCk7XG4gICAgICAgICAgei5tdWxUbyhnMixnW24tMl0sZ1tuXSk7XG4gICAgICAgICAgbiArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBqID0gZS50LTEsIHcsIGlzMSA9IHRydWUsIHIyID0gbmJpKCksIHQ7XG4gICAgICBpID0gbmJpdHMoZVtqXSktMTtcbiAgICAgIHdoaWxlKGogPj0gMCkge1xuICAgICAgICBpZihpID49IGsxKSB3ID0gKGVbal0+PihpLWsxKSkma207XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHcgPSAoZVtqXSYoKDE8PChpKzEpKS0xKSk8PChrMS1pKTtcbiAgICAgICAgICBpZihqID4gMCkgdyB8PSBlW2otMV0+Pih0aGlzLkRCK2ktazEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbiA9IGs7XG4gICAgICAgIHdoaWxlKCh3JjEpID09IDApIHsgdyA+Pj0gMTsgLS1uOyB9XG4gICAgICAgIGlmKChpIC09IG4pIDwgMCkgeyBpICs9IHRoaXMuREI7IC0tajsgfVxuICAgICAgICBpZihpczEpIHtcdC8vIHJldCA9PSAxLCBkb24ndCBib3RoZXIgc3F1YXJpbmcgb3IgbXVsdGlwbHlpbmcgaXRcbiAgICAgICAgICBnW3ddLmNvcHlUbyhyKTtcbiAgICAgICAgICBpczEgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB3aGlsZShuID4gMSkgeyB6LnNxclRvKHIscjIpOyB6LnNxclRvKHIyLHIpOyBuIC09IDI7IH1cbiAgICAgICAgICBpZihuID4gMCkgei5zcXJUbyhyLHIyKTsgZWxzZSB7IHQgPSByOyByID0gcjI7IHIyID0gdDsgfVxuICAgICAgICAgIHoubXVsVG8ocjIsZ1t3XSxyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKGogPj0gMCAmJiAoZVtqXSYoMTw8aSkpID09IDApIHtcbiAgICAgICAgICB6LnNxclRvKHIscjIpOyB0ID0gcjsgciA9IHIyOyByMiA9IHQ7XG4gICAgICAgICAgaWYoLS1pIDwgMCkgeyBpID0gdGhpcy5EQi0xOyAtLWo7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHoucmV2ZXJ0KHIpO1xuICAgIH1cblxuICAgIC8vIChwdWJsaWMpIGdjZCh0aGlzLGEpIChIQUMgMTQuNTQpXG4gICAgZnVuY3Rpb24gYm5HQ0QoYSkge1xuICAgICAgdmFyIHggPSAodGhpcy5zPDApP3RoaXMubmVnYXRlKCk6dGhpcy5jbG9uZSgpO1xuICAgICAgdmFyIHkgPSAoYS5zPDApP2EubmVnYXRlKCk6YS5jbG9uZSgpO1xuICAgICAgaWYoeC5jb21wYXJlVG8oeSkgPCAwKSB7IHZhciB0ID0geDsgeCA9IHk7IHkgPSB0OyB9XG4gICAgICB2YXIgaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCksIGcgPSB5LmdldExvd2VzdFNldEJpdCgpO1xuICAgICAgaWYoZyA8IDApIHJldHVybiB4O1xuICAgICAgaWYoaSA8IGcpIGcgPSBpO1xuICAgICAgaWYoZyA+IDApIHtcbiAgICAgICAgeC5yU2hpZnRUbyhnLHgpO1xuICAgICAgICB5LnJTaGlmdFRvKGcseSk7XG4gICAgICB9XG4gICAgICB3aGlsZSh4LnNpZ251bSgpID4gMCkge1xuICAgICAgICBpZigoaSA9IHguZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeC5yU2hpZnRUbyhpLHgpO1xuICAgICAgICBpZigoaSA9IHkuZ2V0TG93ZXN0U2V0Qml0KCkpID4gMCkgeS5yU2hpZnRUbyhpLHkpO1xuICAgICAgICBpZih4LmNvbXBhcmVUbyh5KSA+PSAwKSB7XG4gICAgICAgICAgeC5zdWJUbyh5LHgpO1xuICAgICAgICAgIHguclNoaWZ0VG8oMSx4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB5LnN1YlRvKHgseSk7XG4gICAgICAgICAgeS5yU2hpZnRUbygxLHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihnID4gMCkgeS5sU2hpZnRUbyhnLHkpO1xuICAgICAgcmV0dXJuIHk7XG4gICAgfVxuXG4gICAgLy8gKHByb3RlY3RlZCkgdGhpcyAlIG4sIG4gPCAyXjI2XG4gICAgZnVuY3Rpb24gYm5wTW9kSW50KG4pIHtcbiAgICAgIGlmKG4gPD0gMCkgcmV0dXJuIDA7XG4gICAgICB2YXIgZCA9IHRoaXMuRFYlbiwgciA9ICh0aGlzLnM8MCk/bi0xOjA7XG4gICAgICBpZih0aGlzLnQgPiAwKVxuICAgICAgICBpZihkID09IDApIHIgPSB0aGlzWzBdJW47XG4gICAgICAgIGVsc2UgZm9yKHZhciBpID0gdGhpcy50LTE7IGkgPj0gMDsgLS1pKSByID0gKGQqcit0aGlzW2ldKSVuO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgLy8gKHB1YmxpYykgMS90aGlzICUgbSAoSEFDIDE0LjYxKVxuICAgIGZ1bmN0aW9uIGJuTW9kSW52ZXJzZShtKSB7XG4gICAgICB2YXIgYWMgPSBtLmlzRXZlbigpO1xuICAgICAgaWYoKHRoaXMuaXNFdmVuKCkgJiYgYWMpIHx8IG0uc2lnbnVtKCkgPT0gMCkgcmV0dXJuIEJpZ0ludGVnZXIuWkVSTztcbiAgICAgIHZhciB1ID0gbS5jbG9uZSgpLCB2ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgdmFyIGEgPSBuYnYoMSksIGIgPSBuYnYoMCksIGMgPSBuYnYoMCksIGQgPSBuYnYoMSk7XG4gICAgICB3aGlsZSh1LnNpZ251bSgpICE9IDApIHtcbiAgICAgICAgd2hpbGUodS5pc0V2ZW4oKSkge1xuICAgICAgICAgIHUuclNoaWZ0VG8oMSx1KTtcbiAgICAgICAgICBpZihhYykge1xuICAgICAgICAgICAgaWYoIWEuaXNFdmVuKCkgfHwgIWIuaXNFdmVuKCkpIHsgYS5hZGRUbyh0aGlzLGEpOyBiLnN1YlRvKG0sYik7IH1cbiAgICAgICAgICAgIGEuclNoaWZ0VG8oMSxhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZighYi5pc0V2ZW4oKSkgYi5zdWJUbyhtLGIpO1xuICAgICAgICAgIGIuclNoaWZ0VG8oMSxiKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSh2LmlzRXZlbigpKSB7XG4gICAgICAgICAgdi5yU2hpZnRUbygxLHYpO1xuICAgICAgICAgIGlmKGFjKSB7XG4gICAgICAgICAgICBpZighYy5pc0V2ZW4oKSB8fCAhZC5pc0V2ZW4oKSkgeyBjLmFkZFRvKHRoaXMsYyk7IGQuc3ViVG8obSxkKTsgfVxuICAgICAgICAgICAgYy5yU2hpZnRUbygxLGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCFkLmlzRXZlbigpKSBkLnN1YlRvKG0sZCk7XG4gICAgICAgICAgZC5yU2hpZnRUbygxLGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHUuY29tcGFyZVRvKHYpID49IDApIHtcbiAgICAgICAgICB1LnN1YlRvKHYsdSk7XG4gICAgICAgICAgaWYoYWMpIGEuc3ViVG8oYyxhKTtcbiAgICAgICAgICBiLnN1YlRvKGQsYik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdi5zdWJUbyh1LHYpO1xuICAgICAgICAgIGlmKGFjKSBjLnN1YlRvKGEsYyk7XG4gICAgICAgICAgZC5zdWJUbyhiLGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZih2LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgIT0gMCkgcmV0dXJuIEJpZ0ludGVnZXIuWkVSTztcbiAgICAgIGlmKGQuY29tcGFyZVRvKG0pID49IDApIHJldHVybiBkLnN1YnRyYWN0KG0pO1xuICAgICAgaWYoZC5zaWdudW0oKSA8IDApIGQuYWRkVG8obSxkKTsgZWxzZSByZXR1cm4gZDtcbiAgICAgIGlmKGQuc2lnbnVtKCkgPCAwKSByZXR1cm4gZC5hZGQobSk7IGVsc2UgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgdmFyIGxvd3ByaW1lcyA9IFsyLDMsNSw3LDExLDEzLDE3LDE5LDIzLDI5LDMxLDM3LDQxLDQzLDQ3LDUzLDU5LDYxLDY3LDcxLDczLDc5LDgzLDg5LDk3LDEwMSwxMDMsMTA3LDEwOSwxMTMsMTI3LDEzMSwxMzcsMTM5LDE0OSwxNTEsMTU3LDE2MywxNjcsMTczLDE3OSwxODEsMTkxLDE5MywxOTcsMTk5LDIxMSwyMjMsMjI3LDIyOSwyMzMsMjM5LDI0MSwyNTEsMjU3LDI2MywyNjksMjcxLDI3NywyODEsMjgzLDI5MywzMDcsMzExLDMxMywzMTcsMzMxLDMzNywzNDcsMzQ5LDM1MywzNTksMzY3LDM3MywzNzksMzgzLDM4OSwzOTcsNDAxLDQwOSw0MTksNDIxLDQzMSw0MzMsNDM5LDQ0Myw0NDksNDU3LDQ2MSw0NjMsNDY3LDQ3OSw0ODcsNDkxLDQ5OSw1MDMsNTA5LDUyMSw1MjMsNTQxLDU0Nyw1NTcsNTYzLDU2OSw1NzEsNTc3LDU4Nyw1OTMsNTk5LDYwMSw2MDcsNjEzLDYxNyw2MTksNjMxLDY0MSw2NDMsNjQ3LDY1Myw2NTksNjYxLDY3Myw2NzcsNjgzLDY5MSw3MDEsNzA5LDcxOSw3MjcsNzMzLDczOSw3NDMsNzUxLDc1Nyw3NjEsNzY5LDc3Myw3ODcsNzk3LDgwOSw4MTEsODIxLDgyMyw4MjcsODI5LDgzOSw4NTMsODU3LDg1OSw4NjMsODc3LDg4MSw4ODMsODg3LDkwNyw5MTEsOTE5LDkyOSw5MzcsOTQxLDk0Nyw5NTMsOTY3LDk3MSw5NzcsOTgzLDk5MSw5OTddO1xuICAgIHZhciBscGxpbSA9ICgxPDwyNikvbG93cHJpbWVzW2xvd3ByaW1lcy5sZW5ndGgtMV07XG5cbiAgICAvLyAocHVibGljKSB0ZXN0IHByaW1hbGl0eSB3aXRoIGNlcnRhaW50eSA+PSAxLS41XnRcbiAgICBmdW5jdGlvbiBibklzUHJvYmFibGVQcmltZSh0KSB7XG4gICAgICB2YXIgaSwgeCA9IHRoaXMuYWJzKCk7XG4gICAgICBpZih4LnQgPT0gMSAmJiB4WzBdIDw9IGxvd3ByaW1lc1tsb3dwcmltZXMubGVuZ3RoLTFdKSB7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxvd3ByaW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZih4WzBdID09IGxvd3ByaW1lc1tpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmKHguaXNFdmVuKCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGkgPSAxO1xuICAgICAgd2hpbGUoaSA8IGxvd3ByaW1lcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG0gPSBsb3dwcmltZXNbaV0sIGogPSBpKzE7XG4gICAgICAgIHdoaWxlKGogPCBsb3dwcmltZXMubGVuZ3RoICYmIG0gPCBscGxpbSkgbSAqPSBsb3dwcmltZXNbaisrXTtcbiAgICAgICAgbSA9IHgubW9kSW50KG0pO1xuICAgICAgICB3aGlsZShpIDwgaikgaWYobSVsb3dwcmltZXNbaSsrXSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4geC5taWxsZXJSYWJpbih0KTtcbiAgICB9XG5cbiAgICAvLyAocHJvdGVjdGVkKSB0cnVlIGlmIHByb2JhYmx5IHByaW1lIChIQUMgNC4yNCwgTWlsbGVyLVJhYmluKVxuICAgIGZ1bmN0aW9uIGJucE1pbGxlclJhYmluKHQpIHtcbiAgICAgIHZhciBuMSA9IHRoaXMuc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICAgICAgdmFyIGsgPSBuMS5nZXRMb3dlc3RTZXRCaXQoKTtcbiAgICAgIGlmKGsgPD0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHIgPSBuMS5zaGlmdFJpZ2h0KGspO1xuICAgICAgdCA9ICh0KzEpPj4xO1xuICAgICAgaWYodCA+IGxvd3ByaW1lcy5sZW5ndGgpIHQgPSBsb3dwcmltZXMubGVuZ3RoO1xuICAgICAgdmFyIGEgPSBuYmkoKTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0OyArK2kpIHtcbiAgICAgICAgLy9QaWNrIGJhc2VzIGF0IHJhbmRvbSwgaW5zdGVhZCBvZiBzdGFydGluZyBhdCAyXG4gICAgICAgIGEuZnJvbUludChsb3dwcmltZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKmxvd3ByaW1lcy5sZW5ndGgpXSk7XG4gICAgICAgIHZhciB5ID0gYS5tb2RQb3cocix0aGlzKTtcbiAgICAgICAgaWYoeS5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpICE9IDAgJiYgeS5jb21wYXJlVG8objEpICE9IDApIHtcbiAgICAgICAgICB2YXIgaiA9IDE7XG4gICAgICAgICAgd2hpbGUoaisrIDwgayAmJiB5LmNvbXBhcmVUbyhuMSkgIT0gMCkge1xuICAgICAgICAgICAgeSA9IHkubW9kUG93SW50KDIsdGhpcyk7XG4gICAgICAgICAgICBpZih5LmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZih5LmNvbXBhcmVUbyhuMSkgIT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBwcm90ZWN0ZWRcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaHVua1NpemUgPSBibnBDaHVua1NpemU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUudG9SYWRpeCA9IGJucFRvUmFkaXg7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZnJvbVJhZGl4ID0gYm5wRnJvbVJhZGl4O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZyb21OdW1iZXIgPSBibnBGcm9tTnVtYmVyO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmJpdHdpc2VUbyA9IGJucEJpdHdpc2VUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jaGFuZ2VCaXQgPSBibnBDaGFuZ2VCaXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkVG8gPSBibnBBZGRUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kTXVsdGlwbHkgPSBibnBETXVsdGlwbHk7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZEFkZE9mZnNldCA9IGJucERBZGRPZmZzZXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHlMb3dlclRvID0gYm5wTXVsdGlwbHlMb3dlclRvO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5VXBwZXJUbyA9IGJucE11bHRpcGx5VXBwZXJUbztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnQgPSBibnBNb2RJbnQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWlsbGVyUmFiaW4gPSBibnBNaWxsZXJSYWJpbjtcblxuICAgIC8vIHB1YmxpY1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNsb25lID0gYm5DbG9uZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGJuSW50VmFsdWU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYnl0ZVZhbHVlID0gYm5CeXRlVmFsdWU7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hvcnRWYWx1ZSA9IGJuU2hvcnRWYWx1ZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaWdudW0gPSBiblNpZ051bTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGJuVG9CeXRlQXJyYXk7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gYm5FcXVhbHM7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWluID0gYm5NaW47XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWF4ID0gYm5NYXg7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kID0gYm5BbmQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUub3IgPSBibk9yO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnhvciA9IGJuWG9yO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFuZE5vdCA9IGJuQW5kTm90O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGJuTm90O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdCA9IGJuU2hpZnRMZWZ0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBiblNoaWZ0UmlnaHQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZ2V0TG93ZXN0U2V0Qml0ID0gYm5HZXRMb3dlc3RTZXRCaXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYml0Q291bnQgPSBibkJpdENvdW50O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRlc3RCaXQgPSBiblRlc3RCaXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2V0Qml0ID0gYm5TZXRCaXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuY2xlYXJCaXQgPSBibkNsZWFyQml0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmZsaXBCaXQgPSBibkZsaXBCaXQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gYm5BZGQ7XG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3QgPSBiblN1YnRyYWN0O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gYm5NdWx0aXBseTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGUgPSBibkRpdmlkZTtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBiblJlbWFpbmRlcjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGVBbmRSZW1haW5kZXIgPSBibkRpdmlkZUFuZFJlbWFpbmRlcjtcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBibk1vZFBvdztcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnZlcnNlID0gYm5Nb2RJbnZlcnNlO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdyA9IGJuUG93O1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdjZCA9IGJuR0NEO1xuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IGJuSXNQcm9iYWJsZVByaW1lO1xuXG4gICAgLy8gSlNCTi1zcGVjaWZpYyBleHRlbnNpb25cbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBiblNxdWFyZTtcblxuICAgIC8vIEV4cG9zZSB0aGUgQmFycmV0dCBmdW5jdGlvblxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLkJhcnJldHQgPSBCYXJyZXR0XG5cbiAgICAvLyBCaWdJbnRlZ2VyIGludGVyZmFjZXMgbm90IGltcGxlbWVudGVkIGluIGpzYm46XG5cbiAgICAvLyBCaWdJbnRlZ2VyKGludCBzaWdudW0sIGJ5dGVbXSBtYWduaXR1ZGUpXG4gICAgLy8gZG91YmxlIGRvdWJsZVZhbHVlKClcbiAgICAvLyBmbG9hdCBmbG9hdFZhbHVlKClcbiAgICAvLyBpbnQgaGFzaENvZGUoKVxuICAgIC8vIGxvbmcgbG9uZ1ZhbHVlKClcbiAgICAvLyBzdGF0aWMgQmlnSW50ZWdlciB2YWx1ZU9mKGxvbmcgdmFsKVxuXG5cdC8vIFJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIC0gcmVxdWlyZXMgYSBQUk5HIGJhY2tlbmQsIGUuZy4gcHJuZzQuanNcblxuXHQvLyBGb3IgYmVzdCByZXN1bHRzLCBwdXQgY29kZSBsaWtlXG5cdC8vIDxib2R5IG9uQ2xpY2s9J3JuZ19zZWVkX3RpbWUoKTsnIG9uS2V5UHJlc3M9J3JuZ19zZWVkX3RpbWUoKTsnPlxuXHQvLyBpbiB5b3VyIG1haW4gSFRNTCBkb2N1bWVudC5cblxuXHR2YXIgcm5nX3N0YXRlO1xuXHR2YXIgcm5nX3Bvb2w7XG5cdHZhciBybmdfcHB0cjtcblxuXHQvLyBNaXggaW4gYSAzMi1iaXQgaW50ZWdlciBpbnRvIHRoZSBwb29sXG5cdGZ1bmN0aW9uIHJuZ19zZWVkX2ludCh4KSB7XG5cdCAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gXj0geCAmIDI1NTtcblx0ICBybmdfcG9vbFtybmdfcHB0cisrXSBePSAoeCA+PiA4KSAmIDI1NTtcblx0ICBybmdfcG9vbFtybmdfcHB0cisrXSBePSAoeCA+PiAxNikgJiAyNTU7XG5cdCAgcm5nX3Bvb2xbcm5nX3BwdHIrK10gXj0gKHggPj4gMjQpICYgMjU1O1xuXHQgIGlmKHJuZ19wcHRyID49IHJuZ19wc2l6ZSkgcm5nX3BwdHIgLT0gcm5nX3BzaXplO1xuXHR9XG5cblx0Ly8gTWl4IGluIHRoZSBjdXJyZW50IHRpbWUgKHcvbWlsbGlzZWNvbmRzKSBpbnRvIHRoZSBwb29sXG5cdGZ1bmN0aW9uIHJuZ19zZWVkX3RpbWUoKSB7XG5cdCAgcm5nX3NlZWRfaW50KG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblx0fVxuXG5cdC8vIEluaXRpYWxpemUgdGhlIHBvb2wgd2l0aCBqdW5rIGlmIG5lZWRlZC5cblx0aWYocm5nX3Bvb2wgPT0gbnVsbCkge1xuXHQgIHJuZ19wb29sID0gbmV3IEFycmF5KCk7XG5cdCAgcm5nX3BwdHIgPSAwO1xuXHQgIHZhciB0O1xuXHQgIGlmKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmNyeXB0bykge1xuXHRcdGlmICh3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuXHRcdCAgLy8gVXNlIHdlYmNyeXB0byBpZiBhdmFpbGFibGVcblx0XHQgIHZhciB1YSA9IG5ldyBVaW50OEFycmF5KDMyKTtcblx0XHQgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHVhKTtcblx0XHQgIGZvcih0ID0gMDsgdCA8IDMyOyArK3QpXG5cdFx0XHRybmdfcG9vbFtybmdfcHB0cisrXSA9IHVhW3RdO1xuXHRcdH1cblx0XHRlbHNlIGlmKG5hdmlnYXRvci5hcHBOYW1lID09IFwiTmV0c2NhcGVcIiAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbiA8IFwiNVwiKSB7XG5cdFx0ICAvLyBFeHRyYWN0IGVudHJvcHkgKDI1NiBiaXRzKSBmcm9tIE5TNCBSTkcgaWYgYXZhaWxhYmxlXG5cdFx0ICB2YXIgeiA9IHdpbmRvdy5jcnlwdG8ucmFuZG9tKDMyKTtcblx0XHQgIGZvcih0ID0gMDsgdCA8IHoubGVuZ3RoOyArK3QpXG5cdFx0XHRybmdfcG9vbFtybmdfcHB0cisrXSA9IHouY2hhckNvZGVBdCh0KSAmIDI1NTtcblx0XHR9XG5cdCAgfVxuXHQgIHdoaWxlKHJuZ19wcHRyIDwgcm5nX3BzaXplKSB7ICAvLyBleHRyYWN0IHNvbWUgcmFuZG9tbmVzcyBmcm9tIE1hdGgucmFuZG9tKClcblx0XHR0ID0gTWF0aC5mbG9vcig2NTUzNiAqIE1hdGgucmFuZG9tKCkpO1xuXHRcdHJuZ19wb29sW3JuZ19wcHRyKytdID0gdCA+Pj4gODtcblx0XHRybmdfcG9vbFtybmdfcHB0cisrXSA9IHQgJiAyNTU7XG5cdCAgfVxuXHQgIHJuZ19wcHRyID0gMDtcblx0ICBybmdfc2VlZF90aW1lKCk7XG5cdCAgLy9ybmdfc2VlZF9pbnQod2luZG93LnNjcmVlblgpO1xuXHQgIC8vcm5nX3NlZWRfaW50KHdpbmRvdy5zY3JlZW5ZKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJuZ19nZXRfYnl0ZSgpIHtcblx0ICBpZihybmdfc3RhdGUgPT0gbnVsbCkge1xuXHRcdHJuZ19zZWVkX3RpbWUoKTtcblx0XHRybmdfc3RhdGUgPSBwcm5nX25ld3N0YXRlKCk7XG5cdFx0cm5nX3N0YXRlLmluaXQocm5nX3Bvb2wpO1xuXHRcdGZvcihybmdfcHB0ciA9IDA7IHJuZ19wcHRyIDwgcm5nX3Bvb2wubGVuZ3RoOyArK3JuZ19wcHRyKVxuXHRcdCAgcm5nX3Bvb2xbcm5nX3BwdHJdID0gMDtcblx0XHRybmdfcHB0ciA9IDA7XG5cdFx0Ly9ybmdfcG9vbCA9IG51bGw7XG5cdCAgfVxuXHQgIC8vIFRPRE86IGFsbG93IHJlc2VlZGluZyBhZnRlciBmaXJzdCByZXF1ZXN0XG5cdCAgcmV0dXJuIHJuZ19zdGF0ZS5uZXh0KCk7XG5cdH1cblxuXHRmdW5jdGlvbiBybmdfZ2V0X2J5dGVzKGJhKSB7XG5cdCAgdmFyIGk7XG5cdCAgZm9yKGkgPSAwOyBpIDwgYmEubGVuZ3RoOyArK2kpIGJhW2ldID0gcm5nX2dldF9ieXRlKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBTZWN1cmVSYW5kb20oKSB7fVxuXG5cdFNlY3VyZVJhbmRvbS5wcm90b3R5cGUubmV4dEJ5dGVzID0gcm5nX2dldF9ieXRlcztcblxuXHQvLyBwcm5nNC5qcyAtIHVzZXMgQXJjZm91ciBhcyBhIFBSTkdcblxuXHRmdW5jdGlvbiBBcmNmb3VyKCkge1xuXHQgIHRoaXMuaSA9IDA7XG5cdCAgdGhpcy5qID0gMDtcblx0ICB0aGlzLlMgPSBuZXcgQXJyYXkoKTtcblx0fVxuXG5cdC8vIEluaXRpYWxpemUgYXJjZm91ciBjb250ZXh0IGZyb20ga2V5LCBhbiBhcnJheSBvZiBpbnRzLCBlYWNoIGZyb20gWzAuLjI1NV1cblx0ZnVuY3Rpb24gQVJDNGluaXQoa2V5KSB7XG5cdCAgdmFyIGksIGosIHQ7XG5cdCAgZm9yKGkgPSAwOyBpIDwgMjU2OyArK2kpXG5cdFx0dGhpcy5TW2ldID0gaTtcblx0ICBqID0gMDtcblx0ICBmb3IoaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuXHRcdGogPSAoaiArIHRoaXMuU1tpXSArIGtleVtpICUga2V5Lmxlbmd0aF0pICYgMjU1O1xuXHRcdHQgPSB0aGlzLlNbaV07XG5cdFx0dGhpcy5TW2ldID0gdGhpcy5TW2pdO1xuXHRcdHRoaXMuU1tqXSA9IHQ7XG5cdCAgfVxuXHQgIHRoaXMuaSA9IDA7XG5cdCAgdGhpcy5qID0gMDtcblx0fVxuXG5cdGZ1bmN0aW9uIEFSQzRuZXh0KCkge1xuXHQgIHZhciB0O1xuXHQgIHRoaXMuaSA9ICh0aGlzLmkgKyAxKSAmIDI1NTtcblx0ICB0aGlzLmogPSAodGhpcy5qICsgdGhpcy5TW3RoaXMuaV0pICYgMjU1O1xuXHQgIHQgPSB0aGlzLlNbdGhpcy5pXTtcblx0ICB0aGlzLlNbdGhpcy5pXSA9IHRoaXMuU1t0aGlzLmpdO1xuXHQgIHRoaXMuU1t0aGlzLmpdID0gdDtcblx0ICByZXR1cm4gdGhpcy5TWyh0ICsgdGhpcy5TW3RoaXMuaV0pICYgMjU1XTtcblx0fVxuXG5cdEFyY2ZvdXIucHJvdG90eXBlLmluaXQgPSBBUkM0aW5pdDtcblx0QXJjZm91ci5wcm90b3R5cGUubmV4dCA9IEFSQzRuZXh0O1xuXG5cdC8vIFBsdWcgaW4geW91ciBSTkcgY29uc3RydWN0b3IgaGVyZVxuXHRmdW5jdGlvbiBwcm5nX25ld3N0YXRlKCkge1xuXHQgIHJldHVybiBuZXcgQXJjZm91cigpO1xuXHR9XG5cblx0Ly8gUG9vbCBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0IGFuZCBncmVhdGVyIHRoYW4gMzIuXG5cdC8vIEFuIGFycmF5IG9mIGJ5dGVzIHRoZSBzaXplIG9mIHRoZSBwb29sIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKVxuXHR2YXIgcm5nX3BzaXplID0gMjU2O1xuXG4gIEJpZ0ludGVnZXIuU2VjdXJlUmFuZG9tID0gU2VjdXJlUmFuZG9tO1xuICBCaWdJbnRlZ2VyLkJpZ0ludGVnZXIgPSBCaWdJbnRlZ2VyO1xuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQmlnSW50ZWdlcjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLkJpZ0ludGVnZXIgPSBCaWdJbnRlZ2VyO1xuICAgIHRoaXMuU2VjdXJlUmFuZG9tID0gU2VjdXJlUmFuZG9tO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZVxufTtcblxudHJhdmVyc2UuYXJyYXlLZXl3b3JkcyA9IHtcbiAgaXRlbXM6IHRydWUsXG4gIGFsbE9mOiB0cnVlLFxuICBhbnlPZjogdHJ1ZSxcbiAgb25lT2Y6IHRydWVcbn07XG5cbnRyYXZlcnNlLnByb3BzS2V5d29yZHMgPSB7XG4gIGRlZmluaXRpb25zOiB0cnVlLFxuICBwcm9wZXJ0aWVzOiB0cnVlLFxuICBwYXR0ZXJuUHJvcGVydGllczogdHJ1ZSxcbiAgZGVwZW5kZW5jaWVzOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5za2lwS2V5d29yZHMgPSB7XG4gIGRlZmF1bHQ6IHRydWUsXG4gIGVudW06IHRydWUsXG4gIGNvbnN0OiB0cnVlLFxuICByZXF1aXJlZDogdHJ1ZSxcbiAgbWF4aW11bTogdHJ1ZSxcbiAgbWluaW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWF4aW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWluaW11bTogdHJ1ZSxcbiAgbXVsdGlwbGVPZjogdHJ1ZSxcbiAgbWF4TGVuZ3RoOiB0cnVlLFxuICBtaW5MZW5ndGg6IHRydWUsXG4gIHBhdHRlcm46IHRydWUsXG4gIGZvcm1hdDogdHJ1ZSxcbiAgbWF4SXRlbXM6IHRydWUsXG4gIG1pbkl0ZW1zOiB0cnVlLFxuICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgbWF4UHJvcGVydGllczogdHJ1ZSxcbiAgbWluUHJvcGVydGllczogdHJ1ZVxufTtcblxuXG5mdW5jdGlvbiBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpIHtcbiAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBwcmUoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICB2YXIgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdHJhdmVyc2UuYXJyYXlLZXl3b3Jkcykge1xuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzY2gubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbaV0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBpLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLnByb3BzS2V5d29yZHMpIHtcbiAgICAgICAgaWYgKHNjaCAmJiB0eXBlb2Ygc2NoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzY2gpXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbcHJvcF0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBlc2NhcGVKc29uUHRyKHByb3ApLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLmtleXdvcmRzIHx8IChvcHRzLmFsbEtleXMgJiYgIShrZXkgaW4gdHJhdmVyc2Uuc2tpcEtleXdvcmRzKSkpIHtcbiAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoLCBqc29uUHRyICsgJy8nICsga2V5LCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvc3Qoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZUpzb25QdHIoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG59XG4iLCIvKipcbiAqIEpTT05TY2hlbWEgVmFsaWRhdG9yIC0gVmFsaWRhdGVzIEphdmFTY3JpcHQgb2JqZWN0cyB1c2luZyBKU09OIFNjaGVtYXNcbiAqXHQoaHR0cDovL3d3dy5qc29uLmNvbS9qc29uLXNjaGVtYS1wcm9wb3NhbC8pXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA3IEtyaXMgWnlwIFNpdGVQZW4gKHd3dy5zaXRlcGVuLmNvbSlcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgKE1JVC1MSUNFTlNFLnR4dCkgbGljZW5zZS5cblRvIHVzZSB0aGUgdmFsaWRhdG9yIGNhbGwgdGhlIHZhbGlkYXRlIGZ1bmN0aW9uIHdpdGggYW4gaW5zdGFuY2Ugb2JqZWN0IGFuZCBhbiBvcHRpb25hbCBzY2hlbWEgb2JqZWN0LlxuSWYgYSBzY2hlbWEgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZS4gSWYgdGhlIGluc3RhbmNlIG9iamVjdCByZWZlcnMgdG8gYSBzY2hlbWEgKHNlbGYtdmFsaWRhdGluZyksXG50aGF0IHNjaGVtYSB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgYW5kIHRoZSBzY2hlbWEgcGFyYW1ldGVyIGlzIG5vdCBuZWNlc3NhcnkgKGlmIGJvdGggZXhpc3QsXG5ib3RoIHZhbGlkYXRpb25zIHdpbGwgb2NjdXIpLlxuVGhlIHZhbGlkYXRlIG1ldGhvZCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9ycy4gSWYgdGhlcmUgYXJlIG5vIGVycm9ycywgdGhlbiBhblxuZW1wdHkgbGlzdCB3aWxsIGJlIHJldHVybmVkLiBBIHZhbGlkYXRpb24gZXJyb3Igd2lsbCBoYXZlIHR3byBwcm9wZXJ0aWVzOlxuXCJwcm9wZXJ0eVwiIHdoaWNoIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0eSBoYWQgdGhlIGVycm9yXG5cIm1lc3NhZ2VcIiB3aGljaCBpbmRpY2F0ZXMgd2hhdCB0aGUgZXJyb3Igd2FzXG4gKi9cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgIC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICAvLyBsaWtlIE5vZGUuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgICAgICByb290Lmpzb25TY2hlbWEgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7Ly8gc2V0dXAgcHJpbWl0aXZlIGNsYXNzZXMgdG8gYmUgSlNPTiBTY2hlbWEgdHlwZXNcbnZhciBleHBvcnRzID0gdmFsaWRhdGVcbmV4cG9ydHMuSW50ZWdlciA9IHt0eXBlOlwiaW50ZWdlclwifTtcbnZhciBwcmltaXRpdmVDb25zdHJ1Y3RvcnMgPSB7XG5cdFN0cmluZzogU3RyaW5nLFxuXHRCb29sZWFuOiBCb29sZWFuLFxuXHROdW1iZXI6IE51bWJlcixcblx0T2JqZWN0OiBPYmplY3QsXG5cdEFycmF5OiBBcnJheSxcblx0RGF0ZTogRGF0ZVxufVxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuZnVuY3Rpb24gdmFsaWRhdGUoLypBbnkqL2luc3RhbmNlLC8qT2JqZWN0Ki9zY2hlbWEpIHtcblx0XHQvLyBTdW1tYXJ5OlxuXHRcdC8vICBcdFRvIHVzZSB0aGUgdmFsaWRhdG9yIGNhbGwgSlNPTlNjaGVtYS52YWxpZGF0ZSB3aXRoIGFuIGluc3RhbmNlIG9iamVjdCBhbmQgYW4gb3B0aW9uYWwgc2NoZW1hIG9iamVjdC5cblx0XHQvLyBcdFx0SWYgYSBzY2hlbWEgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZS4gSWYgdGhlIGluc3RhbmNlIG9iamVjdCByZWZlcnMgdG8gYSBzY2hlbWEgKHNlbGYtdmFsaWRhdGluZyksXG5cdFx0Ly8gXHRcdHRoYXQgc2NoZW1hIHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdGhlIHNjaGVtYSBwYXJhbWV0ZXIgaXMgbm90IG5lY2Vzc2FyeSAoaWYgYm90aCBleGlzdCxcblx0XHQvLyBcdFx0Ym90aCB2YWxpZGF0aW9ucyB3aWxsIG9jY3VyKS5cblx0XHQvLyBcdFx0VGhlIHZhbGlkYXRlIG1ldGhvZCB3aWxsIHJldHVybiBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczpcblx0XHQvLyBcdFx0XHR2YWxpZDogQSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIGluc3RhbmNlIGlzIHZhbGlkIGJ5IHRoZSBzY2hlbWFcblx0XHQvLyBcdFx0XHRlcnJvcnM6IEFuIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzLiBJZiB0aGVyZSBhcmUgbm8gZXJyb3JzLCB0aGVuIGFuXG5cdFx0Ly8gXHRcdFx0XHRcdGVtcHR5IGxpc3Qgd2lsbCBiZSByZXR1cm5lZC4gQSB2YWxpZGF0aW9uIGVycm9yIHdpbGwgaGF2ZSB0d28gcHJvcGVydGllczpcblx0XHQvLyBcdFx0XHRcdFx0XHRwcm9wZXJ0eTogd2hpY2ggaW5kaWNhdGVzIHdoaWNoIHByb3BlcnR5IGhhZCB0aGUgZXJyb3Jcblx0XHQvLyBcdFx0XHRcdFx0XHRtZXNzYWdlOiB3aGljaCBpbmRpY2F0ZXMgd2hhdCB0aGUgZXJyb3Igd2FzXG5cdFx0Ly9cblx0XHRyZXR1cm4gdmFsaWRhdGUoaW5zdGFuY2UsIHNjaGVtYSwge2NoYW5naW5nOiBmYWxzZX0pOy8vLCBjb2VyY2U6IGZhbHNlLCBleGlzdGluZ09ubHk6IGZhbHNlfSk7XG5cdH07XG5leHBvcnRzLmNoZWNrUHJvcGVydHlDaGFuZ2UgPSBmdW5jdGlvbigvKkFueSovdmFsdWUsLypPYmplY3QqL3NjaGVtYSwgLypTdHJpbmcqL3Byb3BlcnR5KSB7XG5cdFx0Ly8gU3VtbWFyeTpcblx0XHQvLyBcdFx0VGhlIGNoZWNrUHJvcGVydHlDaGFuZ2UgbWV0aG9kIHdpbGwgY2hlY2sgdG8gc2VlIGlmIGFuIHZhbHVlIGNhbiBsZWdhbGx5IGJlIGluIHByb3BlcnR5IHdpdGggdGhlIGdpdmVuIHNjaGVtYVxuXHRcdC8vIFx0XHRUaGlzIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIHRoZSB2YWxpZGF0ZSBtZXRob2QgaW4gdGhhdCBpdCB3aWxsIGZhaWwgaWYgdGhlIHNjaGVtYSBpcyByZWFkb25seSBhbmQgaXQgd2lsbFxuXHRcdC8vIFx0XHRub3QgY2hlY2sgZm9yIHNlbGYtdmFsaWRhdGlvbiwgaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwYXNzZWQgaW4gdmFsdWUgaXMgYWxyZWFkeSBpbnRlcm5hbGx5IHZhbGlkLlxuXHRcdC8vIFx0XHRUaGUgY2hlY2tQcm9wZXJ0eUNoYW5nZSBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWUgb2JqZWN0IHR5cGUgYXMgdmFsaWRhdGUsIHNlZSBKU09OU2NoZW1hLnZhbGlkYXRlIGZvclxuXHRcdC8vIFx0XHRpbmZvcm1hdGlvbi5cblx0XHQvL1xuXHRcdHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgc2NoZW1hLCB7Y2hhbmdpbmc6IHByb3BlcnR5IHx8IFwicHJvcGVydHlcIn0pO1xuXHR9O1xudmFyIHZhbGlkYXRlID0gZXhwb3J0cy5fdmFsaWRhdGUgPSBmdW5jdGlvbigvKkFueSovaW5zdGFuY2UsLypPYmplY3QqL3NjaGVtYSwvKk9iamVjdCovb3B0aW9ucykge1xuXG5cdGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuXHR2YXIgX2NoYW5naW5nID0gb3B0aW9ucy5jaGFuZ2luZztcblxuXHRmdW5jdGlvbiBnZXRUeXBlKHNjaGVtYSl7XG5cdFx0cmV0dXJuIHNjaGVtYS50eXBlIHx8IChwcmltaXRpdmVDb25zdHJ1Y3RvcnNbc2NoZW1hLm5hbWVdID09IHNjaGVtYSAmJiBzY2hlbWEubmFtZS50b0xvd2VyQ2FzZSgpKTtcblx0fVxuXHR2YXIgZXJyb3JzID0gW107XG5cdC8vIHZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHByb3BlcnR5IGRlZmluaXRpb25cblx0ZnVuY3Rpb24gY2hlY2tQcm9wKHZhbHVlLCBzY2hlbWEsIHBhdGgsaSl7XG5cblx0XHR2YXIgbDtcblx0XHRwYXRoICs9IHBhdGggPyB0eXBlb2YgaSA9PSAnbnVtYmVyJyA/ICdbJyArIGkgKyAnXScgOiB0eXBlb2YgaSA9PSAndW5kZWZpbmVkJyA/ICcnIDogJy4nICsgaSA6IGk7XG5cdFx0ZnVuY3Rpb24gYWRkRXJyb3IobWVzc2FnZSl7XG5cdFx0XHRlcnJvcnMucHVzaCh7cHJvcGVydHk6cGF0aCxtZXNzYWdlOm1lc3NhZ2V9KTtcblx0XHR9XG5cblx0XHRpZigodHlwZW9mIHNjaGVtYSAhPSAnb2JqZWN0JyB8fCBzY2hlbWEgaW5zdGFuY2VvZiBBcnJheSkgJiYgKHBhdGggfHwgdHlwZW9mIHNjaGVtYSAhPSAnZnVuY3Rpb24nKSAmJiAhKHNjaGVtYSAmJiBnZXRUeXBlKHNjaGVtYSkpKXtcblx0XHRcdGlmKHR5cGVvZiBzY2hlbWEgPT0gJ2Z1bmN0aW9uJyl7XG5cdFx0XHRcdGlmKCEodmFsdWUgaW5zdGFuY2VvZiBzY2hlbWEpKXtcblx0XHRcdFx0XHRhZGRFcnJvcihcImlzIG5vdCBhbiBpbnN0YW5jZSBvZiB0aGUgY2xhc3MvY29uc3RydWN0b3IgXCIgKyBzY2hlbWEubmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1lbHNlIGlmKHNjaGVtYSl7XG5cdFx0XHRcdGFkZEVycm9yKFwiSW52YWxpZCBzY2hlbWEvcHJvcGVydHkgZGVmaW5pdGlvbiBcIiArIHNjaGVtYSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0aWYoX2NoYW5naW5nICYmIHNjaGVtYS5yZWFkb25seSl7XG5cdFx0XHRhZGRFcnJvcihcImlzIGEgcmVhZG9ubHkgZmllbGQsIGl0IGNhbiBub3QgYmUgY2hhbmdlZFwiKTtcblx0XHR9XG5cdFx0aWYoc2NoZW1hWydleHRlbmRzJ10peyAvLyBpZiBpdCBleHRlbmRzIGFub3RoZXIgc2NoZW1hLCBpdCBtdXN0IHBhc3MgdGhhdCBzY2hlbWEgYXMgd2VsbFxuXHRcdFx0Y2hlY2tQcm9wKHZhbHVlLHNjaGVtYVsnZXh0ZW5kcyddLHBhdGgsaSk7XG5cdFx0fVxuXHRcdC8vIHZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHR5cGUgZGVmaW5pdGlvblxuXHRcdGZ1bmN0aW9uIGNoZWNrVHlwZSh0eXBlLHZhbHVlKXtcblx0XHRcdGlmKHR5cGUpe1xuXHRcdFx0XHRpZih0eXBlb2YgdHlwZSA9PSAnc3RyaW5nJyAmJiB0eXBlICE9ICdhbnknICYmXG5cdFx0XHRcdFx0XHQodHlwZSA9PSAnbnVsbCcgPyB2YWx1ZSAhPT0gbnVsbCA6IHR5cGVvZiB2YWx1ZSAhPSB0eXBlKSAmJlxuXHRcdFx0XHRcdFx0ISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHR5cGUgPT0gJ2FycmF5JykgJiZcblx0XHRcdFx0XHRcdCEodmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIHR5cGUgPT0gJ2RhdGUnKSAmJlxuXHRcdFx0XHRcdFx0ISh0eXBlID09ICdpbnRlZ2VyJyAmJiB2YWx1ZSUxPT09MCkpe1xuXHRcdFx0XHRcdHJldHVybiBbe3Byb3BlcnR5OnBhdGgsbWVzc2FnZToodHlwZW9mIHZhbHVlKSArIFwiIHZhbHVlIGZvdW5kLCBidXQgYSBcIiArIHR5cGUgKyBcIiBpcyByZXF1aXJlZFwifV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYodHlwZSBpbnN0YW5jZW9mIEFycmF5KXtcblx0XHRcdFx0XHR2YXIgdW5pb25FcnJvcnM9W107XG5cdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IHR5cGUubGVuZ3RoOyBqKyspeyAvLyBhIHVuaW9uIHR5cGVcblx0XHRcdFx0XHRcdGlmKCEodW5pb25FcnJvcnM9Y2hlY2tUeXBlKHR5cGVbal0sdmFsdWUpKS5sZW5ndGgpe1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYodW5pb25FcnJvcnMubGVuZ3RoKXtcblx0XHRcdFx0XHRcdHJldHVybiB1bmlvbkVycm9ycztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1lbHNlIGlmKHR5cGVvZiB0eXBlID09ICdvYmplY3QnKXtcblx0XHRcdFx0XHR2YXIgcHJpb3JFcnJvcnMgPSBlcnJvcnM7XG5cdFx0XHRcdFx0ZXJyb3JzID0gW107XG5cdFx0XHRcdFx0Y2hlY2tQcm9wKHZhbHVlLHR5cGUscGF0aCk7XG5cdFx0XHRcdFx0dmFyIHRoZXNlRXJyb3JzID0gZXJyb3JzO1xuXHRcdFx0XHRcdGVycm9ycyA9IHByaW9yRXJyb3JzO1xuXHRcdFx0XHRcdHJldHVybiB0aGVzZUVycm9ycztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHRpZih2YWx1ZSA9PT0gdW5kZWZpbmVkKXtcblx0XHRcdGlmKHNjaGVtYS5yZXF1aXJlZCl7XG5cdFx0XHRcdGFkZEVycm9yKFwiaXMgbWlzc2luZyBhbmQgaXQgaXMgcmVxdWlyZWRcIik7XG5cdFx0XHR9XG5cdFx0fWVsc2V7XG5cdFx0XHRlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGNoZWNrVHlwZShnZXRUeXBlKHNjaGVtYSksdmFsdWUpKTtcblx0XHRcdGlmKHNjaGVtYS5kaXNhbGxvdyAmJiAhY2hlY2tUeXBlKHNjaGVtYS5kaXNhbGxvdyx2YWx1ZSkubGVuZ3RoKXtcblx0XHRcdFx0YWRkRXJyb3IoXCIgZGlzYWxsb3dlZCB2YWx1ZSB3YXMgbWF0Y2hlZFwiKTtcblx0XHRcdH1cblx0XHRcdGlmKHZhbHVlICE9PSBudWxsKXtcblx0XHRcdFx0aWYodmFsdWUgaW5zdGFuY2VvZiBBcnJheSl7XG5cdFx0XHRcdFx0aWYoc2NoZW1hLml0ZW1zKXtcblx0XHRcdFx0XHRcdHZhciBpdGVtc0lzQXJyYXkgPSBzY2hlbWEuaXRlbXMgaW5zdGFuY2VvZiBBcnJheTtcblx0XHRcdFx0XHRcdHZhciBwcm9wRGVmID0gc2NoZW1hLml0ZW1zO1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoaXRlbXNJc0FycmF5KVxuXHRcdFx0XHRcdFx0XHRcdHByb3BEZWYgPSBzY2hlbWEuaXRlbXNbaV07XG5cdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLmNvZXJjZSlcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZVtpXSA9IG9wdGlvbnMuY29lcmNlKHZhbHVlW2ldLCBwcm9wRGVmKTtcblx0XHRcdFx0XHRcdFx0ZXJyb3JzLmNvbmNhdChjaGVja1Byb3AodmFsdWVbaV0scHJvcERlZixwYXRoLGkpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoc2NoZW1hLm1pbkl0ZW1zICYmIHZhbHVlLmxlbmd0aCA8IHNjaGVtYS5taW5JdGVtcyl7XG5cdFx0XHRcdFx0XHRhZGRFcnJvcihcIlRoZXJlIG11c3QgYmUgYSBtaW5pbXVtIG9mIFwiICsgc2NoZW1hLm1pbkl0ZW1zICsgXCIgaW4gdGhlIGFycmF5XCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihzY2hlbWEubWF4SXRlbXMgJiYgdmFsdWUubGVuZ3RoID4gc2NoZW1hLm1heEl0ZW1zKXtcblx0XHRcdFx0XHRcdGFkZEVycm9yKFwiVGhlcmUgbXVzdCBiZSBhIG1heGltdW0gb2YgXCIgKyBzY2hlbWEubWF4SXRlbXMgKyBcIiBpbiB0aGUgYXJyYXlcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ZWxzZSBpZihzY2hlbWEucHJvcGVydGllcyB8fCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpe1xuXHRcdFx0XHRcdGVycm9ycy5jb25jYXQoY2hlY2tPYmoodmFsdWUsIHNjaGVtYS5wcm9wZXJ0aWVzLCBwYXRoLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihzY2hlbWEucGF0dGVybiAmJiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgJiYgIXZhbHVlLm1hdGNoKHNjaGVtYS5wYXR0ZXJuKSl7XG5cdFx0XHRcdFx0YWRkRXJyb3IoXCJkb2VzIG5vdCBtYXRjaCB0aGUgcmVnZXggcGF0dGVybiBcIiArIHNjaGVtYS5wYXR0ZXJuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihzY2hlbWEubWF4TGVuZ3RoICYmIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPiBzY2hlbWEubWF4TGVuZ3RoKXtcblx0XHRcdFx0XHRhZGRFcnJvcihcIm1heSBvbmx5IGJlIFwiICsgc2NoZW1hLm1heExlbmd0aCArIFwiIGNoYXJhY3RlcnMgbG9uZ1wiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihzY2hlbWEubWluTGVuZ3RoICYmIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyAmJiB2YWx1ZS5sZW5ndGggPCBzY2hlbWEubWluTGVuZ3RoKXtcblx0XHRcdFx0XHRhZGRFcnJvcihcIm11c3QgYmUgYXQgbGVhc3QgXCIgKyBzY2hlbWEubWluTGVuZ3RoICsgXCIgY2hhcmFjdGVycyBsb25nXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHR5cGVvZiBzY2hlbWEubWluaW11bSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PSB0eXBlb2Ygc2NoZW1hLm1pbmltdW0gJiZcblx0XHRcdFx0XHRcdHNjaGVtYS5taW5pbXVtID4gdmFsdWUpe1xuXHRcdFx0XHRcdGFkZEVycm9yKFwibXVzdCBoYXZlIGEgbWluaW11bSB2YWx1ZSBvZiBcIiArIHNjaGVtYS5taW5pbXVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZih0eXBlb2Ygc2NoZW1hLm1heGltdW0gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT0gdHlwZW9mIHNjaGVtYS5tYXhpbXVtICYmXG5cdFx0XHRcdFx0XHRzY2hlbWEubWF4aW11bSA8IHZhbHVlKXtcblx0XHRcdFx0XHRhZGRFcnJvcihcIm11c3QgaGF2ZSBhIG1heGltdW0gdmFsdWUgb2YgXCIgKyBzY2hlbWEubWF4aW11bSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoc2NoZW1hWydlbnVtJ10pe1xuXHRcdFx0XHRcdHZhciBlbnVtZXIgPSBzY2hlbWFbJ2VudW0nXTtcblx0XHRcdFx0XHRsID0gZW51bWVyLmxlbmd0aDtcblx0XHRcdFx0XHR2YXIgZm91bmQ7XG5cdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGw7IGorKyl7XG5cdFx0XHRcdFx0XHRpZihlbnVtZXJbal09PT12YWx1ZSl7XG5cdFx0XHRcdFx0XHRcdGZvdW5kPTE7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZighZm91bmQpe1xuXHRcdFx0XHRcdFx0YWRkRXJyb3IoXCJkb2VzIG5vdCBoYXZlIGEgdmFsdWUgaW4gdGhlIGVudW1lcmF0aW9uIFwiICsgZW51bWVyLmpvaW4oXCIsIFwiKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHR5cGVvZiBzY2hlbWEubWF4RGVjaW1hbCA9PSAnbnVtYmVyJyAmJlxuXHRcdFx0XHRcdCh2YWx1ZS50b1N0cmluZygpLm1hdGNoKG5ldyBSZWdFeHAoXCJcXFxcLlswLTlde1wiICsgKHNjaGVtYS5tYXhEZWNpbWFsICsgMSkgKyBcIix9XCIpKSkpe1xuXHRcdFx0XHRcdGFkZEVycm9yKFwibWF5IG9ubHkgaGF2ZSBcIiArIHNjaGVtYS5tYXhEZWNpbWFsICsgXCIgZGlnaXRzIG9mIGRlY2ltYWwgcGxhY2VzXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdC8vIHZhbGlkYXRlIGFuIG9iamVjdCBhZ2FpbnN0IGEgc2NoZW1hXG5cdGZ1bmN0aW9uIGNoZWNrT2JqKGluc3RhbmNlLG9ialR5cGVEZWYscGF0aCxhZGRpdGlvbmFsUHJvcCl7XG5cblx0XHRpZih0eXBlb2Ygb2JqVHlwZURlZiA9PSdvYmplY3QnKXtcblx0XHRcdGlmKHR5cGVvZiBpbnN0YW5jZSAhPSAnb2JqZWN0JyB8fCBpbnN0YW5jZSBpbnN0YW5jZW9mIEFycmF5KXtcblx0XHRcdFx0ZXJyb3JzLnB1c2goe3Byb3BlcnR5OnBhdGgsbWVzc2FnZTpcImFuIG9iamVjdCBpcyByZXF1aXJlZFwifSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGZvcih2YXIgaSBpbiBvYmpUeXBlRGVmKXsgXG5cdFx0XHRcdGlmKG9ialR5cGVEZWYuaGFzT3duUHJvcGVydHkoaSkpe1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IGluc3RhbmNlW2ldO1xuXHRcdFx0XHRcdC8vIHNraXAgX25vdF8gc3BlY2lmaWVkIHByb3BlcnRpZXNcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmV4aXN0aW5nT25seSkgY29udGludWU7XG5cdFx0XHRcdFx0dmFyIHByb3BEZWYgPSBvYmpUeXBlRGVmW2ldO1xuXHRcdFx0XHRcdC8vIHNldCBkZWZhdWx0XG5cdFx0XHRcdFx0aWYodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwcm9wRGVmW1wiZGVmYXVsdFwiXSl7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGluc3RhbmNlW2ldID0gcHJvcERlZltcImRlZmF1bHRcIl07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKG9wdGlvbnMuY29lcmNlICYmIGkgaW4gaW5zdGFuY2Upe1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBpbnN0YW5jZVtpXSA9IG9wdGlvbnMuY29lcmNlKHZhbHVlLCBwcm9wRGVmKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hlY2tQcm9wKHZhbHVlLHByb3BEZWYscGF0aCxpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IoaSBpbiBpbnN0YW5jZSl7XG5cdFx0XHRpZihpbnN0YW5jZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhKGkuY2hhckF0KDApID09ICdfJyAmJiBpLmNoYXJBdCgxKSA9PSAnXycpICYmIG9ialR5cGVEZWYgJiYgIW9ialR5cGVEZWZbaV0gJiYgYWRkaXRpb25hbFByb3A9PT1mYWxzZSl7XG5cdFx0XHRcdGlmIChvcHRpb25zLmZpbHRlcikge1xuXHRcdFx0XHRcdGRlbGV0ZSBpbnN0YW5jZVtpXTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlcnJvcnMucHVzaCh7cHJvcGVydHk6cGF0aCxtZXNzYWdlOih0eXBlb2YgdmFsdWUpICsgXCJUaGUgcHJvcGVydHkgXCIgKyBpICtcblx0XHRcdFx0XHRcdFwiIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBzY2hlbWEgYW5kIHRoZSBzY2hlbWEgZG9lcyBub3QgYWxsb3cgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXCJ9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIHJlcXVpcmVzID0gb2JqVHlwZURlZiAmJiBvYmpUeXBlRGVmW2ldICYmIG9ialR5cGVEZWZbaV0ucmVxdWlyZXM7XG5cdFx0XHRpZihyZXF1aXJlcyAmJiAhKHJlcXVpcmVzIGluIGluc3RhbmNlKSl7XG5cdFx0XHRcdGVycm9ycy5wdXNoKHtwcm9wZXJ0eTpwYXRoLG1lc3NhZ2U6XCJ0aGUgcHJlc2VuY2Ugb2YgdGhlIHByb3BlcnR5IFwiICsgaSArIFwiIHJlcXVpcmVzIHRoYXQgXCIgKyByZXF1aXJlcyArIFwiIGFsc28gYmUgcHJlc2VudFwifSk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IGluc3RhbmNlW2ldO1xuXHRcdFx0aWYoYWRkaXRpb25hbFByb3AgJiYgKCEob2JqVHlwZURlZiAmJiB0eXBlb2Ygb2JqVHlwZURlZiA9PSAnb2JqZWN0JykgfHwgIShpIGluIG9ialR5cGVEZWYpKSl7XG5cdFx0XHRcdGlmKG9wdGlvbnMuY29lcmNlKXtcblx0XHRcdFx0XHR2YWx1ZSA9IGluc3RhbmNlW2ldID0gb3B0aW9ucy5jb2VyY2UodmFsdWUsIGFkZGl0aW9uYWxQcm9wKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGVja1Byb3AodmFsdWUsYWRkaXRpb25hbFByb3AscGF0aCxpKTtcblx0XHRcdH1cblx0XHRcdGlmKCFfY2hhbmdpbmcgJiYgdmFsdWUgJiYgdmFsdWUuJHNjaGVtYSl7XG5cdFx0XHRcdGVycm9ycyA9IGVycm9ycy5jb25jYXQoY2hlY2tQcm9wKHZhbHVlLHZhbHVlLiRzY2hlbWEscGF0aCxpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlcnJvcnM7XG5cdH1cblx0aWYoc2NoZW1hKXtcblx0XHRjaGVja1Byb3AoaW5zdGFuY2Usc2NoZW1hLCcnLF9jaGFuZ2luZyB8fCAnJyk7XG5cdH1cblx0aWYoIV9jaGFuZ2luZyAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS4kc2NoZW1hKXtcblx0XHRjaGVja1Byb3AoaW5zdGFuY2UsaW5zdGFuY2UuJHNjaGVtYSwnJywnJyk7XG5cdH1cblx0cmV0dXJuIHt2YWxpZDohZXJyb3JzLmxlbmd0aCxlcnJvcnM6ZXJyb3JzfTtcbn07XG5leHBvcnRzLm11c3RCZVZhbGlkID0gZnVuY3Rpb24ocmVzdWx0KXtcblx0Ly9cdHN1bW1hcnk6XG5cdC8vXHRcdFRoaXMgY2hlY2tzIHRvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgaXMgdmFsaWQgYW5kIHdpbGwgdGhyb3cgYW4gYXBwcm9wcmlhdGUgZXJyb3IgbWVzc2FnZSBpZiBpdCBpcyBub3Rcblx0Ly8gcmVzdWx0OiB0aGUgcmVzdWx0IHJldHVybmVkIGZyb20gY2hlY2tQcm9wZXJ0eUNoYW5nZSBvciB2YWxpZGF0ZVxuXHRpZighcmVzdWx0LnZhbGlkKXtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKHJlc3VsdC5lcnJvcnMubWFwKGZ1bmN0aW9uKGVycm9yKXtyZXR1cm4gXCJmb3IgcHJvcGVydHkgXCIgKyBlcnJvci5wcm9wZXJ0eSArICc6ICcgKyBlcnJvci5tZXNzYWdlO30pLmpvaW4oXCIsIFxcblwiKSk7XG5cdH1cbn1cblxucmV0dXJuIGV4cG9ydHM7XG59KSk7XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbmV4cG9ydHMuZ2V0U2VyaWFsaXplID0gc2VyaWFsaXplclxuXG5mdW5jdGlvbiBzdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VzLCBjeWNsZVJlcGxhY2VyKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIHNlcmlhbGl6ZXIocmVwbGFjZXIsIGN5Y2xlUmVwbGFjZXIpLCBzcGFjZXMpXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZXIocmVwbGFjZXIsIGN5Y2xlUmVwbGFjZXIpIHtcbiAgdmFyIHN0YWNrID0gW10sIGtleXMgPSBbXVxuXG4gIGlmIChjeWNsZVJlcGxhY2VyID09IG51bGwpIGN5Y2xlUmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkgcmV0dXJuIFwiW0NpcmN1bGFyIH5dXCJcbiAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCJcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKVxuICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKVxuICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpXG4gICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB2YWx1ZSA9IGN5Y2xlUmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKVxuICAgIH1cbiAgICBlbHNlIHN0YWNrLnB1c2godmFsdWUpXG5cbiAgICByZXR1cm4gcmVwbGFjZXIgPT0gbnVsbCA/IHZhbHVlIDogcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKVxuICB9XG59XG4iLCIvKlxuICogbGliL2pzcHJpbS5qczogdXRpbGl0aWVzIGZvciBwcmltaXRpdmUgSmF2YVNjcmlwdCB0eXBlc1xuICovXG5cbnZhciBtb2RfYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBtb2RfdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIG1vZF9leHRzcHJpbnRmID0gcmVxdWlyZSgnZXh0c3ByaW50ZicpO1xudmFyIG1vZF92ZXJyb3IgPSByZXF1aXJlKCd2ZXJyb3InKTtcbnZhciBtb2RfanNvbnNjaGVtYSA9IHJlcXVpcmUoJ2pzb24tc2NoZW1hJyk7XG5cbi8qXG4gKiBQdWJsaWMgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydHMuZGVlcENvcHkgPSBkZWVwQ29weTtcbmV4cG9ydHMuZGVlcEVxdWFsID0gZGVlcEVxdWFsO1xuZXhwb3J0cy5pc0VtcHR5ID0gaXNFbXB0eTtcbmV4cG9ydHMuaGFzS2V5ID0gaGFzS2V5O1xuZXhwb3J0cy5mb3JFYWNoS2V5ID0gZm9yRWFjaEtleTtcbmV4cG9ydHMucGx1Y2sgPSBwbHVjaztcbmV4cG9ydHMuZmxhdHRlbk9iamVjdCA9IGZsYXR0ZW5PYmplY3Q7XG5leHBvcnRzLmZsYXR0ZW5JdGVyID0gZmxhdHRlbkl0ZXI7XG5leHBvcnRzLnZhbGlkYXRlSnNvbk9iamVjdCA9IHZhbGlkYXRlSnNvbk9iamVjdEpTO1xuZXhwb3J0cy52YWxpZGF0ZUpzb25PYmplY3RKUyA9IHZhbGlkYXRlSnNvbk9iamVjdEpTO1xuZXhwb3J0cy5yYW5kRWx0ID0gcmFuZEVsdDtcbmV4cG9ydHMuZXh0cmFQcm9wZXJ0aWVzID0gZXh0cmFQcm9wZXJ0aWVzO1xuZXhwb3J0cy5tZXJnZU9iamVjdHMgPSBtZXJnZU9iamVjdHM7XG5cbmV4cG9ydHMuc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG5leHBvcnRzLmVuZHNXaXRoID0gZW5kc1dpdGg7XG5cbmV4cG9ydHMucGFyc2VJbnRlZ2VyID0gcGFyc2VJbnRlZ2VyO1xuXG5leHBvcnRzLmlzbzg2MDEgPSBpc284NjAxO1xuZXhwb3J0cy5yZmMxMTIzID0gcmZjMTEyMztcbmV4cG9ydHMucGFyc2VEYXRlVGltZSA9IHBhcnNlRGF0ZVRpbWU7XG5cbmV4cG9ydHMuaHJ0aW1lZGlmZiA9IGhydGltZURpZmY7XG5leHBvcnRzLmhydGltZURpZmYgPSBocnRpbWVEaWZmO1xuZXhwb3J0cy5ocnRpbWVBY2N1bSA9IGhydGltZUFjY3VtO1xuZXhwb3J0cy5ocnRpbWVBZGQgPSBocnRpbWVBZGQ7XG5leHBvcnRzLmhydGltZU5hbm9zZWMgPSBocnRpbWVOYW5vc2VjO1xuZXhwb3J0cy5ocnRpbWVNaWNyb3NlYyA9IGhydGltZU1pY3Jvc2VjO1xuZXhwb3J0cy5ocnRpbWVNaWxsaXNlYyA9IGhydGltZU1pbGxpc2VjO1xuXG5cbi8qXG4gKiBEZWVwIGNvcHkgYW4gYWN5Y2xpYyAqYmFzaWMqIEphdmFzY3JpcHQgb2JqZWN0LiAgVGhpcyBvbmx5IGhhbmRsZXMgYmFzaWNcbiAqIHNjYWxhcnMgKHN0cmluZ3MsIG51bWJlcnMsIGJvb2xlYW5zKSBhbmQgYXJiaXRyYXJpbHkgZGVlcCBhcnJheXMgYW5kIG9iamVjdHNcbiAqIGNvbnRhaW5pbmcgdGhlc2UuICBUaGlzIGRvZXMgKm5vdCogaGFuZGxlIGluc3RhbmNlcyBvZiBvdGhlciBjbGFzc2VzLlxuICovXG5mdW5jdGlvbiBkZWVwQ29weShvYmopXG57XG5cdHZhciByZXQsIGtleTtcblx0dmFyIG1hcmtlciA9ICdfX2RlZXBDb3B5JztcblxuXHRpZiAob2JqICYmIG9ialttYXJrZXJdKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ2F0dGVtcHRlZCBkZWVwIGNvcHkgb2YgY3ljbGljIG9iamVjdCcpKTtcblxuXHRpZiAob2JqICYmIG9iai5jb25zdHJ1Y3RvciA9PSBPYmplY3QpIHtcblx0XHRyZXQgPSB7fTtcblx0XHRvYmpbbWFya2VyXSA9IHRydWU7XG5cblx0XHRmb3IgKGtleSBpbiBvYmopIHtcblx0XHRcdGlmIChrZXkgPT0gbWFya2VyKVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0cmV0W2tleV0gPSBkZWVwQ29weShvYmpba2V5XSk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIChvYmpbbWFya2VyXSk7XG5cdFx0cmV0dXJuIChyZXQpO1xuXHR9XG5cblx0aWYgKG9iaiAmJiBvYmouY29uc3RydWN0b3IgPT0gQXJyYXkpIHtcblx0XHRyZXQgPSBbXTtcblx0XHRvYmpbbWFya2VyXSA9IHRydWU7XG5cblx0XHRmb3IgKGtleSA9IDA7IGtleSA8IG9iai5sZW5ndGg7IGtleSsrKVxuXHRcdFx0cmV0LnB1c2goZGVlcENvcHkob2JqW2tleV0pKTtcblxuXHRcdGRlbGV0ZSAob2JqW21hcmtlcl0pO1xuXHRcdHJldHVybiAocmV0KTtcblx0fVxuXG5cdC8qXG5cdCAqIEl0IG11c3QgYmUgYSBwcmltaXRpdmUgdHlwZSAtLSBqdXN0IHJldHVybiBpdC5cblx0ICovXG5cdHJldHVybiAob2JqKTtcbn1cblxuZnVuY3Rpb24gZGVlcEVxdWFsKG9iajEsIG9iajIpXG57XG5cdGlmICh0eXBlb2YgKG9iajEpICE9IHR5cGVvZiAob2JqMikpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cblx0aWYgKG9iajEgPT09IG51bGwgfHwgb2JqMiA9PT0gbnVsbCB8fCB0eXBlb2YgKG9iajEpICE9ICdvYmplY3QnKVxuXHRcdHJldHVybiAob2JqMSA9PT0gb2JqMik7XG5cblx0aWYgKG9iajEuY29uc3RydWN0b3IgIT0gb2JqMi5jb25zdHJ1Y3Rvcilcblx0XHRyZXR1cm4gKGZhbHNlKTtcblxuXHR2YXIgaztcblx0Zm9yIChrIGluIG9iajEpIHtcblx0XHRpZiAoIW9iajIuaGFzT3duUHJvcGVydHkoaykpXG5cdFx0XHRyZXR1cm4gKGZhbHNlKTtcblxuXHRcdGlmICghZGVlcEVxdWFsKG9iajFba10sIG9iajJba10pKVxuXHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cdH1cblxuXHRmb3IgKGsgaW4gb2JqMikge1xuXHRcdGlmICghb2JqMS5oYXNPd25Qcm9wZXJ0eShrKSlcblx0XHRcdHJldHVybiAoZmFsc2UpO1xuXHR9XG5cblx0cmV0dXJuICh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eShvYmopXG57XG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIG9iailcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0cmV0dXJuICh0cnVlKTtcbn1cblxuZnVuY3Rpb24gaGFzS2V5KG9iaiwga2V5KVxue1xuXHRtb2RfYXNzZXJ0LmVxdWFsKHR5cGVvZiAoa2V5KSwgJ3N0cmluZycpO1xuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoS2V5KG9iaiwgY2FsbGJhY2spXG57XG5cdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRpZiAoaGFzS2V5KG9iaiwga2V5KSkge1xuXHRcdFx0Y2FsbGJhY2soa2V5LCBvYmpba2V5XSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHBsdWNrKG9iaiwga2V5KVxue1xuXHRtb2RfYXNzZXJ0LmVxdWFsKHR5cGVvZiAoa2V5KSwgJ3N0cmluZycpO1xuXHRyZXR1cm4gKHBsdWNrdihvYmosIGtleSkpO1xufVxuXG5mdW5jdGlvbiBwbHVja3Yob2JqLCBrZXkpXG57XG5cdGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIChvYmopICE9PSAnb2JqZWN0Jylcblx0XHRyZXR1cm4gKHVuZGVmaW5lZCk7XG5cblx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuXHRcdHJldHVybiAob2JqW2tleV0pO1xuXG5cdHZhciBpID0ga2V5LmluZGV4T2YoJy4nKTtcblx0aWYgKGkgPT0gLTEpXG5cdFx0cmV0dXJuICh1bmRlZmluZWQpO1xuXG5cdHZhciBrZXkxID0ga2V5LnN1YnN0cigwLCBpKTtcblx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5MSkpXG5cdFx0cmV0dXJuICh1bmRlZmluZWQpO1xuXG5cdHJldHVybiAocGx1Y2t2KG9ialtrZXkxXSwga2V5LnN1YnN0cihpICsgMSkpKTtcbn1cblxuLypcbiAqIEludm9rZSBjYWxsYmFjayhyb3cpIGZvciBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSB0aGF0IHdvdWxkIGJlIHJldHVybmVkIGJ5XG4gKiBmbGF0dGVuT2JqZWN0KGRhdGEsIGRlcHRoKS4gIFRoaXMgaXMganVzdCBsaWtlIGZsYXR0ZW5PYmplY3QoZGF0YSxcbiAqIGRlcHRoKS5mb3JFYWNoKGNhbGxiYWNrKSwgZXhjZXB0IHRoYXQgdGhlIGludGVybWVkaWF0ZSBhcnJheSBpcyBuZXZlclxuICogY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkl0ZXIoZGF0YSwgZGVwdGgsIGNhbGxiYWNrKVxue1xuXHRkb0ZsYXR0ZW5JdGVyKGRhdGEsIGRlcHRoLCBbXSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBkb0ZsYXR0ZW5JdGVyKGRhdGEsIGRlcHRoLCBhY2N1bSwgY2FsbGJhY2spXG57XG5cdHZhciBlYWNoO1xuXHR2YXIga2V5O1xuXG5cdGlmIChkZXB0aCA9PT0gMCkge1xuXHRcdGVhY2ggPSBhY2N1bS5zbGljZSgwKTtcblx0XHRlYWNoLnB1c2goZGF0YSk7XG5cdFx0Y2FsbGJhY2soZWFjaCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0bW9kX2Fzc2VydC5vayhkYXRhICE9PSBudWxsKTtcblx0bW9kX2Fzc2VydC5lcXVhbCh0eXBlb2YgKGRhdGEpLCAnb2JqZWN0Jyk7XG5cdG1vZF9hc3NlcnQuZXF1YWwodHlwZW9mIChkZXB0aCksICdudW1iZXInKTtcblx0bW9kX2Fzc2VydC5vayhkZXB0aCA+PSAwKTtcblxuXHRmb3IgKGtleSBpbiBkYXRhKSB7XG5cdFx0ZWFjaCA9IGFjY3VtLnNsaWNlKDApO1xuXHRcdGVhY2gucHVzaChrZXkpO1xuXHRcdGRvRmxhdHRlbkl0ZXIoZGF0YVtrZXldLCBkZXB0aCAtIDEsIGVhY2gsIGNhbGxiYWNrKTtcblx0fVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuT2JqZWN0KGRhdGEsIGRlcHRoKVxue1xuXHRpZiAoZGVwdGggPT09IDApXG5cdFx0cmV0dXJuIChbIGRhdGEgXSk7XG5cblx0bW9kX2Fzc2VydC5vayhkYXRhICE9PSBudWxsKTtcblx0bW9kX2Fzc2VydC5lcXVhbCh0eXBlb2YgKGRhdGEpLCAnb2JqZWN0Jyk7XG5cdG1vZF9hc3NlcnQuZXF1YWwodHlwZW9mIChkZXB0aCksICdudW1iZXInKTtcblx0bW9kX2Fzc2VydC5vayhkZXB0aCA+PSAwKTtcblxuXHR2YXIgcnYgPSBbXTtcblx0dmFyIGtleTtcblxuXHRmb3IgKGtleSBpbiBkYXRhKSB7XG5cdFx0ZmxhdHRlbk9iamVjdChkYXRhW2tleV0sIGRlcHRoIC0gMSkuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuXHRcdFx0cnYucHVzaChbIGtleSBdLmNvbmNhdChwKSk7XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gKHJ2KTtcbn1cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHByZWZpeClcbntcblx0cmV0dXJuIChzdHIuc3Vic3RyKDAsIHByZWZpeC5sZW5ndGgpID09IHByZWZpeCk7XG59XG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc3VmZml4KVxue1xuXHRyZXR1cm4gKHN0ci5zdWJzdHIoXG5cdCAgICBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCwgc3VmZml4Lmxlbmd0aCkgPT0gc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gaXNvODYwMShkKVxue1xuXHRpZiAodHlwZW9mIChkKSA9PSAnbnVtYmVyJylcblx0XHRkID0gbmV3IERhdGUoZCk7XG5cdG1vZF9hc3NlcnQub2soZC5jb25zdHJ1Y3RvciA9PT0gRGF0ZSk7XG5cdHJldHVybiAobW9kX2V4dHNwcmludGYuc3ByaW50ZignJTRkLSUwMmQtJTAyZFQlMDJkOiUwMmQ6JTAyZC4lMDNkWicsXG5cdCAgICBkLmdldFVUQ0Z1bGxZZWFyKCksIGQuZ2V0VVRDTW9udGgoKSArIDEsIGQuZ2V0VVRDRGF0ZSgpLFxuXHQgICAgZC5nZXRVVENIb3VycygpLCBkLmdldFVUQ01pbnV0ZXMoKSwgZC5nZXRVVENTZWNvbmRzKCksXG5cdCAgICBkLmdldFVUQ01pbGxpc2Vjb25kcygpKSk7XG59XG5cbnZhciBSRkMxMTIzX01PTlRIUyA9IFtcbiAgICAnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLFxuICAgICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xudmFyIFJGQzExMjNfREFZUyA9IFtcbiAgICAnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J107XG5cbmZ1bmN0aW9uIHJmYzExMjMoZGF0ZSkge1xuXHRyZXR1cm4gKG1vZF9leHRzcHJpbnRmLnNwcmludGYoJyVzLCAlMDJkICVzICUwNGQgJTAyZDolMDJkOiUwMmQgR01UJyxcblx0ICAgIFJGQzExMjNfREFZU1tkYXRlLmdldFVUQ0RheSgpXSwgZGF0ZS5nZXRVVENEYXRlKCksXG5cdCAgICBSRkMxMTIzX01PTlRIU1tkYXRlLmdldFVUQ01vbnRoKCldLCBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG5cdCAgICBkYXRlLmdldFVUQ0hvdXJzKCksIGRhdGUuZ2V0VVRDTWludXRlcygpLFxuXHQgICAgZGF0ZS5nZXRVVENTZWNvbmRzKCkpKTtcbn1cblxuLypcbiAqIFBhcnNlcyBhIGRhdGUgZXhwcmVzc2VkIGFzIGEgc3RyaW5nLCBhcyBlaXRoZXIgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlXG4gKiB0aGUgZXBvY2ggb3IgYW55IHN0cmluZyBmb3JtYXQgdGhhdCBEYXRlIGFjY2VwdHMsIGdpdmluZyBwcmVmZXJlbmNlIHRvIHRoZVxuICogZm9ybWVyIHdoZXJlIHRoZXNlIHR3byBzZXRzIG92ZXJsYXAgKGUuZy4sIHNtYWxsIG51bWJlcnMpLlxuICovXG5mdW5jdGlvbiBwYXJzZURhdGVUaW1lKHN0cilcbntcblx0Lypcblx0ICogVGhpcyBpcyBpcnJpdGF0aW5nbHkgaW1wbGljaXQsIGJ1dCBzaWduaWZpY2FudGx5IG1vcmUgY29uY2lzZSB0aGFuXG5cdCAqIGFsdGVybmF0aXZlcy4gIFRoZSBcIitzdHJcIiB3aWxsIGNvbnZlcnQgYSBzdHJpbmcgY29udGFpbmluZyBvbmx5IGFcblx0ICogbnVtYmVyIGRpcmVjdGx5IHRvIGEgTnVtYmVyLCBvciBOYU4gZm9yIG90aGVyIHN0cmluZ3MuICBUaHVzLCBpZiB0aGVcblx0ICogY29udmVyc2lvbiBzdWNjZWVkcywgd2UgdXNlIGl0ICh0aGlzIGlzIHRoZSBtaWxsaXNlY29uZHMtc2luY2UtZXBvY2hcblx0ICogY2FzZSkuICBPdGhlcndpc2UsIHdlIHBhc3MgdGhlIHN0cmluZyBkaXJlY3RseSB0byB0aGUgRGF0ZVxuXHQgKiBjb25zdHJ1Y3RvciB0byBwYXJzZS5cblx0ICovXG5cdHZhciBudW1lcmljID0gK3N0cjtcblx0aWYgKCFpc05hTihudW1lcmljKSkge1xuXHRcdHJldHVybiAobmV3IERhdGUobnVtZXJpYykpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAobmV3IERhdGUoc3RyKSk7XG5cdH1cbn1cblxuXG4vKlxuICogTnVtYmVyLipfU0FGRV9JTlRFR0VSIGlzbid0IHByZXNlbnQgYmVmb3JlIG5vZGUgdjAuMTIsIHNvIHdlIGhhcmRjb2RlXG4gKiB0aGUgRVM2IGRlZmluaXRpb25zIGhlcmUsIHdoaWxlIGFsbG93aW5nIGZvciB0aGVtIHRvIHNvbWVkYXkgYmUgaGlnaGVyLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgTUlOX1NBRkVfSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxO1xuXG5cbi8qXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNlSW50ZWdlcigpLlxuICovXG52YXIgUElfREVGQVVMVFMgPSB7XG5cdGJhc2U6IDEwLFxuXHRhbGxvd1NpZ246IHRydWUsXG5cdGFsbG93UHJlZml4OiBmYWxzZSxcblx0YWxsb3dUcmFpbGluZzogZmFsc2UsXG5cdGFsbG93SW1wcmVjaXNlOiBmYWxzZSxcblx0dHJpbVdoaXRlc3BhY2U6IGZhbHNlLFxuXHRsZWFkaW5nWmVyb0lzT2N0YWw6IGZhbHNlXG59O1xuXG52YXIgQ1BfMCA9IDB4MzA7XG52YXIgQ1BfOSA9IDB4Mzk7XG5cbnZhciBDUF9BID0gMHg0MTtcbnZhciBDUF9CID0gMHg0MjtcbnZhciBDUF9PID0gMHg0ZjtcbnZhciBDUF9UID0gMHg1NDtcbnZhciBDUF9YID0gMHg1ODtcbnZhciBDUF9aID0gMHg1YTtcblxudmFyIENQX2EgPSAweDYxO1xudmFyIENQX2IgPSAweDYyO1xudmFyIENQX28gPSAweDZmO1xudmFyIENQX3QgPSAweDc0O1xudmFyIENQX3ggPSAweDc4O1xudmFyIENQX3ogPSAweDdhO1xuXG52YXIgUElfQ09OVl9ERUMgPSAweDMwO1xudmFyIFBJX0NPTlZfVUMgPSAweDM3O1xudmFyIFBJX0NPTlZfTEMgPSAweDU3O1xuXG5cbi8qXG4gKiBBIHN0cmljdGVyIHZlcnNpb24gb2YgcGFyc2VJbnQoKSB0aGF0IHByb3ZpZGVzIG9wdGlvbnMgZm9yIGNoYW5naW5nIHdoYXRcbiAqIGlzIGFuIGFjY2VwdGFibGUgc3RyaW5nIChmb3IgZXhhbXBsZSwgZGlzYWxsb3dpbmcgdHJhaWxpbmcgY2hhcmFjdGVycykuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW50ZWdlcihzdHIsIHVvcHRzKVxue1xuXHRtb2RfYXNzZXJ0LnN0cmluZyhzdHIsICdzdHInKTtcblx0bW9kX2Fzc2VydC5vcHRpb25hbE9iamVjdCh1b3B0cywgJ29wdGlvbnMnKTtcblxuXHR2YXIgYmFzZU92ZXJyaWRlID0gZmFsc2U7XG5cdHZhciBvcHRpb25zID0gUElfREVGQVVMVFM7XG5cblx0aWYgKHVvcHRzKSB7XG5cdFx0YmFzZU92ZXJyaWRlID0gaGFzS2V5KHVvcHRzLCAnYmFzZScpO1xuXHRcdG9wdGlvbnMgPSBtZXJnZU9iamVjdHMob3B0aW9ucywgdW9wdHMpO1xuXHRcdG1vZF9hc3NlcnQubnVtYmVyKG9wdGlvbnMuYmFzZSwgJ29wdGlvbnMuYmFzZScpO1xuXHRcdG1vZF9hc3NlcnQub2sob3B0aW9ucy5iYXNlID49IDIsICdvcHRpb25zLmJhc2UgPj0gMicpO1xuXHRcdG1vZF9hc3NlcnQub2sob3B0aW9ucy5iYXNlIDw9IDM2LCAnb3B0aW9ucy5iYXNlIDw9IDM2Jyk7XG5cdFx0bW9kX2Fzc2VydC5ib29sKG9wdGlvbnMuYWxsb3dTaWduLCAnb3B0aW9ucy5hbGxvd1NpZ24nKTtcblx0XHRtb2RfYXNzZXJ0LmJvb2wob3B0aW9ucy5hbGxvd1ByZWZpeCwgJ29wdGlvbnMuYWxsb3dQcmVmaXgnKTtcblx0XHRtb2RfYXNzZXJ0LmJvb2wob3B0aW9ucy5hbGxvd1RyYWlsaW5nLFxuXHRcdCAgICAnb3B0aW9ucy5hbGxvd1RyYWlsaW5nJyk7XG5cdFx0bW9kX2Fzc2VydC5ib29sKG9wdGlvbnMuYWxsb3dJbXByZWNpc2UsXG5cdFx0ICAgICdvcHRpb25zLmFsbG93SW1wcmVjaXNlJyk7XG5cdFx0bW9kX2Fzc2VydC5ib29sKG9wdGlvbnMudHJpbVdoaXRlc3BhY2UsXG5cdFx0ICAgICdvcHRpb25zLnRyaW1XaGl0ZXNwYWNlJyk7XG5cdFx0bW9kX2Fzc2VydC5ib29sKG9wdGlvbnMubGVhZGluZ1plcm9Jc09jdGFsLFxuXHRcdCAgICAnb3B0aW9ucy5sZWFkaW5nWmVyb0lzT2N0YWwnKTtcblxuXHRcdGlmIChvcHRpb25zLmxlYWRpbmdaZXJvSXNPY3RhbCkge1xuXHRcdFx0bW9kX2Fzc2VydC5vayghYmFzZU92ZXJyaWRlLFxuXHRcdFx0ICAgICdcImJhc2VcIiBhbmQgXCJsZWFkaW5nWmVyb0lzT2N0YWxcIiBhcmUgJyArXG5cdFx0XHQgICAgJ211dHVhbGx5IGV4Y2x1c2l2ZScpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBjO1xuXHR2YXIgcGJhc2UgPSAtMTtcblx0dmFyIGJhc2UgPSBvcHRpb25zLmJhc2U7XG5cdHZhciBzdGFydDtcblx0dmFyIG11bHQgPSAxO1xuXHR2YXIgdmFsdWUgPSAwO1xuXHR2YXIgaWR4ID0gMDtcblx0dmFyIGxlbiA9IHN0ci5sZW5ndGg7XG5cblx0LyogVHJpbSBhbnkgd2hpdGVzcGFjZSBvbiB0aGUgbGVmdCBzaWRlLiAqL1xuXHRpZiAob3B0aW9ucy50cmltV2hpdGVzcGFjZSkge1xuXHRcdHdoaWxlIChpZHggPCBsZW4gJiYgaXNTcGFjZShzdHIuY2hhckNvZGVBdChpZHgpKSkge1xuXHRcdFx0KytpZHg7XG5cdFx0fVxuXHR9XG5cblx0LyogQ2hlY2sgdGhlIG51bWJlciBmb3IgYSBsZWFkaW5nIHNpZ24uICovXG5cdGlmIChvcHRpb25zLmFsbG93U2lnbikge1xuXHRcdGlmIChzdHJbaWR4XSA9PT0gJy0nKSB7XG5cdFx0XHRpZHggKz0gMTtcblx0XHRcdG11bHQgPSAtMTtcblx0XHR9IGVsc2UgaWYgKHN0cltpZHhdID09PSAnKycpIHtcblx0XHRcdGlkeCArPSAxO1xuXHRcdH1cblx0fVxuXG5cdC8qIFBhcnNlIHRoZSBiYXNlLWluZGljYXRpbmcgcHJlZml4IGlmIHRoZXJlIGlzIG9uZS4gKi9cblx0aWYgKHN0cltpZHhdID09PSAnMCcpIHtcblx0XHRpZiAob3B0aW9ucy5hbGxvd1ByZWZpeCkge1xuXHRcdFx0cGJhc2UgPSBwcmVmaXhUb0Jhc2Uoc3RyLmNoYXJDb2RlQXQoaWR4ICsgMSkpO1xuXHRcdFx0aWYgKHBiYXNlICE9PSAtMSAmJiAoIWJhc2VPdmVycmlkZSB8fCBwYmFzZSA9PT0gYmFzZSkpIHtcblx0XHRcdFx0YmFzZSA9IHBiYXNlO1xuXHRcdFx0XHRpZHggKz0gMjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocGJhc2UgPT09IC0xICYmIG9wdGlvbnMubGVhZGluZ1plcm9Jc09jdGFsKSB7XG5cdFx0XHRiYXNlID0gODtcblx0XHR9XG5cdH1cblxuXHQvKiBQYXJzZSB0aGUgYWN0dWFsIGRpZ2l0cy4gKi9cblx0Zm9yIChzdGFydCA9IGlkeDsgaWR4IDwgbGVuOyArK2lkeCkge1xuXHRcdGMgPSB0cmFuc2xhdGVEaWdpdChzdHIuY2hhckNvZGVBdChpZHgpKTtcblx0XHRpZiAoYyAhPT0gLTEgJiYgYyA8IGJhc2UpIHtcblx0XHRcdHZhbHVlICo9IGJhc2U7XG5cdFx0XHR2YWx1ZSArPSBjO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvKiBJZiB3ZSBkaWRuJ3QgcGFyc2UgYW55IGRpZ2l0cywgd2UgaGF2ZSBhbiBpbnZhbGlkIG51bWJlci4gKi9cblx0aWYgKHN0YXJ0ID09PSBpZHgpIHtcblx0XHRyZXR1cm4gKG5ldyBFcnJvcignaW52YWxpZCBudW1iZXI6ICcgKyBKU09OLnN0cmluZ2lmeShzdHIpKSk7XG5cdH1cblxuXHQvKiBUcmltIGFueSB3aGl0ZXNwYWNlIG9uIHRoZSByaWdodCBzaWRlLiAqL1xuXHRpZiAob3B0aW9ucy50cmltV2hpdGVzcGFjZSkge1xuXHRcdHdoaWxlIChpZHggPCBsZW4gJiYgaXNTcGFjZShzdHIuY2hhckNvZGVBdChpZHgpKSkge1xuXHRcdFx0KytpZHg7XG5cdFx0fVxuXHR9XG5cblx0LyogQ2hlY2sgZm9yIHRyYWlsaW5nIGNoYXJhY3RlcnMuICovXG5cdGlmIChpZHggPCBsZW4gJiYgIW9wdGlvbnMuYWxsb3dUcmFpbGluZykge1xuXHRcdHJldHVybiAobmV3IEVycm9yKCd0cmFpbGluZyBjaGFyYWN0ZXJzIGFmdGVyIG51bWJlcjogJyArXG5cdFx0ICAgIEpTT04uc3RyaW5naWZ5KHN0ci5zbGljZShpZHgpKSkpO1xuXHR9XG5cblx0LyogSWYgb3VyIHZhbHVlIGlzIDAsIHdlIHJldHVybiBub3csIHRvIGF2b2lkIHJldHVybmluZyAtMC4gKi9cblx0aWYgKHZhbHVlID09PSAwKSB7XG5cdFx0cmV0dXJuICgwKTtcblx0fVxuXG5cdC8qIENhbGN1bGF0ZSBvdXIgZmluYWwgdmFsdWUuICovXG5cdHZhciByZXN1bHQgPSB2YWx1ZSAqIG11bHQ7XG5cblx0Lypcblx0ICogSWYgdGhlIHN0cmluZyByZXByZXNlbnRzIGEgdmFsdWUgdGhhdCBjYW5ub3QgYmUgcHJlY2lzZWx5IHJlcHJlc2VudGVkXG5cdCAqIGJ5IEphdmFTY3JpcHQsIHRoZW4gd2Ugd2FudCB0byBjaGVjayB0aGF0OlxuXHQgKlxuXHQgKiAtIFdlIG5ldmVyIGluY3JlYXNlZCB0aGUgdmFsdWUgcGFzdCBNQVhfU0FGRV9JTlRFR0VSXG5cdCAqIC0gV2UgZG9uJ3QgbWFrZSB0aGUgcmVzdWx0IG5lZ2F0aXZlIGFuZCBiZWxvdyBNSU5fU0FGRV9JTlRFR0VSXG5cdCAqXG5cdCAqIEJlY2F1c2Ugd2Ugb25seSBldmVyIGluY3JlbWVudCB0aGUgdmFsdWUgZHVyaW5nIHBhcnNpbmcsIHRoZXJlJ3Mgbm9cblx0ICogY2hhbmNlIG9mIG1vdmluZyBwYXN0IE1BWF9TQUZFX0lOVEVHRVIgYW5kIHRoZW4gZHJvcHBpbmcgYmVsb3cgaXRcblx0ICogYWdhaW4sIGxvc2luZyBwcmVjaXNpb24gaW4gdGhlIHByb2Nlc3MuIFRoaXMgbWVhbnMgdGhhdCB3ZSBvbmx5IG5lZWRcblx0ICogdG8gZG8gb3VyIGNoZWNrcyBoZXJlLCBhdCB0aGUgZW5kLlxuXHQgKi9cblx0aWYgKCFvcHRpb25zLmFsbG93SW1wcmVjaXNlICYmXG5cdCAgICAodmFsdWUgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHJlc3VsdCA8IE1JTl9TQUZFX0lOVEVHRVIpKSB7XG5cdFx0cmV0dXJuIChuZXcgRXJyb3IoJ251bWJlciBpcyBvdXRzaWRlIG9mIHRoZSBzdXBwb3J0ZWQgcmFuZ2U6ICcgK1xuXHRcdCAgICBKU09OLnN0cmluZ2lmeShzdHIuc2xpY2Uoc3RhcnQsIGlkeCkpKSk7XG5cdH1cblxuXHRyZXR1cm4gKHJlc3VsdCk7XG59XG5cblxuLypcbiAqIEludGVycHJldCBhIGNoYXJhY3RlciBjb2RlIGFzIGEgYmFzZS0zNiBkaWdpdC5cbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlRGlnaXQoZClcbntcblx0aWYgKGQgPj0gQ1BfMCAmJiBkIDw9IENQXzkpIHtcblx0XHQvKiAnMCcgdG8gJzknIC0+IDAgdG8gOSAqL1xuXHRcdHJldHVybiAoZCAtIFBJX0NPTlZfREVDKTtcblx0fSBlbHNlIGlmIChkID49IENQX0EgJiYgZCA8PSBDUF9aKSB7XG5cdFx0LyogJ0EnIC0gJ1onIC0+IDEwIHRvIDM1ICovXG5cdFx0cmV0dXJuIChkIC0gUElfQ09OVl9VQyk7XG5cdH0gZWxzZSBpZiAoZCA+PSBDUF9hICYmIGQgPD0gQ1Bfeikge1xuXHRcdC8qICdhJyAtICd6JyAtPiAxMCB0byAzNSAqL1xuXHRcdHJldHVybiAoZCAtIFBJX0NPTlZfTEMpO1xuXHR9IGVsc2Uge1xuXHRcdC8qIEludmFsaWQgY2hhcmFjdGVyIGNvZGUgKi9cblx0XHRyZXR1cm4gKC0xKTtcblx0fVxufVxuXG5cbi8qXG4gKiBUZXN0IGlmIGEgdmFsdWUgbWF0Y2hlcyB0aGUgRUNNQVNjcmlwdCBkZWZpbml0aW9uIG9mIHRyaW1tYWJsZSB3aGl0ZXNwYWNlLlxuICovXG5mdW5jdGlvbiBpc1NwYWNlKGMpXG57XG5cdHJldHVybiAoYyA9PT0gMHgyMCkgfHxcblx0ICAgIChjID49IDB4MDAwOSAmJiBjIDw9IDB4MDAwZCkgfHxcblx0ICAgIChjID09PSAweDAwYTApIHx8XG5cdCAgICAoYyA9PT0gMHgxNjgwKSB8fFxuXHQgICAgKGMgPT09IDB4MTgwZSkgfHxcblx0ICAgIChjID49IDB4MjAwMCAmJiBjIDw9IDB4MjAwYSkgfHxcblx0ICAgIChjID09PSAweDIwMjgpIHx8XG5cdCAgICAoYyA9PT0gMHgyMDI5KSB8fFxuXHQgICAgKGMgPT09IDB4MjAyZikgfHxcblx0ICAgIChjID09PSAweDIwNWYpIHx8XG5cdCAgICAoYyA9PT0gMHgzMDAwKSB8fFxuXHQgICAgKGMgPT09IDB4ZmVmZik7XG59XG5cblxuLypcbiAqIERldGVybWluZSB3aGljaCBiYXNlIGEgY2hhcmFjdGVyIGluZGljYXRlcyAoZS5nLiwgJ3gnIGluZGljYXRlcyBoZXgpLlxuICovXG5mdW5jdGlvbiBwcmVmaXhUb0Jhc2UoYylcbntcblx0aWYgKGMgPT09IENQX2IgfHwgYyA9PT0gQ1BfQikge1xuXHRcdC8qIDBiLzBCIChiaW5hcnkpICovXG5cdFx0cmV0dXJuICgyKTtcblx0fSBlbHNlIGlmIChjID09PSBDUF9vIHx8IGMgPT09IENQX08pIHtcblx0XHQvKiAwby8wTyAob2N0YWwpICovXG5cdFx0cmV0dXJuICg4KTtcblx0fSBlbHNlIGlmIChjID09PSBDUF90IHx8IGMgPT09IENQX1QpIHtcblx0XHQvKiAwdC8wVCAoZGVjaW1hbCkgKi9cblx0XHRyZXR1cm4gKDEwKTtcblx0fSBlbHNlIGlmIChjID09PSBDUF94IHx8IGMgPT09IENQX1gpIHtcblx0XHQvKiAweC8wWCAoaGV4YWRlY2ltYWwpICovXG5cdFx0cmV0dXJuICgxNik7XG5cdH0gZWxzZSB7XG5cdFx0LyogTm90IGEgbWVhbmluZ2Z1bCBjaGFyYWN0ZXIgKi9cblx0XHRyZXR1cm4gKC0xKTtcblx0fVxufVxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlSnNvbk9iamVjdEpTKHNjaGVtYSwgaW5wdXQpXG57XG5cdHZhciByZXBvcnQgPSBtb2RfanNvbnNjaGVtYS52YWxpZGF0ZShpbnB1dCwgc2NoZW1hKTtcblxuXHRpZiAocmVwb3J0LmVycm9ycy5sZW5ndGggPT09IDApXG5cdFx0cmV0dXJuIChudWxsKTtcblxuXHQvKiBDdXJyZW50bHksIHdlIG9ubHkgZG8gYW55dGhpbmcgdXNlZnVsIHdpdGggdGhlIGZpcnN0IGVycm9yLiAqL1xuXHR2YXIgZXJyb3IgPSByZXBvcnQuZXJyb3JzWzBdO1xuXG5cdC8qIFRoZSBmYWlsZWQgcHJvcGVydHkgaXMgZ2l2ZW4gYnkgYSBVUkkgd2l0aCBhbiBpcnJlbGV2YW50IHByZWZpeC4gKi9cblx0dmFyIHByb3BuYW1lID0gZXJyb3JbJ3Byb3BlcnR5J107XG5cdHZhciByZWFzb24gPSBlcnJvclsnbWVzc2FnZSddLnRvTG93ZXJDYXNlKCk7XG5cdHZhciBpLCBqO1xuXG5cdC8qXG5cdCAqIFRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNhc2Ugd2hlcmUgdGhlIHByb3BlcnR5IGVycm9yIG1lc3NhZ2UgaXNcblx0ICogY29uZnVzaW5nIGF0IGJlc3QuICBXZSB3b3JrIGFyb3VuZCB0aGlzIGhlcmUuXG5cdCAqL1xuXHRpZiAoKGkgPSByZWFzb24uaW5kZXhPZigndGhlIHByb3BlcnR5ICcpKSAhPSAtMSAmJlxuXHQgICAgKGogPSByZWFzb24uaW5kZXhPZignIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBzY2hlbWEgYW5kIHRoZSAnICtcblx0ICAgICdzY2hlbWEgZG9lcyBub3QgYWxsb3cgYWRkaXRpb25hbCBwcm9wZXJ0aWVzJykpICE9IC0xKSB7XG5cdFx0aSArPSAndGhlIHByb3BlcnR5ICcubGVuZ3RoO1xuXHRcdGlmIChwcm9wbmFtZSA9PT0gJycpXG5cdFx0XHRwcm9wbmFtZSA9IHJlYXNvbi5zdWJzdHIoaSwgaiAtIGkpO1xuXHRcdGVsc2Vcblx0XHRcdHByb3BuYW1lID0gcHJvcG5hbWUgKyAnLicgKyByZWFzb24uc3Vic3RyKGksIGogLSBpKTtcblxuXHRcdHJlYXNvbiA9ICd1bnN1cHBvcnRlZCBwcm9wZXJ0eSc7XG5cdH1cblxuXHR2YXIgcnYgPSBuZXcgbW9kX3ZlcnJvci5WRXJyb3IoJ3Byb3BlcnR5IFwiJXNcIjogJXMnLCBwcm9wbmFtZSwgcmVhc29uKTtcblx0cnYuanN2X2RldGFpbHMgPSBlcnJvcjtcblx0cmV0dXJuIChydik7XG59XG5cbmZ1bmN0aW9uIHJhbmRFbHQoYXJyKVxue1xuXHRtb2RfYXNzZXJ0Lm9rKEFycmF5LmlzQXJyYXkoYXJyKSAmJiBhcnIubGVuZ3RoID4gMCxcblx0ICAgICdyYW5kRWx0IGFyZ3VtZW50IG11c3QgYmUgYSBub24tZW1wdHkgYXJyYXknKTtcblxuXHRyZXR1cm4gKGFycltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnIubGVuZ3RoKV0pO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRIcnRpbWUoYSlcbntcblx0bW9kX2Fzc2VydC5vayhhWzBdID49IDAgJiYgYVsxXSA+PSAwLFxuXHQgICAgJ25lZ2F0aXZlIG51bWJlcnMgbm90IGFsbG93ZWQgaW4gaHJ0aW1lcycpO1xuXHRtb2RfYXNzZXJ0Lm9rKGFbMV0gPCAxZTksICduYW5vc2Vjb25kcyBjb2x1bW4gb3ZlcmZsb3cnKTtcbn1cblxuLypcbiAqIENvbXB1dGUgdGhlIHRpbWUgZWxhcHNlZCBiZXR3ZWVuIGhydGltZSByZWFkaW5ncyBBIGFuZCBCLCB3aGVyZSBBIGlzIGxhdGVyXG4gKiB0aGFuIEIuICBocnRpbWUgcmVhZGluZ3MgY29tZSBmcm9tIE5vZGUncyBwcm9jZXNzLmhydGltZSgpLiAgVGhlcmUgaXMgbm9cbiAqIGRlZmluZWQgd2F5IHRvIHJlcHJlc2VudCBuZWdhdGl2ZSBkZWx0YXMsIHNvIGl0J3MgaWxsZWdhbCB0byBkaWZmIEIgZnJvbSBBXG4gKiB3aGVyZSB0aGUgdGltZSBkZW5vdGVkIGJ5IEIgaXMgbGF0ZXIgdGhhbiB0aGUgdGltZSBkZW5vdGVkIGJ5IEEuICBJZiB0aGlzXG4gKiBiZWNvbWVzIHZhbHVhYmxlLCB3ZSBjYW4gZGVmaW5lIGEgcmVwcmVzZW50YXRpb24gYW5kIGV4dGVuZCB0aGVcbiAqIGltcGxlbWVudGF0aW9uIHRvIHN1cHBvcnQgaXQuXG4gKi9cbmZ1bmN0aW9uIGhydGltZURpZmYoYSwgYilcbntcblx0YXNzZXJ0SHJ0aW1lKGEpO1xuXHRhc3NlcnRIcnRpbWUoYik7XG5cdG1vZF9hc3NlcnQub2soYVswXSA+IGJbMF0gfHwgKGFbMF0gPT0gYlswXSAmJiBhWzFdID49IGJbMV0pLFxuXHQgICAgJ25lZ2F0aXZlIGRpZmZlcmVuY2VzIG5vdCBhbGxvd2VkJyk7XG5cblx0dmFyIHJ2ID0gWyBhWzBdIC0gYlswXSwgMCBdO1xuXG5cdGlmIChhWzFdID49IGJbMV0pIHtcblx0XHRydlsxXSA9IGFbMV0gLSBiWzFdO1xuXHR9IGVsc2Uge1xuXHRcdHJ2WzBdLS07XG5cdFx0cnZbMV0gPSAxZTkgLSAoYlsxXSAtIGFbMV0pO1xuXHR9XG5cblx0cmV0dXJuIChydik7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgaHJ0aW1lIHJlYWRpbmcgZnJvbSB0aGUgYXJyYXkgZm9ybWF0IHJldHVybmVkIGJ5IE5vZGUnc1xuICogcHJvY2Vzcy5ocnRpbWUoKSBpbnRvIGEgc2NhbGFyIG51bWJlciBvZiBuYW5vc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gaHJ0aW1lTmFub3NlYyhhKVxue1xuXHRhc3NlcnRIcnRpbWUoYSk7XG5cblx0cmV0dXJuIChNYXRoLmZsb29yKGFbMF0gKiAxZTkgKyBhWzFdKSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgaHJ0aW1lIHJlYWRpbmcgZnJvbSB0aGUgYXJyYXkgZm9ybWF0IHJldHVybmVkIGJ5IE5vZGUnc1xuICogcHJvY2Vzcy5ocnRpbWUoKSBpbnRvIGEgc2NhbGFyIG51bWJlciBvZiBtaWNyb3NlY29uZHMuXG4gKi9cbmZ1bmN0aW9uIGhydGltZU1pY3Jvc2VjKGEpXG57XG5cdGFzc2VydEhydGltZShhKTtcblxuXHRyZXR1cm4gKE1hdGguZmxvb3IoYVswXSAqIDFlNiArIGFbMV0gLyAxZTMpKTtcbn1cblxuLypcbiAqIENvbnZlcnQgYSBocnRpbWUgcmVhZGluZyBmcm9tIHRoZSBhcnJheSBmb3JtYXQgcmV0dXJuZWQgYnkgTm9kZSdzXG4gKiBwcm9jZXNzLmhydGltZSgpIGludG8gYSBzY2FsYXIgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAqL1xuZnVuY3Rpb24gaHJ0aW1lTWlsbGlzZWMoYSlcbntcblx0YXNzZXJ0SHJ0aW1lKGEpO1xuXG5cdHJldHVybiAoTWF0aC5mbG9vcihhWzBdICogMWUzICsgYVsxXSAvIDFlNikpO1xufVxuXG4vKlxuICogQWRkIHR3byBocnRpbWUgcmVhZGluZ3MgQSBhbmQgQiwgb3ZlcndyaXRpbmcgQSB3aXRoIHRoZSByZXN1bHQgb2YgdGhlXG4gKiBhZGRpdGlvbi4gIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGZvciBhY2N1bXVsYXRpbmcgc2V2ZXJhbCBocnRpbWUgaW50ZXJ2YWxzXG4gKiBpbnRvIGEgY291bnRlci4gIFJldHVybnMgQS5cbiAqL1xuZnVuY3Rpb24gaHJ0aW1lQWNjdW0oYSwgYilcbntcblx0YXNzZXJ0SHJ0aW1lKGEpO1xuXHRhc3NlcnRIcnRpbWUoYik7XG5cblx0Lypcblx0ICogQWNjdW11bGF0ZSB0aGUgbmFub3NlY29uZCBjb21wb25lbnQuXG5cdCAqL1xuXHRhWzFdICs9IGJbMV07XG5cdGlmIChhWzFdID49IDFlOSkge1xuXHRcdC8qXG5cdFx0ICogVGhlIG5hbm9zZWNvbmQgY29tcG9uZW50IG92ZXJmbG93ZWQsIHNvIGNhcnJ5IHRvIHRoZSBzZWNvbmRzXG5cdFx0ICogZmllbGQuXG5cdFx0ICovXG5cdFx0YVswXSsrO1xuXHRcdGFbMV0gLT0gMWU5O1xuXHR9XG5cblx0Lypcblx0ICogQWNjdW11bGF0ZSB0aGUgc2Vjb25kcyBjb21wb25lbnQuXG5cdCAqL1xuXHRhWzBdICs9IGJbMF07XG5cblx0cmV0dXJuIChhKTtcbn1cblxuLypcbiAqIEFkZCB0d28gaHJ0aW1lIHJlYWRpbmdzIEEgYW5kIEIsIHJldHVybmluZyB0aGUgcmVzdWx0IGFzIGEgbmV3IGhydGltZSBhcnJheS5cbiAqIERvZXMgbm90IG1vZGlmeSBlaXRoZXIgaW5wdXQgYXJndW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGhydGltZUFkZChhLCBiKVxue1xuXHRhc3NlcnRIcnRpbWUoYSk7XG5cblx0dmFyIHJ2ID0gWyBhWzBdLCBhWzFdIF07XG5cblx0cmV0dXJuIChocnRpbWVBY2N1bShydiwgYikpO1xufVxuXG5cbi8qXG4gKiBDaGVjayBhbiBvYmplY3QgZm9yIHVuZXhwZWN0ZWQgcHJvcGVydGllcy4gIEFjY2VwdHMgdGhlIG9iamVjdCB0byBjaGVjaywgYW5kXG4gKiBhbiBhcnJheSBvZiBhbGxvd2VkIHByb3BlcnR5IG5hbWVzIChzdHJpbmdzKS4gIFJldHVybnMgYW4gYXJyYXkgb2Yga2V5IG5hbWVzXG4gKiB0aGF0IHdlcmUgZm91bmQgb24gdGhlIG9iamVjdCwgYnV0IGRpZCBub3QgYXBwZWFyIGluIHRoZSBsaXN0IG9mIGFsbG93ZWRcbiAqIHByb3BlcnRpZXMuICBJZiBubyBwcm9wZXJ0aWVzIHdlcmUgZm91bmQsIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGJlIG9mXG4gKiB6ZXJvIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFQcm9wZXJ0aWVzKG9iaiwgYWxsb3dlZClcbntcblx0bW9kX2Fzc2VydC5vayh0eXBlb2YgKG9iaikgPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCxcblx0ICAgICdvYmogYXJndW1lbnQgbXVzdCBiZSBhIG5vbi1udWxsIG9iamVjdCcpO1xuXHRtb2RfYXNzZXJ0Lm9rKEFycmF5LmlzQXJyYXkoYWxsb3dlZCksXG5cdCAgICAnYWxsb3dlZCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MnKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbGxvd2VkLmxlbmd0aDsgaSsrKSB7XG5cdFx0bW9kX2Fzc2VydC5vayh0eXBlb2YgKGFsbG93ZWRbaV0pID09PSAnc3RyaW5nJyxcblx0XHQgICAgJ2FsbG93ZWQgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzJyk7XG5cdH1cblxuXHRyZXR1cm4gKE9iamVjdC5rZXlzKG9iaikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRyZXR1cm4gKGFsbG93ZWQuaW5kZXhPZihrZXkpID09PSAtMSk7XG5cdH0pKTtcbn1cblxuLypcbiAqIEdpdmVuIHRocmVlIHNldHMgb2YgcHJvcGVydGllcyBcInByb3ZpZGVkXCIgKG1heSBiZSB1bmRlZmluZWQpLCBcIm92ZXJyaWRlc1wiXG4gKiAocmVxdWlyZWQpLCBhbmQgXCJkZWZhdWx0c1wiIChtYXkgYmUgdW5kZWZpbmVkKSwgY29uc3RydWN0IGFuIG9iamVjdCBjb250YWluaW5nXG4gKiB0aGUgdW5pb24gb2YgdGhlc2Ugc2V0cyB3aXRoIFwib3ZlcnJpZGVzXCIgb3ZlcnJpZGluZyBcInByb3ZpZGVkXCIsIGFuZFxuICogXCJwcm92aWRlZFwiIG92ZXJyaWRpbmcgXCJkZWZhdWx0c1wiLiAgTm9uZSBvZiB0aGUgaW5wdXQgb2JqZWN0cyBhcmUgbW9kaWZpZWQuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhwcm92aWRlZCwgb3ZlcnJpZGVzLCBkZWZhdWx0cylcbntcblx0dmFyIHJ2LCBrO1xuXG5cdHJ2ID0ge307XG5cdGlmIChkZWZhdWx0cykge1xuXHRcdGZvciAoayBpbiBkZWZhdWx0cylcblx0XHRcdHJ2W2tdID0gZGVmYXVsdHNba107XG5cdH1cblxuXHRpZiAocHJvdmlkZWQpIHtcblx0XHRmb3IgKGsgaW4gcHJvdmlkZWQpXG5cdFx0XHRydltrXSA9IHByb3ZpZGVkW2tdO1xuXHR9XG5cblx0aWYgKG92ZXJyaWRlcykge1xuXHRcdGZvciAoayBpbiBvdmVycmlkZXMpXG5cdFx0XHRydltrXSA9IG92ZXJyaWRlc1trXTtcblx0fVxuXG5cdHJldHVybiAocnYpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIHNuYWtlQ2FzZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdsb2Rhc2guc25ha2VjYXNlJykpO1xudmFyIGNhbWVsQ2FzZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdsb2Rhc2guY2FtZWxjYXNlJykpO1xudmFyIGtlYmFiQ2FzZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdsb2Rhc2gua2ViYWJjYXNlJykpO1xudmFyIG9zID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ29zJykpO1xudmFyIGNyeXB0byA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdjcnlwdG8nKSk7XG52YXIgY2hpbGRfcHJvY2VzcyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKTtcbnZhciByZWFkbGluZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdyZWFkbGluZScpKTtcbnZhciBta2RpcnAgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnbWtkaXJwJykpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIGZzX19kZWZhdWx0ID0gX2ludGVyb3BEZWZhdWx0KGZzKTtcbnZhciBwYXRoID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3BhdGgnKSk7XG5cbi8qKlxuICBUYWtlcyBhIEtleWJhc2UgQVBJIGlucHV0IEphdmFTY3JpcHQgb2JqZWN0IGFuZCByZWN1cnNpdmVseSBmb3JtYXRzIGl0IGludG8gc25ha2VfY2FzZSBvciBrZWJhYi1jYXNlIGluc3RlYWQgb2YgY2FtZWxDYXNlIGZvciB0aGUgc2VydmljZS5cbiAgKiBAaWdub3JlXG4gICogQHBhcmFtIG9iaiAtIFRoZSBvYmplY3QgdG8gYmUgZm9ybWF0dGVkLlxuICAqIEBwYXJhbSBhcGlUeXBlIC0gVGhlIHR5cGUgb2YgYXBpIHRoZSB0aGUgaW5wdXQgaXMgYmVpbmcgc2VydmVkIHRvLiBDdXJyZW50bHkgS2V5YmFzZSBoYXMgY2hhdCwgdGVhbSwgYW5kIHdhbGxldCBhcGlzLlxuICAqIEByZXR1cm5zIC0gVGhlIG5ldywgZm9ybWF0dGVkIG9iamVjdC5cbiAgKiBAZXhhbXBsZVxuICAqIGNvbnN0IGlucHV0T3B0aW9ucyA9IGZvcm1hdEFQSU9iamVjdCh7dW5yZWFkT25seTogdHJ1ZX0pXG4gICogY29uc29sZS5sb2coaW5wdXRPcHRpb25zKSAvLyB7dW5yZWFkX29ubHk6IHRydWV9XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEFQSU9iamVjdElucHV0KG9iaiwgYXBpVHlwZSkge1xuICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcChpdGVtID0+IGZvcm1hdEFQSU9iamVjdElucHV0KGl0ZW0sIGFwaVR5cGUpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKG5ld09iaiwga2V5KSA9PiB7XG4gICAgICAvLyBUT0RPOiBob3BlZnVsbHkgd2Ugc3RhbmRhcmRpemUgaG93IHRoZSBLZXliYXNlIEFQSSBoYW5kbGVzIGlucHV0IGtleXNcbiAgICAgIGxldCBmb3JtYXR0ZWRLZXk7XG5cbiAgICAgIGlmIChhcGlUeXBlID09PSAnd2FsbGV0Jykge1xuICAgICAgICBmb3JtYXR0ZWRLZXkgPSBrZWJhYkNhc2Uoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdHRlZEtleSA9IHNuYWtlQ2FzZShrZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4geyAuLi5uZXdPYmosXG4gICAgICAgICAgW2Zvcm1hdHRlZEtleV06IGZvcm1hdEFQSU9iamVjdElucHV0KG9ialtrZXldLCBhcGlUeXBlKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5uZXdPYmosXG4gICAgICAgIFtmb3JtYXR0ZWRLZXldOiBvYmpba2V5XVxuICAgICAgfTtcbiAgICB9LCB7fSk7XG4gIH1cbn1cbi8qXG4gKiBBbiBpbnRlcm5hbCBibGFja2xpc3Qgb2YgcGFyZW50IGxldmVscyBhdCB3aGljaCBmb3JtYXRBUElPYmplY3RPdXRwdXQgdHJhbnNmb3JtYXRpb25zXG4gKiBzaG91bGRuJ3QgYmUgcGVyZm9ybWVkLiBBIGBudWxsYCB2YWx1ZSBtYXRjaGVzIGV2ZXJ5dGhpbmcuXG4gKi9cblxuY29uc3QgdHJhbnNmb3Jtc0JsYWNrbGlzdCA9IHtcbiAgY2hhdDoge1xuICAgIHJlYWQ6IFtbJ21lc3NhZ2VzJywgbnVsbCwgJ21zZycsICdyZWFjdGlvbnMnLCAncmVhY3Rpb25zJywgbnVsbF1dXG4gIH1cbiAgLyoqXG4gICAqIENvbnRleHQgb2YgdGhlIG9iamVjdCBmb3JtYXR0aW5nIHByb2Nlc3MuXG4gICAqIEBpZ25vcmVcbiAgICovXG5cbn07XG5cbi8qXG4gKiBNYXRjaGVzIGEgY29udGV4dCBhZ2FpbnN0IHRoZSBsaXN0IG9mIGJsYWNrbGlzdGVkIHBhcmVudCBsZXZlbHMuXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRvIG1hdGNoLlxuICogQHJldHVybnMgLSBXaGV0aGVyIHRoZSBjb250ZXh0IGlzIGJsYWNrbGlzdGVkIGZyb20gYmVpbmcgZm9ybWF0dGVkLlxuICovXG5mdW5jdGlvbiBtYXRjaEJsYWNrbGlzdChjb250ZXh0KSB7XG4gIGlmICghY29udGV4dCB8fCAhdHJhbnNmb3Jtc0JsYWNrbGlzdFtjb250ZXh0LmFwaU5hbWVdIHx8ICF0cmFuc2Zvcm1zQmxhY2tsaXN0W2NvbnRleHQuYXBpTmFtZV1bY29udGV4dC5tZXRob2RdKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcGFyZW50TGVuZ3RoID0gY29udGV4dC5wYXJlbnQgPyBjb250ZXh0LnBhcmVudC5sZW5ndGggOiAwO1xuXG4gIGZvciAoY29uc3QgbWF0Y2hlciBvZiB0cmFuc2Zvcm1zQmxhY2tsaXN0W2NvbnRleHQuYXBpTmFtZV1bY29udGV4dC5tZXRob2RdKSB7XG4gICAgaWYgKG1hdGNoZXIubGVuZ3RoICE9PSBwYXJlbnRMZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSXRlcmF0ZSBvdmVyIHRoZSBpdGVtcyBvZiB0aGUgbWF0Y2hlclxuXG5cbiAgICBsZXQgbWlzbWF0Y2ggPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgW21hdGNoZXJJbmRleCwgZGVzaXJlZFZhbHVlXSBvZiBtYXRjaGVyLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGRlc2lyZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LnBhcmVudCA9PT0gJ29iamVjdCcgJiYgY29udGV4dC5wYXJlbnRbbWF0Y2hlckluZGV4XSAhPT0gZGVzaXJlZFZhbHVlKSB7XG4gICAgICAgIG1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFtaXNtYXRjaCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLypcbiAqIEFwcGVuZHMgYSBuZXcga2V5IHRvIHRoZSBwYXJlbnRzIGFycmF5IGluIHRoZSBmb3JtYXR0aW5nIGNvbnRleHQuXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHRvIGNvcHkgYW5kIG1vZGlmeS5cbiAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGFwcHJlbnQgdG8gdGhlIHBhcmVudCBhcnJheS5cbiAqIEByZXR1cm5zIC0gQSBuZXcgY29udGV4dC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ1aWxkQ29udGV4dChjb250ZXh0LCBrZXkpIHtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBjb25zdCBjb3BpZWRDb250ZXh0ID0geyAuLi5jb250ZXh0XG4gIH07XG5cbiAgaWYgKCFjb3BpZWRDb250ZXh0LnBhcmVudCkge1xuICAgIGNvcGllZENvbnRleHQucGFyZW50ID0gW2tleV07XG4gIH0gZWxzZSB7XG4gICAgY29waWVkQ29udGV4dC5wYXJlbnQgPSBjb3BpZWRDb250ZXh0LnBhcmVudC5zbGljZSgpO1xuICAgIGNvcGllZENvbnRleHQucGFyZW50LnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBjb3BpZWRDb250ZXh0O1xufVxuLyoqXG4gIFRha2VzIGEgS2V5YmFzZSBvdXRwdXQgb2JqZWN0IGFuZCBmb3JtYXRzIGl0IGluIGEgbW9yZSBkaWdlc3RhYmxlIEphdmFTY3JpcHQgc3R5bGUgYnkgdXNpbmcgY2FtZWxDYXNlIGluc3RlYWQgb2Ygc25ha2VfY2FzZS5cbiAgKiBAaWdub3JlXG4gICogQHBhcmFtIG9iaiAtIFRoZSBvYmplY3QgdG8gYmUgZm9ybWF0dGVkLlxuICAqIEBwYXJhbSBjb250ZXh0IC0gQW4gb3B0aW9uYWwgY29udGV4dCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYWxsZWQgbWV0aG9kIHJlcXVpcmVkIHRvIHBlcmZvcm0gYmxhY2tsaXN0IGxvb2t1cHMuXG4gICogQHJldHVybnMgLSBUaGUgbmV3LCBmb3JtYXR0ZWQgb2JqZWN0LlxuICAqIEBleGFtcGxlXG4gICogY29uc3Qgb3V0cHV0UmVzID0gZm9ybWF0QVBJT2JqZWN0KHt1bnJlYWRfb25seTogdHJ1ZX0pXG4gICogY29uc29sZS5sb2cob3V0cHV0UmVzKSAvLyB7dW5yZWFkT25seTogdHJ1ZX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEFQSU9iamVjdE91dHB1dChvYmosIGNvbnRleHQpIHtcbiAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcCgoaXRlbSwgaSkgPT4gZm9ybWF0QVBJT2JqZWN0T3V0cHV0KGl0ZW0sIGJ1aWxkQ29udGV4dChjb250ZXh0LCBpKSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgobmV3T2JqLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZEtleSA9IG1hdGNoQmxhY2tsaXN0KGNvbnRleHQpID8ga2V5IDogY2FtZWxDYXNlKGtleSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm5ld09iaixcbiAgICAgICAgICBbZm9ybWF0dGVkS2V5XTogZm9ybWF0QVBJT2JqZWN0T3V0cHV0KG9ialtrZXldLCBidWlsZENvbnRleHQoY29udGV4dCwga2V5KSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgLi4ubmV3T2JqLFxuICAgICAgICBbZm9ybWF0dGVkS2V5XTogb2JqW2tleV1cbiAgICAgIH07XG4gICAgfSwge30pO1xuICB9XG59XG5cbmNvbnN0IGtleWJhc2VFeGVjID0gKHdvcmtpbmdEaXIsIGhvbWVEaXIsIGFyZ3MsIG9wdGlvbnMgPSB7XG4gIHN0ZGluQnVmZmVyOiB1bmRlZmluZWQsXG4gIG9uU3RkT3V0OiB1bmRlZmluZWRcbn0pID0+IHtcbiAgY29uc3QgcnVuQXJncyA9IFsuLi5hcmdzXTtcblxuICBpZiAoaG9tZURpcikge1xuICAgIHJ1bkFyZ3MudW5zaGlmdCgnLS1ob21lJywgaG9tZURpcik7XG4gIH1cblxuICBjb25zdCBjaGlsZCA9IGNoaWxkX3Byb2Nlc3Muc3Bhd24ocGF0aC5qb2luKHdvcmtpbmdEaXIsICdrZXliYXNlJyksIHJ1bkFyZ3MpO1xuICBjb25zdCBzdGRPdXRCdWZmZXIgPSBbXTtcbiAgY29uc3Qgc3RkRXJyQnVmZmVyID0gW107XG5cbiAgaWYgKG9wdGlvbnMuc3RkaW5CdWZmZXIpIHtcbiAgICBjaGlsZC5zdGRpbi53cml0ZShvcHRpb25zLnN0ZGluQnVmZmVyKTtcbiAgfVxuXG4gIGNoaWxkLnN0ZGluLmVuZCgpO1xuICBjb25zdCBsaW5lUmVhZGVyU3Rkb3V0ID0gcmVhZGxpbmUuY3JlYXRlSW50ZXJmYWNlKHtcbiAgICBpbnB1dDogY2hpbGQuc3Rkb3V0XG4gIH0pOyAvLyBVc2UgcmVhZGxpbmUgaW50ZXJmYWNlIHRvIHBhcnNlIGVhY2ggbGluZSAoXFxuIHNlcGFyYXRlZCkgd2hlbiBwcm92aWRlZFxuICAvLyB3aXRoIG9uU3RkT3V0IGNhbGxiYWNrXG5cbiAgaWYgKG9wdGlvbnMub25TdGRPdXQpIHtcbiAgICBsaW5lUmVhZGVyU3Rkb3V0Lm9uKCdsaW5lJywgb3B0aW9ucy5vblN0ZE91dCk7XG4gIH0gZWxzZSB7XG4gICAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgc3RkT3V0QnVmZmVyLnB1c2goY2h1bmspO1xuICAgIH0pO1xuICB9IC8vIENhcHR1cmUgU1RERVJSIGFuZCB1c2UgYXMgZXJyb3IgbWVzc2FnZSBpZiBuZWVkZWRcblxuXG4gIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICBzdGRFcnJCdWZmZXIucHVzaChjaHVuayk7XG4gIH0pO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNoaWxkLm9uKCdjbG9zZScsIGNvZGUgPT4ge1xuICAgICAgbGV0IGZpbmFsU3RkT3V0ID0gbnVsbDsgLy8gUGFzcyBiYWNrXG5cbiAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IEJ1ZmZlci5jb25jYXQoc3RkRXJyQnVmZmVyKS50b1N0cmluZygndXRmOCcpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yTWVzc2FnZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3Rkb3V0ID0gQnVmZmVyLmNvbmNhdChzdGRPdXRCdWZmZXIpLnRvU3RyaW5nKCd1dGY4Jyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmaW5hbFN0ZE91dCA9IG9wdGlvbnMuanNvbiA/IEpTT04ucGFyc2Uoc3Rkb3V0KSA6IHN0ZG91dDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGZpbmFsU3RkT3V0KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiByYW5kb21UZW1wRGlyKCkge1xuICBjb25zdCBuYW1lID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnaGV4Jyk7XG4gIHJldHVybiBwYXRoLmpvaW4ob3MudG1wZGlyKCksIGBrZXliYXNlX2JvdF8ke25hbWV9YCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJtZGlyUmVjdXJzaXZlKGRpck5hbWUpIHtcbiAgY29uc3QgZnNMc3RhdCA9IHV0aWwucHJvbWlzaWZ5KGZzX19kZWZhdWx0LmxzdGF0KTtcbiAgY29uc3QgZnNVbmxpbmsgPSB1dGlsLnByb21pc2lmeShmc19fZGVmYXVsdC51bmxpbmspO1xuICBjb25zdCBmc1JtZGlyID0gdXRpbC5wcm9taXNpZnkoZnNfX2RlZmF1bHQucm1kaXIpO1xuICBjb25zdCBmc1JlYWRkaXIgPSB1dGlsLnByb21pc2lmeShmc19fZGVmYXVsdC5yZWFkZGlyKTtcbiAgY29uc3QgZGlyU3RhdCA9IGF3YWl0IGZzTHN0YXQoZGlyTmFtZSk7XG5cbiAgaWYgKGRpclN0YXQpIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGF3YWl0IGZzUmVhZGRpcihkaXJOYW1lKSkge1xuICAgICAgY29uc3QgZW50cnlQYXRoID0gcGF0aC5qb2luKGRpck5hbWUsIGVudHJ5KTtcbiAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBmc0xzdGF0KGVudHJ5UGF0aCk7XG5cbiAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgYXdhaXQgcm1kaXJSZWN1cnNpdmUoZW50cnlQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGZzVW5saW5rKGVudHJ5UGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgZnNSbWRpcihkaXJOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIFVzZWZ1bCBpbmZvcm1hdGlvbiBsaWtlIHRoZSB1c2VybmFtZSwgZGV2aWNlLCBob21lIGRpcmVjdG9yeSBvZiB5b3VyIGJvdCBhbmRcbiAqIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgeyB1c2VybmFtZSwgZGV2aWNlbmFtZSwgaG9tZURpciB9IGZyb20gYGtleWJhc2Ugc3RhdHVzIC0tanNvbmAuXG4gKiBAaWdub3JlXG4gKiBAcGFyYW0gd29ya2luZ0RpciAtIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB0aGUgYmluYXJ5LCBhY2NvcmRpbmcgdG8gdG9wIGxldmVsIEJvdFxuICogQHBhcmFtIGhvbWVEaXIgLSBUaGUgaG9tZSBkaXJlY3Rvcnkgb2YgdGhlIHNlcnZpY2UgeW91IHdhbnQgdG8gZmV0Y2ggdGhlIHN0YXR1cyBmcm9tLlxuICogQGV4YW1wbGVcbiAqIGtleWJhc2VTdGF0dXMoJy9teS9kaXInKS50aGVuKHN0YXR1cyA9PiBjb25zb2xlLmxvZyhzdGF0dXMudXNlcm5hbWUpKVxuICovXG5hc3luYyBmdW5jdGlvbiBrZXliYXNlU3RhdHVzKHdvcmtpbmdEaXIsIGhvbWVEaXIpIHtcbiAgY29uc3Qgc3RhdHVzID0gYXdhaXQga2V5YmFzZUV4ZWMod29ya2luZ0RpciwgaG9tZURpciwgWydzdGF0dXMnLCAnLS1qc29uJ10sIHtcbiAgICBqc29uOiB0cnVlXG4gIH0pO1xuXG4gIGlmIChzdGF0dXMgJiYgc3RhdHVzLlVzZXJuYW1lICYmIHN0YXR1cy5EZXZpY2UgJiYgc3RhdHVzLkRldmljZS5uYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJuYW1lOiBzdGF0dXMuVXNlcm5hbWUsXG4gICAgICBkZXZpY2VuYW1lOiBzdGF0dXMuRGV2aWNlLm5hbWUsXG4gICAgICBob21lRGlyXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgY3VycmVudCB1c2VybmFtZSBhbmQgZGV2aWNlIG5hbWUuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUga2V5YmFzZSBzZXJ2aWNlIGlzIHJ1bm5pbmcgYnkgY2FsbGluZyBga2V5YmFzZSBzdGF0dXMgLS1qc29uYC5cbiAqIEBpZ25vcmVcbiAqIEBwYXJhbSB3b3JraW5nRGlyIC0gdGhlIGRpcmVjdG9yeSBjb250YWluaW5nIHRoZSBiaW5hcnksIGFjY29yZGluZyB0byB0b3AgbGV2ZWwgQm90XG4gKiBAcGFyYW0gaG9tZURpciAtIFRoZSBob21lIGRpcmVjdG9yeSBvZiB0aGUgc2VydmljZSB5b3Ugd2FudCB0byBmZXRjaCB0aGUgc3RhdHVzIGZyb20uXG4gKiBAZXhhbXBsZVxuICogcGluZ0tleWJhc2VTZXJ2aWNlKCcvbXkvZGlyJykudGhlbihzdGF0dXMgPT4gY29uc29sZS5sb2coXCJzZXJ2aWNlIHJ1bm5pbmdcIiwgc3RhdHVzKSlcbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBwaW5nS2V5YmFzZVNlcnZpY2Uod29ya2luZ0RpciwgaG9tZURpcikge1xuICAvLyBUT0RPOiB1c2UgYSBmYXN0ZXIgdGVjaG5pcXVlIHdoZW4gY29yZSByZWxlYXNlcyBvbmVcbiAgdHJ5IHtcbiAgICBhd2FpdCBrZXliYXNlRXhlYyh3b3JraW5nRGlyLCBob21lRGlyLCBbJy0tbm8tYXV0by1mb3JrJywgJ3N0YXR1cycsICctLWpzb24nXSwge1xuICAgICAganNvbjogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuY29uc3QgYUV4ZWMgPSB1dGlsLnByb21pc2lmeShjaGlsZF9wcm9jZXNzLmV4ZWMpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIHBhdGggdG8gdGhlIGtleWJhc2UgYmluYXJ5IG9yIHRocm93cyBhbiBlcnJvclxuICogQGlnbm9yZVxuICogQGV4YW1wbGVcbiAqIHdoaWNoS2V5YmFzZSgpLnRoZW4oKHBhdGgpID0+IGNvbnNvbGUubG9nKHBhdGgpKVxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHdoaWNoS2V5YmFzZSgpIHtcbiAgY29uc3Qge1xuICAgIHN0ZG91dFxuICB9ID0gYXdhaXQgYUV4ZWMoJ3doaWNoIGtleWJhc2UnKTtcblxuICBpZiAoIXN0ZG91dCB8fCAhc3Rkb3V0LnRyaW0oKS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGtleWJhc2UgYmluYXJ5Jyk7XG4gIH1cblxuICBjb25zdCByZXMgPSBzdGRvdXQudHJpbSgpO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiB0aW1lb3V0KHRpbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIHRpbWUpO1xuICB9KTtcbn1cblxuY2xhc3MgU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHdvcmtpbmdEaXIpIHtcbiAgICB0aGlzLndvcmtpbmdEaXIgPSB3b3JraW5nRGlyO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmJvc2UgPSBmYWxzZTtcbiAgICB0aGlzLmJvdExpdGUgPSB0cnVlO1xuICAgIHRoaXMuZGlzYWJsZVR5cGluZyA9IHRydWU7XG4gIH1cblxuICBhc3luYyBpbml0KHVzZXJuYW1lLCBwYXBlcmtleSwgb3B0aW9ucykge1xuICAgIGlmICghdXNlcm5hbWUgfHwgdHlwZW9mIHVzZXJuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2UgcHJvdmlkZSBhIHVzZXJuYW1lIHRvIGluaXRpYWxpemUgdGhlIGJvdC4gR290OiAke0pTT04uc3RyaW5naWZ5KHVzZXJuYW1lKX1gKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcGVya2V5IHx8IHR5cGVvZiBwYXBlcmtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIERvbid0IHdhbnQgdG8gYWNjaWRlbnRhbGx5IHByaW50IHRoZSBwYXBlcmtleSB0byBTVERFUlIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsZWFzZSBwcm92aWRlIGEgcGFwZXJrZXkgdG8gaW5pdGlhbGl6ZSB0aGUgYm90LmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbml0aWFsaXplIGFuIGFscmVhZHkgaW5pdGlhbGl6ZWQgYm90LicpO1xuICAgIH1cblxuICAgIHRoaXMuaG9tZURpciA9IHRoaXMud29ya2luZ0RpcjtcbiAgICB0aGlzLnNlcnZpY2VMb2dGaWxlID0gcGF0aC5qb2luKHRoaXMuaG9tZURpciwgJ0xpYnJhcnknLCAnTG9ncycsICdrZXliYXNlLnNlcnZpY2UubG9nJyk7XG4gICAgdGhpcy5ib3RMaXRlID0gb3B0aW9ucyA/IEJvb2xlYW4odHlwZW9mIG9wdGlvbnMuYm90TGl0ZSAhPT0gJ2Jvb2xlYW4nIHx8IG9wdGlvbnMuYm90TGl0ZSkgOiB0cnVlO1xuICAgIHRoaXMuZGlzYWJsZVR5cGluZyA9IG9wdGlvbnMgPyBCb29sZWFuKHR5cGVvZiBvcHRpb25zLmRpc2FibGVUeXBpbmcgIT09ICdib29sZWFuJyB8fCBvcHRpb25zLmRpc2FibGVUeXBpbmcpIDogdHJ1ZTsgLy8gVW5saWtlIHdpdGggY2xpZW50cyB3ZSBkb24ndCBuZWVkIHRvIHN0b3JlIHRoZSBzZXJ2aWNlLCBzaW5jZSBpdCBzaHV0cyBkb3duIHdpdGggY3RybCBzdG9wXG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zdGFydHVwU2VydmljZSgpO1xuICAgICAgYXdhaXQga2V5YmFzZUV4ZWModGhpcy53b3JraW5nRGlyLCB0aGlzLmhvbWVEaXIsIFsnb25lc2hvdCcsICctLXVzZXJuYW1lJywgdXNlcm5hbWVdLCB7XG4gICAgICAgIHN0ZGluQnVmZmVyOiBwYXBlcmtleVxuICAgICAgfSk7IC8vIFNldCB0aGUgdHlwaW5nIG5vdGlmaWNhdGlvbiBzZXR0aW5ncyBmb3IgdGhlIGJvdFxuXG4gICAgICBhd2FpdCBrZXliYXNlRXhlYyh0aGlzLndvcmtpbmdEaXIsIHRoaXMuaG9tZURpciwgWydjaGF0JywgJ25vdGlmaWNhdGlvbi1zZXR0aW5ncycsICdkaXNhYmxlLXR5cGluZycsIHRoaXMuZGlzYWJsZVR5cGluZy50b1N0cmluZygpXSk7XG4gICAgICBjb25zdCBjdXJyZW50SW5mbyA9IGF3YWl0IGtleWJhc2VTdGF0dXModGhpcy53b3JraW5nRGlyLCB0aGlzLmhvbWVEaXIpO1xuXG4gICAgICBpZiAoY3VycmVudEluZm8gJiYgY3VycmVudEluZm8udXNlcm5hbWUgJiYgY3VycmVudEluZm8uZGV2aWNlbmFtZSkge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gJ3BhcGVya2V5JztcbiAgICAgICAgdGhpcy51c2VybmFtZSA9IGN1cnJlbnRJbmZvLnVzZXJuYW1lO1xuICAgICAgICB0aGlzLmRldmljZW5hbWUgPSBjdXJyZW50SW5mby5kZXZpY2VuYW1lO1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSBvcHRpb25zID8gQm9vbGVhbihvcHRpb25zLnZlcmJvc2UpIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnVzZXJuYW1lICE9PSB1c2VybmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHNlcnZpY2UuJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBhd2FpdCB0aGlzLl9raWxsQ3VzdG9tU2VydmljZSgpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGluaXRGcm9tUnVubmluZ1NlcnZpY2UoaG9tZURpciwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbml0aWFsaXplIGFuIGFscmVhZHkgaW5pdGlhbGl6ZWQgYm90LicpO1xuICAgIH1cblxuICAgIHRoaXMuaG9tZURpciA9IGhvbWVEaXI7XG4gICAgY29uc3QgY3VycmVudEluZm8gPSBhd2FpdCBrZXliYXNlU3RhdHVzKHRoaXMud29ya2luZ0RpciwgdGhpcy5ob21lRGlyKTtcblxuICAgIGlmIChjdXJyZW50SW5mbyAmJiBjdXJyZW50SW5mby51c2VybmFtZSAmJiBjdXJyZW50SW5mby5kZXZpY2VuYW1lKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gJ3J1bm5pbmdTZXJ2aWNlJztcbiAgICAgIHRoaXMudXNlcm5hbWUgPSBjdXJyZW50SW5mby51c2VybmFtZTtcbiAgICAgIHRoaXMuZGV2aWNlbmFtZSA9IGN1cnJlbnRJbmZvLmRldmljZW5hbWU7XG4gICAgICB0aGlzLnZlcmJvc2UgPSBvcHRpb25zID8gQm9vbGVhbihvcHRpb25zLnZlcmJvc2UpIDogZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2tpbGxDdXN0b21TZXJ2aWNlKCkge1xuICAgIC8vIHRoZXNlIDIgY29tbWFuZHMgbWlnaHQgYmUgdW5uZWNlc3Nhcnk7IHNpbmNlIHRoZSBzZXJ2aWNlIHdhcyBgc3Bhd25gZWQgbm90IGRldGFjaGVkXG4gICAgLy8gdGhleSB3aWxsIGFsc28gc2h1dGRvd24gdmlhIFNJR0lOVC4gV2UgZG9uJ3Qgd2FudCB0byBtYWtlIHNlcnZpY2UgZGV0YWNoZWQgYmVjYXVzZSBpdCdkIGJlIG5pY2UgZm9yXG4gICAgLy8gdGhlbSB0byBhdXRvLXNodXRkb3duIGlmIHRoZSB1c2VyIGtpbGxzIHRoZSBwcm9jZXNzXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGtleWJhc2VFeGVjKHRoaXMud29ya2luZ0RpciwgdGhpcy5ob21lRGlyLCBbJ2xvZ291dCddKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGtleWJhc2VFeGVjKHRoaXMud29ya2luZ0RpciwgdGhpcy5ob21lRGlyLCBbJ2N0bCcsICdzdG9wJywgJy0tc2h1dGRvd24nXSk7XG4gICAgfSBjYXRjaCAoZSkge30gLy8gd2FpdCB1bnRpbCB0aGUgcHJvY2VzcyBxdWl0cyBieSB3YXRjaGluZyB0aGUgcnVubmluZyBwcm9wZXJ0eVxuXG5cbiAgICBsZXQgaSA9IDA7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgYXdhaXQgdGltZW91dCgxMDApO1xuXG4gICAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKCsraSA+PSAxMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2VydmljZSBkaWRuJ3QgZmluaXNoIHNodXR0aW5nIGRvd24gaW4gdGltZSAoJHt0aGlzLndvcmtpbmdEaXJ9KWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlaW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlaW5pdGlhbGl6ZSBhbiB1bmluaXRpYWxpemVkIGJvdC4nKTtcbiAgICB9IC8vIElmIHdlIGluaXQgdGhlIGJvdCB1c2luZyBwYXBlcmtleSBjcmVkZW50aWFscywgdGhlbiB3ZSB3YW50IHRvIHN0b3AgdGhlIHNlcnZpY2UgYW5kIHJlbW92ZSBvdXIgZ2VuZXJhdGVkIGRpcmVjdG9yeS5cblxuXG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09ICdwYXBlcmtleScpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2tpbGxDdXN0b21TZXJ2aWNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICB9XG5cbiAgbXlJbmZvKCkge1xuICAgIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMuZGV2aWNlbmFtZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICAgIGRldmljZW5hbWU6IHRoaXMuZGV2aWNlbmFtZSxcbiAgICAgICAgaG9tZURpcjogdGhpcy5ob21lRGlyID8gdGhpcy5ob21lRGlyIDogdW5kZWZpbmVkLFxuICAgICAgICBib3RMaXRlOiB0aGlzLmJvdExpdGUsXG4gICAgICAgIGRpc2FibGVUeXBpbmc6IHRoaXMuZGlzYWJsZVR5cGluZ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQGlnbm9yZVxuICAgKiBUaGlzIGlzIGEgYml0IGRpZmZlcmVudCBmcm9tIG5vcm1hbCBrZXliYXNlRXhlY3MgYW5kIGlzIHVuaXF1ZSB0byB0aGUgc2VydmljZVxuICAgKiBzdGFydGluZyB1cFxuICAgKiBAZXhhbXBsZVxuICAgKiBzZXJ2aWNlLnN0YXJ0dXBTZXJ2aWNlKClcbiAgICovXG5cblxuICBhc3luYyBzdGFydHVwU2VydmljZSgpIHtcbiAgICBjb25zdCBhcmdzID0gWydzZXJ2aWNlJ107XG5cbiAgICBpZiAodGhpcy5ob21lRGlyKSB7XG4gICAgICBhcmdzLnVuc2hpZnQoJy0taG9tZScsIHRoaXMuaG9tZURpcik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2VydmljZUxvZ0ZpbGUpIHtcbiAgICAgIGFyZ3MudW5zaGlmdCgnLWQnLCAnLS1sb2ctZmlsZScsIHRoaXMuc2VydmljZUxvZ0ZpbGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJvdExpdGUpIHtcbiAgICAgIGFyZ3MudW5zaGlmdCgnLS1lbmFibGUtYm90LWxpdGUtbW9kZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRfcHJvY2Vzcy5zcGF3bigna2V5YmFzZScsIGFyZ3MsIHtcbiAgICAgIGVudjogcHJvY2Vzcy5lbnZcbiAgICB9KTsgLy8ga2VlcCB0cmFjayBvZiB0aGUgc3VicHJvY2Vzcycgc3RhdGVcblxuICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgY2hpbGQub24oJ2V4aXQnLCBjb2RlID0+IHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjaGlsZC5vbignY2xvc2UnLCBjb2RlID0+IHtcbiAgICAgICAgLy8gYW55IGNvZGUgaGVyZSBpbmNsdWRpbmcgMCBpcyBiYWQgaGVyZSwgaWYgaXQgaGFwcGVucyBiZWZvcmUgcmVzb2x2ZVxuICAgICAgICAvLywgc2luY2UgdGhpcyBzZXJ2aWNlIHNob3VsZCBzdGF5IHJ1bm5pbmdcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihga2V5YmFzZSBzZXJ2aWNlIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfSAoJHt0aGlzLndvcmtpbmdEaXJ9KWApKTtcbiAgICAgIH0pOyAvLyBXYWl0IGZvciB0aGUgc2VydmljZSB0byBzdGFydCB1cCAtIGdpdmUgaXQgMTBzLlxuXG4gICAgICBsZXQgaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKGF3YWl0IHBpbmdLZXliYXNlU2VydmljZSh0aGlzLndvcmtpbmdEaXIsIHRoaXMuaG9tZURpcikpKSB7XG4gICAgICAgIGF3YWl0IHRpbWVvdXQoMTAwKTtcblxuICAgICAgICBpZiAoKytpID49IDEwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IHN0YXJ0IHVwIHNlcnZpY2UgZmFzdCBlbm91Z2hcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG5cbn1cblxuY29uc3QgQVBJX1ZFUlNJT05TID0ge1xuICBjaGF0OiAxLFxuICB0ZWFtOiAxLFxuICB3YWxsZXQ6IDFcbn07XG5cbi8qKlxuICogQSBDbGllbnQgYmFzZS5cbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgQ2xpZW50QmFzZSB7XG4gIGNvbnN0cnVjdG9yKHdvcmtpbmdEaXIpIHtcbiAgICB0aGlzLl93b3JraW5nRGlyID0gd29ya2luZ0RpcjtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy52ZXJib3NlID0gZmFsc2U7XG4gICAgdGhpcy5zcGF3bmVkUHJvY2Vzc2VzID0gW107XG4gIH1cblxuICBhc3luYyBfaW5pdChob21lRGlyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW5pdEJvdEluZm8gPSBhd2FpdCBrZXliYXNlU3RhdHVzKHRoaXMuX3dvcmtpbmdEaXIsIGhvbWVEaXIpO1xuICAgIHRoaXMuaG9tZURpciA9IGhvbWVEaXI7XG4gICAgdGhpcy51c2VybmFtZSA9IGluaXRCb3RJbmZvLnVzZXJuYW1lO1xuICAgIHRoaXMuZGV2aWNlbmFtZSA9IGluaXRCb3RJbmZvLmRldmljZW5hbWU7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBhc3luYyBfZGVpbml0KCkge1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5zcGF3bmVkUHJvY2Vzc2VzKSB7XG4gICAgICBjaGlsZC5raWxsKCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX3J1bkFwaUNvbW1hbmQoYXJnKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZy5vcHRpb25zID8gZm9ybWF0QVBJT2JqZWN0SW5wdXQoYXJnLm9wdGlvbnMsIGFyZy5hcGlOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBpbnB1dCA9IHtcbiAgICAgIG1ldGhvZDogYXJnLm1ldGhvZCxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB2ZXJzaW9uOiBBUElfVkVSU0lPTlNbYXJnLmFwaU5hbWVdLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnB1dFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgICBjb25zdCBzaXplID0gaW5wdXRTdHJpbmcubGVuZ3RoO1xuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGtleWJhc2VFeGVjKHRoaXMuX3dvcmtpbmdEaXIsIHRoaXMuaG9tZURpciwgW2FyZy5hcGlOYW1lLCAnYXBpJ10sIHtcbiAgICAgIHN0ZGluQnVmZmVyOiBCdWZmZXIuYWxsb2Moc2l6ZSwgaW5wdXRTdHJpbmcsICd1dGY4JyksXG4gICAgICBqc29uOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAob3V0cHV0Lmhhc093blByb3BlcnR5KCdlcnJvcicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iob3V0cHV0LmVycm9yLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IGZvcm1hdEFQSU9iamVjdE91dHB1dChvdXRwdXQucmVzdWx0LCB7XG4gICAgICBhcGlOYW1lOiBhcmcuYXBpTmFtZSxcbiAgICAgIG1ldGhvZDogYXJnLm1ldGhvZFxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBhc3luYyBfZ3VhcmRJbml0aWFsaXplZCgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNsaWVudCBpcyBub3QgeWV0IGluaXRpYWxpemVkLicpO1xuICAgIH1cbiAgfVxuXG4gIF9wYXRoVG9LZXliYXNlQmluYXJ5KCkge1xuICAgIHJldHVybiBwYXRoLmpvaW4odGhpcy5fd29ya2luZ0RpciwgJ2tleWJhc2UnKTtcbiAgfVxuXG59XG5cbi8qKiBUaGUgY2hhdCBtb2R1bGUgb2YgeW91ciBLZXliYXNlIGJvdC4gRm9yIG1vcmUgaW5mbyBhYm91dCB0aGUgQVBJIHRoaXMgbW9kdWxlIHVzZXMsIHlvdSBtYXkgd2FudCB0byBjaGVjayBvdXQgYGtleWJhc2UgY2hhdCBhcGlgLiAqL1xuY2xhc3MgQ2hhdCBleHRlbmRzIENsaWVudEJhc2Uge1xuICAvKipcbiAgICogTGlzdHMgeW91ciBjaGF0cywgd2l0aCBpbmZvIG9uIHdoaWNoIG9uZXMgaGF2ZSB1bnJlYWQgbWVzc2FnZXMuXG4gICAqIEBtZW1iZXJvZiBDaGF0XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QuXG4gICAqIEByZXR1cm5zIC0gQW4gYXJyYXkgb2YgY2hhdCBjb252ZXJzYXRpb25zLiBJZiB0aGVyZSBhcmUgbm8gY29udmVyc2F0aW9ucywgdGhlIGFycmF5IGlzIGVtcHR5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBib3QuY2hhdC5saXN0KHt1bnJlYWRPbmx5OiB0cnVlfSkudGhlbihjaGF0Q29udmVyc2F0aW9ucyA9PiBjb25zb2xlLmxvZyhjaGF0Q29udmVyc2F0aW9ucykpXG4gICAqL1xuICBhc3luYyBsaXN0KG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLl9ndWFyZEluaXRpYWxpemVkKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fcnVuQXBpQ29tbWFuZCh7XG4gICAgICBhcGlOYW1lOiAnY2hhdCcsXG4gICAgICBtZXRob2Q6ICdsaXN0JyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcblxuICAgIGlmICghcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleWJhc2UgY2hhdCBsaXN0IHJldHVybmVkIG5vdGhpbmcuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5jb252ZXJzYXRpb25zIHx8IFtdO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgbWVzc2FnZXMgaW4gYSBjaGFubmVsLiBZb3UgY2FuIHJlYWQgd2l0aCBvciB3aXRob3V0IG1hcmtpbmcgYXMgcmVhZC5cbiAgICogQG1lbWJlcm9mIENoYXRcbiAgICogQHBhcmFtIGNoYW5uZWwgLSBUaGUgY2hhdCBjaGFubmVsIHRvIHJlYWQgbWVzc2FnZXMgaW4uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QuXG4gICAqIEByZXR1cm5zIC0gQSBzdW1tYXJ5IG9mIGRhdGEgYWJvdXQgYSBtZXNzYWdlLCBpbmNsdWRpbmcgd2hvIHNlbmQgaXQsIHdoZW4sIHRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlLCBldGMuIElmIHRoZXJlIGFyZSBubyBtZXNzYWdlcyBpbiB5b3VyIGNoYW5uZWwsIHRoZW4gYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgKiBAZXhhbXBsZVxuICAgKiBhbGljZS5jaGF0LnJlYWQoY2hhbm5lbCkudGhlbihtZXNzYWdlcyA9PiBjb25zb2xlLmxvZyhtZXNzYWdlcykpXG4gICAqL1xuXG5cbiAgYXN5bmMgcmVhZChjaGFubmVsLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy5fZ3VhcmRJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHMgPSB7IC4uLm9wdGlvbnMsXG4gICAgICBjaGFubmVsLFxuICAgICAgcGVlazogb3B0aW9ucyAmJiBvcHRpb25zLnBlZWsgPyBvcHRpb25zLnBlZWsgOiBmYWxzZSxcbiAgICAgIHVucmVhZE9ubHk6IG9wdGlvbnMgJiYgb3B0aW9ucy51bnJlYWRPbmx5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnVucmVhZE9ubHkgOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fcnVuQXBpQ29tbWFuZCh7XG4gICAgICBhcGlOYW1lOiAnY2hhdCcsXG4gICAgICBtZXRob2Q6ICdyZWFkJyxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNXaXRoRGVmYXVsdHNcbiAgICB9KTtcblxuICAgIGlmICghcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleWJhc2UgY2hhdCByZWFkIHJldHVybmVkIG5vdGhpbmcuJyk7XG4gICAgfSAvLyBSZW1vdmVzIGEgc2luZ2xlIG9iamVjdCB3aXRoIHByb3BlcnR5IGBtc2dgXG4gICAgLy8gVE9ETzogaW5jbHVkZSBwYWdpbmF0aW9uP1xuXG5cbiAgICBjb25zdCBjbGVhbmVkUmVzID0gcmVzLm1lc3NhZ2VzLm1hcChtZXNzYWdlID0+IG1lc3NhZ2UubXNnKTtcbiAgICByZXR1cm4gY2xlYW5lZFJlcztcbiAgfVxuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UgdG8gYSBjZXJ0YWluIGNoYW5uZWwuXG4gICAqIEBtZW1iZXJvZiBDaGF0XG4gICAqIEBwYXJhbSBjaGFubmVsIC0gVGhlIGNoYXQgY2hhbm5lbCB0byBzZW5kIHRoZSBtZXNzYWdlIGluLlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBjaGF0IG1lc3NhZ2UgdG8gc2VuZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgb2Ygb3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZC5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgY2hhbm5lbCA9IHtuYW1lOiAna2JvdCwnICsgYm90Lm15SW5mbygpLnVzZXJuYW1lLCBwdWJsaWM6IGZhbHNlLCB0b3BpY190eXBlOiAnY2hhdCd9XG4gICAqIGNvbnN0IG1lc3NhZ2UgPSB7Ym9keTogJ0hlbGxvIGtib3QhJ31cbiAgICogYm90LmNoYXQuc2VuZChjaGFubmVsLCBtZXNzYWdlKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdtZXNzYWdlIHNlbnQhJykpXG4gICAqL1xuXG5cbiAgYXN5bmMgc2VuZChjaGFubmVsLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy5fZ3VhcmRJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IGFyZ3MgPSB7IC4uLm9wdGlvbnMsXG4gICAgICBjaGFubmVsLFxuICAgICAgbWVzc2FnZVxuICAgIH07XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fcnVuQXBpQ29tbWFuZCh7XG4gICAgICBhcGlOYW1lOiAnY2hhdCcsXG4gICAgICBtZXRob2Q6ICdzZW5kJyxcbiAgICAgIG9wdGlvbnM6IGFyZ3NcbiAgICB9KTtcblxuICAgIGlmICghcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleWJhc2UgY2hhdCBzZW5kIHJldHVybmVkIG5vdGhpbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2lkOiByZXMuaWR9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgYSBmaWxlIHRvIGEgY2hhbm5lbC5cbiAgICogQG1lbWJlcm9mIENoYXRcbiAgICogQHBhcmFtIGNoYW5uZWwgLSBUaGUgY2hhdCBjaGFubmVsIHRvIHNlbmQgdGhlIG1lc3NhZ2UgaW4uXG4gICAqIEBwYXJhbSBmaWxlbmFtZSAtIFRoZSBhYnNvbHV0ZSBwYXRoIG9mIHRoZSBmaWxlIHRvIHNlbmQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QuXG4gICAqIEBleGFtcGxlXG4gICAqIGJvdC5jaGF0LmF0dGFjaChjaGFubmVsLCAnL1VzZXJzL25hdGhhbi9teV9waWN0dXJlLnBuZycpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ1NlbnQgYSBwaWN0dXJlIScpKVxuICAgKi9cblxuXG4gIGFzeW5jIGF0dGFjaChjaGFubmVsLCBmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGF3YWl0IHRoaXMuX2d1YXJkSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBhcmdzID0geyAuLi5vcHRpb25zLFxuICAgICAgY2hhbm5lbCxcbiAgICAgIGZpbGVuYW1lXG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9ydW5BcGlDb21tYW5kKHtcbiAgICAgIGFwaU5hbWU6ICdjaGF0JyxcbiAgICAgIG1ldGhvZDogJ2F0dGFjaCcsXG4gICAgICBvcHRpb25zOiBhcmdzXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXliYXNlIGNoYXQgYXR0YWNoIHJldHVybmVkIG5vdGhpbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2lkOiByZXMuaWR9XG4gIH1cbiAgLyoqXG4gICAqIERvd25sb2FkIGEgZmlsZSBzZW5kIHZpYSBLZXliYXNlIGNoYXQuXG4gICAqIEBtZW1iZXJvZiBDaGF0XG4gICAqIEBwYXJhbSBjaGFubmVsIC0gVGhlIGNoYXQgY2hhbm5lbCB0aGF0IHRoZSBkZXNpcmVkIGF0dGFjbWVudCB0byBkb3dubG9hZCBpcyBpbi5cbiAgICogQHBhcmFtIG1lc3NhZ2VJZCAtIFRoZSBtZXNzYWdlIGlkIG9mIHRoZSBhdHRhY2hlZCBmaWxlLlxuICAgKiBAcGFyYW0gb3V0cHV0IC0gVGhlIGFic29sdXRlIHBhdGggb2Ygd2hlcmUgdGhlIGZpbGUgc2hvdWxkIGJlIGRvd25sb2FkZWQgdG8uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICogQGV4YW1wbGVcbiAgICogYm90LmNoYXQuZG93bmxvYWQoY2hhbm5lbCwgMzI1LCAnL1VzZXJzL25hdGhhbi9Eb3dubG9hZHMvZmlsZS5wbmcnKVxuICAgKi9cblxuXG4gIGFzeW5jIGRvd25sb2FkKGNoYW5uZWwsIG1lc3NhZ2VJZCwgb3V0cHV0LCBvcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy5fZ3VhcmRJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IGFyZ3MgPSB7IC4uLm9wdGlvbnMsXG4gICAgICBjaGFubmVsLFxuICAgICAgbWVzc2FnZUlkLFxuICAgICAgb3V0cHV0XG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9ydW5BcGlDb21tYW5kKHtcbiAgICAgIGFwaU5hbWU6ICdjaGF0JyxcbiAgICAgIG1ldGhvZDogJ2Rvd25sb2FkJyxcbiAgICAgIG9wdGlvbnM6IGFyZ3NcbiAgICB9KTtcblxuICAgIGlmICghcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleWJhc2UgY2hhdCBkb3dubG9hZCByZXR1cm5lZCBub3RoaW5nJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWFjdHMgdG8gYSBnaXZlbiBtZXNzYWdlIGluIGEgY2hhbm5lbC4gTWVzc2FnZXMgaGF2ZSBtZXNzYWdlSWQncyBhc3NvY2lhdGVkIHdpdGhcbiAgICogdGhlbSwgd2hpY2ggeW91IGNhbiBsZWFybiBpbiBgYm90LmNoYXQucmVhZGAuXG4gICAqIEBtZW1iZXJvZiBDaGF0XG4gICAqIEBwYXJhbSBjaGFubmVsIC0gVGhlIGNoYXQgY2hhbm5lbCB0byBzZW5kIHRoZSBtZXNzYWdlIGluLlxuICAgKiBAcGFyYW0gbWVzc2FnZUlkIC0gVGhlIGlkIG9mIHRoZSBtZXNzYWdlIHRvIHJlYWN0IHRvLlxuICAgKiBAcGFyYW0gcmVhY3Rpb24gLSBUaGUgcmVhY3Rpb24gZW1vamksIGluIGNvbG9uIGZvcm0uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QuXG4gICAqIEBleGFtcGxlXG4gICAqIGJvdC5jaGF0LnJlYWN0KGNoYW5uZWwsIDMxNCwgJzorMTonKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdUaHVtYnMgdXAhJykpXG4gICAqL1xuXG5cbiAgYXN5bmMgcmVhY3QoY2hhbm5lbCwgbWVzc2FnZUlkLCByZWFjdGlvbiwgb3B0aW9ucykge1xuICAgIGF3YWl0IHRoaXMuX2d1YXJkSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBhcmdzID0geyAuLi5vcHRpb25zLFxuICAgICAgY2hhbm5lbCxcbiAgICAgIG1lc3NhZ2VJZCxcbiAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgYm9keTogcmVhY3Rpb25cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX3J1bkFwaUNvbW1hbmQoe1xuICAgICAgYXBpTmFtZTogJ2NoYXQnLFxuICAgICAgbWV0aG9kOiAncmVhY3Rpb24nLFxuICAgICAgb3B0aW9uczogYXJnc1xuICAgIH0pO1xuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2V5YmFzZSBjaGF0IHJlYWN0IHJldHVybmVkIG5vdGhpbmcuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtpZDogcmVzLmlkfVxuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbWVzc2FnZSBpbiBhIGNoYW5uZWwuIE1lc3NhZ2VzIGhhdmUgbWVzc2FnZUlkJ3MgYXNzb2NpYXRlZCB3aXRoXG4gICAqIHRoZW0sIHdoaWNoIHlvdSBjYW4gbGVhcm4gaW4gYGJvdC5jaGF0LnJlYWRgLiBLbm93biBidWc6IHRoZSBHVUkgaGFzIGEgY2FjaGUsXG4gICAqIGFuZCBkZWxldGluZyBmcm9tIHRoZSBDTEkgbWF5IG5vdCBiZWNvbWUgYXBwYXJlbnQgaW1tZWRpYXRlbHkuXG4gICAqIEBtZW1iZXJvZiBDaGF0XG4gICAqIEBwYXJhbSBjaGFubmVsIC0gVGhlIGNoYXQgY2hhbm5lbCB0byBzZW5kIHRoZSBtZXNzYWdlIGluLlxuICAgKiBAcGFyYW0gbWVzc2FnZUlkIC0gVGhlIGlkIG9mIHRoZSBtZXNzYWdlIHRvIGRlbGV0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvYmplY3Qgb2Ygb3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZC5cbiAgICogQGV4YW1wbGVcbiAgICogYm90LmNoYXQuZGVsZXRlKGNoYW5uZWwsIDMxNCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnbWVzc2FnZSBkZWxldGVkIScpKVxuICAgKi9cblxuXG4gIGFzeW5jIGRlbGV0ZShjaGFubmVsLCBtZXNzYWdlSWQsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLl9ndWFyZEluaXRpYWxpemVkKCk7XG4gICAgY29uc3QgYXJncyA9IHsgLi4ub3B0aW9ucyxcbiAgICAgIGNoYW5uZWwsXG4gICAgICBtZXNzYWdlSWRcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX3J1bkFwaUNvbW1hbmQoe1xuICAgICAgYXBpTmFtZTogJ2NoYXQnLFxuICAgICAgbWV0aG9kOiAnZGVsZXRlJyxcbiAgICAgIG9wdGlvbnM6IGFyZ3NcbiAgICB9KTtcblxuICAgIGlmICghcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleWJhc2UgY2hhdCBkZWxldGUgcmV0dXJuZWQgbm90aGluZy4nKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExpc3RlbnMgZm9yIG5ldyBjaGF0IG1lc3NhZ2VzIG9uIGEgc3BlY2lmaWVkIGNoYW5uZWwuIFRoZSBgb25NZXNzYWdlYCBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGV2ZXJ5IG1lc3NhZ2UgeW91ciBib3QgcmVjZWl2ZXMuIFRoaXMgaXMgcHJldHR5IHNpbWlsYXIgdG8gYHdhdGNoQWxsQ2hhbm5lbHNGb3JOZXdNZXNzYWdlc2AsIGV4Y2VwdCBpdCBzcGVjaWZpY2FsbHkgY2hlY2tzIG9uZSBjaGFubmVsLiBOb3RlIHRoYXQgaXQgcmVjZWl2ZXMgbWVzc2FnZXMgeW91ciBvd24gYm90IHBvc3RzLCBidXQgZnJvbSBvdGhlciBkZXZpY2VzLiBZb3UgY2FuIGZpbHRlciBvdXQgeW91ciBvd24gbWVzc2FnZXMgYnkgbG9va2luZyBhdCBhIG1lc3NhZ2UncyBzZW5kZXIgb2JqZWN0LlxuICAgKiBAbWVtYmVyb2YgQ2hhdFxuICAgKiBAcGFyYW0gY2hhbm5lbCAtIFRoZSBjaGF0IGNoYW5uZWwgdG8gd2F0Y2guXG4gICAqIEBwYXJhbSBvbk1lc3NhZ2UgLSBBIGNhbGxiYWNrIHRoYXQgaXMgdHJpZ2dlcmVkIG9uIGV2ZXJ5IG1lc3NhZ2UgeW91ciBib3QgcmVjZWl2ZXMuXG4gICAqIEBwYXJhbSBvbkVycm9yIC0gQSBjYWxsYmFjayB0aGF0IGlzIHRyaWdnZXJlZCBvbiBhbnkgZXJyb3IgdGhhdCBvY2N1cnMgd2hpbGUgdGhlIG1ldGhvZCBpcyBleGVjdXRpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFJlcGx5IHRvIGFsbCBtZXNzYWdlcyBiZXR3ZWVuIHlvdSBhbmQgYGtib3RgIHdpdGggJ3RoYW5rcyEnXG4gICAqIGNvbnN0IGNoYW5uZWwgPSB7bmFtZTogJ2tib3QsJyArIGJvdC5teUluZm8oKS51c2VybmFtZSwgcHVibGljOiBmYWxzZSwgdG9waWNfdHlwZTogJ2NoYXQnfVxuICAgKiBjb25zdCBvbk1lc3NhZ2UgPSBtZXNzYWdlID0+IHtcbiAgICogICBjb25zdCBjaGFubmVsID0gbWVzc2FnZS5jaGFubmVsXG4gICAqICAgYm90LmNoYXQuc2VuZCh7XG4gICAqICAgIGNoYW5uZWw6IGNoYW5uZWwsXG4gICAqICAgICAgbWVzc2FnZToge1xuICAgKiAgICAgICAgYm9keTogJ3RoYW5rcyEhIScsXG4gICAqICAgICAgfSxcbiAgICogICB9KVxuICAgKiB9XG4gICAqIGJvdC5jaGF0LndhdGNoQ2hhbm5lbEZvck5ld01lc3NhZ2VzKGNoYW5uZWwsIG9uTWVzc2FnZSlcbiAgICovXG5cblxuICBhc3luYyB3YXRjaENoYW5uZWxGb3JOZXdNZXNzYWdlcyhjaGFubmVsLCBvbk1lc3NhZ2UsIG9uRXJyb3IpIHtcbiAgICBhd2FpdCB0aGlzLl9ndWFyZEluaXRpYWxpemVkKCk7XG5cbiAgICB0aGlzLl9jaGF0TGlzdGVuKG9uTWVzc2FnZSwgb25FcnJvciwgY2hhbm5lbCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwdXQgeW91ciBib3QgaW50byBmdWxsLXJlYWQgbW9kZSwgd2hlcmUgaXQgcmVhZHNcbiAgICogZXZlcnl0aGluZyBpdCBjYW4gYW5kIGV2ZXJ5IG5ldyBtZXNzYWdlIGl0IGZpbmRzIGl0IHdpbGwgcGFzcyB0byB5b3UsIHNvXG4gICAqIHlvdSBjYW4gZG8gd2hhdCB5b3Ugd2FudCB3aXRoIGl0LiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gd3JpdGUgYVxuICAgKiBLZXliYXNlIGJvdCB0aGF0IHRhbGtzIHNoaXQgYXQgYW55b25lIHdobyBkYXJlcyBhcHByb2FjaCBpdCwgdGhpcyBpcyB0aGVcbiAgICogZnVuY3Rpb24gdG8gdXNlLiBOb3RlIHRoYXQgaXQgcmVjZWl2ZXMgbWVzc2FnZXMgeW91ciBvd24gYm90IHBvc3RzLCBidXQgZnJvbSBvdGhlciBkZXZpY2VzLlxuICAgKiBZb3UgY2FuIGZpbHRlciBvdXQgeW91ciBvd24gbWVzc2FnZXMgYnkgbG9va2luZyBhdCBhIG1lc3NhZ2UncyBzZW5kZXIgb2JqZWN0LlxuICAgKiBAbWVtYmVyb2YgQ2hhdFxuICAgKiBAcGFyYW0gb25NZXNzYWdlIC0gQSBjYWxsYmFjayB0aGF0IGlzIHRyaWdnZXJlZCBvbiBldmVyeSBtZXNzYWdlIHlvdXIgYm90IHJlY2VpdmVzLlxuICAgKiBAcGFyYW0gb25FcnJvciAtIEEgY2FsbGJhY2sgdGhhdCBpcyB0cmlnZ2VyZWQgb24gYW55IGVycm9yIHRoYXQgb2NjdXJzIHdoaWxlIHRoZSBtZXRob2QgaXMgZXhlY3V0aW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBSZXBseSB0byBpbmNvbWluZyB0cmFmZmljIG9uIGFsbCBjaGFubmVscyB3aXRoICd0aGFua3MhJ1xuICAgKiBjb25zdCBvbk1lc3NhZ2UgPSBtZXNzYWdlID0+IHtcbiAgICogICBjb25zdCBjaGFubmVsID0gbWVzc2FnZS5jaGFubmVsXG4gICAqICAgYm90LmNoYXQuc2VuZCh7XG4gICAqICAgIGNoYW5uZWw6IGNoYW5uZWwsXG4gICAqICAgICAgbWVzc2FnZToge1xuICAgKiAgICAgICAgYm9keTogJ3RoYW5rcyEhIScsXG4gICAqICAgICAgfSxcbiAgICogICB9KVxuICAgKiB9XG4gICAqIGJvdC5jaGF0LndhdGNoQWxsQ2hhbm5lbHNGb3JOZXdNZXNzYWdlcyhvbk1lc3NhZ2UpXG4gICAqXG4gICAqL1xuXG5cbiAgYXN5bmMgd2F0Y2hBbGxDaGFubmVsc0Zvck5ld01lc3NhZ2VzKG9uTWVzc2FnZSwgb25FcnJvcikge1xuICAgIGF3YWl0IHRoaXMuX2d1YXJkSW5pdGlhbGl6ZWQoKTtcblxuICAgIHRoaXMuX2NoYXRMaXN0ZW4ob25NZXNzYWdlLCBvbkVycm9yKTtcbiAgfVxuICAvKipcbiAgICogU3Bhd25zIHRoZSBjaGF0IGxpc3RlbiBwcm9jZXNzIGFuZCBoYW5kbGVzIHRoZSBjYWxsaW5nIG9mIG9uTWVzc2FnZSwgb25FcnJvciwgYW5kIGZpbHRlcmluZyBmb3IgYSBzcGVjaWZpYyBjaGFubmVsLlxuICAgKiBAbWVtYmVyb2YgQ2hhdFxuICAgKiBAaWdub3JlXG4gICAqIEBwYXJhbSBvbk1lc3NhZ2UgLSBBIGNhbGxiYWNrIHRoYXQgaXMgdHJpZ2dlcmVkIG9uIGV2ZXJ5IG1lc3NhZ2UgeW91ciBib3QgcmVjZWl2ZXMuXG4gICAqIEBwYXJhbSBvbkVycm9yIC0gQSBjYWxsYmFjayB0aGF0IGlzIHRyaWdnZXJlZCBvbiBhbnkgZXJyb3IgdGhhdCBvY2N1cnMgd2hpbGUgdGhlIG1ldGhvZCBpcyBleGVjdXRpbmcuXG4gICAqIEBwYXJhbSBjaGFubmVsIC0gVGhlIGNoYXQgY2hhbm5lbCB0byB3YXRjaC5cbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5fY2hhdExpc3Rlbihvbk1lc3NhZ2UsIG9uRXJyb3IpXG4gICAqL1xuXG5cbiAgX2NoYXRMaXN0ZW4ob25NZXNzYWdlLCBvbkVycm9yLCBjaGFubmVsKSB7XG4gICAgY29uc3QgYXJncyA9IFsnY2hhdCcsICdhcGktbGlzdGVuJ107XG5cbiAgICBpZiAodGhpcy5ob21lRGlyKSB7XG4gICAgICBhcmdzLnVuc2hpZnQoJy0taG9tZScsIHRoaXMuaG9tZURpcik7XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZF9wcm9jZXNzLnNwYXduKHRoaXMuX3BhdGhUb0tleWJhc2VCaW5hcnkoKSwgYXJncyk7XG4gICAgdGhpcy5zcGF3bmVkUHJvY2Vzc2VzLnB1c2goY2hpbGQpO1xuICAgIGNvbnN0IGxpbmVSZWFkZXJTdGRvdXQgPSByZWFkbGluZS5jcmVhdGVJbnRlcmZhY2Uoe1xuICAgICAgaW5wdXQ6IGNoaWxkLnN0ZG91dFxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25MaW5lID0gbGluZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtZXNzYWdlT2JqZWN0ID0gZm9ybWF0QVBJT2JqZWN0T3V0cHV0KEpTT04ucGFyc2UobGluZSkpO1xuXG4gICAgICAgIGlmIChtZXNzYWdlT2JqZWN0Lmhhc093blByb3BlcnR5KCdlcnJvcicpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VPYmplY3QuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKCAvLyBmaXJlIG9uTWVzc2FnZSBpZiBpdCB3YXMgZnJvbSBhIGRpZmZlcmVudCBzZW5kZXIgb3IgYXQgbGVhc3QgYSBkaWZmZXJlbnQgZGV2aWNlXG4gICAgICAgIC8vIGZyb20gdGhpcyBzZW5kZXIuIEJvdHMgY2FuIGZpbHRlciBvdXQgdGhlaXIgb3duIG1lc3NhZ2VzIGZyb20gb3RoZXIgZGV2aWNlcy5cbiAgICAgICAgKCFjaGFubmVsIHx8IGNoYW5uZWwubmFtZSA9PT0gbWVzc2FnZU9iamVjdC5tc2cuY2hhbm5lbC5uYW1lKSAmJiB0aGlzLnVzZXJuYW1lICYmIHRoaXMuZGV2aWNlbmFtZSAmJiAobWVzc2FnZU9iamVjdC5tc2cuc2VuZGVyLnVzZXJuYW1lICE9PSB0aGlzLnVzZXJuYW1lLnRvTG93ZXJDYXNlKCkgfHwgbWVzc2FnZU9iamVjdC5tc2cuc2VuZGVyLmRldmljZU5hbWUgIT09IHRoaXMuZGV2aWNlbmFtZSkpIHtcbiAgICAgICAgICBvbk1lc3NhZ2UobWVzc2FnZU9iamVjdC5tc2cpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpbmVSZWFkZXJTdGRvdXQub24oJ2xpbmUnLCBvbkxpbmUpO1xuICB9XG5cbn1cblxuLyoqIFRoZSB3YWxsZXQgbW9kdWxlIG9mIHlvdXIgS2V5YmFzZSBib3QuIEZvciBtb3JlIGluZm8gYWJvdXQgdGhlIEFQSSB0aGlzIG1vZHVsZSB1c2VzLCB5b3UgbWF5IHdhbnQgdG8gY2hlY2sgb3V0IGBrZXliYXNlIHdhbGxldCBhcGlgLiAqL1xuY2xhc3MgV2FsbGV0IGV4dGVuZHMgQ2xpZW50QmFzZSB7XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGxpc3Qgb2YgYWxsIGFjY291bnRzIG93bmVkIGJ5IHRoZSBjdXJyZW50IEtleWJhc2UgdXNlci5cbiAgICogQG1lbWJlcm9mIFdhbGxldFxuICAgKiBAcmV0dXJucyAtIEFuIGFycmF5IG9mIGFjY291bnRzLiBJZiB0aGVyZSBhcmUgbm8gYWNjb3VudHMsIHRoZSBhcnJheSBpcyBlbXB0eS5cbiAgICogQGV4YW1wbGVcbiAgICogYm90LndhbGxldC5iYWxhbmNlcygpLnRoZW4oYWNjb3VudHMgPT4gY29uc29sZS5sb2coYWNjb3VudHMpKVxuICAgKi9cbiAgYXN5bmMgYmFsYW5jZXMoKSB7XG4gICAgYXdhaXQgdGhpcy5fZ3VhcmRJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX3J1bkFwaUNvbW1hbmQoe1xuICAgICAgYXBpTmFtZTogJ3dhbGxldCcsXG4gICAgICBtZXRob2Q6ICdiYWxhbmNlcydcbiAgICB9KTtcblxuICAgIGlmICghcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleWJhc2Ugd2FsbGV0IGJhbGFuYWNlcyByZXR1cm5lZCBub3RoaW5nLicpO1xuICAgIH1cblxuICAgIHJldHVybiByZXMgfHwgW107XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgbGlzdCBvZiBhbGwgdHJhbnNhY3Rpb25zIGluIGEgc2luZ2xlIGFjY291bnQuXG4gICAqIEBtZW1iZXJvZiBXYWxsZXRcbiAgICogQHBhcmFtIGFjY291bnRJZCAtIFRoZSBpZCBvZiBhbiBhY2NvdW50IG93bmVkIGJ5IGEgS2V5YmFzZSB1c2VyLlxuICAgKiBAcmV0dXJucyAtIEFuIGFycmF5IG9mIHRyYW5zYWN0aW9ucyByZWxhdGVkIHRvIHRoZSBhY2NvdW50LlxuICAgKiBAZXhhbXBsZVxuICAgKiBib3Qud2FsbGV0Lmhpc3RvcnkoJ0dEVUtaSDZRM1U1V1FENFBER1pYWUxKRTNQNzZCRFJEV1BTQUxONE9VRkVFU0kyUUw1VVpIQ0snKS50aGVuKHRyYW5zYWN0aW9ucyA9PiBjb25zb2xlLmxvZyh0cmFuc2FjdGlvbnMpKVxuICAgKi9cblxuXG4gIGFzeW5jIGhpc3RvcnkoYWNjb3VudElkKSB7XG4gICAgYXdhaXQgdGhpcy5fZ3VhcmRJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBhY2NvdW50SWRcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX3J1bkFwaUNvbW1hbmQoe1xuICAgICAgYXBpTmFtZTogJ3dhbGxldCcsXG4gICAgICBtZXRob2Q6ICdoaXN0b3J5JyxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcblxuICAgIGlmICghcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleWJhc2Ugd2FsbGV0IGhpc3RvcnkgcmV0dXJuZWQgbm90aGluZy4nKTtcbiAgICB9IC8vIFJlbW92ZXMgYSBzaW5nbGUgb2JqZWN0IHdpdGggcHJvcGVydHkgYHBheW1lbnRgXG5cblxuICAgIGNvbnN0IGNsZWFuZWRSZXMgPSByZXMubWFwKHBheW1lbnQgPT4gcGF5bWVudC5wYXltZW50KTtcbiAgICByZXR1cm4gY2xlYW5lZFJlcztcbiAgfVxuICAvKipcbiAgICogR2V0IGRldGFpbHMgYWJvdXQgYSBwYXJ0aWN1bGFyIHRyYW5zYWN0aW9uXG4gICAqIEBtZW1iZXJvZiBXYWxsZXRcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uSWQgLSBUaGUgaWQgb2YgdGhlIHRyYW5zYWN0aW9uIHlvdSB3b3VsZCBsaWtlIGRldGFpbHMgYWJvdXQuXG4gICAqIEByZXR1cm5zIC0gQW4gb2JqZWN0IG9mIGRldGFpbHMgYWJvdXQgdGhlIHRyYW5zYWN0aW9uIHNwZWNpZmllZC5cbiAgICogQGV4YW1wbGVcbiAgICogYm90LndhbGxldC5kZXRhaWxzKCdlNTMzNDYwMWI5ZGMyYTI0ZTAzMWZmZWVjMmZjZTM3YmI2YThiNGI1MWZjNzExZDE2ZGVjMDRkM2U2NDk3NmM0JykudGhlbihkZXRhaWxzID0+IGNvbnNvbGUubG9nKGRldGFpbHMpKVxuICAgKi9cblxuXG4gIGFzeW5jIGRldGFpbHModHJhbnNhY3Rpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX2d1YXJkSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgdHhpZDogdHJhbnNhY3Rpb25JZFxuICAgIH07XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fcnVuQXBpQ29tbWFuZCh7XG4gICAgICBhcGlOYW1lOiAnd2FsbGV0JyxcbiAgICAgIG1ldGhvZDogJ2RldGFpbHMnLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2V5YmFzZSB3YWxsZXQgZGV0YWlscyByZXR1cm5lZCBub3RoaW5nLicpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXG4gICAqIExvb2t1cCB0aGUgcHJpbWFyeSBTdGVsbGFyIGFjY291bnQgSUQgb2YgYSBLZXliYXNlIHVzZXIuXG4gICAqIEBtZW1iZXJvZiBXYWxsZXRcbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdXNlciB5b3Ugd2FudCB0byBsb29rdXAuIFRoaXMgY2FuIGJlIGVpdGhlciBhIEtleWJhc2UgdXNlcm5hbWUgb3IgYSB1c2VybmFtZSBvZiBhbm90aGVyIGFjY291bnQgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgS2V5YmFzZSBpZiBpdCBpcyBmb2xsb3dlZCBieSBhbiAnQDxzZXJ2aWNlPicuXG4gICAqIEByZXR1cm5zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGFjY291bnQgSUQgYW5kIEtleWJhc2UgdXNlcm5hbWUgb2YgdGhlIGZvdW5kIHVzZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGxvb2t1cDEgPSBib3Qud2FsbGV0Lmxvb2t1cCgncGF0cmljaycpXG4gICAqIC8vICdwYXRyaWNrJyBvbiBLZXliYXNlIGlzICdwYXRyaWNreGInIG9uIHR3aXR0ZXJcbiAgICogY29uc3QgbG9va3VwMiA9IGJvdC53YWxsZXQubG9va3VwKCdwYXRyY2lreGJAdHdpdHRlcicpXG4gICAqIC8vIFVzaW5nIExvZGFzaCdzIGBpc0VxdWFsYCBzaW5jZSBvYmplY3RzIHdpdGggc2FtZSB2YWx1ZXMgYXJlbid0IGVxdWFsIGluIEphdmFTY3JpcHRcbiAgICogXy5pc0VxdWFsKGxvb2t1cDEsIGxvb2t1cDIpIC8vID0+IHRydWVcbiAgICovXG5cblxuICBhc3luYyBsb29rdXAobmFtZSkge1xuICAgIGF3YWl0IHRoaXMuX2d1YXJkSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgbmFtZVxuICAgIH07XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fcnVuQXBpQ29tbWFuZCh7XG4gICAgICBhcGlOYW1lOiAnd2FsbGV0JyxcbiAgICAgIG1ldGhvZDogJ2xvb2t1cCcsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXliYXNlIHdhbGxldCBsb29rdXAgcmV0dXJuZWQgbm90aGluZy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGx1bWVucyAoWExNKSB2aWEgS2V5YmFzZSB3aXRoIHlvdXIgYm90IVxuICAgKiBAbWVtYmVyb2YgV2FsbGV0XG4gICAqIEBwYXJhbSByZWNpcGllbnQgLSBXaG8geW91J3JlIHNlbmRpbmcgeW91ciBtb25leSB0by4gVGhpcyBjYW4gYmUgYSBLZXliYXNlIHVzZXIsIHN0ZWxsYXIgYWRkcmVzcywgb3IgYSB1c2VybmFtZSBvZiBhbm90aGVyIGFjY291bnQgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgS2V5YmFzZSBpZiBpdCBpcyBmb2xsb3dlZCBieSBhbiAnQDxzZXJ2aWNlPicuXG4gICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIFhMTSB0byBzZW5kLlxuICAgKiBAcGFyYW0gW2N1cnJlbmN5XSAtIEFkZHMgYSBjdXJyZW5jeSB2YWx1ZSB0byB0aGUgYW1vdW50IHNwZWNpZmllZC4gRm9yIGV4YW1wbGUsIGFkZGluZyAnVVNEJyB3b3VsZCBzZW5kXG4gICAqIEBwYXJhbSBbbWVzc2FnZV0gLSBUaGUgbWVzc2FnZSBmb3IgeW91ciBwYXltZW50XG4gICAqIEByZXR1cm5zIC0gVGhlIHRyYXNhY3Rpb24gb2JqZWN0IG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICogYm90LndhbGxldC5zZW5kKCduYXRodW5zbWl0dHknLCAnMy41MCcpIC8vIFNlbmQgMy41MCBYTE0gdG8gS2V5YmFzZSB1c2VyIGBuYXRodW5zbWl0dHlgXG4gICAqIGJvdC53YWxsZXQuc2VuZCgnbmF0aHVuc21pdHR5QGdpdGh1YicsICczLjUwJykgLy8gU2VuZCAzLjUwIFhMTSB0byBHaXRIdWIgdXNlciBgbmF0aHVuc21pdHR5YFxuICAgKiBib3Qud2FsbGV0LnNlbmQoJ25hdGh1bnNtaXR0eScsICczLjUwJywgJ1VTRCcpIC8vIFNlbmQgJDMuNTAgd29ydGggb2YgbHVtZW5zIHRvIEtleWJhc2UgdXNlciBgbmF0aHVuc21pdHR5YFxuICAgKiBib3Qud2FsbGV0LnNlbmQoJ25hdGh1bnNtaXR0eScsICczLjUwJywgJ1VTRCcsICdTaHV0IHVwIGFuZCB0YWtlIG15IG1vbmV5IScpIC8vIFNlbmQgJDMuNTAgd29ydGggb2YgbHVtZW5zIHRvIEtleWJhc2UgdXNlciBgbmF0aHVuc21pdHR5YCB3aXRoIGEgbWVtb1xuICAgKi9cblxuXG4gIGFzeW5jIHNlbmQocmVjaXBpZW50LCBhbW91bnQsIGN1cnJlbmN5LCBtZXNzYWdlKSB7XG4gICAgYXdhaXQgdGhpcy5fZ3VhcmRJbml0aWFsaXplZCgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICByZWNpcGllbnQsXG4gICAgICBhbW91bnQsXG4gICAgICBjdXJyZW5jeSxcbiAgICAgIG1lc3NhZ2VcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX3J1bkFwaUNvbW1hbmQoe1xuICAgICAgYXBpTmFtZTogJ3dhbGxldCcsXG4gICAgICBtZXRob2Q6ICdzZW5kJyxcbiAgICAgIG9wdGlvbnNcbiAgICB9KTtcblxuICAgIGlmICghcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleWJhc2Ugd2FsbGV0IHNlbmQgcmV0dXJuZWQgbm90aGluZy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kIGx1bWVucyAoWExNKSB2aWEgS2V5YmFzZSB0byBtb3JlIHRoYW4gb25lIHVzZXIgYXQgb25jZS4gQXMgb3Bwb3NlZCB0byB0aGUgbm9ybWFsIGJvdC53YWxsZXQuc2VuZFxuICAgKiBjb21tYW5kLCB0aGlzIGNhbiBnZXQgbXVsdGlwbGUgdHJhbnNhY3Rpb25zIGludG8gdGhlIHNhbWUgNS1zZWNvbmQgU3RlbGxhciBsZWRnZXIuXG4gICAqIEBtZW1iZXJvZiBXYWxsZXRcbiAgICogQHBhcmFtIGJhdGNoSWQgLSBhIHVuaXF1ZSBJZCBmb3IgdGhpcyBiYXRjaCwgd2hpY2ggeW91IHByb3ZpZGUuIEV4YW1wbGUsIGBhaXJkcm9wMjAyNWAuIEEgdXNlciBjYW4gb25seSByZWNlaXZlIG9uY2UgcGVyIGJhdGNoSWQsIGVuZm9yY2VkIGJ5IEtleWJhc2UsIHNvIGlmIHlvdSBydW4gYSBwcm9ncmFtIHR3aWNlIHdpdGggdGhlIHNhbWUgYmF0Y2hJZCBhbmQgc2VuZCB0byB0aGUgc2FtZSB1c2Vycywgc3Vic2VxdWVudCBzZW5kcyB3aWxsIGVycm9yLlxuICAgKiBAcGFyYW0gcGF5bWVudHMgLSBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgcmVjaXBpZW50cyBhbmQgWExNIG9mIHRoZSBmb3JtIHtcInJlY2lwaWVudFwiOiBcInNvbWV1c2VybmFtZVwiLCBcImFtb3VudFwiOiBcIjEuMjM0XCIsIFwibWVzc2FnZVwiLCBcImhpIHRoZXJlXCJ9XG4gICAqIEByZXR1cm5zIC0gYW4gb2JqZWN0XG4gICAqIEBleGFtcGxlXG4gICAqIGJvdC53YWxsZXQuYmF0Y2goXCJhaXJkcm9wMjA0MFwiLFt7XCJyZWNpcGllbnRcIjpcImExXCIsXCJhbW91bnRcIjogXCIxLjQxNFwiLCBcIm1lc3NhZ2VcIjogXCJoaSBhMSwgeWVzIDFcIn0se1wicmVjaXBpZW50XCI6IFwiYTJcIiwgXCJhbW91bnRcIjogXCIzLjE0MTU5XCIsIFwibWVzc2FnZVwiOiBcImhpIGEyLCB5ZXMgMlwifSx9XSlcbiAgICovXG5cblxuICBhc3luYyBiYXRjaChiYXRjaElkLCBwYXltZW50cykge1xuICAgIGF3YWl0IHRoaXMuX2d1YXJkSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgYmF0Y2hJZCxcbiAgICAgIHBheW1lbnRzXG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9ydW5BcGlDb21tYW5kKHtcbiAgICAgIGFwaU5hbWU6ICd3YWxsZXQnLFxuICAgICAgbWV0aG9kOiAnYmF0Y2gnLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignS2V5YmFzZSB3YWxsZXQgYmF0Y2ggcmV0dXJuZWQgbm90aGluZy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBJZiB5b3Ugc2VuZCBYTE0gdG8gYSBLZXliYXNlIHVzZXIgd2hvIGhhcyBub3QgZXN0YWJsaXNoZWQgYSB3YWxsZXQsIHlvdSBjYW4gY2FuY2VsIHRoZSBwYXltZW50IGJlZm9yZSB0aGUgcmVjaXBpZW50IGNsYWltcyBpdCBhbmQgdGhlIFhMTSB3aWxsIGJlIHJldHVybmVkIHRvIHlvdXIgYWNjb3VudC5cbiAgICogQG1lbWJlcm9mIFdhbGxldFxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25JZCAtIFRoZSBpZCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gY2FuY2VsLlxuICAgKiBAZXhhbXBsZVxuICAgKiBib3Qud2FsbGV0LmNhbmNlbCgnZTUzMzQ2MDFiOWRjMmEyNGUwMzFmZmVlYzJmY2UzN2JiNmE4YjRiNTFmYzcxMWQxNmRlYzA0ZDNlNjQ5NzZjNCcpLnRoZW4oKCkgPT4gY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uIHN1Y2Nlc3NmdWxseSBjYW5jZWxlZCEnKSlcbiAgICovXG5cblxuICBhc3luYyBjYW5jZWwodHJhbnNhY3Rpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX2d1YXJkSW5pdGlhbGl6ZWQoKTtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgdHhpZDogdHJhbnNhY3Rpb25JZFxuICAgIH07XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fcnVuQXBpQ29tbWFuZCh7XG4gICAgICBhcGlOYW1lOiAnd2FsbGV0JyxcbiAgICAgIG1ldGhvZDogJ2NhbmNlbCcsXG4gICAgICBvcHRpb25zXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXliYXNlIHdhbGxldCBjYW5jZWwgcmV0dXJuZWQgbm90aGluZy4nKTtcbiAgICB9XG4gIH1cblxufVxuXG4vKiogQSBLZXliYXNlIGJvdC4gKi9cbmNsYXNzIEJvdCB7XG4gIC8vIHdoZXJlIEtCIGJpbmFyeSBjb3BpZWQsIGFuZCBob21lRGlyIChpZiBub3QgZXhpc3Rpbmcgc3ZjKVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBib3QuIE5vdGUgeW91IGNhbid0IGRvIG11Y2ggdG9vIGV4Y2l0aW5nIHdpdGggeW91ciBib3QgYWZ0ZXIgeW91IGluc3RhbnRpYXRlIGl0OyB5b3UgaGF2ZSB0byBpbml0aWFsaXplIGl0IGZpcnN0LlxuICAgKiBAbWVtYmVyb2YgQm90XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGJvdCA9IG5ldyBCb3QoKVxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fd29ya2luZ0RpciA9IHJhbmRvbVRlbXBEaXIoKTtcbiAgICB0aGlzLl9zZXJ2aWNlID0gbmV3IFNlcnZpY2UodGhpcy5fd29ya2luZ0Rpcik7XG4gICAgdGhpcy5jaGF0ID0gbmV3IENoYXQodGhpcy5fd29ya2luZ0Rpcik7XG4gICAgdGhpcy53YWxsZXQgPSBuZXcgV2FsbGV0KHRoaXMuX3dvcmtpbmdEaXIpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHlvdXIgYm90IGJ5IHN0YXJ0aW5nIGFuIGluc3RhbmNlIG9mIHRoZSBLZXliYXNlIHNlcnZpY2UgYW5kIGxvZ2dpbmcgaW4gdXNpbmcgb25lc2hvdCBtb2RlLlxuICAgKiBAbWVtYmVyb2YgQm90XG4gICAqIEBwYXJhbSB1c2VybmFtZSAtIFRoZSB1c2VybmFtZSBvZiB5b3VyIGJvdCdzIEtleWJhc2UgYWNjb3VudC5cbiAgICogQHBhcmFtIHBhcGVya2V5IC0gVGhlIHBhcGVya2V5IG9mIHlvdXIgYm90J3MgS2V5YmFzZSBhY2NvdW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBpbml0aWFsaXphdGlvbiBvcHRpb25zIGZvciB5b3VyIGJvdC5cbiAgICogQGV4YW1wbGVcbiAgICogYm90LmluaXQoJ3VzZXJuYW1lJywgJ3BhcGVya2V5JylcbiAgICovXG5cblxuICBhc3luYyBpbml0KHVzZXJuYW1lLCBwYXBlcmtleSwgb3B0aW9ucykge1xuICAgIGF3YWl0IHRoaXMuX3ByZXBXb3JraW5nRGlyKCk7XG4gICAgYXdhaXQgdGhpcy5fc2VydmljZS5pbml0KHVzZXJuYW1lLCBwYXBlcmtleSwgb3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5faW5pdFN1YkJvdHMob3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgeW91ciBib3QgYnkgdXNpbmcgYW4gZXhpc3RpbmcgcnVubmluZyBzZXJ2aWNlIHdpdGggYSBsb2dnZWQgaW4gdXNlci5cbiAgICogQG1lbWJlcm9mIEJvdFxuICAgKiBAcGFyYW0gaG9tZURpciAtIFRoZSBob21lIGRpcmVjdG9yeSBvZiB0aGlzIGN1cnJlbnRseSBydW5uaW5nIHNlcnZpY2UuIExlYXZlIGJsYW5rIHRvIHVzZSB0aGUgZGVmYXVsdCBob21lRGlyIGZvciB5b3VyIHN5c3RlbS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgaW5pdGlhbGl6YXRpb24gb3B0aW9ucyBmb3IgeW91ciBib3QuXG4gICAqIEBleGFtcGxlXG4gICAqIGJvdC5pbml0RnJvbVJ1bm5pbmdTZXJ2aWNlKClcbiAgICovXG5cblxuICBhc3luYyBpbml0RnJvbVJ1bm5pbmdTZXJ2aWNlKGhvbWVEaXIsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLl9wcmVwV29ya2luZ0RpcigpO1xuICAgIGF3YWl0IHRoaXMuX3NlcnZpY2UuaW5pdEZyb21SdW5uaW5nU2VydmljZShob21lRGlyLCBvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLl9pbml0U3ViQm90cyhvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGluZm8gYWJvdXQgeW91ciBib3QhXG4gICAqIEBtZW1iZXJvZiBCb3RcbiAgICogQHJldHVybnMg4oCTIFVzZWZ1bCBpbmZvcm1hdGlvbiBsaWtlIHRoZSB1c2VybmFtZSwgZGV2aWNlLCBhbmQgaG9tZSBkaXJlY3Rvcnkgb2YgeW91ciBib3QuIElmIHlvdXIgYm90IGlzbid0IGluaXRpYWxpemVkLCB5b3UnbGwgZ2V0IGBudWxsYC5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgaW5mbyA9IGJvdC5teUluZm8oKVxuICAgKi9cblxuXG4gIG15SW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VydmljZS5teUluZm8oKTtcbiAgfVxuICAvKipcbiAgICogRGVpbml0aWFsaXplcyB0aGUgYm90IGJ5IGxvZ2dpbmcgb3V0LCBzdG9wcGluZyB0aGUga2V5YmFzZSBzZXJ2aWNlLCBhbmQgcmVtb3ZpbmcgYW55IGxlZnRvdmVyIGxvZ2luIGZpbGVzIG1hZGUgYnkgdGhlIGJvdC4gVGhpcyBzaG91bGQgYmUgcnVuIGJlZm9yZSB5b3VyIGJvdCBlbmRzLlxuICAgKiBAbWVtYmVyb2YgQm90XG4gICAqIEBleGFtcGxlXG4gICAqIGJvdC5kZWluaXQoKVxuICAgKi9cblxuXG4gIGFzeW5jIGRlaW5pdCgpIHtcbiAgICAvLyBTdG9wIHRoZSBjbGllbnRzIGZpcnN0LCBzbyB0aGF0IHRoZXkgYXJlbid0IHRyeWluZyB0b1xuICAgIC8vIHRhbGsgdG8gYSBkZWluaXQnZWQgc2VydmljZVxuICAgIGF3YWl0IHRoaXMuY2hhdC5fZGVpbml0KCk7XG4gICAgYXdhaXQgdGhpcy5fc2VydmljZS5kZWluaXQoKTtcbiAgICBhd2FpdCBybWRpclJlY3Vyc2l2ZSh0aGlzLl93b3JraW5nRGlyKTtcbiAgfVxuXG4gIGFzeW5jIF9wcmVwV29ya2luZ0RpcigpIHtcbiAgICBjb25zdCBrZXliYXNlQmluYXJ5TG9jYXRpb24gPSBhd2FpdCB3aGljaEtleWJhc2UoKTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHBhdGguam9pbih0aGlzLl93b3JraW5nRGlyLCAna2V5YmFzZScpO1xuICAgIGF3YWl0IHV0aWwucHJvbWlzaWZ5KG1rZGlycCkodGhpcy5fd29ya2luZ0Rpcik7XG4gICAgYXdhaXQgdXRpbC5wcm9taXNpZnkoZnMuY29weUZpbGUpKGtleWJhc2VCaW5hcnlMb2NhdGlvbiwgZGVzdGluYXRpb24pO1xuICB9XG5cbiAgYXN5bmMgX2luaXRTdWJCb3RzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5teUluZm8oKTtcblxuICAgIGlmIChpbmZvKSB7XG4gICAgICBhd2FpdCB0aGlzLmNoYXQuX2luaXQoaW5mby5ob21lRGlyLCBvcHRpb25zKTtcbiAgICAgIGF3YWl0IHRoaXMud2FsbGV0Ll9pbml0KGluZm8uaG9tZURpciwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSXNzdWUgaW5pdGlhbGl6aW5nIGJvdC4nKTtcbiAgICB9XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJvdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG52YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xudmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZlxcXFx1ZmUyMC1cXFxcdWZlMjMnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmMCcsXG4gICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib01hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgJ10nLFxuICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcnNMb3dlck1pc2MgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNVcHBlck1pc2MgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNPcHRMb3dlckNvbnRyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgcnNPcHRVcHBlckNvbnRyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xudmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAqL1xudmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG52YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRMb3dlckNvbnRyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzVXBwZXJNaXNjICsgJysnICsgcnNPcHRVcHBlckNvbnRyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTG93ZXJNaXNjLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXJNaXNjICsgJysnICsgcnNPcHRMb3dlckNvbnRyLFxuICByc1VwcGVyICsgJysnICsgcnNPcHRVcHBlckNvbnRyLFxuICByc0RpZ2l0cyxcbiAgcnNFbW9qaVxuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xudmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib01hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbnZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mix9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4vKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJyxcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3NzJ1xufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufVxuXG4vKipcbiAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAqL1xudmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgOiBhc2NpaVRvQXJyYXkoc3RyaW5nKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59XG5cbi8qKlxuICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICovXG5mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAqIC8vID0+ICdmb29CYXInXG4gKlxuICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gKiAvLyA9PiAnZm9vQmFyJ1xuICpcbiAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICogLy8gPT4gJ2Zvb0JhcidcbiAqL1xudmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gKiB0byBsb3dlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICogLy8gPT4gJ0ZyZWQnXG4gKi9cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG59XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gKiAvLyA9PiAnRnJlZCdcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAqIC8vID0+ICdGUkVEJ1xuICovXG52YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxuLyoqXG4gKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICpcbiAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAqL1xuZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxDYXNlO1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG52YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIExhdGluIFVuaWNvZGUgbGV0dGVycyAoZXhjbHVkaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRvcnMpLiAqL1xudmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZlxcXFx1ZmUyMC1cXFxcdWZlMjMnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmMCcsXG4gICAgcnNEaW5nYmF0UmFuZ2UgPSAnXFxcXHUyNzAwLVxcXFx1MjdiZicsXG4gICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICByc05vbkNoYXJSYW5nZSA9ICdcXFxceDAwLVxcXFx4MmZcXFxceDNhLVxcXFx4NDBcXFxceDViLVxcXFx4NjBcXFxceDdiLVxcXFx4YmYnLFxuICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgIHJzVXBwZXJSYW5nZSA9ICdBLVpcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZGUnLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UgKyAnXScsXG4gICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICByc0xvd2VyID0gJ1snICsgcnNMb3dlclJhbmdlICsgJ10nLFxuICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByc0xvd2VyTWlzYyA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc1VwcGVyTWlzYyA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICByc09wdExvd2VyQ29udHIgPSAnKD86JyArIHJzQXBvcyArICcoPzpkfGxsfG18cmV8c3x0fHZlKSk/JyxcbiAgICByc09wdFVwcGVyQ29udHIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc0Vtb2ppID0gJyg/OicgKyBbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc1NlcTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG52YXIgcmVBcG9zID0gUmVnRXhwKHJzQXBvcywgJ2cnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxuICovXG52YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbnZhciByZVVuaWNvZGVXb3JkID0gUmVnRXhwKFtcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdExvd2VyQ29udHIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlck1pc2MgKyAnKycgKyByc09wdFVwcGVyQ29udHIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNMb3dlck1pc2MsICckJ10uam9pbignfCcpICsgJyknLFxuICByc1VwcGVyICsgJz8nICsgcnNMb3dlck1pc2MgKyAnKycgKyByc09wdExvd2VyQ29udHIsXG4gIHJzVXBwZXIgKyAnKycgKyByc09wdFVwcGVyQ29udHIsXG4gIHJzRGlnaXRzLFxuICByc0Vtb2ppXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3MgdGhhdCBuZWVkIGEgbW9yZSByb2J1c3QgcmVnZXhwIHRvIG1hdGNoIHdvcmRzLiAqL1xudmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyLH1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbi8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbnZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICdcXHhlMCc6ICdhJywgICdcXHhlMSc6ICdhJywgJ1xceGUyJzogJ2EnLCAnXFx4ZTMnOiAnYScsICdcXHhlNCc6ICdhJywgJ1xceGU1JzogJ2EnLFxuICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgJ1xceGM4JzogJ0UnLCAgJ1xceGM5JzogJ0UnLCAnXFx4Y2EnOiAnRScsICdcXHhjYic6ICdFJyxcbiAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgJ1xceGVjJzogJ2knLCAgJ1xceGVkJzogJ2knLCAnXFx4ZWUnOiAnaScsICdcXHhlZic6ICdpJyxcbiAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgJ1xceGYyJzogJ28nLCAgJ1xceGYzJzogJ28nLCAnXFx4ZjQnOiAnbycsICdcXHhmNSc6ICdvJywgJ1xceGY2JzogJ28nLCAnXFx4ZjgnOiAnbycsXG4gICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICdcXHhkZCc6ICdZJywgICdcXHhmZCc6ICd5JywgJ1xceGZmJzogJ3knLFxuICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAnXFx4ZGYnOiAnc3MnLFxuICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgJ1xcdTAxMDEnOiAnYScsICAnXFx1MDEwMyc6ICdhJywgJ1xcdTAxMDUnOiAnYScsXG4gICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAnXFx1MDEwZSc6ICdEJywgICdcXHUwMTEwJzogJ0QnLCAnXFx1MDEwZic6ICdkJywgJ1xcdTAxMTEnOiAnZCcsXG4gICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICdcXHUwMTFjJzogJ0cnLCAgJ1xcdTAxMWUnOiAnRycsICdcXHUwMTIwJzogJ0cnLCAnXFx1MDEyMic6ICdHJyxcbiAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICdcXHUwMTI4JzogJ0knLCAgJ1xcdTAxMmEnOiAnSScsICdcXHUwMTJjJzogJ0knLCAnXFx1MDEyZSc6ICdJJywgJ1xcdTAxMzAnOiAnSScsXG4gICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICdcXHUwMTM2JzogJ0snLCAgJ1xcdTAxMzcnOiAnaycsICdcXHUwMTM4JzogJ2snLFxuICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAnXFx1MDE0Myc6ICdOJywgICdcXHUwMTQ1JzogJ04nLCAnXFx1MDE0Nyc6ICdOJywgJ1xcdTAxNGEnOiAnTicsXG4gICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICdcXHUwMTRkJzogJ28nLCAgJ1xcdTAxNGYnOiAnbycsICdcXHUwMTUxJzogJ28nLFxuICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICdcXHUwMTVhJzogJ1MnLCAgJ1xcdTAxNWMnOiAnUycsICdcXHUwMTVlJzogJ1MnLCAnXFx1MDE2MCc6ICdTJyxcbiAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgJ1xcdTAxNjMnOiAndCcsICAnXFx1MDE2NSc6ICd0JywgJ1xcdTAxNjcnOiAndCcsXG4gICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgJ1xcdTAxNzQnOiAnVycsICAnXFx1MDE3NSc6ICd3JyxcbiAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAnXFx1MDE3YSc6ICd6JywgICdcXHUwMTdjJzogJ3onLCAnXFx1MDE3ZSc6ICd6JyxcbiAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAnXFx1MDE0OSc6IFwiJ25cIiwgJ1xcdTAxN2YnOiAnc3MnXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgbGV0dGVyLlxuICovXG52YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG59XG5cbi8qKlxuICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gYXJyYXlSZWR1Y2Uod29yZHMoZGVidXJyKHN0cmluZykucmVwbGFjZShyZUFwb3MsICcnKSksIGNhbGxiYWNrLCAnJyk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAqIC8vID0+ICdkZWphIHZ1J1xuICovXG5mdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICogLy8gPT4gJ2Zvby1iYXInXG4gKlxuICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICogLy8gPT4gJ2Zvby1iYXInXG4gKlxuICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gKiAvLyA9PiAnZm9vLWJhcidcbiAqL1xudmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbi8qKlxuICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAqXG4gKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gKi9cbmZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtlYmFiQ2FzZTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlQXNjaWlXb3JkID0gL1teXFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2ZdKy9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbnZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmZcXFxcdWZlMjAtXFxcXHVmZTIzJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZjAnLFxuICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgIHJzTWF0aE9wUmFuZ2UgPSAnXFxcXHhhY1xcXFx4YjFcXFxceGQ3XFxcXHhmNycsXG4gICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgcnNTcGFjZVJhbmdlID0gJyBcXFxcdFxcXFx4MGJcXFxcZlxcXFx4YTBcXFxcdWZlZmZcXFxcblxcXFxyXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHUxNjgwXFxcXHUxODBlXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBhXFxcXHUyMDJmXFxcXHUyMDVmXFxcXHUzMDAwJyxcbiAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgcnNCcmVhayA9ICdbJyArIHJzQnJlYWtSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib01hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgJ10nLFxuICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgcnNEaW5nYmF0ID0gJ1snICsgcnNEaW5nYmF0UmFuZ2UgKyAnXScsXG4gICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcnNMb3dlck1pc2MgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNVcHBlck1pc2MgPSAnKD86JyArIHJzVXBwZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgcnNPcHRMb3dlckNvbnRyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgcnNPcHRVcHBlckNvbnRyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGFwb3N0cm9waGVzLiAqL1xudmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpIGFuZFxuICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAqL1xudmFyIHJlQ29tYm9NYXJrID0gUmVnRXhwKHJzQ29tYm8sICdnJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGNvbXBsZXggb3IgY29tcG91bmQgd29yZHMuICovXG52YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRMb3dlckNvbnRyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gIHJzVXBwZXJNaXNjICsgJysnICsgcnNPcHRVcHBlckNvbnRyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciArIHJzTG93ZXJNaXNjLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgcnNVcHBlciArICc/JyArIHJzTG93ZXJNaXNjICsgJysnICsgcnNPcHRMb3dlckNvbnRyLFxuICByc1VwcGVyICsgJysnICsgcnNPcHRVcHBlckNvbnRyLFxuICByc0RpZ2l0cyxcbiAgcnNFbW9qaVxuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbnZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mix9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vO1xuXG4vKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXG52YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICdcXHhjMCc6ICdBJywgICdcXHhjMSc6ICdBJywgJ1xceGMyJzogJ0EnLCAnXFx4YzMnOiAnQScsICdcXHhjNCc6ICdBJywgJ1xceGM1JzogJ0EnLFxuICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAnXFx4ZDAnOiAnRCcsICAnXFx4ZjAnOiAnZCcsXG4gICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICdcXHhjYyc6ICdJJywgICdcXHhjZCc6ICdJJywgJ1xceGNlJzogJ0knLCAnXFx4Y2YnOiAnSScsXG4gICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgJ1xceGQyJzogJ08nLCAgJ1xceGQzJzogJ08nLCAnXFx4ZDQnOiAnTycsICdcXHhkNSc6ICdPJywgJ1xceGQ2JzogJ08nLCAnXFx4ZDgnOiAnTycsXG4gICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAnXFx4ZjknOiAndScsICAnXFx4ZmEnOiAndScsICdcXHhmYic6ICd1JywgJ1xceGZjJzogJ3UnLFxuICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgJ1xceGRlJzogJ1RoJywgJ1xceGZlJzogJ3RoJyxcbiAgJ1xceGRmJzogJ3NzJyxcbiAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgJ1xcdTAxMDAnOiAnQScsICAnXFx1MDEwMic6ICdBJywgJ1xcdTAxMDQnOiAnQScsXG4gICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICdcXHUwMTA3JzogJ2MnLCAgJ1xcdTAxMDknOiAnYycsICdcXHUwMTBiJzogJ2MnLCAnXFx1MDEwZCc6ICdjJyxcbiAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAnXFx1MDExMyc6ICdlJywgICdcXHUwMTE1JzogJ2UnLCAnXFx1MDExNyc6ICdlJywgJ1xcdTAxMTknOiAnZScsICdcXHUwMTFiJzogJ2UnLFxuICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgJ1xcdTAxMjQnOiAnSCcsICAnXFx1MDEyNic6ICdIJywgJ1xcdTAxMjUnOiAnaCcsICdcXHUwMTI3JzogJ2gnLFxuICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAnXFx1MDEzNCc6ICdKJywgICdcXHUwMTM1JzogJ2onLFxuICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgJ1xcdTAxM2EnOiAnbCcsICAnXFx1MDEzYyc6ICdsJywgJ1xcdTAxM2UnOiAnbCcsICdcXHUwMTQwJzogJ2wnLCAnXFx1MDE0Mic6ICdsJyxcbiAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICdcXHUwMTRjJzogJ08nLCAgJ1xcdTAxNGUnOiAnTycsICdcXHUwMTUwJzogJ08nLFxuICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICdcXHUwMTU1JzogJ3InLCAgJ1xcdTAxNTcnOiAncicsICdcXHUwMTU5JzogJ3InLFxuICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgJ1xcdTAxNjInOiAnVCcsICAnXFx1MDE2NCc6ICdUJywgJ1xcdTAxNjYnOiAnVCcsXG4gICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgJ1xcdTAxNjknOiAndScsICAnXFx1MDE2Yic6ICd1JywgJ1xcdTAxNmQnOiAndScsICdcXHUwMTZmJzogJ3UnLCAnXFx1MDE3MSc6ICd1JywgJ1xcdTAxNzMnOiAndScsXG4gICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAnXFx1MDE3OSc6ICdaJywgICdcXHUwMTdiJzogJ1onLCAnXFx1MDE3ZCc6ICdaJyxcbiAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAnXFx1MDE1Mic6ICdPZScsICdcXHUwMTUzJzogJ29lJyxcbiAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3NzJ1xufTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVBc2NpaVdvcmQpIHx8IFtdO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZXR0ZXIgVGhlIG1hdGNoZWQgbGV0dGVyIHRvIGRlYnVyci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAqL1xudmFyIGRlYnVyckxldHRlciA9IGJhc2VQcm9wZXJ0eU9mKGRlYnVycmVkTGV0dGVycyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgd29yZCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZVdvcmQudGVzdChzdHJpbmcpO1xufVxuXG4vKipcbiAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICovXG5mdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlV29yZCkgfHwgW107XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uY2FtZWxDYXNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmUgZWFjaCB3b3JkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG91bmRlcihjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gKiAvLyA9PiAnZGVqYSB2dSdcbiAqL1xuZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gKiBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAqIC8vID0+ICdmb29fYmFyJ1xuICpcbiAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAqIC8vID0+ICdmb29fYmFyJ1xuICpcbiAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICogLy8gPT4gJ2Zvb19iYXInXG4gKi9cbnZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gKlxuICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICovXG5mdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzbmFrZUNhc2U7XG4iLCIvKiFcbiAqIG1pbWUtZGJcbiAqIENvcHlyaWdodChjKSAyMDE0IEpvbmF0aGFuIE9uZ1xuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGIuanNvbicpXG4iLCIvKiFcbiAqIG1pbWUtdHlwZXNcbiAqIENvcHlyaWdodChjKSAyMDE0IEpvbmF0aGFuIE9uZ1xuICogQ29weXJpZ2h0KGMpIDIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBkYiA9IHJlcXVpcmUoJ21pbWUtZGInKVxudmFyIGV4dG5hbWUgPSByZXF1aXJlKCdwYXRoJykuZXh0bmFtZVxuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBFWFRSQUNUX1RZUEVfUkVHRVhQID0gL15cXHMqKFteO1xcc10qKSg/Ojt8XFxzfCQpL1xudmFyIFRFWFRfVFlQRV9SRUdFWFAgPSAvXnRleHRcXC8vaVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY2hhcnNldCA9IGNoYXJzZXRcbmV4cG9ydHMuY2hhcnNldHMgPSB7IGxvb2t1cDogY2hhcnNldCB9XG5leHBvcnRzLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGVcbmV4cG9ydHMuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uXG5leHBvcnRzLmV4dGVuc2lvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5leHBvcnRzLmxvb2t1cCA9IGxvb2t1cFxuZXhwb3J0cy50eXBlcyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuLy8gUG9wdWxhdGUgdGhlIGV4dGVuc2lvbnMvdHlwZXMgbWFwc1xucG9wdWxhdGVNYXBzKGV4cG9ydHMuZXh0ZW5zaW9ucywgZXhwb3J0cy50eXBlcylcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgY2hhcnNldCBmb3IgYSBNSU1FIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGNoYXJzZXQgKHR5cGUpIHtcbiAgaWYgKCF0eXBlIHx8IHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gVE9ETzogdXNlIG1lZGlhLXR5cGVyXG4gIHZhciBtYXRjaCA9IEVYVFJBQ1RfVFlQRV9SRUdFWFAuZXhlYyh0eXBlKVxuICB2YXIgbWltZSA9IG1hdGNoICYmIGRiW21hdGNoWzFdLnRvTG93ZXJDYXNlKCldXG5cbiAgaWYgKG1pbWUgJiYgbWltZS5jaGFyc2V0KSB7XG4gICAgcmV0dXJuIG1pbWUuY2hhcnNldFxuICB9XG5cbiAgLy8gZGVmYXVsdCB0ZXh0LyogdG8gdXRmLThcbiAgaWYgKG1hdGNoICYmIFRFWFRfVFlQRV9SRUdFWFAudGVzdChtYXRjaFsxXSkpIHtcbiAgICByZXR1cm4gJ1VURi04J1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVsbCBDb250ZW50LVR5cGUgaGVhZGVyIGdpdmVuIGEgTUlNRSB0eXBlIG9yIGV4dGVuc2lvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBjb250ZW50VHlwZSAoc3RyKSB7XG4gIC8vIFRPRE86IHNob3VsZCB0aGlzIGV2ZW4gYmUgaW4gdGhpcyBtb2R1bGU/XG4gIGlmICghc3RyIHx8IHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgbWltZSA9IHN0ci5pbmRleE9mKCcvJykgPT09IC0xXG4gICAgPyBleHBvcnRzLmxvb2t1cChzdHIpXG4gICAgOiBzdHJcblxuICBpZiAoIW1pbWUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFRPRE86IHVzZSBjb250ZW50LXR5cGUgb3Igb3RoZXIgbW9kdWxlXG4gIGlmIChtaW1lLmluZGV4T2YoJ2NoYXJzZXQnKSA9PT0gLTEpIHtcbiAgICB2YXIgY2hhcnNldCA9IGV4cG9ydHMuY2hhcnNldChtaW1lKVxuICAgIGlmIChjaGFyc2V0KSBtaW1lICs9ICc7IGNoYXJzZXQ9JyArIGNoYXJzZXQudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgcmV0dXJuIG1pbWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgZXh0ZW5zaW9uIGZvciBhIE1JTUUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZXh0ZW5zaW9uICh0eXBlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFRPRE86IHVzZSBtZWRpYS10eXBlclxuICB2YXIgbWF0Y2ggPSBFWFRSQUNUX1RZUEVfUkVHRVhQLmV4ZWModHlwZSlcblxuICAvLyBnZXQgZXh0ZW5zaW9uc1xuICB2YXIgZXh0cyA9IG1hdGNoICYmIGV4cG9ydHMuZXh0ZW5zaW9uc1ttYXRjaFsxXS50b0xvd2VyQ2FzZSgpXVxuXG4gIGlmICghZXh0cyB8fCAhZXh0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBleHRzWzBdXG59XG5cbi8qKlxuICogTG9va3VwIHRoZSBNSU1FIHR5cGUgZm9yIGEgZmlsZSBwYXRoL2V4dGVuc2lvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gbG9va3VwIChwYXRoKSB7XG4gIGlmICghcGF0aCB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGdldCB0aGUgZXh0ZW5zaW9uIChcImV4dFwiIG9yIFwiLmV4dFwiIG9yIGZ1bGwgcGF0aClcbiAgdmFyIGV4dGVuc2lvbiA9IGV4dG5hbWUoJ3guJyArIHBhdGgpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAuc3Vic3RyKDEpXG5cbiAgaWYgKCFleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLnR5cGVzW2V4dGVuc2lvbl0gfHwgZmFsc2Vcbn1cblxuLyoqXG4gKiBQb3B1bGF0ZSB0aGUgZXh0ZW5zaW9ucyBhbmQgdHlwZXMgbWFwcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9wdWxhdGVNYXBzIChleHRlbnNpb25zLCB0eXBlcykge1xuICAvLyBzb3VyY2UgcHJlZmVyZW5jZSAobGVhc3QgLT4gbW9zdClcbiAgdmFyIHByZWZlcmVuY2UgPSBbJ25naW54JywgJ2FwYWNoZScsIHVuZGVmaW5lZCwgJ2lhbmEnXVxuXG4gIE9iamVjdC5rZXlzKGRiKS5mb3JFYWNoKGZ1bmN0aW9uIGZvckVhY2hNaW1lVHlwZSAodHlwZSkge1xuICAgIHZhciBtaW1lID0gZGJbdHlwZV1cbiAgICB2YXIgZXh0cyA9IG1pbWUuZXh0ZW5zaW9uc1xuXG4gICAgaWYgKCFleHRzIHx8ICFleHRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gbWltZSAtPiBleHRlbnNpb25zXG4gICAgZXh0ZW5zaW9uc1t0eXBlXSA9IGV4dHNcblxuICAgIC8vIGV4dGVuc2lvbiAtPiBtaW1lXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0c1tpXVxuXG4gICAgICBpZiAodHlwZXNbZXh0ZW5zaW9uXSkge1xuICAgICAgICB2YXIgZnJvbSA9IHByZWZlcmVuY2UuaW5kZXhPZihkYlt0eXBlc1tleHRlbnNpb25dXS5zb3VyY2UpXG4gICAgICAgIHZhciB0byA9IHByZWZlcmVuY2UuaW5kZXhPZihtaW1lLnNvdXJjZSlcblxuICAgICAgICBpZiAodHlwZXNbZXh0ZW5zaW9uXSAhPT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgJiZcbiAgICAgICAgICAoZnJvbSA+IHRvIHx8IChmcm9tID09PSB0byAmJiB0eXBlc1tleHRlbnNpb25dLnN1YnN0cigwLCAxMikgPT09ICdhcHBsaWNhdGlvbi8nKSkpIHtcbiAgICAgICAgICAvLyBza2lwIHRoZSByZW1hcHBpbmdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB0aGUgZXh0ZW5zaW9uIC0+IG1pbWVcbiAgICAgIHR5cGVzW2V4dGVuc2lvbl0gPSB0eXBlXG4gICAgfVxuICB9KVxufVxuIiwidmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIF8wNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBta2RpclAubWtkaXJwID0gbWtkaXJQLm1rZGlyUCA9IG1rZGlyUDtcblxuZnVuY3Rpb24gbWtkaXJQIChwLCBvcHRzLCBmLCBtYWRlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGYgPSBvcHRzO1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XG4gICAgfVxuICAgIFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xuICAgIFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbW9kZSA9IF8wNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpO1xuICAgIH1cbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xuICAgIFxuICAgIHZhciBjYiA9IGYgfHwgZnVuY3Rpb24gKCkge307XG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcbiAgICBcbiAgICB4ZnMubWtkaXIocCwgbW9kZSwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgIGlmICghZXIpIHtcbiAgICAgICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbWFkZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnOlxuICAgICAgICAgICAgICAgIG1rZGlyUChwYXRoLmRpcm5hbWUocCksIG9wdHMsIGZ1bmN0aW9uIChlciwgbWFkZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIGNiKGVyLCBtYWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBta2RpclAocCwgb3B0cywgY2IsIG1hZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHhmcy5zdGF0KHAsIGZ1bmN0aW9uIChlcjIsIHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXQgZmFpbHMsIHRoZW4gdGhhdCdzIHN1cGVyIHdlaXJkLlxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgdGhlIG9yaWdpbmFsIGVycm9yIGJlIHRoZSBmYWlsdXJlIHJlYXNvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyMiB8fCAhc3RhdC5pc0RpcmVjdG9yeSgpKSBjYihlciwgbWFkZSlcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjYihudWxsLCBtYWRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5ta2RpclAuc3luYyA9IGZ1bmN0aW9uIHN5bmMgKHAsIG9wdHMsIG1hZGUpIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XG4gICAgdmFyIHhmcyA9IG9wdHMuZnMgfHwgZnM7XG4gICAgXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtb2RlID0gXzA3NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XG4gICAgfVxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XG5cbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgeGZzLm1rZGlyU3luYyhwLCBtb2RlKTtcbiAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycjApIHtcbiAgICAgICAgc3dpdGNoIChlcnIwLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCcgOlxuICAgICAgICAgICAgICAgIG1hZGUgPSBzeW5jKHBhdGguZGlybmFtZShwKSwgb3B0cywgbWFkZSk7XG4gICAgICAgICAgICAgICAgc3luYyhwLCBvcHRzLCBtYWRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXG4gICAgICAgICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gaXMgYm9ya2VkLlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgc3RhdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ID0geGZzLnN0YXRTeW5jKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnIwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgdGhyb3cgZXJyMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYWRlO1xufTtcbiIsInZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuXG5mdW5jdGlvbiBzaGEgKGtleSwgYm9keSwgYWxnb3JpdGhtKSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSG1hYyhhbGdvcml0aG0sIGtleSkudXBkYXRlKGJvZHkpLmRpZ2VzdCgnYmFzZTY0Jylcbn1cblxuZnVuY3Rpb24gcnNhIChrZXksIGJvZHkpIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVTaWduKCdSU0EtU0hBMScpLnVwZGF0ZShib2R5KS5zaWduKGtleSwgJ2Jhc2U2NCcpXG59XG5cbmZ1bmN0aW9uIHJmYzM5ODYgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgICAucmVwbGFjZSgvIS9nLCclMjEnKVxuICAgIC5yZXBsYWNlKC9cXCovZywnJTJBJylcbiAgICAucmVwbGFjZSgvXFwoL2csJyUyOCcpXG4gICAgLnJlcGxhY2UoL1xcKS9nLCclMjknKVxuICAgIC5yZXBsYWNlKC8nL2csJyUyNycpXG59XG5cbi8vIE1hcHMgb2JqZWN0IHRvIGJpLWRpbWVuc2lvbmFsIGFycmF5XG4vLyBDb252ZXJ0cyB7IGZvbzogJ0EnLCBiYXI6IFsgJ2InLCAnQicgXX0gdG9cbi8vIFsgWydmb28nLCAnQSddLCBbJ2JhcicsICdiJ10sIFsnYmFyJywgJ0InXSBdXG5mdW5jdGlvbiBtYXAgKG9iaikge1xuICB2YXIga2V5LCB2YWwsIGFyciA9IFtdXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIHZhbCA9IG9ialtrZXldXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKVxuICAgICAgICBhcnIucHVzaChba2V5LCB2YWxbaV1dKVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKVxuICAgICAgZm9yICh2YXIgcHJvcCBpbiB2YWwpXG4gICAgICAgIGFyci5wdXNoKFtrZXkgKyAnWycgKyBwcm9wICsgJ10nLCB2YWxbcHJvcF1dKVxuICAgIGVsc2VcbiAgICAgIGFyci5wdXNoKFtrZXksIHZhbF0pXG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG4vLyBDb21wYXJlIGZ1bmN0aW9uIGZvciBzb3J0XG5mdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMFxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJhc2UgKGh0dHBNZXRob2QsIGJhc2VfdXJpLCBwYXJhbXMpIHtcbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZGV2LnR3aXR0ZXIuY29tL2RvY3MvYXV0aC9vYXV0aCBhbmQgXG4gIC8vIGh0dHBzOi8vZGV2LnR3aXR0ZXIuY29tL2RvY3MvYXV0aC9jcmVhdGluZy1zaWduYXR1cmVcblxuICAvLyBQYXJhbWV0ZXIgbm9ybWFsaXphdGlvblxuICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1ODQ5I3NlY3Rpb24tMy40LjEuMy4yXG4gIHZhciBub3JtYWxpemVkID0gbWFwKHBhcmFtcylcbiAgLy8gMS4gIEZpcnN0LCB0aGUgbmFtZSBhbmQgdmFsdWUgb2YgZWFjaCBwYXJhbWV0ZXIgYXJlIGVuY29kZWRcbiAgLm1hcChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBbIHJmYzM5ODYocFswXSksIHJmYzM5ODYocFsxXSB8fCAnJykgXVxuICB9KVxuICAvLyAyLiAgVGhlIHBhcmFtZXRlcnMgYXJlIHNvcnRlZCBieSBuYW1lLCB1c2luZyBhc2NlbmRpbmcgYnl0ZSB2YWx1ZVxuICAvLyAgICAgb3JkZXJpbmcuICBJZiB0d28gb3IgbW9yZSBwYXJhbWV0ZXJzIHNoYXJlIHRoZSBzYW1lIG5hbWUsIHRoZXlcbiAgLy8gICAgIGFyZSBzb3J0ZWQgYnkgdGhlaXIgdmFsdWUuXG4gIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYVswXSwgYlswXSkgfHwgY29tcGFyZShhWzFdLCBiWzFdKVxuICB9KVxuICAvLyAzLiAgVGhlIG5hbWUgb2YgZWFjaCBwYXJhbWV0ZXIgaXMgY29uY2F0ZW5hdGVkIHRvIGl0cyBjb3JyZXNwb25kaW5nXG4gIC8vICAgICB2YWx1ZSB1c2luZyBhbiBcIj1cIiBjaGFyYWN0ZXIgKEFTQ0lJIGNvZGUgNjEpIGFzIGEgc2VwYXJhdG9yLCBldmVuXG4gIC8vICAgICBpZiB0aGUgdmFsdWUgaXMgZW1wdHkuXG4gIC5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAuam9pbignPScpIH0pXG4gICAvLyA0LiAgVGhlIHNvcnRlZCBuYW1lL3ZhbHVlIHBhaXJzIGFyZSBjb25jYXRlbmF0ZWQgdG9nZXRoZXIgaW50byBhXG4gICAvLyAgICAgc2luZ2xlIHN0cmluZyBieSB1c2luZyBhbiBcIiZcIiBjaGFyYWN0ZXIgKEFTQ0lJIGNvZGUgMzgpIGFzXG4gICAvLyAgICAgc2VwYXJhdG9yLlxuICAuam9pbignJicpXG5cbiAgdmFyIGJhc2UgPSBbXG4gICAgcmZjMzk4NihodHRwTWV0aG9kID8gaHR0cE1ldGhvZC50b1VwcGVyQ2FzZSgpIDogJ0dFVCcpLFxuICAgIHJmYzM5ODYoYmFzZV91cmkpLFxuICAgIHJmYzM5ODYobm9ybWFsaXplZClcbiAgXS5qb2luKCcmJylcblxuICByZXR1cm4gYmFzZVxufVxuXG5mdW5jdGlvbiBobWFjc2lnbiAoaHR0cE1ldGhvZCwgYmFzZV91cmksIHBhcmFtcywgY29uc3VtZXJfc2VjcmV0LCB0b2tlbl9zZWNyZXQpIHtcbiAgdmFyIGJhc2UgPSBnZW5lcmF0ZUJhc2UoaHR0cE1ldGhvZCwgYmFzZV91cmksIHBhcmFtcylcbiAgdmFyIGtleSA9IFtcbiAgICBjb25zdW1lcl9zZWNyZXQgfHwgJycsXG4gICAgdG9rZW5fc2VjcmV0IHx8ICcnXG4gIF0ubWFwKHJmYzM5ODYpLmpvaW4oJyYnKVxuXG4gIHJldHVybiBzaGEoa2V5LCBiYXNlLCAnc2hhMScpXG59XG5cbmZ1bmN0aW9uIGhtYWNzaWduMjU2IChodHRwTWV0aG9kLCBiYXNlX3VyaSwgcGFyYW1zLCBjb25zdW1lcl9zZWNyZXQsIHRva2VuX3NlY3JldCkge1xuICB2YXIgYmFzZSA9IGdlbmVyYXRlQmFzZShodHRwTWV0aG9kLCBiYXNlX3VyaSwgcGFyYW1zKVxuICB2YXIga2V5ID0gW1xuICAgIGNvbnN1bWVyX3NlY3JldCB8fCAnJyxcbiAgICB0b2tlbl9zZWNyZXQgfHwgJydcbiAgXS5tYXAocmZjMzk4Nikuam9pbignJicpXG5cbiAgcmV0dXJuIHNoYShrZXksIGJhc2UsICdzaGEyNTYnKVxufVxuXG5mdW5jdGlvbiByc2FzaWduIChodHRwTWV0aG9kLCBiYXNlX3VyaSwgcGFyYW1zLCBwcml2YXRlX2tleSwgdG9rZW5fc2VjcmV0KSB7XG4gIHZhciBiYXNlID0gZ2VuZXJhdGVCYXNlKGh0dHBNZXRob2QsIGJhc2VfdXJpLCBwYXJhbXMpXG4gIHZhciBrZXkgPSBwcml2YXRlX2tleSB8fCAnJ1xuXG4gIHJldHVybiByc2Eoa2V5LCBiYXNlKVxufVxuXG5mdW5jdGlvbiBwbGFpbnRleHQgKGNvbnN1bWVyX3NlY3JldCwgdG9rZW5fc2VjcmV0KSB7XG4gIHZhciBrZXkgPSBbXG4gICAgY29uc3VtZXJfc2VjcmV0IHx8ICcnLFxuICAgIHRva2VuX3NlY3JldCB8fCAnJ1xuICBdLm1hcChyZmMzOTg2KS5qb2luKCcmJylcblxuICByZXR1cm4ga2V5XG59XG5cbmZ1bmN0aW9uIHNpZ24gKHNpZ25NZXRob2QsIGh0dHBNZXRob2QsIGJhc2VfdXJpLCBwYXJhbXMsIGNvbnN1bWVyX3NlY3JldCwgdG9rZW5fc2VjcmV0KSB7XG4gIHZhciBtZXRob2RcbiAgdmFyIHNraXBBcmdzID0gMVxuXG4gIHN3aXRjaCAoc2lnbk1ldGhvZCkge1xuICAgIGNhc2UgJ1JTQS1TSEExJzpcbiAgICAgIG1ldGhvZCA9IHJzYXNpZ25cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnSE1BQy1TSEExJzpcbiAgICAgIG1ldGhvZCA9IGhtYWNzaWduXG4gICAgICBicmVha1xuICAgIGNhc2UgJ0hNQUMtU0hBMjU2JzpcbiAgICAgIG1ldGhvZCA9IGhtYWNzaWduMjU2XG4gICAgICBicmVha1xuICAgIGNhc2UgJ1BMQUlOVEVYVCc6XG4gICAgICBtZXRob2QgPSBwbGFpbnRleHRcbiAgICAgIHNraXBBcmdzID0gNFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBtZXRob2Qgbm90IHN1cHBvcnRlZDogJyArIHNpZ25NZXRob2QpXG4gIH1cblxuICByZXR1cm4gbWV0aG9kLmFwcGx5KG51bGwsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCBza2lwQXJncykpXG59XG5cbmV4cG9ydHMuaG1hY3NpZ24gPSBobWFjc2lnblxuZXhwb3J0cy5obWFjc2lnbjI1NiA9IGhtYWNzaWduMjU2XG5leHBvcnRzLnJzYXNpZ24gPSByc2FzaWduXG5leHBvcnRzLnBsYWludGV4dCA9IHBsYWludGV4dFxuZXhwb3J0cy5zaWduID0gc2lnblxuZXhwb3J0cy5yZmMzOTg2ID0gcmZjMzk4NlxuZXhwb3J0cy5nZW5lcmF0ZUJhc2UgPSBnZW5lcmF0ZUJhc2UiLCJleHBvcnRzLk9BdXRoID0gcmVxdWlyZShcIi4vbGliL29hdXRoXCIpLk9BdXRoO1xuZXhwb3J0cy5PQXV0aEVjaG8gPSByZXF1aXJlKFwiLi9saWIvb2F1dGhcIikuT0F1dGhFY2hvO1xuZXhwb3J0cy5PQXV0aDIgPSByZXF1aXJlKFwiLi9saWIvb2F1dGgyXCIpLk9BdXRoMjsiLCIvLyBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIGhvc3QgdGhhdCBjbG9zZXMgKmJlZm9yZSogaXQgZW5kcz8hPyFcbm1vZHVsZS5leHBvcnRzLmlzQW5FYXJseUNsb3NlSG9zdD0gZnVuY3Rpb24oIGhvc3ROYW1lICkge1xuICByZXR1cm4gaG9zdE5hbWUgJiYgaG9zdE5hbWUubWF0Y2goXCIuKmdvb2dsZShhcGlzKT8uY29tJFwiKVxufSIsInZhciBjcnlwdG89IHJlcXVpcmUoJ2NyeXB0bycpLFxuICAgIHNoYTE9IHJlcXVpcmUoJy4vc2hhMScpLFxuICAgIGh0dHA9IHJlcXVpcmUoJ2h0dHAnKSxcbiAgICBodHRwcz0gcmVxdWlyZSgnaHR0cHMnKSxcbiAgICBVUkw9IHJlcXVpcmUoJ3VybCcpLFxuICAgIHF1ZXJ5c3RyaW5nPSByZXF1aXJlKCdxdWVyeXN0cmluZycpLFxuICAgIE9BdXRoVXRpbHM9IHJlcXVpcmUoJy4vX3V0aWxzJyk7XG5cbmV4cG9ydHMuT0F1dGg9IGZ1bmN0aW9uKHJlcXVlc3RVcmwsIGFjY2Vzc1VybCwgY29uc3VtZXJLZXksIGNvbnN1bWVyU2VjcmV0LCB2ZXJzaW9uLCBhdXRob3JpemVfY2FsbGJhY2ssIHNpZ25hdHVyZU1ldGhvZCwgbm9uY2VTaXplLCBjdXN0b21IZWFkZXJzKSB7XG4gIHRoaXMuX2lzRWNobyA9IGZhbHNlO1xuXG4gIHRoaXMuX3JlcXVlc3RVcmw9IHJlcXVlc3RVcmw7XG4gIHRoaXMuX2FjY2Vzc1VybD0gYWNjZXNzVXJsO1xuICB0aGlzLl9jb25zdW1lcktleT0gY29uc3VtZXJLZXk7XG4gIHRoaXMuX2NvbnN1bWVyU2VjcmV0PSB0aGlzLl9lbmNvZGVEYXRhKCBjb25zdW1lclNlY3JldCApO1xuICBpZiAoc2lnbmF0dXJlTWV0aG9kID09IFwiUlNBLVNIQTFcIikge1xuICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBjb25zdW1lclNlY3JldDtcbiAgfVxuICB0aGlzLl92ZXJzaW9uPSB2ZXJzaW9uO1xuICBpZiggYXV0aG9yaXplX2NhbGxiYWNrID09PSB1bmRlZmluZWQgKSB7XG4gICAgdGhpcy5fYXV0aG9yaXplX2NhbGxiYWNrPSBcIm9vYlwiO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuX2F1dGhvcml6ZV9jYWxsYmFjaz0gYXV0aG9yaXplX2NhbGxiYWNrO1xuICB9XG5cbiAgaWYoIHNpZ25hdHVyZU1ldGhvZCAhPSBcIlBMQUlOVEVYVFwiICYmIHNpZ25hdHVyZU1ldGhvZCAhPSBcIkhNQUMtU0hBMVwiICYmIHNpZ25hdHVyZU1ldGhvZCAhPSBcIlJTQS1TSEExXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW4tc3VwcG9ydGVkIHNpZ25hdHVyZSBtZXRob2Q6IFwiICsgc2lnbmF0dXJlTWV0aG9kIClcbiAgdGhpcy5fc2lnbmF0dXJlTWV0aG9kPSBzaWduYXR1cmVNZXRob2Q7XG4gIHRoaXMuX25vbmNlU2l6ZT0gbm9uY2VTaXplIHx8IDMyO1xuICB0aGlzLl9oZWFkZXJzPSBjdXN0b21IZWFkZXJzIHx8IHtcIkFjY2VwdFwiIDogXCIqLypcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb25uZWN0aW9uXCIgOiBcImNsb3NlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVXNlci1BZ2VudFwiIDogXCJOb2RlIGF1dGhlbnRpY2F0aW9uXCJ9XG4gIHRoaXMuX2NsaWVudE9wdGlvbnM9IHRoaXMuX2RlZmF1bHRDbGllbnRPcHRpb25zPSB7XCJyZXF1ZXN0VG9rZW5IdHRwTWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWNjZXNzVG9rZW5IdHRwTWV0aG9kXCI6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9sbG93UmVkaXJlY3RzXCI6IHRydWV9O1xuICB0aGlzLl9vYXV0aFBhcmFtZXRlclNlcGVyYXRvciA9IFwiLFwiO1xufTtcblxuZXhwb3J0cy5PQXV0aEVjaG89IGZ1bmN0aW9uKHJlYWxtLCB2ZXJpZnlfY3JlZGVudGlhbHMsIGNvbnN1bWVyS2V5LCBjb25zdW1lclNlY3JldCwgdmVyc2lvbiwgc2lnbmF0dXJlTWV0aG9kLCBub25jZVNpemUsIGN1c3RvbUhlYWRlcnMpIHtcbiAgdGhpcy5faXNFY2hvID0gdHJ1ZTtcblxuICB0aGlzLl9yZWFsbT0gcmVhbG07XG4gIHRoaXMuX3ZlcmlmeUNyZWRlbnRpYWxzID0gdmVyaWZ5X2NyZWRlbnRpYWxzO1xuICB0aGlzLl9jb25zdW1lcktleT0gY29uc3VtZXJLZXk7XG4gIHRoaXMuX2NvbnN1bWVyU2VjcmV0PSB0aGlzLl9lbmNvZGVEYXRhKCBjb25zdW1lclNlY3JldCApO1xuICBpZiAoc2lnbmF0dXJlTWV0aG9kID09IFwiUlNBLVNIQTFcIikge1xuICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBjb25zdW1lclNlY3JldDtcbiAgfVxuICB0aGlzLl92ZXJzaW9uPSB2ZXJzaW9uO1xuXG4gIGlmKCBzaWduYXR1cmVNZXRob2QgIT0gXCJQTEFJTlRFWFRcIiAmJiBzaWduYXR1cmVNZXRob2QgIT0gXCJITUFDLVNIQTFcIiAmJiBzaWduYXR1cmVNZXRob2QgIT0gXCJSU0EtU0hBMVwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuLXN1cHBvcnRlZCBzaWduYXR1cmUgbWV0aG9kOiBcIiArIHNpZ25hdHVyZU1ldGhvZCApO1xuICB0aGlzLl9zaWduYXR1cmVNZXRob2Q9IHNpZ25hdHVyZU1ldGhvZDtcbiAgdGhpcy5fbm9uY2VTaXplPSBub25jZVNpemUgfHwgMzI7XG4gIHRoaXMuX2hlYWRlcnM9IGN1c3RvbUhlYWRlcnMgfHwge1wiQWNjZXB0XCIgOiBcIiovKlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbm5lY3Rpb25cIiA6IFwiY2xvc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJVc2VyLUFnZW50XCIgOiBcIk5vZGUgYXV0aGVudGljYXRpb25cIn07XG4gIHRoaXMuX29hdXRoUGFyYW1ldGVyU2VwZXJhdG9yID0gXCIsXCI7XG59XG5cbmV4cG9ydHMuT0F1dGhFY2hvLnByb3RvdHlwZSA9IGV4cG9ydHMuT0F1dGgucHJvdG90eXBlO1xuXG5leHBvcnRzLk9BdXRoLnByb3RvdHlwZS5fZ2V0VGltZXN0YW1wPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwICk7XG59XG5cbmV4cG9ydHMuT0F1dGgucHJvdG90eXBlLl9lbmNvZGVEYXRhPSBmdW5jdGlvbih0b0VuY29kZSl7XG4gaWYoIHRvRW5jb2RlID09IG51bGwgfHwgdG9FbmNvZGUgPT0gXCJcIiApIHJldHVybiBcIlwiXG4gZWxzZSB7XG4gICAgdmFyIHJlc3VsdD0gZW5jb2RlVVJJQ29tcG9uZW50KHRvRW5jb2RlKTtcbiAgICAvLyBGaXggdGhlIG1pc21hdGNoIGJldHdlZW4gT0F1dGgncyAgUkZDMzk4NidzIGFuZCBKYXZhc2NyaXB0J3MgYmVsaWVmcyBpbiB3aGF0IGlzIHJpZ2h0IGFuZCB3cm9uZyA7KVxuICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFwhL2csIFwiJTIxXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCcvZywgXCIlMjdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKC9nLCBcIiUyOFwiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwpL2csIFwiJTI5XCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCovZywgXCIlMkFcIik7XG4gfVxufVxuXG5leHBvcnRzLk9BdXRoLnByb3RvdHlwZS5fZGVjb2RlRGF0YT0gZnVuY3Rpb24odG9EZWNvZGUpIHtcbiAgaWYoIHRvRGVjb2RlICE9IG51bGwgKSB7XG4gICAgdG9EZWNvZGUgPSB0b0RlY29kZS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpO1xuICB9XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoIHRvRGVjb2RlKTtcbn1cblxuZXhwb3J0cy5PQXV0aC5wcm90b3R5cGUuX2dldFNpZ25hdHVyZT0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBhcmFtZXRlcnMsIHRva2VuU2VjcmV0KSB7XG4gIHZhciBzaWduYXR1cmVCYXNlPSB0aGlzLl9jcmVhdGVTaWduYXR1cmVCYXNlKG1ldGhvZCwgdXJsLCBwYXJhbWV0ZXJzKTtcbiAgcmV0dXJuIHRoaXMuX2NyZWF0ZVNpZ25hdHVyZSggc2lnbmF0dXJlQmFzZSwgdG9rZW5TZWNyZXQgKTtcbn1cblxuZXhwb3J0cy5PQXV0aC5wcm90b3R5cGUuX25vcm1hbGl6ZVVybD0gZnVuY3Rpb24odXJsKSB7XG4gIHZhciBwYXJzZWRVcmw9IFVSTC5wYXJzZSh1cmwsIHRydWUpXG4gICB2YXIgcG9ydCA9XCJcIjtcbiAgIGlmKCBwYXJzZWRVcmwucG9ydCApIHtcbiAgICAgaWYoIChwYXJzZWRVcmwucHJvdG9jb2wgPT0gXCJodHRwOlwiICYmIHBhcnNlZFVybC5wb3J0ICE9IFwiODBcIiApIHx8XG4gICAgICAgICAocGFyc2VkVXJsLnByb3RvY29sID09IFwiaHR0cHM6XCIgJiYgcGFyc2VkVXJsLnBvcnQgIT0gXCI0NDNcIikgKSB7XG4gICAgICAgICAgIHBvcnQ9IFwiOlwiICsgcGFyc2VkVXJsLnBvcnQ7XG4gICAgICAgICB9XG4gICB9XG5cbiAgaWYoICFwYXJzZWRVcmwucGF0aG5hbWUgIHx8IHBhcnNlZFVybC5wYXRobmFtZSA9PSBcIlwiICkgcGFyc2VkVXJsLnBhdGhuYW1lID1cIi9cIjtcblxuICByZXR1cm4gcGFyc2VkVXJsLnByb3RvY29sICsgXCIvL1wiICsgcGFyc2VkVXJsLmhvc3RuYW1lICsgcG9ydCArIHBhcnNlZFVybC5wYXRobmFtZTtcbn1cblxuLy8gSXMgdGhlIHBhcmFtZXRlciBjb25zaWRlcmVkIGFuIE9BdXRoIHBhcmFtZXRlclxuZXhwb3J0cy5PQXV0aC5wcm90b3R5cGUuX2lzUGFyYW1ldGVyTmFtZUFuT0F1dGhQYXJhbWV0ZXI9IGZ1bmN0aW9uKHBhcmFtZXRlcikge1xuICB2YXIgbSA9IHBhcmFtZXRlci5tYXRjaCgnXm9hdXRoXycpO1xuICBpZiggbSAmJiAoIG1bMF0gPT09IFwib2F1dGhfXCIgKSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8vIGJ1aWxkIHRoZSBPQXV0aCByZXF1ZXN0IGF1dGhvcml6YXRpb24gaGVhZGVyXG5leHBvcnRzLk9BdXRoLnByb3RvdHlwZS5fYnVpbGRBdXRob3JpemF0aW9uSGVhZGVycz0gZnVuY3Rpb24ob3JkZXJlZFBhcmFtZXRlcnMpIHtcbiAgdmFyIGF1dGhIZWFkZXI9XCJPQXV0aCBcIjtcbiAgaWYoIHRoaXMuX2lzRWNobyApIHtcbiAgICBhdXRoSGVhZGVyICs9ICdyZWFsbT1cIicgKyB0aGlzLl9yZWFsbSArICdcIiwnO1xuICB9XG5cbiAgZm9yKCB2YXIgaT0gMCA7IGkgPCBvcmRlcmVkUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAvLyBXaGlsc3QgdGhlIGFsbCB0aGUgcGFyYW1ldGVycyBzaG91bGQgYmUgaW5jbHVkZWQgd2l0aGluIHRoZSBzaWduYXR1cmUsIG9ubHkgdGhlIG9hdXRoXyBhcmd1bWVudHNcbiAgICAgLy8gc2hvdWxkIGFwcGVhciB3aXRoaW4gdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyLlxuICAgICBpZiggdGhpcy5faXNQYXJhbWV0ZXJOYW1lQW5PQXV0aFBhcmFtZXRlcihvcmRlcmVkUGFyYW1ldGVyc1tpXVswXSkgKSB7XG4gICAgICBhdXRoSGVhZGVyKz0gXCJcIiArIHRoaXMuX2VuY29kZURhdGEob3JkZXJlZFBhcmFtZXRlcnNbaV1bMF0pK1wiPVxcXCJcIisgdGhpcy5fZW5jb2RlRGF0YShvcmRlcmVkUGFyYW1ldGVyc1tpXVsxXSkrXCJcXFwiXCIrIHRoaXMuX29hdXRoUGFyYW1ldGVyU2VwZXJhdG9yO1xuICAgICB9XG4gIH1cblxuICBhdXRoSGVhZGVyPSBhdXRoSGVhZGVyLnN1YnN0cmluZygwLCBhdXRoSGVhZGVyLmxlbmd0aC10aGlzLl9vYXV0aFBhcmFtZXRlclNlcGVyYXRvci5sZW5ndGgpO1xuICByZXR1cm4gYXV0aEhlYWRlcjtcbn1cblxuLy8gVGFrZXMgYW4gb2JqZWN0IGxpdGVyYWwgdGhhdCByZXByZXNlbnRzIHRoZSBhcmd1bWVudHMsIGFuZCByZXR1cm5zIGFuIGFycmF5XG4vLyBvZiBhcmd1bWVudC92YWx1ZSBwYWlycy5cbmV4cG9ydHMuT0F1dGgucHJvdG90eXBlLl9tYWtlQXJyYXlPZkFyZ3VtZW50c0hhc2g9IGZ1bmN0aW9uKGFyZ3VtZW50c0hhc2gpIHtcbiAgdmFyIGFyZ3VtZW50X3BhaXJzPSBbXTtcbiAgZm9yKHZhciBrZXkgaW4gYXJndW1lbnRzSGFzaCApIHtcbiAgICBpZiAoYXJndW1lbnRzSGFzaC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgdmFyIHZhbHVlPSBhcmd1bWVudHNIYXNoW2tleV07XG4gICAgICAgaWYoIEFycmF5LmlzQXJyYXkodmFsdWUpICkge1xuICAgICAgICAgZm9yKHZhciBpPTA7aTx2YWx1ZS5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgIGFyZ3VtZW50X3BhaXJzW2FyZ3VtZW50X3BhaXJzLmxlbmd0aF09IFtrZXksIHZhbHVlW2ldXTtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgZWxzZSB7XG4gICAgICAgICBhcmd1bWVudF9wYWlyc1thcmd1bWVudF9wYWlycy5sZW5ndGhdPSBba2V5LCB2YWx1ZV07XG4gICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJndW1lbnRfcGFpcnM7XG59XG5cbi8vIFNvcnRzIHRoZSBlbmNvZGVkIGtleSB2YWx1ZSBwYWlycyBieSBlbmNvZGVkIG5hbWUsIHRoZW4gZW5jb2RlZCB2YWx1ZVxuZXhwb3J0cy5PQXV0aC5wcm90b3R5cGUuX3NvcnRSZXF1ZXN0UGFyYW1zPSBmdW5jdGlvbihhcmd1bWVudF9wYWlycykge1xuICAvLyBTb3J0IGJ5IG5hbWUsIHRoZW4gdmFsdWUuXG4gIGFyZ3VtZW50X3BhaXJzLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgICBpZiAoIGFbMF09PSBiWzBdICkgIHtcbiAgICAgICAgcmV0dXJuIGFbMV0gPCBiWzFdID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgZWxzZSByZXR1cm4gYVswXSA8IGJbMF0gPyAtMSA6IDE7XG4gIH0pO1xuXG4gIHJldHVybiBhcmd1bWVudF9wYWlycztcbn1cblxuZXhwb3J0cy5PQXV0aC5wcm90b3R5cGUuX25vcm1hbGlzZVJlcXVlc3RQYXJhbXM9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgdmFyIGFyZ3VtZW50X3BhaXJzPSB0aGlzLl9tYWtlQXJyYXlPZkFyZ3VtZW50c0hhc2goYXJncyk7XG4gIC8vIEZpcnN0IGVuY29kZSB0aGVtICMzLjQuMS4zLjIgLjFcbiAgZm9yKHZhciBpPTA7aTxhcmd1bWVudF9wYWlycy5sZW5ndGg7aSsrKSB7XG4gICAgYXJndW1lbnRfcGFpcnNbaV1bMF09IHRoaXMuX2VuY29kZURhdGEoIGFyZ3VtZW50X3BhaXJzW2ldWzBdICk7XG4gICAgYXJndW1lbnRfcGFpcnNbaV1bMV09IHRoaXMuX2VuY29kZURhdGEoIGFyZ3VtZW50X3BhaXJzW2ldWzFdICk7XG4gIH1cblxuICAvLyBUaGVuIHNvcnQgdGhlbSAjMy40LjEuMy4yIC4yXG4gIGFyZ3VtZW50X3BhaXJzPSB0aGlzLl9zb3J0UmVxdWVzdFBhcmFtcyggYXJndW1lbnRfcGFpcnMgKTtcblxuICAvLyBUaGVuIGNvbmNhdGVuYXRlIHRvZ2V0aGVyICMzLjQuMS4zLjIgLjMgJiAuNFxuICB2YXIgYXJncz0gXCJcIjtcbiAgZm9yKHZhciBpPTA7aTxhcmd1bWVudF9wYWlycy5sZW5ndGg7aSsrKSB7XG4gICAgICBhcmdzKz0gYXJndW1lbnRfcGFpcnNbaV1bMF07XG4gICAgICBhcmdzKz0gXCI9XCJcbiAgICAgIGFyZ3MrPSBhcmd1bWVudF9wYWlyc1tpXVsxXTtcbiAgICAgIGlmKCBpIDwgYXJndW1lbnRfcGFpcnMubGVuZ3RoLTEgKSBhcmdzKz0gXCImXCI7XG4gIH1cbiAgcmV0dXJuIGFyZ3M7XG59XG5cbmV4cG9ydHMuT0F1dGgucHJvdG90eXBlLl9jcmVhdGVTaWduYXR1cmVCYXNlPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGFyYW1ldGVycykge1xuICB1cmw9IHRoaXMuX2VuY29kZURhdGEoIHRoaXMuX25vcm1hbGl6ZVVybCh1cmwpICk7XG4gIHBhcmFtZXRlcnM9IHRoaXMuX2VuY29kZURhdGEoIHBhcmFtZXRlcnMgKTtcbiAgcmV0dXJuIG1ldGhvZC50b1VwcGVyQ2FzZSgpICsgXCImXCIgKyB1cmwgKyBcIiZcIiArIHBhcmFtZXRlcnM7XG59XG5cbmV4cG9ydHMuT0F1dGgucHJvdG90eXBlLl9jcmVhdGVTaWduYXR1cmU9IGZ1bmN0aW9uKHNpZ25hdHVyZUJhc2UsIHRva2VuU2VjcmV0KSB7XG4gICBpZiggdG9rZW5TZWNyZXQgPT09IHVuZGVmaW5lZCApIHZhciB0b2tlblNlY3JldD0gXCJcIjtcbiAgIGVsc2UgdG9rZW5TZWNyZXQ9IHRoaXMuX2VuY29kZURhdGEoIHRva2VuU2VjcmV0ICk7XG4gICAvLyBjb25zdW1lclNlY3JldCBpcyBhbHJlYWR5IGVuY29kZWRcbiAgIHZhciBrZXk9IHRoaXMuX2NvbnN1bWVyU2VjcmV0ICsgXCImXCIgKyB0b2tlblNlY3JldDtcblxuICAgdmFyIGhhc2g9IFwiXCJcbiAgIGlmKCB0aGlzLl9zaWduYXR1cmVNZXRob2QgPT0gXCJQTEFJTlRFWFRcIiApIHtcbiAgICAgaGFzaD0ga2V5O1xuICAgfVxuICAgZWxzZSBpZiAodGhpcy5fc2lnbmF0dXJlTWV0aG9kID09IFwiUlNBLVNIQTFcIikge1xuICAgICBrZXkgPSB0aGlzLl9wcml2YXRlS2V5IHx8IFwiXCI7XG4gICAgIGhhc2g9IGNyeXB0by5jcmVhdGVTaWduKFwiUlNBLVNIQTFcIikudXBkYXRlKHNpZ25hdHVyZUJhc2UpLnNpZ24oa2V5LCAnYmFzZTY0Jyk7XG4gICB9XG4gICBlbHNlIHtcbiAgICAgICBpZiggY3J5cHRvLkhtYWMgKSB7XG4gICAgICAgICBoYXNoID0gY3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGExXCIsIGtleSkudXBkYXRlKHNpZ25hdHVyZUJhc2UpLmRpZ2VzdChcImJhc2U2NFwiKTtcbiAgICAgICB9XG4gICAgICAgZWxzZSB7XG4gICAgICAgICBoYXNoPSBzaGExLkhNQUNTSEExKGtleSwgc2lnbmF0dXJlQmFzZSk7XG4gICAgICAgfVxuICAgfVxuICAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnRzLk9BdXRoLnByb3RvdHlwZS5OT05DRV9DSEFSUz0gWydhJywnYicsJ2MnLCdkJywnZScsJ2YnLCdnJywnaCcsJ2knLCdqJywnaycsJ2wnLCdtJywnbicsXG4gICAgICAgICAgICAgICdvJywncCcsJ3EnLCdyJywncycsJ3QnLCd1JywndicsJ3cnLCd4JywneScsJ3onLCdBJywnQicsXG4gICAgICAgICAgICAgICdDJywnRCcsJ0UnLCdGJywnRycsJ0gnLCdJJywnSicsJ0snLCdMJywnTScsJ04nLCdPJywnUCcsXG4gICAgICAgICAgICAgICdRJywnUicsJ1MnLCdUJywnVScsJ1YnLCdXJywnWCcsJ1knLCdaJywnMCcsJzEnLCcyJywnMycsXG4gICAgICAgICAgICAgICc0JywnNScsJzYnLCc3JywnOCcsJzknXTtcblxuZXhwb3J0cy5PQXV0aC5wcm90b3R5cGUuX2dldE5vbmNlPSBmdW5jdGlvbihub25jZVNpemUpIHtcbiAgIHZhciByZXN1bHQgPSBbXTtcbiAgIHZhciBjaGFycz0gdGhpcy5OT05DRV9DSEFSUztcbiAgIHZhciBjaGFyX3BvcztcbiAgIHZhciBub25jZV9jaGFyc19sZW5ndGg9IGNoYXJzLmxlbmd0aDtcblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25jZVNpemU7IGkrKykge1xuICAgICAgIGNoYXJfcG9zPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub25jZV9jaGFyc19sZW5ndGgpO1xuICAgICAgIHJlc3VsdFtpXT0gIGNoYXJzW2NoYXJfcG9zXTtcbiAgIH1cbiAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG59XG5cbmV4cG9ydHMuT0F1dGgucHJvdG90eXBlLl9jcmVhdGVDbGllbnQ9IGZ1bmN0aW9uKCBwb3J0LCBob3N0bmFtZSwgbWV0aG9kLCBwYXRoLCBoZWFkZXJzLCBzc2xFbmFibGVkICkge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBob3N0OiBob3N0bmFtZSxcbiAgICBwb3J0OiBwb3J0LFxuICAgIHBhdGg6IHBhdGgsXG4gICAgbWV0aG9kOiBtZXRob2QsXG4gICAgaGVhZGVyczogaGVhZGVyc1xuICB9O1xuICB2YXIgaHR0cE1vZGVsO1xuICBpZiggc3NsRW5hYmxlZCApIHtcbiAgICBodHRwTW9kZWw9IGh0dHBzO1xuICB9IGVsc2Uge1xuICAgIGh0dHBNb2RlbD0gaHR0cDtcbiAgfVxuICByZXR1cm4gaHR0cE1vZGVsLnJlcXVlc3Qob3B0aW9ucyk7XG59XG5cbmV4cG9ydHMuT0F1dGgucHJvdG90eXBlLl9wcmVwYXJlUGFyYW1ldGVycz0gZnVuY3Rpb24oIG9hdXRoX3Rva2VuLCBvYXV0aF90b2tlbl9zZWNyZXQsIG1ldGhvZCwgdXJsLCBleHRyYV9wYXJhbXMgKSB7XG4gIHZhciBvYXV0aFBhcmFtZXRlcnM9IHtcbiAgICAgIFwib2F1dGhfdGltZXN0YW1wXCI6ICAgICAgICB0aGlzLl9nZXRUaW1lc3RhbXAoKSxcbiAgICAgIFwib2F1dGhfbm9uY2VcIjogICAgICAgICAgICB0aGlzLl9nZXROb25jZSh0aGlzLl9ub25jZVNpemUpLFxuICAgICAgXCJvYXV0aF92ZXJzaW9uXCI6ICAgICAgICAgIHRoaXMuX3ZlcnNpb24sXG4gICAgICBcIm9hdXRoX3NpZ25hdHVyZV9tZXRob2RcIjogdGhpcy5fc2lnbmF0dXJlTWV0aG9kLFxuICAgICAgXCJvYXV0aF9jb25zdW1lcl9rZXlcIjogICAgIHRoaXMuX2NvbnN1bWVyS2V5XG4gIH07XG5cbiAgaWYoIG9hdXRoX3Rva2VuICkge1xuICAgIG9hdXRoUGFyYW1ldGVyc1tcIm9hdXRoX3Rva2VuXCJdPSBvYXV0aF90b2tlbjtcbiAgfVxuXG4gIHZhciBzaWc7XG4gIGlmKCB0aGlzLl9pc0VjaG8gKSB7XG4gICAgc2lnID0gdGhpcy5fZ2V0U2lnbmF0dXJlKCBcIkdFVFwiLCAgdGhpcy5fdmVyaWZ5Q3JlZGVudGlhbHMsICB0aGlzLl9ub3JtYWxpc2VSZXF1ZXN0UGFyYW1zKG9hdXRoUGFyYW1ldGVycyksIG9hdXRoX3Rva2VuX3NlY3JldCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYoIGV4dHJhX3BhcmFtcyApIHtcbiAgICAgIGZvciggdmFyIGtleSBpbiBleHRyYV9wYXJhbXMgKSB7XG4gICAgICAgIGlmIChleHRyYV9wYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkgb2F1dGhQYXJhbWV0ZXJzW2tleV09IGV4dHJhX3BhcmFtc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcGFyc2VkVXJsPSBVUkwucGFyc2UoIHVybCwgZmFsc2UgKTtcblxuICAgIGlmKCBwYXJzZWRVcmwucXVlcnkgKSB7XG4gICAgICB2YXIga2V5MjtcbiAgICAgIHZhciBleHRyYVBhcmFtZXRlcnM9IHF1ZXJ5c3RyaW5nLnBhcnNlKHBhcnNlZFVybC5xdWVyeSk7XG4gICAgICBmb3IodmFyIGtleSBpbiBleHRyYVBhcmFtZXRlcnMgKSB7XG4gICAgICAgIHZhciB2YWx1ZT0gZXh0cmFQYXJhbWV0ZXJzW2tleV07XG4gICAgICAgICAgaWYoIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICl7XG4gICAgICAgICAgICAvLyBUT0RPOiBUaGlzIHByb2JhYmx5IHNob3VsZCBiZSByZWN1cnNpdmVcbiAgICAgICAgICAgIGZvcihrZXkyIGluIHZhbHVlKXtcbiAgICAgICAgICAgICAgb2F1dGhQYXJhbWV0ZXJzW2tleSArIFwiW1wiICsga2V5MiArIFwiXVwiXSA9IHZhbHVlW2tleTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYXV0aFBhcmFtZXRlcnNba2V5XT0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2lnID0gdGhpcy5fZ2V0U2lnbmF0dXJlKCBtZXRob2QsICB1cmwsICB0aGlzLl9ub3JtYWxpc2VSZXF1ZXN0UGFyYW1zKG9hdXRoUGFyYW1ldGVycyksIG9hdXRoX3Rva2VuX3NlY3JldCk7XG4gIH1cblxuICB2YXIgb3JkZXJlZFBhcmFtZXRlcnM9IHRoaXMuX3NvcnRSZXF1ZXN0UGFyYW1zKCB0aGlzLl9tYWtlQXJyYXlPZkFyZ3VtZW50c0hhc2gob2F1dGhQYXJhbWV0ZXJzKSApO1xuICBvcmRlcmVkUGFyYW1ldGVyc1tvcmRlcmVkUGFyYW1ldGVycy5sZW5ndGhdPSBbXCJvYXV0aF9zaWduYXR1cmVcIiwgc2lnXTtcbiAgcmV0dXJuIG9yZGVyZWRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnRzLk9BdXRoLnByb3RvdHlwZS5fcGVyZm9ybVNlY3VyZVJlcXVlc3Q9IGZ1bmN0aW9uKCBvYXV0aF90b2tlbiwgb2F1dGhfdG9rZW5fc2VjcmV0LCBtZXRob2QsIHVybCwgZXh0cmFfcGFyYW1zLCBwb3N0X2JvZHksIHBvc3RfY29udGVudF90eXBlLCAgY2FsbGJhY2sgKSB7XG4gIHZhciBvcmRlcmVkUGFyYW1ldGVycz0gdGhpcy5fcHJlcGFyZVBhcmFtZXRlcnMob2F1dGhfdG9rZW4sIG9hdXRoX3Rva2VuX3NlY3JldCwgbWV0aG9kLCB1cmwsIGV4dHJhX3BhcmFtcyk7XG5cbiAgaWYoICFwb3N0X2NvbnRlbnRfdHlwZSApIHtcbiAgICBwb3N0X2NvbnRlbnRfdHlwZT0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcbiAgfVxuICB2YXIgcGFyc2VkVXJsPSBVUkwucGFyc2UoIHVybCwgZmFsc2UgKTtcbiAgaWYoIHBhcnNlZFVybC5wcm90b2NvbCA9PSBcImh0dHA6XCIgJiYgIXBhcnNlZFVybC5wb3J0ICkgcGFyc2VkVXJsLnBvcnQ9IDgwO1xuICBpZiggcGFyc2VkVXJsLnByb3RvY29sID09IFwiaHR0cHM6XCIgJiYgIXBhcnNlZFVybC5wb3J0ICkgcGFyc2VkVXJsLnBvcnQ9IDQ0MztcblxuICB2YXIgaGVhZGVycz0ge307XG4gIHZhciBhdXRob3JpemF0aW9uID0gdGhpcy5fYnVpbGRBdXRob3JpemF0aW9uSGVhZGVycyhvcmRlcmVkUGFyYW1ldGVycyk7XG4gIGlmICggdGhpcy5faXNFY2hvICkge1xuICAgIGhlYWRlcnNbXCJYLVZlcmlmeS1DcmVkZW50aWFscy1BdXRob3JpemF0aW9uXCJdPSBhdXRob3JpemF0aW9uO1xuICB9XG4gIGVsc2Uge1xuICAgIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdPSBhdXRob3JpemF0aW9uO1xuICB9XG5cbiAgaGVhZGVyc1tcIkhvc3RcIl0gPSBwYXJzZWRVcmwuaG9zdFxuXG4gIGZvciggdmFyIGtleSBpbiB0aGlzLl9oZWFkZXJzICkge1xuICAgIGlmICh0aGlzLl9oZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGhlYWRlcnNba2V5XT0gdGhpcy5faGVhZGVyc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbHRlciBvdXQgYW55IHBhc3NlZCBleHRyYV9wYXJhbXMgdGhhdCBhcmUgcmVhbGx5IHRvIGRvIHdpdGggT0F1dGhcbiAgZm9yKHZhciBrZXkgaW4gZXh0cmFfcGFyYW1zKSB7XG4gICAgaWYoIHRoaXMuX2lzUGFyYW1ldGVyTmFtZUFuT0F1dGhQYXJhbWV0ZXIoIGtleSApICkge1xuICAgICAgZGVsZXRlIGV4dHJhX3BhcmFtc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIGlmKCAobWV0aG9kID09IFwiUE9TVFwiIHx8IG1ldGhvZCA9PSBcIlBVVFwiKSAgJiYgKCBwb3N0X2JvZHkgPT0gbnVsbCAmJiBleHRyYV9wYXJhbXMgIT0gbnVsbCkgKSB7XG4gICAgLy8gRml4IHRoZSBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBvdXRwdXQgb2YgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KCkgYW5kIHRoaXMuX2VuY29kZURhdGEoKVxuICAgIHBvc3RfYm9keT0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KGV4dHJhX3BhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcIS9nLCBcIiUyMVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwnL2csIFwiJTI3XCIpXG4gICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCgvZywgXCIlMjhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKS9nLCBcIiUyOVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwqL2csIFwiJTJBXCIpO1xuICB9XG5cbiAgaWYoIHBvc3RfYm9keSApIHtcbiAgICAgIGlmICggQnVmZmVyLmlzQnVmZmVyKHBvc3RfYm9keSkgKSB7XG4gICAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtbGVuZ3RoXCJdPSBwb3N0X2JvZHkubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1sZW5ndGhcIl09IEJ1ZmZlci5ieXRlTGVuZ3RoKHBvc3RfYm9keSk7XG4gICAgICB9XG4gIH0gZWxzZSB7XG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1sZW5ndGhcIl09IDA7XG4gIH1cblxuICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdPSBwb3N0X2NvbnRlbnRfdHlwZTtcblxuICB2YXIgcGF0aDtcbiAgaWYoICFwYXJzZWRVcmwucGF0aG5hbWUgIHx8IHBhcnNlZFVybC5wYXRobmFtZSA9PSBcIlwiICkgcGFyc2VkVXJsLnBhdGhuYW1lID1cIi9cIjtcbiAgaWYoIHBhcnNlZFVybC5xdWVyeSApIHBhdGg9IHBhcnNlZFVybC5wYXRobmFtZSArIFwiP1wiKyBwYXJzZWRVcmwucXVlcnkgO1xuICBlbHNlIHBhdGg9IHBhcnNlZFVybC5wYXRobmFtZTtcblxuICB2YXIgcmVxdWVzdDtcbiAgaWYoIHBhcnNlZFVybC5wcm90b2NvbCA9PSBcImh0dHBzOlwiICkge1xuICAgIHJlcXVlc3Q9IHRoaXMuX2NyZWF0ZUNsaWVudChwYXJzZWRVcmwucG9ydCwgcGFyc2VkVXJsLmhvc3RuYW1lLCBtZXRob2QsIHBhdGgsIGhlYWRlcnMsIHRydWUpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJlcXVlc3Q9IHRoaXMuX2NyZWF0ZUNsaWVudChwYXJzZWRVcmwucG9ydCwgcGFyc2VkVXJsLmhvc3RuYW1lLCBtZXRob2QsIHBhdGgsIGhlYWRlcnMpO1xuICB9XG5cbiAgdmFyIGNsaWVudE9wdGlvbnMgPSB0aGlzLl9jbGllbnRPcHRpb25zO1xuICBpZiggY2FsbGJhY2sgKSB7XG4gICAgdmFyIGRhdGE9XCJcIjtcbiAgICB2YXIgc2VsZj0gdGhpcztcblxuICAgIC8vIFNvbWUgaG9zdHMgKmNvdWdoKiBnb29nbGUgYXBwZWFyIHRvIGNsb3NlIHRoZSBjb25uZWN0aW9uIGVhcmx5IC8gc2VuZCBubyBjb250ZW50LWxlbmd0aCBoZWFkZXJcbiAgICAvLyBhbGxvdyB0aGlzIGJlaGF2aW91ci5cbiAgICB2YXIgYWxsb3dFYXJseUNsb3NlPSBPQXV0aFV0aWxzLmlzQW5FYXJseUNsb3NlSG9zdCggcGFyc2VkVXJsLmhvc3RuYW1lICk7XG4gICAgdmFyIGNhbGxiYWNrQ2FsbGVkPSBmYWxzZTtcbiAgICB2YXIgcGFzc0JhY2tDb250cm9sID0gZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuICAgICAgaWYoIWNhbGxiYWNrQ2FsbGVkKSB7XG4gICAgICAgIGNhbGxiYWNrQ2FsbGVkPSB0cnVlO1xuICAgICAgICBpZiAoIHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPD0gMjk5ICkge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEsIHJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGb2xsb3cgMzAxIG9yIDMwMiByZWRpcmVjdHMgd2l0aCBMb2NhdGlvbiBIVFRQIGhlYWRlclxuICAgICAgICAgIGlmKChyZXNwb25zZS5zdGF0dXNDb2RlID09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09IDMwMikgJiYgY2xpZW50T3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgJiYgcmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICBzZWxmLl9wZXJmb3JtU2VjdXJlUmVxdWVzdCggb2F1dGhfdG9rZW4sIG9hdXRoX3Rva2VuX3NlY3JldCwgbWV0aG9kLCByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uLCBleHRyYV9wYXJhbXMsIHBvc3RfYm9keSwgcG9zdF9jb250ZW50X3R5cGUsICBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soeyBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlLCBkYXRhOiBkYXRhIH0sIGRhdGEsIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgcmVzcG9uc2Uuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIGRhdGErPWNodW5rO1xuICAgICAgfSk7XG4gICAgICByZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBwYXNzQmFja0NvbnRyb2woIHJlc3BvbnNlICk7XG4gICAgICB9KTtcbiAgICAgIHJlc3BvbnNlLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoIGFsbG93RWFybHlDbG9zZSApIHtcbiAgICAgICAgICBwYXNzQmFja0NvbnRyb2woIHJlc3BvbnNlICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmVxdWVzdC5vbihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYoIWNhbGxiYWNrQ2FsbGVkKSB7XG4gICAgICAgIGNhbGxiYWNrQ2FsbGVkPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayggZXJyIClcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKCAobWV0aG9kID09IFwiUE9TVFwiIHx8IG1ldGhvZCA9PVwiUFVUXCIpICYmIHBvc3RfYm9keSAhPSBudWxsICYmIHBvc3RfYm9keSAhPSBcIlwiICkge1xuICAgICAgcmVxdWVzdC53cml0ZShwb3N0X2JvZHkpO1xuICAgIH1cbiAgICByZXF1ZXN0LmVuZCgpO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmKCAobWV0aG9kID09IFwiUE9TVFwiIHx8IG1ldGhvZCA9PVwiUFVUXCIpICYmIHBvc3RfYm9keSAhPSBudWxsICYmIHBvc3RfYm9keSAhPSBcIlwiICkge1xuICAgICAgcmVxdWVzdC53cml0ZShwb3N0X2JvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuZXhwb3J0cy5PQXV0aC5wcm90b3R5cGUuc2V0Q2xpZW50T3B0aW9ucz0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIga2V5LFxuICAgICAgbWVyZ2VkT3B0aW9ucz0ge30sXG4gICAgICBoYXNPd25Qcm9wZXJ0eT0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IoIGtleSBpbiB0aGlzLl9kZWZhdWx0Q2xpZW50T3B0aW9ucyApIHtcbiAgICBpZiggIWhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywga2V5KSApIHtcbiAgICAgIG1lcmdlZE9wdGlvbnNba2V5XT0gdGhpcy5fZGVmYXVsdENsaWVudE9wdGlvbnNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VkT3B0aW9uc1trZXldPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY2xpZW50T3B0aW9ucz0gbWVyZ2VkT3B0aW9ucztcbn07XG5cbmV4cG9ydHMuT0F1dGgucHJvdG90eXBlLmdldE9BdXRoQWNjZXNzVG9rZW49IGZ1bmN0aW9uKG9hdXRoX3Rva2VuLCBvYXV0aF90b2tlbl9zZWNyZXQsIG9hdXRoX3ZlcmlmaWVyLCAgY2FsbGJhY2spIHtcbiAgdmFyIGV4dHJhUGFyYW1zPSB7fTtcbiAgaWYoIHR5cGVvZiBvYXV0aF92ZXJpZmllciA9PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgY2FsbGJhY2s9IG9hdXRoX3ZlcmlmaWVyO1xuICB9IGVsc2Uge1xuICAgIGV4dHJhUGFyYW1zLm9hdXRoX3ZlcmlmaWVyPSBvYXV0aF92ZXJpZmllcjtcbiAgfVxuXG4gICB0aGlzLl9wZXJmb3JtU2VjdXJlUmVxdWVzdCggb2F1dGhfdG9rZW4sIG9hdXRoX3Rva2VuX3NlY3JldCwgdGhpcy5fY2xpZW50T3B0aW9ucy5hY2Nlc3NUb2tlbkh0dHBNZXRob2QsIHRoaXMuX2FjY2Vzc1VybCwgZXh0cmFQYXJhbXMsIG51bGwsIG51bGwsIGZ1bmN0aW9uKGVycm9yLCBkYXRhLCByZXNwb25zZSkge1xuICAgICAgICAgaWYoIGVycm9yICkgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgIHZhciByZXN1bHRzPSBxdWVyeXN0cmluZy5wYXJzZSggZGF0YSApO1xuICAgICAgICAgICB2YXIgb2F1dGhfYWNjZXNzX3Rva2VuPSByZXN1bHRzW1wib2F1dGhfdG9rZW5cIl07XG4gICAgICAgICAgIGRlbGV0ZSByZXN1bHRzW1wib2F1dGhfdG9rZW5cIl07XG4gICAgICAgICAgIHZhciBvYXV0aF9hY2Nlc3NfdG9rZW5fc2VjcmV0PSByZXN1bHRzW1wib2F1dGhfdG9rZW5fc2VjcmV0XCJdO1xuICAgICAgICAgICBkZWxldGUgcmVzdWx0c1tcIm9hdXRoX3Rva2VuX3NlY3JldFwiXTtcbiAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgb2F1dGhfYWNjZXNzX3Rva2VuLCBvYXV0aF9hY2Nlc3NfdG9rZW5fc2VjcmV0LCByZXN1bHRzICk7XG4gICAgICAgICB9XG4gICB9KVxufVxuXG4vLyBEZXByZWNhdGVkXG5leHBvcnRzLk9BdXRoLnByb3RvdHlwZS5nZXRQcm90ZWN0ZWRSZXNvdXJjZT0gZnVuY3Rpb24odXJsLCBtZXRob2QsIG9hdXRoX3Rva2VuLCBvYXV0aF90b2tlbl9zZWNyZXQsIGNhbGxiYWNrKSB7XG4gIHRoaXMuX3BlcmZvcm1TZWN1cmVSZXF1ZXN0KCBvYXV0aF90b2tlbiwgb2F1dGhfdG9rZW5fc2VjcmV0LCBtZXRob2QsIHVybCwgbnVsbCwgXCJcIiwgbnVsbCwgY2FsbGJhY2sgKTtcbn1cblxuZXhwb3J0cy5PQXV0aC5wcm90b3R5cGUuZGVsZXRlPSBmdW5jdGlvbih1cmwsIG9hdXRoX3Rva2VuLCBvYXV0aF90b2tlbl9zZWNyZXQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9wZXJmb3JtU2VjdXJlUmVxdWVzdCggb2F1dGhfdG9rZW4sIG9hdXRoX3Rva2VuX3NlY3JldCwgXCJERUxFVEVcIiwgdXJsLCBudWxsLCBcIlwiLCBudWxsLCBjYWxsYmFjayApO1xufVxuXG5leHBvcnRzLk9BdXRoLnByb3RvdHlwZS5nZXQ9IGZ1bmN0aW9uKHVybCwgb2F1dGhfdG9rZW4sIG9hdXRoX3Rva2VuX3NlY3JldCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX3BlcmZvcm1TZWN1cmVSZXF1ZXN0KCBvYXV0aF90b2tlbiwgb2F1dGhfdG9rZW5fc2VjcmV0LCBcIkdFVFwiLCB1cmwsIG51bGwsIFwiXCIsIG51bGwsIGNhbGxiYWNrICk7XG59XG5cbmV4cG9ydHMuT0F1dGgucHJvdG90eXBlLl9wdXRPclBvc3Q9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBvYXV0aF90b2tlbiwgb2F1dGhfdG9rZW5fc2VjcmV0LCBwb3N0X2JvZHksIHBvc3RfY29udGVudF90eXBlLCBjYWxsYmFjaykge1xuICB2YXIgZXh0cmFfcGFyYW1zPSBudWxsO1xuICBpZiggdHlwZW9mIHBvc3RfY29udGVudF90eXBlID09IFwiZnVuY3Rpb25cIiApIHtcbiAgICBjYWxsYmFjaz0gcG9zdF9jb250ZW50X3R5cGU7XG4gICAgcG9zdF9jb250ZW50X3R5cGU9IG51bGw7XG4gIH1cbiAgaWYgKCB0eXBlb2YgcG9zdF9ib2R5ICE9IFwic3RyaW5nXCIgJiYgIUJ1ZmZlci5pc0J1ZmZlcihwb3N0X2JvZHkpICkge1xuICAgIHBvc3RfY29udGVudF90eXBlPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgZXh0cmFfcGFyYW1zPSBwb3N0X2JvZHk7XG4gICAgcG9zdF9ib2R5PSBudWxsO1xuICB9XG4gIHJldHVybiB0aGlzLl9wZXJmb3JtU2VjdXJlUmVxdWVzdCggb2F1dGhfdG9rZW4sIG9hdXRoX3Rva2VuX3NlY3JldCwgbWV0aG9kLCB1cmwsIGV4dHJhX3BhcmFtcywgcG9zdF9ib2R5LCBwb3N0X2NvbnRlbnRfdHlwZSwgY2FsbGJhY2sgKTtcbn1cblxuXG5leHBvcnRzLk9BdXRoLnByb3RvdHlwZS5wdXQ9IGZ1bmN0aW9uKHVybCwgb2F1dGhfdG9rZW4sIG9hdXRoX3Rva2VuX3NlY3JldCwgcG9zdF9ib2R5LCBwb3N0X2NvbnRlbnRfdHlwZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX3B1dE9yUG9zdChcIlBVVFwiLCB1cmwsIG9hdXRoX3Rva2VuLCBvYXV0aF90b2tlbl9zZWNyZXQsIHBvc3RfYm9keSwgcG9zdF9jb250ZW50X3R5cGUsIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0cy5PQXV0aC5wcm90b3R5cGUucG9zdD0gZnVuY3Rpb24odXJsLCBvYXV0aF90b2tlbiwgb2F1dGhfdG9rZW5fc2VjcmV0LCBwb3N0X2JvZHksIHBvc3RfY29udGVudF90eXBlLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fcHV0T3JQb3N0KFwiUE9TVFwiLCB1cmwsIG9hdXRoX3Rva2VuLCBvYXV0aF90b2tlbl9zZWNyZXQsIHBvc3RfYm9keSwgcG9zdF9jb250ZW50X3R5cGUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBHZXRzIGEgcmVxdWVzdCB0b2tlbiBmcm9tIHRoZSBPQXV0aCBwcm92aWRlciBhbmQgcGFzc2VzIHRoYXQgaW5mb3JtYXRpb24gYmFja1xuICogdG8gdGhlIGNhbGxpbmcgY29kZS5cbiAqXG4gKiBUaGUgY2FsbGJhY2sgc2hvdWxkIGV4cGVjdCBhIGZ1bmN0aW9uIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAqXG4gKiBmdW5jdGlvbihlcnIsIHRva2VuLCB0b2tlbl9zZWNyZXQsIHBhcnNlZFF1ZXJ5U3RyaW5nKSB7fVxuICpcbiAqIFRoaXMgbWV0aG9kIGhhcyBvcHRpb25hbCBwYXJhbWV0ZXJzIHNvIGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyAyIHdheXM6XG4gKlxuICogMSkgUHJpbWFyeSB1c2UgY2FzZTogRG9lcyBhIGJhc2ljIHJlcXVlc3Qgd2l0aCBubyBleHRyYSBwYXJhbWV0ZXJzXG4gKiAgZ2V0T0F1dGhSZXF1ZXN0VG9rZW4oIGNhbGxiYWNrRnVuY3Rpb24gKVxuICpcbiAqIDIpIEFzIGFib3ZlIGJ1dCBhbGxvd3MgZm9yIHByb3Zpc2lvbiBvZiBleHRyYSBwYXJhbWV0ZXJzIHRvIGJlIHNlbnQgYXMgcGFydCBvZiB0aGUgcXVlcnkgdG8gdGhlIHNlcnZlci5cbiAqICBnZXRPQXV0aFJlcXVlc3RUb2tlbiggZXh0cmFQYXJhbXMsIGNhbGxiYWNrRnVuY3Rpb24gKVxuICpcbiAqIE4uQi4gVGhpcyBtZXRob2Qgd2lsbCBIVFRQIFBPU1QgdmVyYnMgYnkgZGVmYXVsdCwgaWYgeW91IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvdXIgeW91IHdpbGxcbiAqIG5lZWQgdG8gcHJvdmlkZSBhIHJlcXVlc3RUb2tlbkh0dHBNZXRob2Qgb3B0aW9uIHdoZW4gY3JlYXRpbmcgdGhlIGNsaWVudC5cbiAqXG4gKiovXG5leHBvcnRzLk9BdXRoLnByb3RvdHlwZS5nZXRPQXV0aFJlcXVlc3RUb2tlbj0gZnVuY3Rpb24oIGV4dHJhUGFyYW1zLCBjYWxsYmFjayApIHtcbiAgIGlmKCB0eXBlb2YgZXh0cmFQYXJhbXMgPT0gXCJmdW5jdGlvblwiICl7XG4gICAgIGNhbGxiYWNrID0gZXh0cmFQYXJhbXM7XG4gICAgIGV4dHJhUGFyYW1zID0ge307XG4gICB9XG4gIC8vIENhbGxiYWNrcyBhcmUgMS4wQSByZWxhdGVkXG4gIGlmKCB0aGlzLl9hdXRob3JpemVfY2FsbGJhY2sgKSB7XG4gICAgZXh0cmFQYXJhbXNbXCJvYXV0aF9jYWxsYmFja1wiXT0gdGhpcy5fYXV0aG9yaXplX2NhbGxiYWNrO1xuICB9XG4gIHRoaXMuX3BlcmZvcm1TZWN1cmVSZXF1ZXN0KCBudWxsLCBudWxsLCB0aGlzLl9jbGllbnRPcHRpb25zLnJlcXVlc3RUb2tlbkh0dHBNZXRob2QsIHRoaXMuX3JlcXVlc3RVcmwsIGV4dHJhUGFyYW1zLCBudWxsLCBudWxsLCBmdW5jdGlvbihlcnJvciwgZGF0YSwgcmVzcG9uc2UpIHtcbiAgICBpZiggZXJyb3IgKSBjYWxsYmFjayhlcnJvcik7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0cz0gcXVlcnlzdHJpbmcucGFyc2UoZGF0YSk7XG5cbiAgICAgIHZhciBvYXV0aF90b2tlbj0gcmVzdWx0c1tcIm9hdXRoX3Rva2VuXCJdO1xuICAgICAgdmFyIG9hdXRoX3Rva2VuX3NlY3JldD0gcmVzdWx0c1tcIm9hdXRoX3Rva2VuX3NlY3JldFwiXTtcbiAgICAgIGRlbGV0ZSByZXN1bHRzW1wib2F1dGhfdG9rZW5cIl07XG4gICAgICBkZWxldGUgcmVzdWx0c1tcIm9hdXRoX3Rva2VuX3NlY3JldFwiXTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIG9hdXRoX3Rva2VuLCBvYXV0aF90b2tlbl9zZWNyZXQsICByZXN1bHRzICk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5PQXV0aC5wcm90b3R5cGUuc2lnblVybD0gZnVuY3Rpb24odXJsLCBvYXV0aF90b2tlbiwgb2F1dGhfdG9rZW5fc2VjcmV0LCBtZXRob2QpIHtcblxuICBpZiggbWV0aG9kID09PSB1bmRlZmluZWQgKSB7XG4gICAgdmFyIG1ldGhvZD0gXCJHRVRcIjtcbiAgfVxuXG4gIHZhciBvcmRlcmVkUGFyYW1ldGVycz0gdGhpcy5fcHJlcGFyZVBhcmFtZXRlcnMob2F1dGhfdG9rZW4sIG9hdXRoX3Rva2VuX3NlY3JldCwgbWV0aG9kLCB1cmwsIHt9KTtcbiAgdmFyIHBhcnNlZFVybD0gVVJMLnBhcnNlKCB1cmwsIGZhbHNlICk7XG5cbiAgdmFyIHF1ZXJ5PVwiXCI7XG4gIGZvciggdmFyIGk9IDAgOyBpIDwgb3JkZXJlZFBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBxdWVyeSs9IG9yZGVyZWRQYXJhbWV0ZXJzW2ldWzBdK1wiPVwiKyB0aGlzLl9lbmNvZGVEYXRhKG9yZGVyZWRQYXJhbWV0ZXJzW2ldWzFdKSArIFwiJlwiO1xuICB9XG4gIHF1ZXJ5PSBxdWVyeS5zdWJzdHJpbmcoMCwgcXVlcnkubGVuZ3RoLTEpO1xuXG4gIHJldHVybiBwYXJzZWRVcmwucHJvdG9jb2wgKyBcIi8vXCIrIHBhcnNlZFVybC5ob3N0ICsgcGFyc2VkVXJsLnBhdGhuYW1lICsgXCI/XCIgKyBxdWVyeTtcbn07XG5cbmV4cG9ydHMuT0F1dGgucHJvdG90eXBlLmF1dGhIZWFkZXI9IGZ1bmN0aW9uKHVybCwgb2F1dGhfdG9rZW4sIG9hdXRoX3Rva2VuX3NlY3JldCwgbWV0aG9kKSB7XG4gIGlmKCBtZXRob2QgPT09IHVuZGVmaW5lZCApIHtcbiAgICB2YXIgbWV0aG9kPSBcIkdFVFwiO1xuICB9XG5cbiAgdmFyIG9yZGVyZWRQYXJhbWV0ZXJzPSB0aGlzLl9wcmVwYXJlUGFyYW1ldGVycyhvYXV0aF90b2tlbiwgb2F1dGhfdG9rZW5fc2VjcmV0LCBtZXRob2QsIHVybCwge30pO1xuICByZXR1cm4gdGhpcy5fYnVpbGRBdXRob3JpemF0aW9uSGVhZGVycyhvcmRlcmVkUGFyYW1ldGVycyk7XG59O1xuIiwidmFyIHF1ZXJ5c3RyaW5nPSByZXF1aXJlKCdxdWVyeXN0cmluZycpLFxuICAgIGNyeXB0bz0gcmVxdWlyZSgnY3J5cHRvJyksXG4gICAgaHR0cHM9IHJlcXVpcmUoJ2h0dHBzJyksXG4gICAgaHR0cD0gcmVxdWlyZSgnaHR0cCcpLFxuICAgIFVSTD0gcmVxdWlyZSgndXJsJyksXG4gICAgT0F1dGhVdGlscz0gcmVxdWlyZSgnLi9fdXRpbHMnKTtcblxuZXhwb3J0cy5PQXV0aDI9IGZ1bmN0aW9uKGNsaWVudElkLCBjbGllbnRTZWNyZXQsIGJhc2VTaXRlLCBhdXRob3JpemVQYXRoLCBhY2Nlc3NUb2tlblBhdGgsIGN1c3RvbUhlYWRlcnMpIHtcbiAgdGhpcy5fY2xpZW50SWQ9IGNsaWVudElkO1xuICB0aGlzLl9jbGllbnRTZWNyZXQ9IGNsaWVudFNlY3JldDtcbiAgdGhpcy5fYmFzZVNpdGU9IGJhc2VTaXRlO1xuICB0aGlzLl9hdXRob3JpemVVcmw9IGF1dGhvcml6ZVBhdGggfHwgXCIvb2F1dGgvYXV0aG9yaXplXCI7XG4gIHRoaXMuX2FjY2Vzc1Rva2VuVXJsPSBhY2Nlc3NUb2tlblBhdGggfHwgXCIvb2F1dGgvYWNjZXNzX3Rva2VuXCI7XG4gIHRoaXMuX2FjY2Vzc1Rva2VuTmFtZT0gXCJhY2Nlc3NfdG9rZW5cIjtcbiAgdGhpcy5fYXV0aE1ldGhvZD0gXCJCZWFyZXJcIjtcbiAgdGhpcy5fY3VzdG9tSGVhZGVycyA9IGN1c3RvbUhlYWRlcnMgfHwge307XG4gIHRoaXMuX3VzZUF1dGhvcml6YXRpb25IZWFkZXJGb3JHRVQ9IGZhbHNlO1xuXG4gIC8vb3VyIGFnZW50XG4gIHRoaXMuX2FnZW50ID0gdW5kZWZpbmVkO1xufTtcblxuLy8gQWxsb3dzIHlvdSB0byBzZXQgYW4gYWdlbnQgdG8gdXNlIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgSFRUUCBvclxuLy8gSFRUUFMgYWdlbnRzLiBVc2VmdWwgd2hlbiBkZWFsaW5nIHdpdGggeW91ciBvd24gY2VydGlmaWNhdGVzLlxuZXhwb3J0cy5PQXV0aDIucHJvdG90eXBlLnNldEFnZW50ID0gZnVuY3Rpb24oYWdlbnQpIHtcbiAgdGhpcy5fYWdlbnQgPSBhZ2VudDtcbn07XG5cbi8vIFRoaXMgJ2hhY2snIG1ldGhvZCBpcyByZXF1aXJlZCBmb3Igc2l0ZXMgdGhhdCBkb24ndCB1c2Vcbi8vICdhY2Nlc3NfdG9rZW4nIGFzIHRoZSBuYW1lIG9mIHRoZSBhY2Nlc3MgdG9rZW4gKGZvciByZXF1ZXN0cykuXG4vLyAoIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtb2F1dGgtdjItMTYjc2VjdGlvbi03IClcbi8vIGl0IGlzbid0IGNsZWFyIHdoYXQgdGhlIGNvcnJlY3QgdmFsdWUgc2hvdWxkIGJlIGF0bSwgc28gYWxsb3dpbmdcbi8vIGZvciBzcGVjaWZpYyAodGVtcG9yYXJ5Pykgb3ZlcnJpZGUgZm9yIG5vdy5cbmV4cG9ydHMuT0F1dGgyLnByb3RvdHlwZS5zZXRBY2Nlc3NUb2tlbk5hbWU9IGZ1bmN0aW9uICggbmFtZSApIHtcbiAgdGhpcy5fYWNjZXNzVG9rZW5OYW1lPSBuYW1lO1xufVxuXG4vLyBTZXRzIHRoZSBhdXRob3JpemF0aW9uIG1ldGhvZCBmb3IgQXV0aG9yaXphdGlvbiBoZWFkZXIuXG4vLyBlLmcuIEF1dGhvcml6YXRpb246IEJlYXJlciA8dG9rZW4+ICAjIFwiQmVhcmVyXCIgaXMgdGhlIGF1dGhvcml6YXRpb24gbWV0aG9kLlxuZXhwb3J0cy5PQXV0aDIucHJvdG90eXBlLnNldEF1dGhNZXRob2QgPSBmdW5jdGlvbiAoIGF1dGhNZXRob2QgKSB7XG4gIHRoaXMuX2F1dGhNZXRob2QgPSBhdXRoTWV0aG9kO1xufTtcblxuXG4vLyBJZiB5b3UgdXNlIHRoZSBPQXV0aDIgZXhwb3NlZCAnZ2V0JyBtZXRob2QgKGFuZCBkb24ndCBjb25zdHJ1Y3QgeW91ciBvd24gX3JlcXVlc3QgY2FsbCApXG4vLyB0aGlzIHdpbGwgc3BlY2lmeSB3aGV0aGVyIHRvIHVzZSBhbiAnQXV0aG9yaXplJyBoZWFkZXIgaW5zdGVhZCBvZiBwYXNzaW5nIHRoZSBhY2Nlc3NfdG9rZW4gYXMgYSBxdWVyeSBwYXJhbWV0ZXJcbmV4cG9ydHMuT0F1dGgyLnByb3RvdHlwZS51c2VBdXRob3JpemF0aW9uSGVhZGVyZm9yR0VUID0gZnVuY3Rpb24odXNlSXQpIHtcbiAgdGhpcy5fdXNlQXV0aG9yaXphdGlvbkhlYWRlckZvckdFVD0gdXNlSXQ7XG59XG5cbmV4cG9ydHMuT0F1dGgyLnByb3RvdHlwZS5fZ2V0QWNjZXNzVG9rZW5Vcmw9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYmFzZVNpdGUgKyB0aGlzLl9hY2Nlc3NUb2tlblVybDsgLyogKyBcIj9cIiArIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShwYXJhbXMpOyAqL1xufVxuXG4vLyBCdWlsZCB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXIuIEluIHBhcnRpY3VsYXIsIGJ1aWxkIHRoZSBwYXJ0IGFmdGVyIHRoZSBjb2xvbi5cbi8vIGUuZy4gQXV0aG9yaXphdGlvbjogQmVhcmVyIDx0b2tlbj4gICMgQnVpbGQgXCJCZWFyZXIgPHRva2VuPlwiXG5leHBvcnRzLk9BdXRoMi5wcm90b3R5cGUuYnVpbGRBdXRoSGVhZGVyPSBmdW5jdGlvbih0b2tlbikge1xuICByZXR1cm4gdGhpcy5fYXV0aE1ldGhvZCArICcgJyArIHRva2VuO1xufTtcblxuZXhwb3J0cy5PQXV0aDIucHJvdG90eXBlLl9jaG9vc2VIdHRwTGlicmFyeT0gZnVuY3Rpb24oIHBhcnNlZFVybCApIHtcbiAgdmFyIGh0dHBfbGlicmFyeT0gaHR0cHM7XG4gIC8vIEFzIHRoaXMgaXMgT0FVdGgyLCB3ZSAqYXNzdW1lKiBodHRwcyB1bmxlc3MgdG9sZCBleHBsaWNpdGx5IG90aGVyd2lzZS5cbiAgaWYoIHBhcnNlZFVybC5wcm90b2NvbCAhPSBcImh0dHBzOlwiICkge1xuICAgIGh0dHBfbGlicmFyeT0gaHR0cDtcbiAgfVxuICByZXR1cm4gaHR0cF9saWJyYXJ5O1xufTtcblxuZXhwb3J0cy5PQXV0aDIucHJvdG90eXBlLl9yZXF1ZXN0PSBmdW5jdGlvbihtZXRob2QsIHVybCwgaGVhZGVycywgcG9zdF9ib2R5LCBhY2Nlc3NfdG9rZW4sIGNhbGxiYWNrKSB7XG5cbiAgdmFyIHBhcnNlZFVybD0gVVJMLnBhcnNlKCB1cmwsIHRydWUgKTtcbiAgaWYoIHBhcnNlZFVybC5wcm90b2NvbCA9PSBcImh0dHBzOlwiICYmICFwYXJzZWRVcmwucG9ydCApIHtcbiAgICBwYXJzZWRVcmwucG9ydD0gNDQzO1xuICB9XG5cbiAgdmFyIGh0dHBfbGlicmFyeT0gdGhpcy5fY2hvb3NlSHR0cExpYnJhcnkoIHBhcnNlZFVybCApO1xuXG5cbiAgdmFyIHJlYWxIZWFkZXJzPSB7fTtcbiAgZm9yKCB2YXIga2V5IGluIHRoaXMuX2N1c3RvbUhlYWRlcnMgKSB7XG4gICAgcmVhbEhlYWRlcnNba2V5XT0gdGhpcy5fY3VzdG9tSGVhZGVyc1trZXldO1xuICB9XG4gIGlmKCBoZWFkZXJzICkge1xuICAgIGZvcih2YXIga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgIHJlYWxIZWFkZXJzW2tleV0gPSBoZWFkZXJzW2tleV07XG4gICAgfVxuICB9XG4gIHJlYWxIZWFkZXJzWydIb3N0J109IHBhcnNlZFVybC5ob3N0O1xuXG4gIGlmICghcmVhbEhlYWRlcnNbJ1VzZXItQWdlbnQnXSkge1xuICAgIHJlYWxIZWFkZXJzWydVc2VyLUFnZW50J10gPSAnTm9kZS1vYXV0aCc7XG4gIH1cblxuICBpZiggcG9zdF9ib2R5ICkge1xuICAgICAgaWYgKCBCdWZmZXIuaXNCdWZmZXIocG9zdF9ib2R5KSApIHtcbiAgICAgICAgICByZWFsSGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdPSBwb3N0X2JvZHkubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWFsSGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdPSBCdWZmZXIuYnl0ZUxlbmd0aChwb3N0X2JvZHkpO1xuICAgICAgfVxuICB9IGVsc2Uge1xuICAgICAgcmVhbEhlYWRlcnNbXCJDb250ZW50LWxlbmd0aFwiXT0gMDtcbiAgfVxuXG4gIGlmKCBhY2Nlc3NfdG9rZW4gJiYgISgnQXV0aG9yaXphdGlvbicgaW4gcmVhbEhlYWRlcnMpKSB7XG4gICAgaWYoICEgcGFyc2VkVXJsLnF1ZXJ5ICkgcGFyc2VkVXJsLnF1ZXJ5PSB7fTtcbiAgICBwYXJzZWRVcmwucXVlcnlbdGhpcy5fYWNjZXNzVG9rZW5OYW1lXT0gYWNjZXNzX3Rva2VuO1xuICB9XG5cbiAgdmFyIHF1ZXJ5U3RyPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkocGFyc2VkVXJsLnF1ZXJ5KTtcbiAgaWYoIHF1ZXJ5U3RyICkgcXVlcnlTdHI9ICBcIj9cIiArIHF1ZXJ5U3RyO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBob3N0OnBhcnNlZFVybC5ob3N0bmFtZSxcbiAgICBwb3J0OiBwYXJzZWRVcmwucG9ydCxcbiAgICBwYXRoOiBwYXJzZWRVcmwucGF0aG5hbWUgKyBxdWVyeVN0cixcbiAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICBoZWFkZXJzOiByZWFsSGVhZGVyc1xuICB9O1xuXG4gIHRoaXMuX2V4ZWN1dGVSZXF1ZXN0KCBodHRwX2xpYnJhcnksIG9wdGlvbnMsIHBvc3RfYm9keSwgY2FsbGJhY2sgKTtcbn1cblxuZXhwb3J0cy5PQXV0aDIucHJvdG90eXBlLl9leGVjdXRlUmVxdWVzdD0gZnVuY3Rpb24oIGh0dHBfbGlicmFyeSwgb3B0aW9ucywgcG9zdF9ib2R5LCBjYWxsYmFjayApIHtcbiAgLy8gU29tZSBob3N0cyAqY291Z2gqIGdvb2dsZSBhcHBlYXIgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24gZWFybHkgLyBzZW5kIG5vIGNvbnRlbnQtbGVuZ3RoIGhlYWRlclxuICAvLyBhbGxvdyB0aGlzIGJlaGF2aW91ci5cbiAgdmFyIGFsbG93RWFybHlDbG9zZT0gT0F1dGhVdGlscy5pc0FuRWFybHlDbG9zZUhvc3Qob3B0aW9ucy5ob3N0KTtcbiAgdmFyIGNhbGxiYWNrQ2FsbGVkPSBmYWxzZTtcbiAgZnVuY3Rpb24gcGFzc0JhY2tDb250cm9sKCByZXNwb25zZSwgcmVzdWx0ICkge1xuICAgIGlmKCFjYWxsYmFja0NhbGxlZCkge1xuICAgICAgY2FsbGJhY2tDYWxsZWQ9dHJ1ZTtcbiAgICAgIGlmKCAhKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPD0gMjk5KSAmJiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPSAzMDEpICYmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9IDMwMikgKSB7XG4gICAgICAgIGNhbGxiYWNrKHsgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzQ29kZSwgZGF0YTogcmVzdWx0IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0LCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdD0gXCJcIjtcblxuICAvL3NldCB0aGUgYWdlbnQgb24gdGhlIHJlcXVlc3Qgb3B0aW9uc1xuICBpZiAodGhpcy5fYWdlbnQpIHtcbiAgICBvcHRpb25zLmFnZW50ID0gdGhpcy5fYWdlbnQ7XG4gIH1cblxuICB2YXIgcmVxdWVzdCA9IGh0dHBfbGlicmFyeS5yZXF1ZXN0KG9wdGlvbnMpO1xuICByZXF1ZXN0Lm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgIHJlc3BvbnNlLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHJlc3VsdCs9IGNodW5rXG4gICAgfSk7XG4gICAgcmVzcG9uc2Uub24oXCJjbG9zZVwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiggYWxsb3dFYXJseUNsb3NlICkge1xuICAgICAgICBwYXNzQmFja0NvbnRyb2woIHJlc3BvbnNlLCByZXN1bHQgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXNwb25zZS5hZGRMaXN0ZW5lcihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBwYXNzQmFja0NvbnRyb2woIHJlc3BvbnNlLCByZXN1bHQgKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJlcXVlc3Qub24oJ2Vycm9yJywgZnVuY3Rpb24oZSkge1xuICAgIGNhbGxiYWNrQ2FsbGVkPSB0cnVlO1xuICAgIGNhbGxiYWNrKGUpO1xuICB9KTtcblxuICBpZiggKG9wdGlvbnMubWV0aG9kID09ICdQT1NUJyB8fCBvcHRpb25zLm1ldGhvZCA9PSAnUFVUJykgJiYgcG9zdF9ib2R5ICkge1xuICAgICByZXF1ZXN0LndyaXRlKHBvc3RfYm9keSk7XG4gIH1cbiAgcmVxdWVzdC5lbmQoKTtcbn1cblxuZXhwb3J0cy5PQXV0aDIucHJvdG90eXBlLmdldEF1dGhvcml6ZVVybD0gZnVuY3Rpb24oIHBhcmFtcyApIHtcbiAgdmFyIHBhcmFtcz0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXNbJ2NsaWVudF9pZCddID0gdGhpcy5fY2xpZW50SWQ7XG4gIHJldHVybiB0aGlzLl9iYXNlU2l0ZSArIHRoaXMuX2F1dGhvcml6ZVVybCArIFwiP1wiICsgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHBhcmFtcyk7XG59XG5cbmV4cG9ydHMuT0F1dGgyLnByb3RvdHlwZS5nZXRPQXV0aEFjY2Vzc1Rva2VuPSBmdW5jdGlvbihjb2RlLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciBwYXJhbXM9IHBhcmFtcyB8fCB7fTtcbiAgcGFyYW1zWydjbGllbnRfaWQnXSA9IHRoaXMuX2NsaWVudElkO1xuICBwYXJhbXNbJ2NsaWVudF9zZWNyZXQnXSA9IHRoaXMuX2NsaWVudFNlY3JldDtcbiAgdmFyIGNvZGVQYXJhbSA9IChwYXJhbXMuZ3JhbnRfdHlwZSA9PT0gJ3JlZnJlc2hfdG9rZW4nKSA/ICdyZWZyZXNoX3Rva2VuJyA6ICdjb2RlJztcbiAgcGFyYW1zW2NvZGVQYXJhbV09IGNvZGU7XG5cbiAgdmFyIHBvc3RfZGF0YT0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KCBwYXJhbXMgKTtcbiAgdmFyIHBvc3RfaGVhZGVycz0ge1xuICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgfTtcblxuXG4gIHRoaXMuX3JlcXVlc3QoXCJQT1NUXCIsIHRoaXMuX2dldEFjY2Vzc1Rva2VuVXJsKCksIHBvc3RfaGVhZGVycywgcG9zdF9kYXRhLCBudWxsLCBmdW5jdGlvbihlcnJvciwgZGF0YSwgcmVzcG9uc2UpIHtcbiAgICBpZiggZXJyb3IgKSAgY2FsbGJhY2soZXJyb3IpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdHM7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBBcyBvZiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW9hdXRoLXYyLTA3XG4gICAgICAgIC8vIHJlc3BvbnNlcyBzaG91bGQgYmUgaW4gSlNPTlxuICAgICAgICByZXN1bHRzPSBKU09OLnBhcnNlKCBkYXRhICk7XG4gICAgICB9XG4gICAgICBjYXRjaChlKSB7XG4gICAgICAgIC8vIC4uLi4gSG93ZXZlciBib3RoIEZhY2Vib29rICsgR2l0aHViIGN1cnJlbnRseSB1c2UgcmV2MDUgb2YgdGhlIHNwZWNcbiAgICAgICAgLy8gYW5kIG5laXRoZXIgc2VlbSB0byBzcGVjaWZ5IGEgY29udGVudC10eXBlIGNvcnJlY3RseSBpbiB0aGVpciByZXNwb25zZSBoZWFkZXJzIDooXG4gICAgICAgIC8vIGNsaWVudHMgb2YgdGhlc2Ugc2VydmljZXMgd2lsbCBzdWZmZXIgYSAqbWlub3IqIHBlcmZvcm1hbmNlIGNvc3Qgb2YgdGhlIGV4Y2VwdGlvblxuICAgICAgICAvLyBiZWluZyB0aHJvd25cbiAgICAgICAgcmVzdWx0cz0gcXVlcnlzdHJpbmcucGFyc2UoIGRhdGEgKTtcbiAgICAgIH1cbiAgICAgIHZhciBhY2Nlc3NfdG9rZW49IHJlc3VsdHNbXCJhY2Nlc3NfdG9rZW5cIl07XG4gICAgICB2YXIgcmVmcmVzaF90b2tlbj0gcmVzdWx0c1tcInJlZnJlc2hfdG9rZW5cIl07XG4gICAgICBkZWxldGUgcmVzdWx0c1tcInJlZnJlc2hfdG9rZW5cIl07XG4gICAgICBjYWxsYmFjayhudWxsLCBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4sIHJlc3VsdHMpOyAvLyBjYWxsYmFjayByZXN1bHRzID0tPVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIERlcHJlY2F0ZWRcbmV4cG9ydHMuT0F1dGgyLnByb3RvdHlwZS5nZXRQcm90ZWN0ZWRSZXNvdXJjZT0gZnVuY3Rpb24odXJsLCBhY2Nlc3NfdG9rZW4sIGNhbGxiYWNrKSB7XG4gIHRoaXMuX3JlcXVlc3QoXCJHRVRcIiwgdXJsLCB7fSwgXCJcIiwgYWNjZXNzX3Rva2VuLCBjYWxsYmFjayApO1xufVxuXG5leHBvcnRzLk9BdXRoMi5wcm90b3R5cGUuZ2V0PSBmdW5jdGlvbih1cmwsIGFjY2Vzc190b2tlbiwgY2FsbGJhY2spIHtcbiAgaWYoIHRoaXMuX3VzZUF1dGhvcml6YXRpb25IZWFkZXJGb3JHRVQgKSB7XG4gICAgdmFyIGhlYWRlcnM9IHsnQXV0aG9yaXphdGlvbic6IHRoaXMuYnVpbGRBdXRoSGVhZGVyKGFjY2Vzc190b2tlbikgfVxuICAgIGFjY2Vzc190b2tlbj0gbnVsbDtcbiAgfVxuICBlbHNlIHtcbiAgICBoZWFkZXJzPSB7fTtcbiAgfVxuICB0aGlzLl9yZXF1ZXN0KFwiR0VUXCIsIHVybCwgaGVhZGVycywgXCJcIiwgYWNjZXNzX3Rva2VuLCBjYWxsYmFjayApO1xufVxuIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMVxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbi8qXG4gKiBDb25maWd1cmFibGUgdmFyaWFibGVzLiBZb3UgbWF5IG5lZWQgdG8gdHdlYWsgdGhlc2UgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gKiB0aGUgc2VydmVyLXNpZGUsIGJ1dCB0aGUgZGVmYXVsdHMgd29yayBpbiBtb3N0IGNhc2VzLlxuICovXG52YXIgaGV4Y2FzZSA9IDE7ICAvKiBoZXggb3V0cHV0IGZvcm1hdC4gMCAtIGxvd2VyY2FzZTsgMSAtIHVwcGVyY2FzZSAgICAgICAgKi9cbnZhciBiNjRwYWQgID0gXCI9XCI7IC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gXCI9XCIgZm9yIHN0cmljdCBSRkMgY29tcGxpYW5jZSAgICovXG5cbi8qXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcbiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5mdW5jdGlvbiBoZXhfc2hhMShzKSAgICB7IHJldHVybiByc3RyMmhleChyc3RyX3NoYTEoc3RyMnJzdHJfdXRmOChzKSkpOyB9XG5mdW5jdGlvbiBiNjRfc2hhMShzKSAgICB7IHJldHVybiByc3RyMmI2NChyc3RyX3NoYTEoc3RyMnJzdHJfdXRmOChzKSkpOyB9XG5mdW5jdGlvbiBhbnlfc2hhMShzLCBlKSB7IHJldHVybiByc3RyMmFueShyc3RyX3NoYTEoc3RyMnJzdHJfdXRmOChzKSksIGUpOyB9XG5mdW5jdGlvbiBoZXhfaG1hY19zaGExKGssIGQpXG4gIHsgcmV0dXJuIHJzdHIyaGV4KHJzdHJfaG1hY19zaGExKHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpKTsgfVxuZnVuY3Rpb24gYjY0X2htYWNfc2hhMShrLCBkKVxuICB7IHJldHVybiByc3RyMmI2NChyc3RyX2htYWNfc2hhMShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSk7IH1cbmZ1bmN0aW9uIGFueV9obWFjX3NoYTEoaywgZCwgZSlcbiAgeyByZXR1cm4gcnN0cjJhbnkocnN0cl9obWFjX3NoYTEoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSksIGUpOyB9XG5cbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcbiAqL1xuZnVuY3Rpb24gc2hhMV92bV90ZXN0KClcbntcbiAgcmV0dXJuIGhleF9zaGExKFwiYWJjXCIpLnRvTG93ZXJDYXNlKCkgPT0gXCJhOTk5M2UzNjQ3MDY4MTZhYmEzZTI1NzE3ODUwYzI2YzljZDBkODlkXCI7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIFNIQTEgb2YgYSByYXcgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHJfc2hhMShzKVxue1xuICByZXR1cm4gYmluYjJyc3RyKGJpbmJfc2hhMShyc3RyMmJpbmIocyksIHMubGVuZ3RoICogOCkpO1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBITUFDLVNIQTEgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YSAocmF3IHN0cmluZ3MpXG4gKi9cbmZ1bmN0aW9uIHJzdHJfaG1hY19zaGExKGtleSwgZGF0YSlcbntcbiAgdmFyIGJrZXkgPSByc3RyMmJpbmIoa2V5KTtcbiAgaWYoYmtleS5sZW5ndGggPiAxNikgYmtleSA9IGJpbmJfc2hhMShia2V5LCBrZXkubGVuZ3RoICogOCk7XG5cbiAgdmFyIGlwYWQgPSBBcnJheSgxNiksIG9wYWQgPSBBcnJheSgxNik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICB7XG4gICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1QztcbiAgfVxuXG4gIHZhciBoYXNoID0gYmluYl9zaGExKGlwYWQuY29uY2F0KHJzdHIyYmluYihkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogOCk7XG4gIHJldHVybiBiaW5iMnJzdHIoYmluYl9zaGExKG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxNjApKTtcbn1cblxuLypcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiByc3RyMmhleChpbnB1dClcbntcbiAgdHJ5IHsgaGV4Y2FzZSB9IGNhdGNoKGUpIHsgaGV4Y2FzZT0wOyB9XG4gIHZhciBoZXhfdGFiID0gaGV4Y2FzZSA/IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiIDogXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICB2YXIgeDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKVxuICB7XG4gICAgeCA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgb3V0cHV0ICs9IGhleF90YWIuY2hhckF0KCh4ID4+PiA0KSAmIDB4MEYpXG4gICAgICAgICAgICsgIGhleF90YWIuY2hhckF0KCB4ICAgICAgICAmIDB4MEYpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhIGJhc2UtNjQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYjY0KGlucHV0KVxue1xuICB0cnkgeyBiNjRwYWQgfSBjYXRjaChlKSB7IGI2NHBhZD0nJzsgfVxuICB2YXIgdGFiID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICB2YXIgbGVuID0gaW5wdXQubGVuZ3RoO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpXG4gIHtcbiAgICB2YXIgdHJpcGxldCA9IChpbnB1dC5jaGFyQ29kZUF0KGkpIDw8IDE2KVxuICAgICAgICAgICAgICAgIHwgKGkgKyAxIDwgbGVuID8gaW5wdXQuY2hhckNvZGVBdChpKzEpIDw8IDggOiAwKVxuICAgICAgICAgICAgICAgIHwgKGkgKyAyIDwgbGVuID8gaW5wdXQuY2hhckNvZGVBdChpKzIpICAgICAgOiAwKTtcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgNDsgaisrKVxuICAgIHtcbiAgICAgIGlmKGkgKiA4ICsgaiAqIDYgPiBpbnB1dC5sZW5ndGggKiA4KSBvdXRwdXQgKz0gYjY0cGFkO1xuICAgICAgZWxzZSBvdXRwdXQgKz0gdGFiLmNoYXJBdCgodHJpcGxldCA+Pj4gNiooMy1qKSkgJiAweDNGKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFyYml0cmFyeSBzdHJpbmcgZW5jb2RpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cjJhbnkoaW5wdXQsIGVuY29kaW5nKVxue1xuICB2YXIgZGl2aXNvciA9IGVuY29kaW5nLmxlbmd0aDtcbiAgdmFyIHJlbWFpbmRlcnMgPSBBcnJheSgpO1xuICB2YXIgaSwgcSwgeCwgcXVvdGllbnQ7XG5cbiAgLyogQ29udmVydCB0byBhbiBhcnJheSBvZiAxNi1iaXQgYmlnLWVuZGlhbiB2YWx1ZXMsIGZvcm1pbmcgdGhlIGRpdmlkZW5kICovXG4gIHZhciBkaXZpZGVuZCA9IEFycmF5KE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyAyKSk7XG4gIGZvcihpID0gMDsgaSA8IGRpdmlkZW5kLmxlbmd0aDsgaSsrKVxuICB7XG4gICAgZGl2aWRlbmRbaV0gPSAoaW5wdXQuY2hhckNvZGVBdChpICogMikgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XG4gIH1cblxuICAvKlxuICAgKiBSZXBlYXRlZGx5IHBlcmZvcm0gYSBsb25nIGRpdmlzaW9uLiBUaGUgYmluYXJ5IGFycmF5IGZvcm1zIHRoZSBkaXZpZGVuZCxcbiAgICogdGhlIGxlbmd0aCBvZiB0aGUgZW5jb2RpbmcgaXMgdGhlIGRpdmlzb3IuIE9uY2UgY29tcHV0ZWQsIHRoZSBxdW90aWVudFxuICAgKiBmb3JtcyB0aGUgZGl2aWRlbmQgZm9yIHRoZSBuZXh0IHN0ZXAuIFdlIHN0b3Agd2hlbiB0aGUgZGl2aWRlbmQgaXMgemVyby5cbiAgICogQWxsIHJlbWFpbmRlcnMgYXJlIHN0b3JlZCBmb3IgbGF0ZXIgdXNlLlxuICAgKi9cbiAgd2hpbGUoZGl2aWRlbmQubGVuZ3RoID4gMClcbiAge1xuICAgIHF1b3RpZW50ID0gQXJyYXkoKTtcbiAgICB4ID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkaXZpZGVuZC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICB4ID0gKHggPDwgMTYpICsgZGl2aWRlbmRbaV07XG4gICAgICBxID0gTWF0aC5mbG9vcih4IC8gZGl2aXNvcik7XG4gICAgICB4IC09IHEgKiBkaXZpc29yO1xuICAgICAgaWYocXVvdGllbnQubGVuZ3RoID4gMCB8fCBxID4gMClcbiAgICAgICAgcXVvdGllbnRbcXVvdGllbnQubGVuZ3RoXSA9IHE7XG4gICAgfVxuICAgIHJlbWFpbmRlcnNbcmVtYWluZGVycy5sZW5ndGhdID0geDtcbiAgICBkaXZpZGVuZCA9IHF1b3RpZW50O1xuICB9XG5cbiAgLyogQ29udmVydCB0aGUgcmVtYWluZGVycyB0byB0aGUgb3V0cHV0IHN0cmluZyAqL1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKGkgPSByZW1haW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIG91dHB1dCArPSBlbmNvZGluZy5jaGFyQXQocmVtYWluZGVyc1tpXSk7XG5cbiAgLyogQXBwZW5kIGxlYWRpbmcgemVybyBlcXVpdmFsZW50cyAqL1xuICB2YXIgZnVsbF9sZW5ndGggPSBNYXRoLmNlaWwoaW5wdXQubGVuZ3RoICogOCAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoTWF0aC5sb2coZW5jb2RpbmcubGVuZ3RoKSAvIE1hdGgubG9nKDIpKSlcbiAgZm9yKGkgPSBvdXRwdXQubGVuZ3RoOyBpIDwgZnVsbF9sZW5ndGg7IGkrKylcbiAgICBvdXRwdXQgPSBlbmNvZGluZ1swXSArIG91dHB1dDtcblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi04LlxuICogRm9yIGVmZmljaWVuY3ksIHRoaXMgYXNzdW1lcyB0aGUgaW5wdXQgaXMgdmFsaWQgdXRmLTE2LlxuICovXG5mdW5jdGlvbiBzdHIycnN0cl91dGY4KGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHgsIHk7XG5cbiAgd2hpbGUoKytpIDwgaW5wdXQubGVuZ3RoKVxuICB7XG4gICAgLyogRGVjb2RlIHV0Zi0xNiBzdXJyb2dhdGUgcGFpcnMgKi9cbiAgICB4ID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICB5ID0gaSArIDEgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQ29kZUF0KGkgKyAxKSA6IDA7XG4gICAgaWYoMHhEODAwIDw9IHggJiYgeCA8PSAweERCRkYgJiYgMHhEQzAwIDw9IHkgJiYgeSA8PSAweERGRkYpXG4gICAge1xuICAgICAgeCA9IDB4MTAwMDAgKyAoKHggJiAweDAzRkYpIDw8IDEwKSArICh5ICYgMHgwM0ZGKTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvKiBFbmNvZGUgb3V0cHV0IGFzIHV0Zi04ICovXG4gICAgaWYoeCA8PSAweDdGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gICAgZWxzZSBpZih4IDw9IDB4N0ZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhDMCB8ICgoeCA+Pj4gNiApICYgMHgxRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gICAgZWxzZSBpZih4IDw9IDB4RkZGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RTAgfCAoKHggPj4+IDEyKSAmIDB4MEYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gNiApICYgMHgzRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gICAgZWxzZSBpZih4IDw9IDB4MUZGRkZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGMCB8ICgoeCA+Pj4gMTgpICYgMHgwNyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiAxMikgJiAweDNGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDYgKSAmIDB4M0YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBFbmNvZGUgYSBzdHJpbmcgYXMgdXRmLTE2XG4gKi9cbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjE2bGUoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGlucHV0LmNoYXJDb2RlQXQoaSkgICAgICAgICYgMHhGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gc3RyMnJzdHJfdXRmMTZiZShpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYmluYihpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IEFycmF5KGlucHV0Lmxlbmd0aCA+PiAyKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXRbaV0gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogODsgaSArPSA4KVxuICAgIG91dHB1dFtpPj41XSB8PSAoaW5wdXQuY2hhckNvZGVBdChpIC8gOCkgJiAweEZGKSA8PCAoMjQgLSBpICUgMzIpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGJpbmIycnN0cihpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiAzMjsgaSArPSA4KVxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dFtpPj41XSA+Pj4gKDI0IC0gaSAlIDMyKSkgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgU0hBLTEgb2YgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxuICovXG5mdW5jdGlvbiBiaW5iX3NoYTEoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgeFsoKGxlbiArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbGVuO1xuXG4gIHZhciB3ID0gQXJyYXkoODApO1xuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcbiAgdmFyIGUgPSAtMTAwOTU4OTc3NjtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG4gICAgdmFyIG9sZGUgPSBlO1xuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDgwOyBqKyspXG4gICAge1xuICAgICAgaWYoaiA8IDE2KSB3W2pdID0geFtpICsgal07XG4gICAgICBlbHNlIHdbal0gPSBiaXRfcm9sKHdbai0zXSBeIHdbai04XSBeIHdbai0xNF0gXiB3W2otMTZdLCAxKTtcbiAgICAgIHZhciB0ID0gc2FmZV9hZGQoc2FmZV9hZGQoYml0X3JvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXG4gICAgICAgICAgICAgICAgICAgICAgIHNhZmVfYWRkKHNhZmVfYWRkKGUsIHdbal0pLCBzaGExX2t0KGopKSk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IGJpdF9yb2woYiwgMzApO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gICAgZSA9IHNhZmVfYWRkKGUsIG9sZGUpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkLCBlKTtcblxufVxuXG4vKlxuICogUGVyZm9ybSB0aGUgYXBwcm9wcmlhdGUgdHJpcGxldCBjb21iaW5hdGlvbiBmdW5jdGlvbiBmb3IgdGhlIGN1cnJlbnRcbiAqIGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBzaGExX2Z0KHQsIGIsIGMsIGQpXG57XG4gIGlmKHQgPCAyMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpO1xuICBpZih0IDwgNDApIHJldHVybiBiIF4gYyBeIGQ7XG4gIGlmKHQgPCA2MCkgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcbiAgcmV0dXJuIGIgXiBjIF4gZDtcbn1cblxuLypcbiAqIERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgYWRkaXRpdmUgY29uc3RhbnQgZm9yIHRoZSBjdXJyZW50IGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBzaGExX2t0KHQpXG57XG4gIHJldHVybiAodCA8IDIwKSA/ICAxNTE4NTAwMjQ5IDogKHQgPCA0MCkgPyAgMTg1OTc3NTM5MyA6XG4gICAgICAgICAodCA8IDYwKSA/IC0xODk0MDA3NTg4IDogLTg5OTQ5NzUxNDtcbn1cblxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpXG57XG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG59XG5cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGJpdF9yb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxuZXhwb3J0cy5ITUFDU0hBMT0gZnVuY3Rpb24oa2V5LCBkYXRhKSB7XG4gIHJldHVybiBiNjRfaG1hY19zaGExKGtleSwgZGF0YSk7XG59IiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIGdldE5hbm9TZWNvbmRzLCBocnRpbWUsIGxvYWRUaW1lLCBtb2R1bGVMb2FkVGltZSwgbm9kZUxvYWRUaW1lLCB1cFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbm9kZUxvYWRUaW1lKSAvIDFlNjtcbiAgICB9O1xuICAgIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgIGdldE5hbm9TZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGhydGltZSgpO1xuICAgICAgcmV0dXJuIGhyWzBdICogMWU5ICsgaHJbMV07XG4gICAgfTtcbiAgICBtb2R1bGVMb2FkVGltZSA9IGdldE5hbm9TZWNvbmRzKCk7XG4gICAgdXBUaW1lID0gcHJvY2Vzcy51cHRpbWUoKSAqIDFlOTtcbiAgICBub2RlTG9hZFRpbWUgPSBtb2R1bGVMb2FkVGltZSAtIHVwVGltZTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyZm9ybWFuY2Utbm93LmpzLm1hcFxuIiwiLyplc2xpbnQgbm8tdmFyOjAsIHByZWZlci1hcnJvdy1jYWxsYmFjazogMCwgb2JqZWN0LXNob3J0aGFuZDogMCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBQdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGludGVybmFscyA9IHt9O1xuXG5cbi8vXG4vLyBSZWFkIHJ1bGVzIGZyb20gZmlsZS5cbi8vXG5pbnRlcm5hbHMucnVsZXMgPSByZXF1aXJlKCcuL2RhdGEvcnVsZXMuanNvbicpLm1hcChmdW5jdGlvbiAocnVsZSkge1xuXG4gIHJldHVybiB7XG4gICAgcnVsZTogcnVsZSxcbiAgICBzdWZmaXg6IHJ1bGUucmVwbGFjZSgvXihcXCpcXC58XFwhKS8sICcnKSxcbiAgICBwdW55U3VmZml4OiAtMSxcbiAgICB3aWxkY2FyZDogcnVsZS5jaGFyQXQoMCkgPT09ICcqJyxcbiAgICBleGNlcHRpb246IHJ1bGUuY2hhckF0KDApID09PSAnISdcbiAgfTtcbn0pO1xuXG5cbi8vXG4vLyBDaGVjayBpcyBnaXZlbiBzdHJpbmcgZW5kcyB3aXRoIGBzdWZmaXhgLlxuLy9cbmludGVybmFscy5lbmRzV2l0aCA9IGZ1bmN0aW9uIChzdHIsIHN1ZmZpeCkge1xuXG4gIHJldHVybiBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG59O1xuXG5cbi8vXG4vLyBGaW5kIHJ1bGUgZm9yIGEgZ2l2ZW4gZG9tYWluLlxuLy9cbmludGVybmFscy5maW5kUnVsZSA9IGZ1bmN0aW9uIChkb21haW4pIHtcblxuICB2YXIgcHVueURvbWFpbiA9IFB1bnljb2RlLnRvQVNDSUkoZG9tYWluKTtcbiAgcmV0dXJuIGludGVybmFscy5ydWxlcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIHJ1bGUpIHtcblxuICAgIGlmIChydWxlLnB1bnlTdWZmaXggPT09IC0xKXtcbiAgICAgIHJ1bGUucHVueVN1ZmZpeCA9IFB1bnljb2RlLnRvQVNDSUkocnVsZS5zdWZmaXgpO1xuICAgIH1cbiAgICBpZiAoIWludGVybmFscy5lbmRzV2l0aChwdW55RG9tYWluLCAnLicgKyBydWxlLnB1bnlTdWZmaXgpICYmIHB1bnlEb21haW4gIT09IHJ1bGUucHVueVN1ZmZpeCkge1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuICAgIC8vIFRoaXMgaGFzIGJlZW4gY29tbWVudGVkIG91dCBhcyBpdCBuZXZlciBzZWVtcyB0byBydW4uIFRoaXMgaXMgYmVjYXVzZVxuICAgIC8vIHN1YiB0bGRzIGFsd2F5cyBhcHBlYXIgYWZ0ZXIgdGhlaXIgcGFyZW50cyBhbmQgd2UgbmV2ZXIgZmluZCBhIHNob3J0ZXJcbiAgICAvLyBtYXRjaC5cbiAgICAvL2lmIChtZW1vKSB7XG4gICAgLy8gIHZhciBtZW1vU3VmZml4ID0gUHVueWNvZGUudG9BU0NJSShtZW1vLnN1ZmZpeCk7XG4gICAgLy8gIGlmIChtZW1vU3VmZml4Lmxlbmd0aCA+PSBwdW55U3VmZml4Lmxlbmd0aCkge1xuICAgIC8vICAgIHJldHVybiBtZW1vO1xuICAgIC8vICB9XG4gICAgLy99XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH0sIG51bGwpO1xufTtcblxuXG4vL1xuLy8gRXJyb3IgY29kZXMgYW5kIG1lc3NhZ2VzLlxuLy9cbmV4cG9ydHMuZXJyb3JDb2RlcyA9IHtcbiAgRE9NQUlOX1RPT19TSE9SVDogJ0RvbWFpbiBuYW1lIHRvbyBzaG9ydC4nLFxuICBET01BSU5fVE9PX0xPTkc6ICdEb21haW4gbmFtZSB0b28gbG9uZy4gSXQgc2hvdWxkIGJlIG5vIG1vcmUgdGhhbiAyNTUgY2hhcnMuJyxcbiAgTEFCRUxfU1RBUlRTX1dJVEhfREFTSDogJ0RvbWFpbiBuYW1lIGxhYmVsIGNhbiBub3Qgc3RhcnQgd2l0aCBhIGRhc2guJyxcbiAgTEFCRUxfRU5EU19XSVRIX0RBU0g6ICdEb21haW4gbmFtZSBsYWJlbCBjYW4gbm90IGVuZCB3aXRoIGEgZGFzaC4nLFxuICBMQUJFTF9UT09fTE9ORzogJ0RvbWFpbiBuYW1lIGxhYmVsIHNob3VsZCBiZSBhdCBtb3N0IDYzIGNoYXJzIGxvbmcuJyxcbiAgTEFCRUxfVE9PX1NIT1JUOiAnRG9tYWluIG5hbWUgbGFiZWwgc2hvdWxkIGJlIGF0IGxlYXN0IDEgY2hhcmFjdGVyIGxvbmcuJyxcbiAgTEFCRUxfSU5WQUxJRF9DSEFSUzogJ0RvbWFpbiBuYW1lIGxhYmVsIGNhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgb3IgZGFzaGVzLidcbn07XG5cblxuLy9cbi8vIFZhbGlkYXRlIGRvbWFpbiBuYW1lIGFuZCB0aHJvdyBpZiBub3QgdmFsaWQuXG4vL1xuLy8gRnJvbSB3aWtpcGVkaWE6XG4vL1xuLy8gSG9zdG5hbWVzIGFyZSBjb21wb3NlZCBvZiBzZXJpZXMgb2YgbGFiZWxzIGNvbmNhdGVuYXRlZCB3aXRoIGRvdHMsIGFzIGFyZSBhbGxcbi8vIGRvbWFpbiBuYW1lcy4gRWFjaCBsYWJlbCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNjMgY2hhcmFjdGVycyBsb25nLCBhbmQgdGhlXG4vLyBlbnRpcmUgaG9zdG5hbWUgKGluY2x1ZGluZyB0aGUgZGVsaW1pdGluZyBkb3RzKSBoYXMgYSBtYXhpbXVtIG9mIDI1NSBjaGFycy5cbi8vXG4vLyBBbGxvd2VkIGNoYXJzOlxuLy9cbi8vICogYGEtemBcbi8vICogYDAtOWBcbi8vICogYC1gIGJ1dCBub3QgYXMgYSBzdGFydGluZyBvciBlbmRpbmcgY2hhcmFjdGVyXG4vLyAqIGAuYCBhcyBhIHNlcGFyYXRvciBmb3IgdGhlIHRleHR1YWwgcG9ydGlvbnMgb2YgYSBkb21haW4gbmFtZVxuLy9cbi8vICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb21haW5fbmFtZVxuLy8gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hvc3RuYW1lXG4vL1xuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cbiAgLy8gQmVmb3JlIHdlIGNhbiB2YWxpZGF0ZSB3ZSBuZWVkIHRvIHRha2UgY2FyZSBvZiBJRE5zIHdpdGggdW5pY29kZSBjaGFycy5cbiAgdmFyIGFzY2lpID0gUHVueWNvZGUudG9BU0NJSShpbnB1dCk7XG5cbiAgaWYgKGFzY2lpLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gJ0RPTUFJTl9UT09fU0hPUlQnO1xuICB9XG4gIGlmIChhc2NpaS5sZW5ndGggPiAyNTUpIHtcbiAgICByZXR1cm4gJ0RPTUFJTl9UT09fTE9ORyc7XG4gIH1cblxuICAvLyBDaGVjayBlYWNoIHBhcnQncyBsZW5ndGggYW5kIGFsbG93ZWQgY2hhcnMuXG4gIHZhciBsYWJlbHMgPSBhc2NpaS5zcGxpdCgnLicpO1xuICB2YXIgbGFiZWw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICBpZiAoIWxhYmVsLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICdMQUJFTF9UT09fU0hPUlQnO1xuICAgIH1cbiAgICBpZiAobGFiZWwubGVuZ3RoID4gNjMpIHtcbiAgICAgIHJldHVybiAnTEFCRUxfVE9PX0xPTkcnO1xuICAgIH1cbiAgICBpZiAobGFiZWwuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgIHJldHVybiAnTEFCRUxfU1RBUlRTX1dJVEhfREFTSCc7XG4gICAgfVxuICAgIGlmIChsYWJlbC5jaGFyQXQobGFiZWwubGVuZ3RoIC0gMSkgPT09ICctJykge1xuICAgICAgcmV0dXJuICdMQUJFTF9FTkRTX1dJVEhfREFTSCc7XG4gICAgfVxuICAgIGlmICghL15bYS16MC05XFwtXSskLy50ZXN0KGxhYmVsKSkge1xuICAgICAgcmV0dXJuICdMQUJFTF9JTlZBTElEX0NIQVJTJztcbiAgICB9XG4gIH1cbn07XG5cblxuLy9cbi8vIFB1YmxpYyBBUElcbi8vXG5cblxuLy9cbi8vIFBhcnNlIGRvbWFpbi5cbi8vXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEb21haW4gbmFtZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgLy8gRm9yY2UgZG9tYWluIHRvIGxvd2VyY2FzZS5cbiAgdmFyIGRvbWFpbiA9IGlucHV0LnNsaWNlKDApLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gSGFuZGxlIEZRRE4uXG4gIC8vIFRPRE86IFNpbXBseSByZW1vdmUgdHJhaWxpbmcgZG90P1xuICBpZiAoZG9tYWluLmNoYXJBdChkb21haW4ubGVuZ3RoIC0gMSkgPT09ICcuJykge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgwLCBkb21haW4ubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBhbmQgc2FuaXRpc2UgaW5wdXQuXG4gIHZhciBlcnJvciA9IGludGVybmFscy52YWxpZGF0ZShkb21haW4pO1xuICBpZiAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgZXJyb3I6IHtcbiAgICAgICAgbWVzc2FnZTogZXhwb3J0cy5lcnJvckNvZGVzW2Vycm9yXSxcbiAgICAgICAgY29kZTogZXJyb3JcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIHBhcnNlZCA9IHtcbiAgICBpbnB1dDogaW5wdXQsXG4gICAgdGxkOiBudWxsLFxuICAgIHNsZDogbnVsbCxcbiAgICBkb21haW46IG51bGwsXG4gICAgc3ViZG9tYWluOiBudWxsLFxuICAgIGxpc3RlZDogZmFsc2VcbiAgfTtcblxuICB2YXIgZG9tYWluUGFydHMgPSBkb21haW4uc3BsaXQoJy4nKTtcblxuICAvLyBOb24tSW50ZXJuZXQgVExEXG4gIGlmIChkb21haW5QYXJ0c1tkb21haW5QYXJ0cy5sZW5ndGggLSAxXSA9PT0gJ2xvY2FsJykge1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICB2YXIgaGFuZGxlUHVueWNvZGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIS94bi0tLy50ZXN0KGRvbWFpbikpIHtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGlmIChwYXJzZWQuZG9tYWluKSB7XG4gICAgICBwYXJzZWQuZG9tYWluID0gUHVueWNvZGUudG9BU0NJSShwYXJzZWQuZG9tYWluKTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5zdWJkb21haW4pIHtcbiAgICAgIHBhcnNlZC5zdWJkb21haW4gPSBQdW55Y29kZS50b0FTQ0lJKHBhcnNlZC5zdWJkb21haW4pO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9O1xuXG4gIHZhciBydWxlID0gaW50ZXJuYWxzLmZpbmRSdWxlKGRvbWFpbik7XG5cbiAgLy8gVW5saXN0ZWQgdGxkLlxuICBpZiAoIXJ1bGUpIHtcbiAgICBpZiAoZG9tYWluUGFydHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgcGFyc2VkLnRsZCA9IGRvbWFpblBhcnRzLnBvcCgpO1xuICAgIHBhcnNlZC5zbGQgPSBkb21haW5QYXJ0cy5wb3AoKTtcbiAgICBwYXJzZWQuZG9tYWluID0gW3BhcnNlZC5zbGQsIHBhcnNlZC50bGRdLmpvaW4oJy4nKTtcbiAgICBpZiAoZG9tYWluUGFydHMubGVuZ3RoKSB7XG4gICAgICBwYXJzZWQuc3ViZG9tYWluID0gZG9tYWluUGFydHMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVQdW55Y29kZSgpO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBrbm93IHRoZSBwdWJsaWMgc3VmZml4IGlzIGxpc3RlZC5cbiAgcGFyc2VkLmxpc3RlZCA9IHRydWU7XG5cbiAgdmFyIHRsZFBhcnRzID0gcnVsZS5zdWZmaXguc3BsaXQoJy4nKTtcbiAgdmFyIHByaXZhdGVQYXJ0cyA9IGRvbWFpblBhcnRzLnNsaWNlKDAsIGRvbWFpblBhcnRzLmxlbmd0aCAtIHRsZFBhcnRzLmxlbmd0aCk7XG5cbiAgaWYgKHJ1bGUuZXhjZXB0aW9uKSB7XG4gICAgcHJpdmF0ZVBhcnRzLnB1c2godGxkUGFydHMuc2hpZnQoKSk7XG4gIH1cblxuICBwYXJzZWQudGxkID0gdGxkUGFydHMuam9pbignLicpO1xuXG4gIGlmICghcHJpdmF0ZVBhcnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBoYW5kbGVQdW55Y29kZSgpO1xuICB9XG5cbiAgaWYgKHJ1bGUud2lsZGNhcmQpIHtcbiAgICB0bGRQYXJ0cy51bnNoaWZ0KHByaXZhdGVQYXJ0cy5wb3AoKSk7XG4gICAgcGFyc2VkLnRsZCA9IHRsZFBhcnRzLmpvaW4oJy4nKTtcbiAgfVxuXG4gIGlmICghcHJpdmF0ZVBhcnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBoYW5kbGVQdW55Y29kZSgpO1xuICB9XG5cbiAgcGFyc2VkLnNsZCA9IHByaXZhdGVQYXJ0cy5wb3AoKTtcbiAgcGFyc2VkLmRvbWFpbiA9IFtwYXJzZWQuc2xkLCAgcGFyc2VkLnRsZF0uam9pbignLicpO1xuXG4gIGlmIChwcml2YXRlUGFydHMubGVuZ3RoKSB7XG4gICAgcGFyc2VkLnN1YmRvbWFpbiA9IHByaXZhdGVQYXJ0cy5qb2luKCcuJyk7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlUHVueWNvZGUoKTtcbn07XG5cblxuLy9cbi8vIEdldCBkb21haW4uXG4vL1xuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAoZG9tYWluKSB7XG5cbiAgaWYgKCFkb21haW4pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZXhwb3J0cy5wYXJzZShkb21haW4pLmRvbWFpbiB8fCBudWxsO1xufTtcblxuXG4vL1xuLy8gQ2hlY2sgd2hldGhlciBkb21haW4gYmVsb25ncyB0byBhIGtub3duIHB1YmxpYyBzdWZmaXguXG4vL1xuZXhwb3J0cy5pc1ZhbGlkID0gZnVuY3Rpb24gKGRvbWFpbikge1xuXG4gIHZhciBwYXJzZWQgPSBleHBvcnRzLnBhcnNlKGRvbWFpbik7XG4gIHJldHVybiBCb29sZWFuKHBhcnNlZC5kb21haW4gJiYgcGFyc2VkLmxpc3RlZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcbnZhciBwZXJjZW50VHdlbnRpZXMgPSAvJTIwL2c7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdkZWZhdWx0JzogJ1JGQzM5ODYnLFxuICAgIGZvcm1hdHRlcnM6IHtcbiAgICAgICAgUkZDMTczODogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZS5jYWxsKHZhbHVlLCBwZXJjZW50VHdlbnRpZXMsICcrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFJGQzM5ODY6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBSRkMxNzM4OiAnUkZDMTczOCcsXG4gICAgUkZDMzk4NjogJ1JGQzM5ODYnXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdHM6IGZvcm1hdHMsXG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcbiAgICBhbGxvd1Byb3RvdHlwZXM6IGZhbHNlLFxuICAgIGFycmF5TGltaXQ6IDIwLFxuICAgIGRlY29kZXI6IHV0aWxzLmRlY29kZSxcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBkZXB0aDogNSxcbiAgICBwYXJhbWV0ZXJMaW1pdDogMTAwMCxcbiAgICBwbGFpbk9iamVjdHM6IGZhbHNlLFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2Vcbn07XG5cbnZhciBwYXJzZVZhbHVlcyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdWYWx1ZXMoc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBjbGVhblN0ciA9IG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPyBzdHIucmVwbGFjZSgvXlxcPy8sICcnKSA6IHN0cjtcbiAgICB2YXIgbGltaXQgPSBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQ7XG4gICAgdmFyIHBhcnRzID0gY2xlYW5TdHIuc3BsaXQob3B0aW9ucy5kZWxpbWl0ZXIsIGxpbWl0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICB2YXIgYnJhY2tldEVxdWFsc1BvcyA9IHBhcnQuaW5kZXhPZignXT0nKTtcbiAgICAgICAgdmFyIHBvcyA9IGJyYWNrZXRFcXVhbHNQb3MgPT09IC0xID8gcGFydC5pbmRleE9mKCc9JykgOiBicmFja2V0RXF1YWxzUG9zICsgMTtcblxuICAgICAgICB2YXIga2V5LCB2YWw7XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydCwgZGVmYXVsdHMuZGVjb2Rlcik7XG4gICAgICAgICAgICB2YWwgPSBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA/IG51bGwgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtleSA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LnNsaWNlKDAsIHBvcyksIGRlZmF1bHRzLmRlY29kZXIpO1xuICAgICAgICAgICAgdmFsID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQuc2xpY2UocG9zICsgMSksIGRlZmF1bHRzLmRlY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gW10uY29uY2F0KG9ialtrZXldKS5jb25jYXQodmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uIChjaGFpbiwgdmFsLCBvcHRpb25zKSB7XG4gICAgdmFyIGxlYWYgPSB2YWw7XG5cbiAgICBmb3IgKHZhciBpID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG9iajtcbiAgICAgICAgdmFyIHJvb3QgPSBjaGFpbltpXTtcblxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJykge1xuICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICBvYmogPSBvYmouY29uY2F0KGxlYWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdC5jaGFyQXQoMCkgPT09ICdbJyAmJiByb290LmNoYXJBdChyb290Lmxlbmd0aCAtIDEpID09PSAnXScgPyByb290LnNsaWNlKDEsIC0xKSA6IHJvb3Q7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjbGVhblJvb3QsIDEwKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhaXNOYU4oaW5kZXgpXG4gICAgICAgICAgICAgICAgJiYgcm9vdCAhPT0gY2xlYW5Sb290XG4gICAgICAgICAgICAgICAgJiYgU3RyaW5nKGluZGV4KSA9PT0gY2xlYW5Sb290XG4gICAgICAgICAgICAgICAgJiYgaW5kZXggPj0gMFxuICAgICAgICAgICAgICAgICYmIChvcHRpb25zLnBhcnNlQXJyYXlzICYmIGluZGV4IDw9IG9wdGlvbnMuYXJyYXlMaW1pdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgICAgICAgIG9ialtpbmRleF0gPSBsZWFmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmpbY2xlYW5Sb290XSA9IGxlYWY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZWFmID0gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiBsZWFmO1xufTtcblxudmFyIHBhcnNlS2V5cyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdLZXlzKGdpdmVuS2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWdpdmVuS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gZG90IG5vdGF0aW9uIHRvIGJyYWNrZXQgbm90YXRpb25cbiAgICB2YXIga2V5ID0gb3B0aW9ucy5hbGxvd0RvdHMgPyBnaXZlbktleS5yZXBsYWNlKC9cXC4oW14uW10rKS9nLCAnWyQxXScpIDogZ2l2ZW5LZXk7XG5cbiAgICAvLyBUaGUgcmVnZXggY2h1bmtzXG5cbiAgICB2YXIgYnJhY2tldHMgPSAvKFxcW1teW1xcXV0qXSkvO1xuICAgIHZhciBjaGlsZCA9IC8oXFxbW15bXFxdXSpdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gYnJhY2tldHMuZXhlYyhrZXkpO1xuICAgIHZhciBwYXJlbnQgPSBzZWdtZW50ID8ga2V5LnNsaWNlKDAsIHNlZ21lbnQuaW5kZXgpIDoga2V5O1xuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgcGxhaW4gb2JqZWN0cywgb3B0aW9uYWxseSBwcmVmaXgga2V5c1xuICAgICAgICAvLyB0aGF0IHdvdWxkIG92ZXJ3cml0ZSBvYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFwcGVuZGluZyB0byB0aGUgYXJyYXkgdW50aWwgd2UgaGl0IGRlcHRoXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKChzZWdtZW50ID0gY2hpbGQuZXhlYyhrZXkpKSAhPT0gbnVsbCAmJiBpIDwgb3B0aW9ucy5kZXB0aCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc2VnbWVudFsxXS5zbGljZSgxLCAtMSkpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBqdXN0IGFkZCB3aGF0ZXZlciBpcyBsZWZ0XG5cbiAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBrZXlzLnB1c2goJ1snICsga2V5LnNsaWNlKHNlZ21lbnQuaW5kZXgpICsgJ10nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgIHZhciBvcHRpb25zID0gb3B0cyA/IHV0aWxzLmFzc2lnbih7fSwgb3B0cykgOiB7fTtcblxuICAgIGlmIChvcHRpb25zLmRlY29kZXIgIT09IG51bGwgJiYgb3B0aW9ucy5kZWNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID09PSB0cnVlO1xuICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gdHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRpb25zLmRlbGltaXRlcikgPyBvcHRpb25zLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcjtcbiAgICBvcHRpb25zLmRlcHRoID0gdHlwZW9mIG9wdGlvbnMuZGVwdGggPT09ICdudW1iZXInID8gb3B0aW9ucy5kZXB0aCA6IGRlZmF1bHRzLmRlcHRoO1xuICAgIG9wdGlvbnMuYXJyYXlMaW1pdCA9IHR5cGVvZiBvcHRpb25zLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0aW9ucy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdDtcbiAgICBvcHRpb25zLnBhcnNlQXJyYXlzID0gb3B0aW9ucy5wYXJzZUFycmF5cyAhPT0gZmFsc2U7XG4gICAgb3B0aW9ucy5kZWNvZGVyID0gdHlwZW9mIG9wdGlvbnMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXI7XG4gICAgb3B0aW9ucy5hbGxvd0RvdHMgPSB0eXBlb2Ygb3B0aW9ucy5hbGxvd0RvdHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuYWxsb3dEb3RzIDogZGVmYXVsdHMuYWxsb3dEb3RzO1xuICAgIG9wdGlvbnMucGxhaW5PYmplY3RzID0gdHlwZW9mIG9wdGlvbnMucGxhaW5PYmplY3RzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnBsYWluT2JqZWN0cyA6IGRlZmF1bHRzLnBsYWluT2JqZWN0cztcbiAgICBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA9IHR5cGVvZiBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMgOiBkZWZhdWx0cy5hbGxvd1Byb3RvdHlwZXM7XG4gICAgb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdDtcbiAgICBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9IHR5cGVvZiBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmc7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH1cblxuICAgIHZhciB0ZW1wT2JqID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zKTtcbiAgICAgICAgb2JqID0gdXRpbHMubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5jb21wYWN0KG9iaik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG52YXIgYXJyYXlQcmVmaXhHZW5lcmF0b3JzID0ge1xuICAgIGJyYWNrZXRzOiBmdW5jdGlvbiBicmFja2V0cyhwcmVmaXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgfSxcbiAgICBpbmRpY2VzOiBmdW5jdGlvbiBpbmRpY2VzKHByZWZpeCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnWycgKyBrZXkgKyAnXSc7XG4gICAgfSxcbiAgICByZXBlYXQ6IGZ1bmN0aW9uIHJlcGVhdChwcmVmaXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG59O1xuXG52YXIgdG9JU08gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGRlZmF1bHRzID0ge1xuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGVuY29kZTogdHJ1ZSxcbiAgICBlbmNvZGVyOiB1dGlscy5lbmNvZGUsXG4gICAgZW5jb2RlVmFsdWVzT25seTogZmFsc2UsXG4gICAgc2VyaWFsaXplRGF0ZTogZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShkYXRlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKGRhdGUpO1xuICAgIH0sXG4gICAgc2tpcE51bGxzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgIG9iamVjdCxcbiAgICBwcmVmaXgsXG4gICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgc2tpcE51bGxzLFxuICAgIGVuY29kZXIsXG4gICAgZmlsdGVyLFxuICAgIHNvcnQsXG4gICAgYWxsb3dEb3RzLFxuICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgZm9ybWF0dGVyLFxuICAgIGVuY29kZVZhbHVlc09ubHlcbikge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIGlmIChzdHJpY3ROdWxsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVyICYmICFlbmNvZGVWYWx1ZXNPbmx5ID8gZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIpIDogcHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IHR5cGVvZiBvYmogPT09ICdib29sZWFuJyB8fCB1dGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4IDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIpO1xuICAgICAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIoa2V5VmFsdWUpICsgJz0nICsgZm9ybWF0dGVyKGVuY29kZXIob2JqLCBkZWZhdWx0cy5lbmNvZGVyKSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZm9ybWF0dGVyKHByZWZpeCkgKyAnPScgKyBmb3JtYXR0ZXIoU3RyaW5nKG9iaikpXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICB2YXIgb2JqS2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBvYmpLZXlzID0gc29ydCA/IGtleXMuc29ydChzb3J0KSA6IGtleXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2ldO1xuXG4gICAgICAgIGlmIChza2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChzdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeChwcmVmaXgsIGtleSksXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgICAgIGVuY29kZXIsXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHlcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChzdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICAgICAgcHJlZml4ICsgKGFsbG93RG90cyA/ICcuJyArIGtleSA6ICdbJyArIGtleSArICddJyksXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgICAgIGVuY29kZXIsXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHlcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0cykge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzID8gdXRpbHMuYXNzaWduKHt9LCBvcHRzKSA6IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZW5jb2RlciAhPT0gbnVsbCAmJiBvcHRpb25zLmVuY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5lbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlbGltaXRlciA9IHR5cGVvZiBvcHRpb25zLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kZWxpbWl0ZXIgOiBvcHRpb25zLmRlbGltaXRlcjtcbiAgICB2YXIgc3RyaWN0TnVsbEhhbmRsaW5nID0gdHlwZW9mIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZztcbiAgICB2YXIgc2tpcE51bGxzID0gdHlwZW9mIG9wdGlvbnMuc2tpcE51bGxzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNraXBOdWxscyA6IGRlZmF1bHRzLnNraXBOdWxscztcbiAgICB2YXIgZW5jb2RlID0gdHlwZW9mIG9wdGlvbnMuZW5jb2RlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmVuY29kZSA6IGRlZmF1bHRzLmVuY29kZTtcbiAgICB2YXIgZW5jb2RlciA9IHR5cGVvZiBvcHRpb25zLmVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmVuY29kZXIgOiBkZWZhdWx0cy5lbmNvZGVyO1xuICAgIHZhciBzb3J0ID0gdHlwZW9mIG9wdGlvbnMuc29ydCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuc29ydCA6IG51bGw7XG4gICAgdmFyIGFsbG93RG90cyA9IHR5cGVvZiBvcHRpb25zLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IG9wdGlvbnMuYWxsb3dEb3RzO1xuICAgIHZhciBzZXJpYWxpemVEYXRlID0gdHlwZW9mIG9wdGlvbnMuc2VyaWFsaXplRGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuc2VyaWFsaXplRGF0ZSA6IGRlZmF1bHRzLnNlcmlhbGl6ZURhdGU7XG4gICAgdmFyIGVuY29kZVZhbHVlc09ubHkgPSB0eXBlb2Ygb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5ID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmVuY29kZVZhbHVlc09ubHkgOiBkZWZhdWx0cy5lbmNvZGVWYWx1ZXNPbmx5O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb3JtYXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gZm9ybWF0c1snZGVmYXVsdCddO1xuICAgIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JtYXRzLmZvcm1hdHRlcnMsIG9wdGlvbnMuZm9ybWF0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGZvcm1hdCBvcHRpb24gcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIHZhciBmb3JtYXR0ZXIgPSBmb3JtYXRzLmZvcm1hdHRlcnNbb3B0aW9ucy5mb3JtYXRdO1xuICAgIHZhciBvYmpLZXlzO1xuICAgIHZhciBmaWx0ZXI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmogPSBmaWx0ZXIoJycsIG9iaik7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIGFycmF5Rm9ybWF0O1xuICAgIGlmIChvcHRpb25zLmFycmF5Rm9ybWF0IGluIGFycmF5UHJlZml4R2VuZXJhdG9ycykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdGlvbnMuYXJyYXlGb3JtYXQ7XG4gICAgfSBlbHNlIGlmICgnaW5kaWNlcycgaW4gb3B0aW9ucykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdGlvbnMuaW5kaWNlcyA/ICdpbmRpY2VzJyA6ICdyZXBlYXQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gJ2luZGljZXMnO1xuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZUFycmF5UHJlZml4ID0gYXJyYXlQcmVmaXhHZW5lcmF0b3JzW2FycmF5Rm9ybWF0XTtcblxuICAgIGlmICghb2JqS2V5cykge1xuICAgICAgICBvYmpLZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQoc29ydCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2ldO1xuXG4gICAgICAgIGlmIChza2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgIHNraXBOdWxscyxcbiAgICAgICAgICAgIGVuY29kZSA/IGVuY29kZXIgOiBudWxsLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5XG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBrZXlzLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB2YXIgcHJlZml4ID0gb3B0aW9ucy5hZGRRdWVyeVByZWZpeCA9PT0gdHJ1ZSA/ICc/JyA6ICcnO1xuXG4gICAgcmV0dXJuIGpvaW5lZC5sZW5ndGggPiAwID8gcHJlZml4ICsgam9pbmVkIDogJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGhleFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufSgpKTtcblxudmFyIGNvbXBhY3RRdWV1ZSA9IGZ1bmN0aW9uIGNvbXBhY3RRdWV1ZShxdWV1ZSkge1xuICAgIHZhciBvYmo7XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgICAgIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2pdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgYXJyYXlUb09iamVjdCA9IGZ1bmN0aW9uIGFycmF5VG9PYmplY3Qoc291cmNlLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wbGFpbk9iamVjdHMgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBvYmpbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wbGFpbk9iamVjdHMgfHwgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMgfHwgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VUYXJnZXQgPSB0YXJnZXQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIG1lcmdlVGFyZ2V0ID0gYXJyYXlUb09iamVjdCh0YXJnZXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICBpZiAoaGFzLmNhbGwodGFyZ2V0LCBpKSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbaV0gJiYgdHlwZW9mIHRhcmdldFtpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gbWVyZ2UodGFyZ2V0W2ldLCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XG5cbiAgICAgICAgaWYgKGhhcy5jYWxsKGFjYywga2V5KSkge1xuICAgICAgICAgICAgYWNjW2tleV0gPSBtZXJnZShhY2Nba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG1lcmdlVGFyZ2V0KTtcbn07XG5cbnZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ25TaW5nbGVTb3VyY2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gc291cmNlW2tleV07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgdGFyZ2V0KTtcbn07XG5cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKHN0cikge1xuICAgIC8vIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGJ5IEJyaWFuIFdoaXRlIChtc2NkZXgpIGZvciB0aGUgaW8uanMgY29yZSBxdWVyeXN0cmluZyBsaWJyYXJ5LlxuICAgIC8vIEl0IGhhcyBiZWVuIGFkYXB0ZWQgaGVyZSBmb3Igc3RyaWN0ZXIgYWRoZXJlbmNlIHRvIFJGQyAzOTg2XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIgOiBTdHJpbmcoc3RyKTtcblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPT09IDB4MkQgLy8gLVxuICAgICAgICAgICAgfHwgYyA9PT0gMHgyRSAvLyAuXG4gICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cbiAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgfHwgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIC8vIDAtOVxuICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxuICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICApIHtcbiAgICAgICAgICAgIG91dCArPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIGhleFRhYmxlW2NdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhDMCB8IChjID4+IDYpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPj0gMHhFMDAwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhFMCB8IChjID4+IDEyKV0gKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgICBjID0gMHgxMDAwMCArICgoKGMgJiAweDNGRikgPDwgMTApIHwgKHN0cmluZy5jaGFyQ29kZUF0KGkpICYgMHgzRkYpKTtcbiAgICAgICAgb3V0ICs9IGhleFRhYmxlWzB4RjAgfCAoYyA+PiAxOCldXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzRildXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG52YXIgY29tcGFjdCA9IGZ1bmN0aW9uIGNvbXBhY3QodmFsdWUpIHtcbiAgICB2YXIgcXVldWUgPSBbeyBvYmo6IHsgbzogdmFsdWUgfSwgcHJvcDogJ28nIH1dO1xuICAgIHZhciByZWZzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBpdGVtID0gcXVldWVbaV07XG4gICAgICAgIHZhciBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xuXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgcmVmcy5pbmRleE9mKHZhbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh7IG9iajogb2JqLCBwcm9wOiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgcmVmcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGFjdFF1ZXVlKHF1ZXVlKTtcbn07XG5cbnZhciBpc1JlZ0V4cCA9IGZ1bmN0aW9uIGlzUmVnRXhwKG9iaikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59O1xuXG52YXIgaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhcnJheVRvT2JqZWN0OiBhcnJheVRvT2JqZWN0LFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGNvbXBhY3Q6IGNvbXBhY3QsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICAgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgICBtZXJnZTogbWVyZ2Vcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAxMC0yMDEyIE1pa2VhbCBSb2dlcnNcbi8vXG4vLyAgICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8gICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vICAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vICAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vICAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kJylcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi9saWIvY29va2llcycpXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vbGliL2hlbHBlcnMnKVxuXG52YXIgcGFyYW1zSGF2ZVJlcXVlc3RCb2R5ID0gaGVscGVycy5wYXJhbXNIYXZlUmVxdWVzdEJvZHlcblxuLy8gb3JnYW5pemUgcGFyYW1zIGZvciBwYXRjaCwgcG9zdCwgcHV0LCBoZWFkLCBkZWxcbmZ1bmN0aW9uIGluaXRQYXJhbXMgKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gIH1cblxuICB2YXIgcGFyYW1zID0ge31cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgIGV4dGVuZChwYXJhbXMsIG9wdGlvbnMsIHt1cmk6IHVyaX0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICBleHRlbmQocGFyYW1zLCB7dXJpOiB1cml9KVxuICB9IGVsc2Uge1xuICAgIGV4dGVuZChwYXJhbXMsIHVyaSlcbiAgfVxuXG4gIHBhcmFtcy5jYWxsYmFjayA9IGNhbGxiYWNrIHx8IHBhcmFtcy5jYWxsYmFja1xuICByZXR1cm4gcGFyYW1zXG59XG5cbmZ1bmN0aW9uIHJlcXVlc3QgKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmRlZmluZWQgaXMgbm90IGEgdmFsaWQgdXJpIG9yIG9wdGlvbnMgb2JqZWN0LicpXG4gIH1cblxuICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuXG4gIGlmIChwYXJhbXMubWV0aG9kID09PSAnSEVBRCcgJiYgcGFyYW1zSGF2ZVJlcXVlc3RCb2R5KHBhcmFtcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0hUVFAgSEVBRCByZXF1ZXN0cyBNVVNUIE5PVCBpbmNsdWRlIGEgcmVxdWVzdCBib2R5LicpXG4gIH1cblxuICByZXR1cm4gbmV3IHJlcXVlc3QuUmVxdWVzdChwYXJhbXMpXG59XG5cbmZ1bmN0aW9uIHZlcmJGdW5jICh2ZXJiKSB7XG4gIHZhciBtZXRob2QgPSB2ZXJiLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIGZ1bmN0aW9uICh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcmFtcyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICBwYXJhbXMubWV0aG9kID0gbWV0aG9kXG4gICAgcmV0dXJuIHJlcXVlc3QocGFyYW1zLCBwYXJhbXMuY2FsbGJhY2spXG4gIH1cbn1cblxuLy8gZGVmaW5lIGxpa2UgdGhpcyB0byBwbGVhc2UgY29kZWludGVsL2ludGVsbGlzZW5zZSBJREVzXG5yZXF1ZXN0LmdldCA9IHZlcmJGdW5jKCdnZXQnKVxucmVxdWVzdC5oZWFkID0gdmVyYkZ1bmMoJ2hlYWQnKVxucmVxdWVzdC5vcHRpb25zID0gdmVyYkZ1bmMoJ29wdGlvbnMnKVxucmVxdWVzdC5wb3N0ID0gdmVyYkZ1bmMoJ3Bvc3QnKVxucmVxdWVzdC5wdXQgPSB2ZXJiRnVuYygncHV0JylcbnJlcXVlc3QucGF0Y2ggPSB2ZXJiRnVuYygncGF0Y2gnKVxucmVxdWVzdC5kZWwgPSB2ZXJiRnVuYygnZGVsZXRlJylcbnJlcXVlc3RbJ2RlbGV0ZSddID0gdmVyYkZ1bmMoJ2RlbGV0ZScpXG5cbnJlcXVlc3QuamFyID0gZnVuY3Rpb24gKHN0b3JlKSB7XG4gIHJldHVybiBjb29raWVzLmphcihzdG9yZSlcbn1cblxucmVxdWVzdC5jb29raWUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBjb29raWVzLnBhcnNlKHN0cilcbn1cblxuZnVuY3Rpb24gd3JhcFJlcXVlc3RNZXRob2QgKG1ldGhvZCwgb3B0aW9ucywgcmVxdWVzdGVyLCB2ZXJiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodXJpLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJhbXMgPSBpbml0UGFyYW1zKHVyaSwgb3B0cywgY2FsbGJhY2spXG5cbiAgICB2YXIgdGFyZ2V0ID0ge31cbiAgICBleHRlbmQodHJ1ZSwgdGFyZ2V0LCBvcHRpb25zLCBwYXJhbXMpXG5cbiAgICB0YXJnZXQucG9vbCA9IHBhcmFtcy5wb29sIHx8IG9wdGlvbnMucG9vbFxuXG4gICAgaWYgKHZlcmIpIHtcbiAgICAgIHRhcmdldC5tZXRob2QgPSB2ZXJiLnRvVXBwZXJDYXNlKClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlcXVlc3RlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbWV0aG9kID0gcmVxdWVzdGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZCh0YXJnZXQsIHRhcmdldC5jYWxsYmFjaylcbiAgfVxufVxuXG5yZXF1ZXN0LmRlZmF1bHRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHJlcXVlc3Rlcikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlcXVlc3RlciA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHZhciBkZWZhdWx0cyA9IHdyYXBSZXF1ZXN0TWV0aG9kKHNlbGYsIG9wdGlvbnMsIHJlcXVlc3RlcilcblxuICB2YXIgdmVyYnMgPSBbJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2RlbCcsICdkZWxldGUnXVxuICB2ZXJicy5mb3JFYWNoKGZ1bmN0aW9uICh2ZXJiKSB7XG4gICAgZGVmYXVsdHNbdmVyYl0gPSB3cmFwUmVxdWVzdE1ldGhvZChzZWxmW3ZlcmJdLCBvcHRpb25zLCByZXF1ZXN0ZXIsIHZlcmIpXG4gIH0pXG5cbiAgZGVmYXVsdHMuY29va2llID0gd3JhcFJlcXVlc3RNZXRob2Qoc2VsZi5jb29raWUsIG9wdGlvbnMsIHJlcXVlc3RlcilcbiAgZGVmYXVsdHMuamFyID0gc2VsZi5qYXJcbiAgZGVmYXVsdHMuZGVmYXVsdHMgPSBzZWxmLmRlZmF1bHRzXG4gIHJldHVybiBkZWZhdWx0c1xufVxuXG5yZXF1ZXN0LmZvcmV2ZXIgPSBmdW5jdGlvbiAoYWdlbnRPcHRpb25zLCBvcHRpb25zQXJnKSB7XG4gIHZhciBvcHRpb25zID0ge31cbiAgaWYgKG9wdGlvbnNBcmcpIHtcbiAgICBleHRlbmQob3B0aW9ucywgb3B0aW9uc0FyZylcbiAgfVxuICBpZiAoYWdlbnRPcHRpb25zKSB7XG4gICAgb3B0aW9ucy5hZ2VudE9wdGlvbnMgPSBhZ2VudE9wdGlvbnNcbiAgfVxuXG4gIG9wdGlvbnMuZm9yZXZlciA9IHRydWVcbiAgcmV0dXJuIHJlcXVlc3QuZGVmYXVsdHMob3B0aW9ucylcbn1cblxuLy8gRXhwb3J0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVlc3RcbnJlcXVlc3QuUmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpXG5yZXF1ZXN0LmluaXRQYXJhbXMgPSBpbml0UGFyYW1zXG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciByZXF1ZXN0LmRlYnVnXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWVzdCwgJ2RlYnVnJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5SZXF1ZXN0LmRlYnVnXG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGRlYnVnKSB7XG4gICAgcmVxdWVzdC5SZXF1ZXN0LmRlYnVnID0gZGVidWdcbiAgfVxufSlcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY2FzZWxlc3MgPSByZXF1aXJlKCdjYXNlbGVzcycpXG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjQnKVxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKVxuXG52YXIgbWQ1ID0gaGVscGVycy5tZDVcbnZhciB0b0Jhc2U2NCA9IGhlbHBlcnMudG9CYXNlNjRcblxuZnVuY3Rpb24gQXV0aCAocmVxdWVzdCkge1xuICAvLyBkZWZpbmUgYWxsIHB1YmxpYyBwcm9wZXJ0aWVzIGhlcmVcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICB0aGlzLmhhc0F1dGggPSBmYWxzZVxuICB0aGlzLnNlbnRBdXRoID0gZmFsc2VcbiAgdGhpcy5iZWFyZXJUb2tlbiA9IG51bGxcbiAgdGhpcy51c2VyID0gbnVsbFxuICB0aGlzLnBhc3MgPSBudWxsXG59XG5cbkF1dGgucHJvdG90eXBlLmJhc2ljID0gZnVuY3Rpb24gKHVzZXIsIHBhc3MsIHNlbmRJbW1lZGlhdGVseSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHR5cGVvZiB1c2VyICE9PSAnc3RyaW5nJyB8fCAocGFzcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXNzICE9PSAnc3RyaW5nJykpIHtcbiAgICBzZWxmLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2F1dGgoKSByZWNlaXZlZCBpbnZhbGlkIHVzZXIgb3IgcGFzc3dvcmQnKSlcbiAgfVxuICBzZWxmLnVzZXIgPSB1c2VyXG4gIHNlbGYucGFzcyA9IHBhc3NcbiAgc2VsZi5oYXNBdXRoID0gdHJ1ZVxuICB2YXIgaGVhZGVyID0gdXNlciArICc6JyArIChwYXNzIHx8ICcnKVxuICBpZiAoc2VuZEltbWVkaWF0ZWx5IHx8IHR5cGVvZiBzZW5kSW1tZWRpYXRlbHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGF1dGhIZWFkZXIgPSAnQmFzaWMgJyArIHRvQmFzZTY0KGhlYWRlcilcbiAgICBzZWxmLnNlbnRBdXRoID0gdHJ1ZVxuICAgIHJldHVybiBhdXRoSGVhZGVyXG4gIH1cbn1cblxuQXV0aC5wcm90b3R5cGUuYmVhcmVyID0gZnVuY3Rpb24gKGJlYXJlciwgc2VuZEltbWVkaWF0ZWx5KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLmJlYXJlclRva2VuID0gYmVhcmVyXG4gIHNlbGYuaGFzQXV0aCA9IHRydWVcbiAgaWYgKHNlbmRJbW1lZGlhdGVseSB8fCB0eXBlb2Ygc2VuZEltbWVkaWF0ZWx5ID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgYmVhcmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBiZWFyZXIgPSBiZWFyZXIoKVxuICAgIH1cbiAgICB2YXIgYXV0aEhlYWRlciA9ICdCZWFyZXIgJyArIChiZWFyZXIgfHwgJycpXG4gICAgc2VsZi5zZW50QXV0aCA9IHRydWVcbiAgICByZXR1cm4gYXV0aEhlYWRlclxuICB9XG59XG5cbkF1dGgucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhdGgsIGF1dGhIZWFkZXIpIHtcbiAgLy8gVE9ETzogTW9yZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBSRkMgMjYxNy5cbiAgLy8gICAtIGhhbmRsZSBjaGFsbGVuZ2UuZG9tYWluXG4gIC8vICAgLSBzdXBwb3J0IHFvcD1cImF1dGgtaW50XCIgb25seVxuICAvLyAgIC0gaGFuZGxlIEF1dGhlbnRpY2F0aW9uLUluZm8gKG5vdCBuZWNlc3NhcmlseT8pXG4gIC8vICAgLSBjaGVjayBjaGFsbGVuZ2Uuc3RhbGUgKG5vdCBuZWNlc3NhcmlseT8pXG4gIC8vICAgLSBpbmNyZWFzZSBuYyAobm90IG5lY2Vzc2FyaWx5PylcbiAgLy8gRm9yIHJlZmVyZW5jZTpcbiAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjYxNyNzZWN0aW9uLTNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhZ2Rlci9jdXJsL2Jsb2IvbWFzdGVyL2xpYi9odHRwX2RpZ2VzdC5jXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIGNoYWxsZW5nZSA9IHt9XG4gIHZhciByZSA9IC8oW2EtejAtOV8tXSspPSg/OlwiKFteXCJdKylcInwoW2EtejAtOV8tXSspKS9naVxuICBmb3IgKDs7KSB7XG4gICAgdmFyIG1hdGNoID0gcmUuZXhlYyhhdXRoSGVhZGVyKVxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNoYWxsZW5nZVttYXRjaFsxXV0gPSBtYXRjaFsyXSB8fCBtYXRjaFszXVxuICB9XG5cbiAgLyoqXG4gICAqIFJGQyAyNjE3OiBoYW5kbGUgYm90aCBNRDUgYW5kIE1ENS1zZXNzIGFsZ29yaXRobXMuXG4gICAqXG4gICAqIElmIHRoZSBhbGdvcml0aG0gZGlyZWN0aXZlJ3MgdmFsdWUgaXMgXCJNRDVcIiBvciB1bnNwZWNpZmllZCwgdGhlbiBIQTEgaXNcbiAgICogICBIQTE9TUQ1KHVzZXJuYW1lOnJlYWxtOnBhc3N3b3JkKVxuICAgKiBJZiB0aGUgYWxnb3JpdGhtIGRpcmVjdGl2ZSdzIHZhbHVlIGlzIFwiTUQ1LXNlc3NcIiwgdGhlbiBIQTEgaXNcbiAgICogICBIQTE9TUQ1KE1ENSh1c2VybmFtZTpyZWFsbTpwYXNzd29yZCk6bm9uY2U6Y25vbmNlKVxuICAgKi9cbiAgdmFyIGhhMUNvbXB1dGUgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCB1c2VyLCByZWFsbSwgcGFzcywgbm9uY2UsIGNub25jZSkge1xuICAgIHZhciBoYTEgPSBtZDUodXNlciArICc6JyArIHJlYWxtICsgJzonICsgcGFzcylcbiAgICBpZiAoYWxnb3JpdGhtICYmIGFsZ29yaXRobS50b0xvd2VyQ2FzZSgpID09PSAnbWQ1LXNlc3MnKSB7XG4gICAgICByZXR1cm4gbWQ1KGhhMSArICc6JyArIG5vbmNlICsgJzonICsgY25vbmNlKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGExXG4gICAgfVxuICB9XG5cbiAgdmFyIHFvcCA9IC8oXnwsKVxccyphdXRoXFxzKigkfCwpLy50ZXN0KGNoYWxsZW5nZS5xb3ApICYmICdhdXRoJ1xuICB2YXIgbmMgPSBxb3AgJiYgJzAwMDAwMDAxJ1xuICB2YXIgY25vbmNlID0gcW9wICYmIHV1aWQoKS5yZXBsYWNlKC8tL2csICcnKVxuICB2YXIgaGExID0gaGExQ29tcHV0ZShjaGFsbGVuZ2UuYWxnb3JpdGhtLCBzZWxmLnVzZXIsIGNoYWxsZW5nZS5yZWFsbSwgc2VsZi5wYXNzLCBjaGFsbGVuZ2Uubm9uY2UsIGNub25jZSlcbiAgdmFyIGhhMiA9IG1kNShtZXRob2QgKyAnOicgKyBwYXRoKVxuICB2YXIgZGlnZXN0UmVzcG9uc2UgPSBxb3BcbiAgICA/IG1kNShoYTEgKyAnOicgKyBjaGFsbGVuZ2Uubm9uY2UgKyAnOicgKyBuYyArICc6JyArIGNub25jZSArICc6JyArIHFvcCArICc6JyArIGhhMilcbiAgICA6IG1kNShoYTEgKyAnOicgKyBjaGFsbGVuZ2Uubm9uY2UgKyAnOicgKyBoYTIpXG4gIHZhciBhdXRoVmFsdWVzID0ge1xuICAgIHVzZXJuYW1lOiBzZWxmLnVzZXIsXG4gICAgcmVhbG06IGNoYWxsZW5nZS5yZWFsbSxcbiAgICBub25jZTogY2hhbGxlbmdlLm5vbmNlLFxuICAgIHVyaTogcGF0aCxcbiAgICBxb3A6IHFvcCxcbiAgICByZXNwb25zZTogZGlnZXN0UmVzcG9uc2UsXG4gICAgbmM6IG5jLFxuICAgIGNub25jZTogY25vbmNlLFxuICAgIGFsZ29yaXRobTogY2hhbGxlbmdlLmFsZ29yaXRobSxcbiAgICBvcGFxdWU6IGNoYWxsZW5nZS5vcGFxdWVcbiAgfVxuXG4gIGF1dGhIZWFkZXIgPSBbXVxuICBmb3IgKHZhciBrIGluIGF1dGhWYWx1ZXMpIHtcbiAgICBpZiAoYXV0aFZhbHVlc1trXSkge1xuICAgICAgaWYgKGsgPT09ICdxb3AnIHx8IGsgPT09ICduYycgfHwgayA9PT0gJ2FsZ29yaXRobScpIHtcbiAgICAgICAgYXV0aEhlYWRlci5wdXNoKGsgKyAnPScgKyBhdXRoVmFsdWVzW2tdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXV0aEhlYWRlci5wdXNoKGsgKyAnPVwiJyArIGF1dGhWYWx1ZXNba10gKyAnXCInKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhdXRoSGVhZGVyID0gJ0RpZ2VzdCAnICsgYXV0aEhlYWRlci5qb2luKCcsICcpXG4gIHNlbGYuc2VudEF1dGggPSB0cnVlXG4gIHJldHVybiBhdXRoSGVhZGVyXG59XG5cbkF1dGgucHJvdG90eXBlLm9uUmVxdWVzdCA9IGZ1bmN0aW9uICh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHksIGJlYXJlcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlcXVlc3QgPSBzZWxmLnJlcXVlc3RcblxuICB2YXIgYXV0aEhlYWRlclxuICBpZiAoYmVhcmVyID09PSB1bmRlZmluZWQgJiYgdXNlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyBhdXRoIG1lY2hhbmlzbSBkZWZpbmVkJykpXG4gIH0gZWxzZSBpZiAoYmVhcmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICBhdXRoSGVhZGVyID0gc2VsZi5iZWFyZXIoYmVhcmVyLCBzZW5kSW1tZWRpYXRlbHkpXG4gIH0gZWxzZSB7XG4gICAgYXV0aEhlYWRlciA9IHNlbGYuYmFzaWModXNlciwgcGFzcywgc2VuZEltbWVkaWF0ZWx5KVxuICB9XG4gIGlmIChhdXRoSGVhZGVyKSB7XG4gICAgcmVxdWVzdC5zZXRIZWFkZXIoJ2F1dGhvcml6YXRpb24nLCBhdXRoSGVhZGVyKVxuICB9XG59XG5cbkF1dGgucHJvdG90eXBlLm9uUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZXF1ZXN0ID0gc2VsZi5yZXF1ZXN0XG5cbiAgaWYgKCFzZWxmLmhhc0F1dGggfHwgc2VsZi5zZW50QXV0aCkgeyByZXR1cm4gbnVsbCB9XG5cbiAgdmFyIGMgPSBjYXNlbGVzcyhyZXNwb25zZS5oZWFkZXJzKVxuXG4gIHZhciBhdXRoSGVhZGVyID0gYy5nZXQoJ3d3dy1hdXRoZW50aWNhdGUnKVxuICB2YXIgYXV0aFZlcmIgPSBhdXRoSGVhZGVyICYmIGF1dGhIZWFkZXIuc3BsaXQoJyAnKVswXS50b0xvd2VyQ2FzZSgpXG4gIHJlcXVlc3QuZGVidWcoJ3JlYXV0aCcsIGF1dGhWZXJiKVxuXG4gIHN3aXRjaCAoYXV0aFZlcmIpIHtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICByZXR1cm4gc2VsZi5iYXNpYyhzZWxmLnVzZXIsIHNlbGYucGFzcywgdHJ1ZSlcblxuICAgIGNhc2UgJ2JlYXJlcic6XG4gICAgICByZXR1cm4gc2VsZi5iZWFyZXIoc2VsZi5iZWFyZXJUb2tlbiwgdHJ1ZSlcblxuICAgIGNhc2UgJ2RpZ2VzdCc6XG4gICAgICByZXR1cm4gc2VsZi5kaWdlc3QocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QucGF0aCwgYXV0aEhlYWRlcilcbiAgfVxufVxuXG5leHBvcnRzLkF1dGggPSBBdXRoXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHRvdWdoID0gcmVxdWlyZSgndG91Z2gtY29va2llJylcblxudmFyIENvb2tpZSA9IHRvdWdoLkNvb2tpZVxudmFyIENvb2tpZUphciA9IHRvdWdoLkNvb2tpZUphclxuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAoc3RyICYmIHN0ci51cmkpIHtcbiAgICBzdHIgPSBzdHIudXJpXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY29va2llIGZ1bmN0aW9uIG9ubHkgYWNjZXB0cyBTVFJJTkcgYXMgcGFyYW0nKVxuICB9XG4gIHJldHVybiBDb29raWUucGFyc2Uoc3RyLCB7bG9vc2U6IHRydWV9KVxufVxuXG4vLyBBZGFwdCB0aGUgc29tZXRpbWVzLUFzeW5jIGFwaSBvZiB0b3VnaC5Db29raWVKYXIgdG8gb3VyIHJlcXVpcmVtZW50c1xuZnVuY3Rpb24gUmVxdWVzdEphciAoc3RvcmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuX2phciA9IG5ldyBDb29raWVKYXIoc3RvcmUsIHtsb29zZU1vZGU6IHRydWV9KVxufVxuUmVxdWVzdEphci5wcm90b3R5cGUuc2V0Q29va2llID0gZnVuY3Rpb24gKGNvb2tpZU9yU3RyLCB1cmksIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiBzZWxmLl9qYXIuc2V0Q29va2llU3luYyhjb29raWVPclN0ciwgdXJpLCBvcHRpb25zIHx8IHt9KVxufVxuUmVxdWVzdEphci5wcm90b3R5cGUuZ2V0Q29va2llU3RyaW5nID0gZnVuY3Rpb24gKHVyaSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHNlbGYuX2phci5nZXRDb29raWVTdHJpbmdTeW5jKHVyaSlcbn1cblJlcXVlc3RKYXIucHJvdG90eXBlLmdldENvb2tpZXMgPSBmdW5jdGlvbiAodXJpKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICByZXR1cm4gc2VsZi5famFyLmdldENvb2tpZXNTeW5jKHVyaSlcbn1cblxuZXhwb3J0cy5qYXIgPSBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0SmFyKHN0b3JlKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIGZvcm1hdEhvc3RuYW1lIChob3N0bmFtZSkge1xuICAvLyBjYW5vbmljYWxpemUgdGhlIGhvc3RuYW1lLCBzbyB0aGF0ICdvb2dsZS5jb20nIHdvbid0IG1hdGNoICdnb29nbGUuY29tJ1xuICByZXR1cm4gaG9zdG5hbWUucmVwbGFjZSgvXlxcLiovLCAnLicpLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gcGFyc2VOb1Byb3h5Wm9uZSAoem9uZSkge1xuICB6b25lID0gem9uZS50cmltKCkudG9Mb3dlckNhc2UoKVxuXG4gIHZhciB6b25lUGFydHMgPSB6b25lLnNwbGl0KCc6JywgMilcbiAgdmFyIHpvbmVIb3N0ID0gZm9ybWF0SG9zdG5hbWUoem9uZVBhcnRzWzBdKVxuICB2YXIgem9uZVBvcnQgPSB6b25lUGFydHNbMV1cbiAgdmFyIGhhc1BvcnQgPSB6b25lLmluZGV4T2YoJzonKSA+IC0xXG5cbiAgcmV0dXJuIHtob3N0bmFtZTogem9uZUhvc3QsIHBvcnQ6IHpvbmVQb3J0LCBoYXNQb3J0OiBoYXNQb3J0fVxufVxuXG5mdW5jdGlvbiB1cmlJbk5vUHJveHkgKHVyaSwgbm9Qcm94eSkge1xuICB2YXIgcG9ydCA9IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09ICdodHRwczonID8gJzQ0MycgOiAnODAnKVxuICB2YXIgaG9zdG5hbWUgPSBmb3JtYXRIb3N0bmFtZSh1cmkuaG9zdG5hbWUpXG4gIHZhciBub1Byb3h5TGlzdCA9IG5vUHJveHkuc3BsaXQoJywnKVxuXG4gIC8vIGl0ZXJhdGUgdGhyb3VnaCB0aGUgbm9Qcm94eUxpc3QgdW50aWwgaXQgZmluZHMgYSBtYXRjaC5cbiAgcmV0dXJuIG5vUHJveHlMaXN0Lm1hcChwYXJzZU5vUHJveHlab25lKS5zb21lKGZ1bmN0aW9uIChub1Byb3h5Wm9uZSkge1xuICAgIHZhciBpc01hdGNoZWRBdCA9IGhvc3RuYW1lLmluZGV4T2Yobm9Qcm94eVpvbmUuaG9zdG5hbWUpXG4gICAgdmFyIGhvc3RuYW1lTWF0Y2hlZCA9IChcbiAgICAgIGlzTWF0Y2hlZEF0ID4gLTEgJiZcbiAgICAgICAgKGlzTWF0Y2hlZEF0ID09PSBob3N0bmFtZS5sZW5ndGggLSBub1Byb3h5Wm9uZS5ob3N0bmFtZS5sZW5ndGgpXG4gICAgKVxuXG4gICAgaWYgKG5vUHJveHlab25lLmhhc1BvcnQpIHtcbiAgICAgIHJldHVybiAocG9ydCA9PT0gbm9Qcm94eVpvbmUucG9ydCkgJiYgaG9zdG5hbWVNYXRjaGVkXG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RuYW1lTWF0Y2hlZFxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRQcm94eUZyb21VUkkgKHVyaSkge1xuICAvLyBEZWNpZGUgdGhlIHByb3BlciByZXF1ZXN0IHByb3h5IHRvIHVzZSBiYXNlZCBvbiB0aGUgcmVxdWVzdCBVUkkgb2JqZWN0IGFuZCB0aGVcbiAgLy8gZW52aXJvbm1lbnRhbCB2YXJpYWJsZXMgKE5PX1BST1hZLCBIVFRQX1BST1hZLCBldGMuKVxuICAvLyByZXNwZWN0IE5PX1BST1hZIGVudmlyb25tZW50IHZhcmlhYmxlcyAoc2VlOiBodHRwOi8vbHlueC5pc2Mub3JnL2N1cnJlbnQvYnJlYWtvdXQvbHlueF9oZWxwL2tleXN0cm9rZXMvZW52aXJvbm1lbnRzLmh0bWwpXG5cbiAgdmFyIG5vUHJveHkgPSBwcm9jZXNzLmVudi5OT19QUk9YWSB8fCBwcm9jZXNzLmVudi5ub19wcm94eSB8fCAnJ1xuXG4gIC8vIGlmIHRoZSBub1Byb3h5IGlzIGEgd2lsZGNhcmQgdGhlbiByZXR1cm4gbnVsbFxuXG4gIGlmIChub1Byb3h5ID09PSAnKicpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gaWYgdGhlIG5vUHJveHkgaXMgbm90IGVtcHR5IGFuZCB0aGUgdXJpIGlzIGZvdW5kIHJldHVybiBudWxsXG5cbiAgaWYgKG5vUHJveHkgIT09ICcnICYmIHVyaUluTm9Qcm94eSh1cmksIG5vUHJveHkpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBIVFRQIG9yIEhUVFBTIFByb3h5IGluIGVudmlyb25tZW50IEVsc2UgZGVmYXVsdCB0byBudWxsXG5cbiAgaWYgKHVyaS5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5IVFRQX1BST1hZIHx8XG4gICAgICBwcm9jZXNzLmVudi5odHRwX3Byb3h5IHx8IG51bGxcbiAgfVxuXG4gIGlmICh1cmkucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkhUVFBTX1BST1hZIHx8XG4gICAgICBwcm9jZXNzLmVudi5odHRwc19wcm94eSB8fFxuICAgICAgcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSB8fFxuICAgICAgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSB8fCBudWxsXG4gIH1cblxuICAvLyBpZiBub25lIG9mIHRoYXQgd29ya3MsIHJldHVybiBudWxsXG4gIC8vIChXaGF0IHVyaSBwcm90b2NvbCBhcmUgeW91IHVzaW5nIHRoZW4/KVxuXG4gIHJldHVybiBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJveHlGcm9tVVJJXG4iLCIndXNlIHN0cmljdCdcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKVxudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnaGFyLXZhbGlkYXRvcicpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kJylcblxuZnVuY3Rpb24gSGFyIChyZXF1ZXN0KSB7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Rcbn1cblxuSGFyLnByb3RvdHlwZS5yZWR1Y2VyID0gZnVuY3Rpb24gKG9iaiwgcGFpcikge1xuICAvLyBuZXcgcHJvcGVydHkgP1xuICBpZiAob2JqW3BhaXIubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIG9ialtwYWlyLm5hbWVdID0gcGFpci52YWx1ZVxuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIC8vIGV4aXN0aW5nPyBjb252ZXJ0IHRvIGFycmF5XG4gIHZhciBhcnIgPSBbXG4gICAgb2JqW3BhaXIubmFtZV0sXG4gICAgcGFpci52YWx1ZVxuICBdXG5cbiAgb2JqW3BhaXIubmFtZV0gPSBhcnJcblxuICByZXR1cm4gb2JqXG59XG5cbkhhci5wcm90b3R5cGUucHJlcCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIC8vIGNvbnN0cnVjdCB1dGlsaXR5IHByb3BlcnRpZXNcbiAgZGF0YS5xdWVyeU9iaiA9IHt9XG4gIGRhdGEuaGVhZGVyc09iaiA9IHt9XG4gIGRhdGEucG9zdERhdGEuanNvbk9iaiA9IGZhbHNlXG4gIGRhdGEucG9zdERhdGEucGFyYW1zT2JqID0gZmFsc2VcblxuICAvLyBjb25zdHJ1Y3QgcXVlcnkgb2JqZWN0c1xuICBpZiAoZGF0YS5xdWVyeVN0cmluZyAmJiBkYXRhLnF1ZXJ5U3RyaW5nLmxlbmd0aCkge1xuICAgIGRhdGEucXVlcnlPYmogPSBkYXRhLnF1ZXJ5U3RyaW5nLnJlZHVjZSh0aGlzLnJlZHVjZXIsIHt9KVxuICB9XG5cbiAgLy8gY29uc3RydWN0IGhlYWRlcnMgb2JqZWN0c1xuICBpZiAoZGF0YS5oZWFkZXJzICYmIGRhdGEuaGVhZGVycy5sZW5ndGgpIHtcbiAgICAvLyBsb3dlQ2FzZSBoZWFkZXIga2V5c1xuICAgIGRhdGEuaGVhZGVyc09iaiA9IGRhdGEuaGVhZGVycy5yZWR1Y2VSaWdodChmdW5jdGlvbiAoaGVhZGVycywgaGVhZGVyKSB7XG4gICAgICBoZWFkZXJzW2hlYWRlci5uYW1lXSA9IGhlYWRlci52YWx1ZVxuICAgICAgcmV0dXJuIGhlYWRlcnNcbiAgICB9LCB7fSlcbiAgfVxuXG4gIC8vIGNvbnN0cnVjdCBDb29raWUgaGVhZGVyXG4gIGlmIChkYXRhLmNvb2tpZXMgJiYgZGF0YS5jb29raWVzLmxlbmd0aCkge1xuICAgIHZhciBjb29raWVzID0gZGF0YS5jb29raWVzLm1hcChmdW5jdGlvbiAoY29va2llKSB7XG4gICAgICByZXR1cm4gY29va2llLm5hbWUgKyAnPScgKyBjb29raWUudmFsdWVcbiAgICB9KVxuXG4gICAgaWYgKGNvb2tpZXMubGVuZ3RoKSB7XG4gICAgICBkYXRhLmhlYWRlcnNPYmouY29va2llID0gY29va2llcy5qb2luKCc7ICcpXG4gICAgfVxuICB9XG5cbiAgLy8gcHJlcCBib2R5XG4gIGZ1bmN0aW9uIHNvbWUgKGFycikge1xuICAgIHJldHVybiBhcnIuc29tZShmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIGRhdGEucG9zdERhdGEubWltZVR5cGUuaW5kZXhPZih0eXBlKSA9PT0gMFxuICAgIH0pXG4gIH1cblxuICBpZiAoc29tZShbXG4gICAgJ211bHRpcGFydC9taXhlZCcsXG4gICAgJ211bHRpcGFydC9yZWxhdGVkJyxcbiAgICAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgJ211bHRpcGFydC9hbHRlcm5hdGl2ZSddKSkge1xuICAgIC8vIHJlc2V0IHZhbHVlc1xuICAgIGRhdGEucG9zdERhdGEubWltZVR5cGUgPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgfSBlbHNlIGlmIChzb21lKFtcbiAgICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ10pKSB7XG4gICAgaWYgKCFkYXRhLnBvc3REYXRhLnBhcmFtcykge1xuICAgICAgZGF0YS5wb3N0RGF0YS50ZXh0ID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5wb3N0RGF0YS5wYXJhbXNPYmogPSBkYXRhLnBvc3REYXRhLnBhcmFtcy5yZWR1Y2UodGhpcy5yZWR1Y2VyLCB7fSlcblxuICAgICAgLy8gYWx3YXlzIG92ZXJ3cml0ZVxuICAgICAgZGF0YS5wb3N0RGF0YS50ZXh0ID0gcXMuc3RyaW5naWZ5KGRhdGEucG9zdERhdGEucGFyYW1zT2JqKVxuICAgIH1cbiAgfSBlbHNlIGlmIChzb21lKFtcbiAgICAndGV4dC9qc29uJyxcbiAgICAndGV4dC94LWpzb24nLFxuICAgICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAnYXBwbGljYXRpb24veC1qc29uJ10pKSB7XG4gICAgZGF0YS5wb3N0RGF0YS5taW1lVHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJ1xuXG4gICAgaWYgKGRhdGEucG9zdERhdGEudGV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YS5wb3N0RGF0YS5qc29uT2JqID0gSlNPTi5wYXJzZShkYXRhLnBvc3REYXRhLnRleHQpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdC5kZWJ1ZyhlKVxuXG4gICAgICAgIC8vIGZvcmNlIGJhY2sgdG8gdGV4dC9wbGFpblxuICAgICAgICBkYXRhLnBvc3REYXRhLm1pbWVUeXBlID0gJ3RleHQvcGxhaW4nXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGFcbn1cblxuSGFyLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gc2tpcCBpZiBubyBoYXIgcHJvcGVydHkgZGVmaW5lZFxuICBpZiAoIW9wdGlvbnMuaGFyKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIHZhciBoYXIgPSB7fVxuICBleHRlbmQoaGFyLCBvcHRpb25zLmhhcilcblxuICAvLyBvbmx5IHByb2Nlc3MgdGhlIGZpcnN0IGVudHJ5XG4gIGlmIChoYXIubG9nICYmIGhhci5sb2cuZW50cmllcykge1xuICAgIGhhciA9IGhhci5sb2cuZW50cmllc1swXVxuICB9XG5cbiAgLy8gYWRkIG9wdGlvbmFsIHByb3BlcnRpZXMgdG8gbWFrZSB2YWxpZGF0aW9uIHN1Y2Nlc3NmdWxcbiAgaGFyLnVybCA9IGhhci51cmwgfHwgb3B0aW9ucy51cmwgfHwgb3B0aW9ucy51cmkgfHwgb3B0aW9ucy5iYXNlVXJsIHx8ICcvJ1xuICBoYXIuaHR0cFZlcnNpb24gPSBoYXIuaHR0cFZlcnNpb24gfHwgJ0hUVFAvMS4xJ1xuICBoYXIucXVlcnlTdHJpbmcgPSBoYXIucXVlcnlTdHJpbmcgfHwgW11cbiAgaGFyLmhlYWRlcnMgPSBoYXIuaGVhZGVycyB8fCBbXVxuICBoYXIuY29va2llcyA9IGhhci5jb29raWVzIHx8IFtdXG4gIGhhci5wb3N0RGF0YSA9IGhhci5wb3N0RGF0YSB8fCB7fVxuICBoYXIucG9zdERhdGEubWltZVR5cGUgPSBoYXIucG9zdERhdGEubWltZVR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcblxuICBoYXIuYm9keVNpemUgPSAwXG4gIGhhci5oZWFkZXJzU2l6ZSA9IDBcbiAgaGFyLnBvc3REYXRhLnNpemUgPSAwXG5cbiAgaWYgKCF2YWxpZGF0ZS5yZXF1ZXN0KGhhcikpIHtcbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgLy8gY2xlYW4gdXAgYW5kIGdldCBzb21lIHV0aWxpdHkgcHJvcGVydGllc1xuICB2YXIgcmVxID0gdGhpcy5wcmVwKGhhcilcblxuICAvLyBjb25zdHJ1Y3QgbmV3IG9wdGlvbnNcbiAgaWYgKHJlcS51cmwpIHtcbiAgICBvcHRpb25zLnVybCA9IHJlcS51cmxcbiAgfVxuXG4gIGlmIChyZXEubWV0aG9kKSB7XG4gICAgb3B0aW9ucy5tZXRob2QgPSByZXEubWV0aG9kXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMocmVxLnF1ZXJ5T2JqKS5sZW5ndGgpIHtcbiAgICBvcHRpb25zLnFzID0gcmVxLnF1ZXJ5T2JqXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMocmVxLmhlYWRlcnNPYmopLmxlbmd0aCkge1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IHJlcS5oZWFkZXJzT2JqXG4gIH1cblxuICBmdW5jdGlvbiB0ZXN0ICh0eXBlKSB7XG4gICAgcmV0dXJuIHJlcS5wb3N0RGF0YS5taW1lVHlwZS5pbmRleE9mKHR5cGUpID09PSAwXG4gIH1cbiAgaWYgKHRlc3QoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpKSB7XG4gICAgb3B0aW9ucy5mb3JtID0gcmVxLnBvc3REYXRhLnBhcmFtc09ialxuICB9IGVsc2UgaWYgKHRlc3QoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgIGlmIChyZXEucG9zdERhdGEuanNvbk9iaikge1xuICAgICAgb3B0aW9ucy5ib2R5ID0gcmVxLnBvc3REYXRhLmpzb25PYmpcbiAgICAgIG9wdGlvbnMuanNvbiA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSBpZiAodGVzdCgnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpKSB7XG4gICAgb3B0aW9ucy5mb3JtRGF0YSA9IHt9XG5cbiAgICByZXEucG9zdERhdGEucGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICB2YXIgYXR0YWNobWVudCA9IHt9XG5cbiAgICAgIGlmICghcGFyYW0uZmlsZU5hbWUgJiYgIXBhcmFtLmZpbGVOYW1lICYmICFwYXJhbS5jb250ZW50VHlwZSkge1xuICAgICAgICBvcHRpb25zLmZvcm1EYXRhW3BhcmFtLm5hbWVdID0gcGFyYW0udmFsdWVcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIGF0dGVtcHQgdG8gcmVhZCBmcm9tIGRpc2shXG4gICAgICBpZiAocGFyYW0uZmlsZU5hbWUgJiYgIXBhcmFtLnZhbHVlKSB7XG4gICAgICAgIGF0dGFjaG1lbnQudmFsdWUgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKHBhcmFtLmZpbGVOYW1lKVxuICAgICAgfSBlbHNlIGlmIChwYXJhbS52YWx1ZSkge1xuICAgICAgICBhdHRhY2htZW50LnZhbHVlID0gcGFyYW0udmFsdWVcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmFtLmZpbGVOYW1lKSB7XG4gICAgICAgIGF0dGFjaG1lbnQub3B0aW9ucyA9IHtcbiAgICAgICAgICBmaWxlbmFtZTogcGFyYW0uZmlsZU5hbWUsXG4gICAgICAgICAgY29udGVudFR5cGU6IHBhcmFtLmNvbnRlbnRUeXBlID8gcGFyYW0uY29udGVudFR5cGUgOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5mb3JtRGF0YVtwYXJhbS5uYW1lXSA9IGF0dGFjaG1lbnRcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGlmIChyZXEucG9zdERhdGEudGV4dCkge1xuICAgICAgb3B0aW9ucy5ib2R5ID0gcmVxLnBvc3REYXRhLnRleHRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5leHBvcnRzLkhhciA9IEhhclxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuXG5mdW5jdGlvbiByYW5kb21TdHJpbmcgKHNpemUpIHtcbiAgdmFyIGJpdHMgPSAoc2l6ZSArIDEpICogNlxuICB2YXIgYnVmZmVyID0gY3J5cHRvLnJhbmRvbUJ5dGVzKE1hdGguY2VpbChiaXRzIC8gOCkpXG4gIHZhciBzdHJpbmcgPSBidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoLz0vZywgJycpXG4gIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGF5bG9hZEhhc2ggKHBheWxvYWQsIGFsZ29yaXRobSwgY29udGVudFR5cGUpIHtcbiAgdmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0pXG4gIGhhc2gudXBkYXRlKCdoYXdrLjEucGF5bG9hZFxcbicpXG4gIGhhc2gudXBkYXRlKChjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCkgOiAnJykgKyAnXFxuJylcbiAgaGFzaC51cGRhdGUocGF5bG9hZCB8fCAnJylcbiAgaGFzaC51cGRhdGUoJ1xcbicpXG4gIHJldHVybiBoYXNoLmRpZ2VzdCgnYmFzZTY0Jylcbn1cblxuZXhwb3J0cy5jYWxjdWxhdGVNYWMgPSBmdW5jdGlvbiAoY3JlZGVudGlhbHMsIG9wdHMpIHtcbiAgdmFyIG5vcm1hbGl6ZWQgPSAnaGF3ay4xLmhlYWRlclxcbicgK1xuICAgIG9wdHMudHMgKyAnXFxuJyArXG4gICAgb3B0cy5ub25jZSArICdcXG4nICtcbiAgICAob3B0cy5tZXRob2QgfHwgJycpLnRvVXBwZXJDYXNlKCkgKyAnXFxuJyArXG4gICAgb3B0cy5yZXNvdXJjZSArICdcXG4nICtcbiAgICBvcHRzLmhvc3QudG9Mb3dlckNhc2UoKSArICdcXG4nICtcbiAgICBvcHRzLnBvcnQgKyAnXFxuJyArXG4gICAgKG9wdHMuaGFzaCB8fCAnJykgKyAnXFxuJ1xuXG4gIGlmIChvcHRzLmV4dCkge1xuICAgIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVkICsgb3B0cy5leHQucmVwbGFjZSgnXFxcXCcsICdcXFxcXFxcXCcpLnJlcGxhY2UoJ1xcbicsICdcXFxcbicpXG4gIH1cblxuICBub3JtYWxpemVkID0gbm9ybWFsaXplZCArICdcXG4nXG5cbiAgaWYgKG9wdHMuYXBwKSB7XG4gICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgKyBvcHRzLmFwcCArICdcXG4nICsgKG9wdHMuZGxnIHx8ICcnKSArICdcXG4nXG4gIH1cblxuICB2YXIgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGNyZWRlbnRpYWxzLmFsZ29yaXRobSwgY3JlZGVudGlhbHMua2V5KS51cGRhdGUobm9ybWFsaXplZClcbiAgdmFyIGRpZ2VzdCA9IGhtYWMuZGlnZXN0KCdiYXNlNjQnKVxuICByZXR1cm4gZGlnZXN0XG59XG5cbmV4cG9ydHMuaGVhZGVyID0gZnVuY3Rpb24gKHVyaSwgbWV0aG9kLCBvcHRzKSB7XG4gIHZhciB0aW1lc3RhbXAgPSBvcHRzLnRpbWVzdGFtcCB8fCBNYXRoLmZsb29yKChEYXRlLm5vdygpICsgKG9wdHMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKSkgLyAxMDAwKVxuICB2YXIgY3JlZGVudGlhbHMgPSBvcHRzLmNyZWRlbnRpYWxzXG4gIGlmICghY3JlZGVudGlhbHMgfHwgIWNyZWRlbnRpYWxzLmlkIHx8ICFjcmVkZW50aWFscy5rZXkgfHwgIWNyZWRlbnRpYWxzLmFsZ29yaXRobSkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKFsnc2hhMScsICdzaGEyNTYnXS5pbmRleE9mKGNyZWRlbnRpYWxzLmFsZ29yaXRobSkgPT09IC0xKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICB2YXIgYXJ0aWZhY3RzID0ge1xuICAgIHRzOiB0aW1lc3RhbXAsXG4gICAgbm9uY2U6IG9wdHMubm9uY2UgfHwgcmFuZG9tU3RyaW5nKDYpLFxuICAgIG1ldGhvZDogbWV0aG9kLFxuICAgIHJlc291cmNlOiB1cmkucGF0aG5hbWUgKyAodXJpLnNlYXJjaCB8fCAnJyksXG4gICAgaG9zdDogdXJpLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09ICdodHRwOicgPyA4MCA6IDQ0MyksXG4gICAgaGFzaDogb3B0cy5oYXNoLFxuICAgIGV4dDogb3B0cy5leHQsXG4gICAgYXBwOiBvcHRzLmFwcCxcbiAgICBkbGc6IG9wdHMuZGxnXG4gIH1cblxuICBpZiAoIWFydGlmYWN0cy5oYXNoICYmIChvcHRzLnBheWxvYWQgfHwgb3B0cy5wYXlsb2FkID09PSAnJykpIHtcbiAgICBhcnRpZmFjdHMuaGFzaCA9IGNhbGN1bGF0ZVBheWxvYWRIYXNoKG9wdHMucGF5bG9hZCwgY3JlZGVudGlhbHMuYWxnb3JpdGhtLCBvcHRzLmNvbnRlbnRUeXBlKVxuICB9XG5cbiAgdmFyIG1hYyA9IGV4cG9ydHMuY2FsY3VsYXRlTWFjKGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMpXG5cbiAgdmFyIGhhc0V4dCA9IGFydGlmYWN0cy5leHQgIT09IG51bGwgJiYgYXJ0aWZhY3RzLmV4dCAhPT0gdW5kZWZpbmVkICYmIGFydGlmYWN0cy5leHQgIT09ICcnXG4gIHZhciBoZWFkZXIgPSAnSGF3ayBpZD1cIicgKyBjcmVkZW50aWFscy5pZCArXG4gICAgJ1wiLCB0cz1cIicgKyBhcnRpZmFjdHMudHMgK1xuICAgICdcIiwgbm9uY2U9XCInICsgYXJ0aWZhY3RzLm5vbmNlICtcbiAgICAoYXJ0aWZhY3RzLmhhc2ggPyAnXCIsIGhhc2g9XCInICsgYXJ0aWZhY3RzLmhhc2ggOiAnJykgK1xuICAgIChoYXNFeHQgPyAnXCIsIGV4dD1cIicgKyBhcnRpZmFjdHMuZXh0LnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpIDogJycpICtcbiAgICAnXCIsIG1hYz1cIicgKyBtYWMgKyAnXCInXG5cbiAgaWYgKGFydGlmYWN0cy5hcHApIHtcbiAgICBoZWFkZXIgPSBoZWFkZXIgKyAnLCBhcHA9XCInICsgYXJ0aWZhY3RzLmFwcCArIChhcnRpZmFjdHMuZGxnID8gJ1wiLCBkbGc9XCInICsgYXJ0aWZhY3RzLmRsZyA6ICcnKSArICdcIidcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIganNvblNhZmVTdHJpbmdpZnkgPSByZXF1aXJlKCdqc29uLXN0cmluZ2lmeS1zYWZlJylcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBkZWZlciA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICd1bmRlZmluZWQnXG4gID8gcHJvY2Vzcy5uZXh0VGlja1xuICA6IHNldEltbWVkaWF0ZVxuXG5mdW5jdGlvbiBwYXJhbXNIYXZlUmVxdWVzdEJvZHkgKHBhcmFtcykge1xuICByZXR1cm4gKFxuICAgIHBhcmFtcy5ib2R5IHx8XG4gICAgcGFyYW1zLnJlcXVlc3RCb2R5U3RyZWFtIHx8XG4gICAgKHBhcmFtcy5qc29uICYmIHR5cGVvZiBwYXJhbXMuanNvbiAhPT0gJ2Jvb2xlYW4nKSB8fFxuICAgIHBhcmFtcy5tdWx0aXBhcnRcbiAgKVxufVxuXG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5IChvYmosIHJlcGxhY2VyKSB7XG4gIHZhciByZXRcbiAgdHJ5IHtcbiAgICByZXQgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyKVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0ID0ganNvblNhZmVTdHJpbmdpZnkob2JqLCByZXBsYWNlcilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIG1kNSAoc3RyKSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKHN0cikuZGlnZXN0KCdoZXgnKVxufVxuXG5mdW5jdGlvbiBpc1JlYWRTdHJlYW0gKHJzKSB7XG4gIHJldHVybiBycy5yZWFkYWJsZSAmJiBycy5wYXRoICYmIHJzLm1vZGVcbn1cblxuZnVuY3Rpb24gdG9CYXNlNjQgKHN0cikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc3RyIHx8ICcnLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiBjb3B5IChvYmopIHtcbiAgdmFyIG8gPSB7fVxuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICBvW2ldID0gb2JqW2ldXG4gIH0pXG4gIHJldHVybiBvXG59XG5cbmZ1bmN0aW9uIHZlcnNpb24gKCkge1xuICB2YXIgbnVtYmVycyA9IHByb2Nlc3MudmVyc2lvbi5yZXBsYWNlKCd2JywgJycpLnNwbGl0KCcuJylcbiAgcmV0dXJuIHtcbiAgICBtYWpvcjogcGFyc2VJbnQobnVtYmVyc1swXSwgMTApLFxuICAgIG1pbm9yOiBwYXJzZUludChudW1iZXJzWzFdLCAxMCksXG4gICAgcGF0Y2g6IHBhcnNlSW50KG51bWJlcnNbMl0sIDEwKVxuICB9XG59XG5cbmV4cG9ydHMucGFyYW1zSGF2ZVJlcXVlc3RCb2R5ID0gcGFyYW1zSGF2ZVJlcXVlc3RCb2R5XG5leHBvcnRzLnNhZmVTdHJpbmdpZnkgPSBzYWZlU3RyaW5naWZ5XG5leHBvcnRzLm1kNSA9IG1kNVxuZXhwb3J0cy5pc1JlYWRTdHJlYW0gPSBpc1JlYWRTdHJlYW1cbmV4cG9ydHMudG9CYXNlNjQgPSB0b0Jhc2U2NFxuZXhwb3J0cy5jb3B5ID0gY29weVxuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvblxuZXhwb3J0cy5kZWZlciA9IGRlZmVyXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHV1aWQgPSByZXF1aXJlKCd1dWlkL3Y0JylcbnZhciBDb21iaW5lZFN0cmVhbSA9IHJlcXVpcmUoJ2NvbWJpbmVkLXN0cmVhbScpXG52YXIgaXNzdHJlYW0gPSByZXF1aXJlKCdpc3N0cmVhbScpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuZnVuY3Rpb24gTXVsdGlwYXJ0IChyZXF1ZXN0KSB7XG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3RcbiAgdGhpcy5ib3VuZGFyeSA9IHV1aWQoKVxuICB0aGlzLmNodW5rZWQgPSBmYWxzZVxuICB0aGlzLmJvZHkgPSBudWxsXG59XG5cbk11bHRpcGFydC5wcm90b3R5cGUuaXNDaHVua2VkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBjaHVua2VkID0gZmFsc2VcbiAgdmFyIHBhcnRzID0gb3B0aW9ucy5kYXRhIHx8IG9wdGlvbnNcblxuICBpZiAoIXBhcnRzLmZvckVhY2gpIHtcbiAgICBzZWxmLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0FyZ3VtZW50IGVycm9yLCBvcHRpb25zLm11bHRpcGFydC4nKSlcbiAgfVxuXG4gIGlmIChvcHRpb25zLmNodW5rZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNodW5rZWQgPSBvcHRpb25zLmNodW5rZWRcbiAgfVxuXG4gIGlmIChzZWxmLnJlcXVlc3QuZ2V0SGVhZGVyKCd0cmFuc2Zlci1lbmNvZGluZycpID09PSAnY2h1bmtlZCcpIHtcbiAgICBjaHVua2VkID0gdHJ1ZVxuICB9XG5cbiAgaWYgKCFjaHVua2VkKSB7XG4gICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0LmJvZHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNlbGYucmVxdWVzdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQm9keSBhdHRyaWJ1dGUgbWlzc2luZyBpbiBtdWx0aXBhcnQuJykpXG4gICAgICB9XG4gICAgICBpZiAoaXNzdHJlYW0ocGFydC5ib2R5KSkge1xuICAgICAgICBjaHVua2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gY2h1bmtlZFxufVxuXG5NdWx0aXBhcnQucHJvdG90eXBlLnNldEhlYWRlcnMgPSBmdW5jdGlvbiAoY2h1bmtlZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoY2h1bmtlZCAmJiAhc2VsZi5yZXF1ZXN0Lmhhc0hlYWRlcigndHJhbnNmZXItZW5jb2RpbmcnKSkge1xuICAgIHNlbGYucmVxdWVzdC5zZXRIZWFkZXIoJ3RyYW5zZmVyLWVuY29kaW5nJywgJ2NodW5rZWQnKVxuICB9XG5cbiAgdmFyIGhlYWRlciA9IHNlbGYucmVxdWVzdC5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpXG5cbiAgaWYgKCFoZWFkZXIgfHwgaGVhZGVyLmluZGV4T2YoJ211bHRpcGFydCcpID09PSAtMSkge1xuICAgIHNlbGYucmVxdWVzdC5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdtdWx0aXBhcnQvcmVsYXRlZDsgYm91bmRhcnk9JyArIHNlbGYuYm91bmRhcnkpXG4gIH0gZWxzZSB7XG4gICAgaWYgKGhlYWRlci5pbmRleE9mKCdib3VuZGFyeScpICE9PSAtMSkge1xuICAgICAgc2VsZi5ib3VuZGFyeSA9IGhlYWRlci5yZXBsYWNlKC8uKmJvdW5kYXJ5PShbXlxccztdKykuKi8sICckMScpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYucmVxdWVzdC5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIGhlYWRlciArICc7IGJvdW5kYXJ5PScgKyBzZWxmLmJvdW5kYXJ5KVxuICAgIH1cbiAgfVxufVxuXG5NdWx0aXBhcnQucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKHBhcnRzLCBjaHVua2VkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgYm9keSA9IGNodW5rZWQgPyBuZXcgQ29tYmluZWRTdHJlYW0oKSA6IFtdXG5cbiAgZnVuY3Rpb24gYWRkIChwYXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgcGFydCA9IHBhcnQudG9TdHJpbmcoKVxuICAgIH1cbiAgICByZXR1cm4gY2h1bmtlZCA/IGJvZHkuYXBwZW5kKHBhcnQpIDogYm9keS5wdXNoKEJ1ZmZlci5mcm9tKHBhcnQpKVxuICB9XG5cbiAgaWYgKHNlbGYucmVxdWVzdC5wcmVhbWJsZUNSTEYpIHtcbiAgICBhZGQoJ1xcclxcbicpXG4gIH1cblxuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgdmFyIHByZWFtYmxlID0gJy0tJyArIHNlbGYuYm91bmRhcnkgKyAnXFxyXFxuJ1xuICAgIE9iamVjdC5rZXlzKHBhcnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2JvZHknKSB7IHJldHVybiB9XG4gICAgICBwcmVhbWJsZSArPSBrZXkgKyAnOiAnICsgcGFydFtrZXldICsgJ1xcclxcbidcbiAgICB9KVxuICAgIHByZWFtYmxlICs9ICdcXHJcXG4nXG4gICAgYWRkKHByZWFtYmxlKVxuICAgIGFkZChwYXJ0LmJvZHkpXG4gICAgYWRkKCdcXHJcXG4nKVxuICB9KVxuICBhZGQoJy0tJyArIHNlbGYuYm91bmRhcnkgKyAnLS0nKVxuXG4gIGlmIChzZWxmLnJlcXVlc3QucG9zdGFtYmxlQ1JMRikge1xuICAgIGFkZCgnXFxyXFxuJylcbiAgfVxuXG4gIHJldHVybiBib2R5XG59XG5cbk11bHRpcGFydC5wcm90b3R5cGUub25SZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdmFyIGNodW5rZWQgPSBzZWxmLmlzQ2h1bmtlZChvcHRpb25zKVxuICB2YXIgcGFydHMgPSBvcHRpb25zLmRhdGEgfHwgb3B0aW9uc1xuXG4gIHNlbGYuc2V0SGVhZGVycyhjaHVua2VkKVxuICBzZWxmLmNodW5rZWQgPSBjaHVua2VkXG4gIHNlbGYuYm9keSA9IHNlbGYuYnVpbGQocGFydHMsIGNodW5rZWQpXG59XG5cbmV4cG9ydHMuTXVsdGlwYXJ0ID0gTXVsdGlwYXJ0XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG52YXIgcXMgPSByZXF1aXJlKCdxcycpXG52YXIgY2FzZWxlc3MgPSByZXF1aXJlKCdjYXNlbGVzcycpXG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQvdjQnKVxudmFyIG9hdXRoID0gcmVxdWlyZSgnb2F1dGgtc2lnbicpXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5mdW5jdGlvbiBPQXV0aCAocmVxdWVzdCkge1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gIHRoaXMucGFyYW1zID0gbnVsbFxufVxuXG5PQXV0aC5wcm90b3R5cGUuYnVpbGRQYXJhbXMgPSBmdW5jdGlvbiAoX29hdXRoLCB1cmksIG1ldGhvZCwgcXVlcnksIGZvcm0sIHFzTGliKSB7XG4gIHZhciBvYSA9IHt9XG4gIGZvciAodmFyIGkgaW4gX29hdXRoKSB7XG4gICAgb2FbJ29hdXRoXycgKyBpXSA9IF9vYXV0aFtpXVxuICB9XG4gIGlmICghb2Eub2F1dGhfdmVyc2lvbikge1xuICAgIG9hLm9hdXRoX3ZlcnNpb24gPSAnMS4wJ1xuICB9XG4gIGlmICghb2Eub2F1dGhfdGltZXN0YW1wKSB7XG4gICAgb2Eub2F1dGhfdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkudG9TdHJpbmcoKVxuICB9XG4gIGlmICghb2Eub2F1dGhfbm9uY2UpIHtcbiAgICBvYS5vYXV0aF9ub25jZSA9IHV1aWQoKS5yZXBsYWNlKC8tL2csICcnKVxuICB9XG4gIGlmICghb2Eub2F1dGhfc2lnbmF0dXJlX21ldGhvZCkge1xuICAgIG9hLm9hdXRoX3NpZ25hdHVyZV9tZXRob2QgPSAnSE1BQy1TSEExJ1xuICB9XG5cbiAgdmFyIGNvbnN1bWVyX3NlY3JldF9vcl9wcml2YXRlX2tleSA9IG9hLm9hdXRoX2NvbnN1bWVyX3NlY3JldCB8fCBvYS5vYXV0aF9wcml2YXRlX2tleSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICBkZWxldGUgb2Eub2F1dGhfY29uc3VtZXJfc2VjcmV0XG4gIGRlbGV0ZSBvYS5vYXV0aF9wcml2YXRlX2tleVxuXG4gIHZhciB0b2tlbl9zZWNyZXQgPSBvYS5vYXV0aF90b2tlbl9zZWNyZXQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgZGVsZXRlIG9hLm9hdXRoX3Rva2VuX3NlY3JldFxuXG4gIHZhciByZWFsbSA9IG9hLm9hdXRoX3JlYWxtXG4gIGRlbGV0ZSBvYS5vYXV0aF9yZWFsbVxuICBkZWxldGUgb2Eub2F1dGhfdHJhbnNwb3J0X21ldGhvZFxuXG4gIHZhciBiYXNldXJsID0gdXJpLnByb3RvY29sICsgJy8vJyArIHVyaS5ob3N0ICsgdXJpLnBhdGhuYW1lXG4gIHZhciBwYXJhbXMgPSBxc0xpYi5wYXJzZShbXS5jb25jYXQocXVlcnksIGZvcm0sIHFzTGliLnN0cmluZ2lmeShvYSkpLmpvaW4oJyYnKSlcblxuICBvYS5vYXV0aF9zaWduYXR1cmUgPSBvYXV0aC5zaWduKFxuICAgIG9hLm9hdXRoX3NpZ25hdHVyZV9tZXRob2QsXG4gICAgbWV0aG9kLFxuICAgIGJhc2V1cmwsXG4gICAgcGFyYW1zLFxuICAgIGNvbnN1bWVyX3NlY3JldF9vcl9wcml2YXRlX2tleSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICB0b2tlbl9zZWNyZXQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgKVxuXG4gIGlmIChyZWFsbSkge1xuICAgIG9hLnJlYWxtID0gcmVhbG1cbiAgfVxuXG4gIHJldHVybiBvYVxufVxuXG5PQXV0aC5wcm90b3R5cGUuYnVpbGRCb2R5SGFzaCA9IGZ1bmN0aW9uIChfb2F1dGgsIGJvZHkpIHtcbiAgaWYgKFsnSE1BQy1TSEExJywgJ1JTQS1TSEExJ10uaW5kZXhPZihfb2F1dGguc2lnbmF0dXJlX21ldGhvZCB8fCAnSE1BQy1TSEExJykgPCAwKSB7XG4gICAgdGhpcy5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvYXV0aDogJyArIF9vYXV0aC5zaWduYXR1cmVfbWV0aG9kICtcbiAgICAgICcgc2lnbmF0dXJlX21ldGhvZCBub3Qgc3VwcG9ydGVkIHdpdGggYm9keV9oYXNoIHNpZ25pbmcuJykpXG4gIH1cblxuICB2YXIgc2hhc3VtID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKVxuICBzaGFzdW0udXBkYXRlKGJvZHkgfHwgJycpXG4gIHZhciBzaGExID0gc2hhc3VtLmRpZ2VzdCgnaGV4JylcblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2hhMSwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKVxufVxuXG5PQXV0aC5wcm90b3R5cGUuY29uY2F0UGFyYW1zID0gZnVuY3Rpb24gKG9hLCBzZXAsIHdyYXApIHtcbiAgd3JhcCA9IHdyYXAgfHwgJydcblxuICB2YXIgcGFyYW1zID0gT2JqZWN0LmtleXMob2EpLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpICE9PSAncmVhbG0nICYmIGkgIT09ICdvYXV0aF9zaWduYXR1cmUnXG4gIH0pLnNvcnQoKVxuXG4gIGlmIChvYS5yZWFsbSkge1xuICAgIHBhcmFtcy5zcGxpY2UoMCwgMCwgJ3JlYWxtJylcbiAgfVxuICBwYXJhbXMucHVzaCgnb2F1dGhfc2lnbmF0dXJlJylcblxuICByZXR1cm4gcGFyYW1zLm1hcChmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpICsgJz0nICsgd3JhcCArIG9hdXRoLnJmYzM5ODYob2FbaV0pICsgd3JhcFxuICB9KS5qb2luKHNlcClcbn1cblxuT0F1dGgucHJvdG90eXBlLm9uUmVxdWVzdCA9IGZ1bmN0aW9uIChfb2F1dGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYucGFyYW1zID0gX29hdXRoXG5cbiAgdmFyIHVyaSA9IHNlbGYucmVxdWVzdC51cmkgfHwge31cbiAgdmFyIG1ldGhvZCA9IHNlbGYucmVxdWVzdC5tZXRob2QgfHwgJydcbiAgdmFyIGhlYWRlcnMgPSBjYXNlbGVzcyhzZWxmLnJlcXVlc3QuaGVhZGVycylcbiAgdmFyIGJvZHkgPSBzZWxmLnJlcXVlc3QuYm9keSB8fCAnJ1xuICB2YXIgcXNMaWIgPSBzZWxmLnJlcXVlc3QucXNMaWIgfHwgcXNcblxuICB2YXIgZm9ybVxuICB2YXIgcXVlcnlcbiAgdmFyIGNvbnRlbnRUeXBlID0gaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnXG4gIHZhciBmb3JtQ29udGVudFR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICB2YXIgdHJhbnNwb3J0ID0gX29hdXRoLnRyYW5zcG9ydF9tZXRob2QgfHwgJ2hlYWRlcidcblxuICBpZiAoY29udGVudFR5cGUuc2xpY2UoMCwgZm9ybUNvbnRlbnRUeXBlLmxlbmd0aCkgPT09IGZvcm1Db250ZW50VHlwZSkge1xuICAgIGNvbnRlbnRUeXBlID0gZm9ybUNvbnRlbnRUeXBlXG4gICAgZm9ybSA9IGJvZHlcbiAgfVxuICBpZiAodXJpLnF1ZXJ5KSB7XG4gICAgcXVlcnkgPSB1cmkucXVlcnlcbiAgfVxuICBpZiAodHJhbnNwb3J0ID09PSAnYm9keScgJiYgKG1ldGhvZCAhPT0gJ1BPU1QnIHx8IGNvbnRlbnRUeXBlICE9PSBmb3JtQ29udGVudFR5cGUpKSB7XG4gICAgc2VsZi5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvYXV0aDogdHJhbnNwb3J0X21ldGhvZCBvZiBib2R5IHJlcXVpcmVzIFBPU1QgJyArXG4gICAgICAnYW5kIGNvbnRlbnQtdHlwZSAnICsgZm9ybUNvbnRlbnRUeXBlKSlcbiAgfVxuXG4gIGlmICghZm9ybSAmJiB0eXBlb2YgX29hdXRoLmJvZHlfaGFzaCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgX29hdXRoLmJvZHlfaGFzaCA9IHNlbGYuYnVpbGRCb2R5SGFzaChfb2F1dGgsIHNlbGYucmVxdWVzdC5ib2R5LnRvU3RyaW5nKCkpXG4gIH1cblxuICB2YXIgb2EgPSBzZWxmLmJ1aWxkUGFyYW1zKF9vYXV0aCwgdXJpLCBtZXRob2QsIHF1ZXJ5LCBmb3JtLCBxc0xpYilcblxuICBzd2l0Y2ggKHRyYW5zcG9ydCkge1xuICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBzZWxmLnJlcXVlc3Quc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ09BdXRoICcgKyBzZWxmLmNvbmNhdFBhcmFtcyhvYSwgJywnLCAnXCInKSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICB2YXIgaHJlZiA9IHNlbGYucmVxdWVzdC51cmkuaHJlZiArPSAocXVlcnkgPyAnJicgOiAnPycpICsgc2VsZi5jb25jYXRQYXJhbXMob2EsICcmJylcbiAgICAgIHNlbGYucmVxdWVzdC51cmkgPSB1cmwucGFyc2UoaHJlZilcbiAgICAgIHNlbGYucmVxdWVzdC5wYXRoID0gc2VsZi5yZXF1ZXN0LnVyaS5wYXRoXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnYm9keSc6XG4gICAgICBzZWxmLnJlcXVlc3QuYm9keSA9IChmb3JtID8gZm9ybSArICcmJyA6ICcnKSArIHNlbGYuY29uY2F0UGFyYW1zKG9hLCAnJicpXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHNlbGYucmVxdWVzdC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb2F1dGg6IHRyYW5zcG9ydF9tZXRob2QgaW52YWxpZCcpKVxuICB9XG59XG5cbmV4cG9ydHMuT0F1dGggPSBPQXV0aFxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBxcyA9IHJlcXVpcmUoJ3FzJylcbnZhciBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcblxuZnVuY3Rpb24gUXVlcnlzdHJpbmcgKHJlcXVlc3QpIHtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICB0aGlzLmxpYiA9IG51bGxcbiAgdGhpcy51c2VRdWVyeXN0cmluZyA9IG51bGxcbiAgdGhpcy5wYXJzZU9wdGlvbnMgPSBudWxsXG4gIHRoaXMuc3RyaW5naWZ5T3B0aW9ucyA9IG51bGxcbn1cblxuUXVlcnlzdHJpbmcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAodGhpcy5saWIpIHsgcmV0dXJuIH1cblxuICB0aGlzLnVzZVF1ZXJ5c3RyaW5nID0gb3B0aW9ucy51c2VRdWVyeXN0cmluZ1xuICB0aGlzLmxpYiA9ICh0aGlzLnVzZVF1ZXJ5c3RyaW5nID8gcXVlcnlzdHJpbmcgOiBxcylcblxuICB0aGlzLnBhcnNlT3B0aW9ucyA9IG9wdGlvbnMucXNQYXJzZU9wdGlvbnMgfHwge31cbiAgdGhpcy5zdHJpbmdpZnlPcHRpb25zID0gb3B0aW9ucy5xc1N0cmluZ2lmeU9wdGlvbnMgfHwge31cbn1cblxuUXVlcnlzdHJpbmcucHJvdG90eXBlLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuICh0aGlzLnVzZVF1ZXJ5c3RyaW5nKVxuICAgID8gdGhpcy5yZmMzOTg2KHRoaXMubGliLnN0cmluZ2lmeShvYmosXG4gICAgICB0aGlzLnN0cmluZ2lmeU9wdGlvbnMuc2VwIHx8IG51bGwsXG4gICAgICB0aGlzLnN0cmluZ2lmeU9wdGlvbnMuZXEgfHwgbnVsbCxcbiAgICAgIHRoaXMuc3RyaW5naWZ5T3B0aW9ucykpXG4gICAgOiB0aGlzLmxpYi5zdHJpbmdpZnkob2JqLCB0aGlzLnN0cmluZ2lmeU9wdGlvbnMpXG59XG5cblF1ZXJ5c3RyaW5nLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuICh0aGlzLnVzZVF1ZXJ5c3RyaW5nKVxuICAgID8gdGhpcy5saWIucGFyc2Uoc3RyLFxuICAgICAgdGhpcy5wYXJzZU9wdGlvbnMuc2VwIHx8IG51bGwsXG4gICAgICB0aGlzLnBhcnNlT3B0aW9ucy5lcSB8fCBudWxsLFxuICAgICAgdGhpcy5wYXJzZU9wdGlvbnMpXG4gICAgOiB0aGlzLmxpYi5wYXJzZShzdHIsIHRoaXMucGFyc2VPcHRpb25zKVxufVxuXG5RdWVyeXN0cmluZy5wcm90b3R5cGUucmZjMzk4NiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG5RdWVyeXN0cmluZy5wcm90b3R5cGUudW5lc2NhcGUgPSBxdWVyeXN0cmluZy51bmVzY2FwZVxuXG5leHBvcnRzLlF1ZXJ5c3RyaW5nID0gUXVlcnlzdHJpbmdcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbnZhciBpc1VybCA9IC9eaHR0cHM/Oi9cblxuZnVuY3Rpb24gUmVkaXJlY3QgKHJlcXVlc3QpIHtcbiAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFxuICB0aGlzLmZvbGxvd1JlZGlyZWN0ID0gdHJ1ZVxuICB0aGlzLmZvbGxvd1JlZGlyZWN0cyA9IHRydWVcbiAgdGhpcy5mb2xsb3dBbGxSZWRpcmVjdHMgPSBmYWxzZVxuICB0aGlzLmZvbGxvd09yaWdpbmFsSHR0cE1ldGhvZCA9IGZhbHNlXG4gIHRoaXMuYWxsb3dSZWRpcmVjdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfVxuICB0aGlzLm1heFJlZGlyZWN0cyA9IDEwXG4gIHRoaXMucmVkaXJlY3RzID0gW11cbiAgdGhpcy5yZWRpcmVjdHNGb2xsb3dlZCA9IDBcbiAgdGhpcy5yZW1vdmVSZWZlcmVySGVhZGVyID0gZmFsc2Vcbn1cblxuUmVkaXJlY3QucHJvdG90eXBlLm9uUmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChvcHRpb25zLm1heFJlZGlyZWN0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5tYXhSZWRpcmVjdHMgPSBvcHRpb25zLm1heFJlZGlyZWN0c1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5mb2xsb3dSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuYWxsb3dSZWRpcmVjdCA9IG9wdGlvbnMuZm9sbG93UmVkaXJlY3RcbiAgfVxuICBpZiAob3B0aW9ucy5mb2xsb3dSZWRpcmVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5mb2xsb3dSZWRpcmVjdHMgPSAhIW9wdGlvbnMuZm9sbG93UmVkaXJlY3RcbiAgfVxuICBpZiAob3B0aW9ucy5mb2xsb3dBbGxSZWRpcmVjdHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzID0gb3B0aW9ucy5mb2xsb3dBbGxSZWRpcmVjdHNcbiAgfVxuICBpZiAoc2VsZi5mb2xsb3dSZWRpcmVjdHMgfHwgc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMpIHtcbiAgICBzZWxmLnJlZGlyZWN0cyA9IHNlbGYucmVkaXJlY3RzIHx8IFtdXG4gIH1cbiAgaWYgKG9wdGlvbnMucmVtb3ZlUmVmZXJlckhlYWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VsZi5yZW1vdmVSZWZlcmVySGVhZGVyID0gb3B0aW9ucy5yZW1vdmVSZWZlcmVySGVhZGVyXG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9sbG93T3JpZ2luYWxIdHRwTWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZWxmLmZvbGxvd09yaWdpbmFsSHR0cE1ldGhvZCA9IG9wdGlvbnMuZm9sbG93T3JpZ2luYWxIdHRwTWV0aG9kXG4gIH1cbn1cblxuUmVkaXJlY3QucHJvdG90eXBlLnJlZGlyZWN0VG8gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciByZXF1ZXN0ID0gc2VsZi5yZXF1ZXN0XG5cbiAgdmFyIHJlZGlyZWN0VG8gPSBudWxsXG4gIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCAmJiByZXNwb25zZS5zdGF0dXNDb2RlIDwgNDAwICYmIHJlc3BvbnNlLmNhc2VsZXNzLmhhcygnbG9jYXRpb24nKSkge1xuICAgIHZhciBsb2NhdGlvbiA9IHJlc3BvbnNlLmNhc2VsZXNzLmdldCgnbG9jYXRpb24nKVxuICAgIHJlcXVlc3QuZGVidWcoJ3JlZGlyZWN0JywgbG9jYXRpb24pXG5cbiAgICBpZiAoc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMpIHtcbiAgICAgIHJlZGlyZWN0VG8gPSBsb2NhdGlvblxuICAgIH0gZWxzZSBpZiAoc2VsZi5mb2xsb3dSZWRpcmVjdHMpIHtcbiAgICAgIHN3aXRjaCAocmVxdWVzdC5tZXRob2QpIHtcbiAgICAgICAgY2FzZSAnUEFUQ0gnOlxuICAgICAgICBjYXNlICdQVVQnOlxuICAgICAgICBjYXNlICdQT1NUJzpcbiAgICAgICAgY2FzZSAnREVMRVRFJzpcbiAgICAgICAgICAvLyBEbyBub3QgZm9sbG93IHJlZGlyZWN0c1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVkaXJlY3RUbyA9IGxvY2F0aW9uXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDAxKSB7XG4gICAgdmFyIGF1dGhIZWFkZXIgPSByZXF1ZXN0Ll9hdXRoLm9uUmVzcG9uc2UocmVzcG9uc2UpXG4gICAgaWYgKGF1dGhIZWFkZXIpIHtcbiAgICAgIHJlcXVlc3Quc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgYXV0aEhlYWRlcilcbiAgICAgIHJlZGlyZWN0VG8gPSByZXF1ZXN0LnVyaVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVkaXJlY3RUb1xufVxuXG5SZWRpcmVjdC5wcm90b3R5cGUub25SZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlcXVlc3QgPSBzZWxmLnJlcXVlc3RcblxuICB2YXIgcmVkaXJlY3RUbyA9IHNlbGYucmVkaXJlY3RUbyhyZXNwb25zZSlcbiAgaWYgKCFyZWRpcmVjdFRvIHx8ICFzZWxmLmFsbG93UmVkaXJlY3QuY2FsbChyZXF1ZXN0LCByZXNwb25zZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJlcXVlc3QuZGVidWcoJ3JlZGlyZWN0IHRvJywgcmVkaXJlY3RUbylcblxuICAvLyBpZ25vcmUgYW55IHBvdGVudGlhbCByZXNwb25zZSBib2R5LiAgaXQgY2Fubm90IHBvc3NpYmx5IGJlIHVzZWZ1bFxuICAvLyB0byB1cyBhdCB0aGlzIHBvaW50LlxuICAvLyByZXNwb25zZS5yZXN1bWUgc2hvdWxkIGJlIGRlZmluZWQsIGJ1dCBjaGVjayBhbnl3YXkgYmVmb3JlIGNhbGxpbmcuIFdvcmthcm91bmQgZm9yIGJyb3dzZXJpZnkuXG4gIGlmIChyZXNwb25zZS5yZXN1bWUpIHtcbiAgICByZXNwb25zZS5yZXN1bWUoKVxuICB9XG5cbiAgaWYgKHNlbGYucmVkaXJlY3RzRm9sbG93ZWQgPj0gc2VsZi5tYXhSZWRpcmVjdHMpIHtcbiAgICByZXF1ZXN0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdFeGNlZWRlZCBtYXhSZWRpcmVjdHMuIFByb2JhYmx5IHN0dWNrIGluIGEgcmVkaXJlY3QgbG9vcCAnICsgcmVxdWVzdC51cmkuaHJlZikpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgc2VsZi5yZWRpcmVjdHNGb2xsb3dlZCArPSAxXG5cbiAgaWYgKCFpc1VybC50ZXN0KHJlZGlyZWN0VG8pKSB7XG4gICAgcmVkaXJlY3RUbyA9IHVybC5yZXNvbHZlKHJlcXVlc3QudXJpLmhyZWYsIHJlZGlyZWN0VG8pXG4gIH1cblxuICB2YXIgdXJpUHJldiA9IHJlcXVlc3QudXJpXG4gIHJlcXVlc3QudXJpID0gdXJsLnBhcnNlKHJlZGlyZWN0VG8pXG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGNoYW5nZSBwcm90b2NvbCBmcm9tIGh0dHBzIHRvIGh0dHAgb3IgdmljZSB2ZXJzYVxuICBpZiAocmVxdWVzdC51cmkucHJvdG9jb2wgIT09IHVyaVByZXYucHJvdG9jb2wpIHtcbiAgICBkZWxldGUgcmVxdWVzdC5hZ2VudFxuICB9XG5cbiAgc2VsZi5yZWRpcmVjdHMucHVzaCh7IHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlZGlyZWN0VXJpOiByZWRpcmVjdFRvIH0pXG5cbiAgaWYgKHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzICYmIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgJiZcbiAgICByZXNwb25zZS5zdGF0dXNDb2RlICE9PSA0MDEgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMzA3KSB7XG4gICAgcmVxdWVzdC5tZXRob2QgPSBzZWxmLmZvbGxvd09yaWdpbmFsSHR0cE1ldGhvZCA/IHJlcXVlc3QubWV0aG9kIDogJ0dFVCdcbiAgfVxuICAvLyByZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnIC8vIEZvcmNlIGFsbCByZWRpcmVjdHMgdG8gdXNlIEdFVCB8fCBjb21tZW50ZWQgb3V0IGZpeGVzICMyMTVcbiAgZGVsZXRlIHJlcXVlc3Quc3JjXG4gIGRlbGV0ZSByZXF1ZXN0LnJlcVxuICBkZWxldGUgcmVxdWVzdC5fc3RhcnRlZFxuICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gNDAxICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDMwNykge1xuICAgIC8vIFJlbW92ZSBwYXJhbWV0ZXJzIGZyb20gdGhlIHByZXZpb3VzIHJlc3BvbnNlLCB1bmxlc3MgdGhpcyBpcyB0aGUgc2Vjb25kIHJlcXVlc3RcbiAgICAvLyBmb3IgYSBzZXJ2ZXIgdGhhdCByZXF1aXJlcyBkaWdlc3QgYXV0aGVudGljYXRpb24uXG4gICAgZGVsZXRlIHJlcXVlc3QuYm9keVxuICAgIGRlbGV0ZSByZXF1ZXN0Ll9mb3JtXG4gICAgaWYgKHJlcXVlc3QuaGVhZGVycykge1xuICAgICAgcmVxdWVzdC5yZW1vdmVIZWFkZXIoJ2hvc3QnKVxuICAgICAgcmVxdWVzdC5yZW1vdmVIZWFkZXIoJ2NvbnRlbnQtdHlwZScpXG4gICAgICByZXF1ZXN0LnJlbW92ZUhlYWRlcignY29udGVudC1sZW5ndGgnKVxuICAgICAgaWYgKHJlcXVlc3QudXJpLmhvc3RuYW1lICE9PSByZXF1ZXN0Lm9yaWdpbmFsSG9zdC5zcGxpdCgnOicpWzBdKSB7XG4gICAgICAgIC8vIFJlbW92ZSBhdXRob3JpemF0aW9uIGlmIGNoYW5naW5nIGhvc3RuYW1lcyAoYnV0IG5vdCBpZiBqdXN0XG4gICAgICAgIC8vIGNoYW5naW5nIHBvcnRzIG9yIHByb3RvY29scykuICBUaGlzIG1hdGNoZXMgdGhlIGJlaGF2aW9yIG9mIGN1cmw6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWdkZXIvY3VybC9ibG9iLzZiZWIwZWVlL2xpYi9odHRwLmMjTDcxMFxuICAgICAgICByZXF1ZXN0LnJlbW92ZUhlYWRlcignYXV0aG9yaXphdGlvbicpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzZWxmLnJlbW92ZVJlZmVyZXJIZWFkZXIpIHtcbiAgICByZXF1ZXN0LnNldEhlYWRlcigncmVmZXJlcicsIHVyaVByZXYuaHJlZilcbiAgfVxuXG4gIHJlcXVlc3QuZW1pdCgncmVkaXJlY3QnKVxuXG4gIHJlcXVlc3QuaW5pdCgpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0cy5SZWRpcmVjdCA9IFJlZGlyZWN0XG4iLCIndXNlIHN0cmljdCdcblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG52YXIgdHVubmVsID0gcmVxdWlyZSgndHVubmVsLWFnZW50JylcblxudmFyIGRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdCA9IFtcbiAgJ2FjY2VwdCcsXG4gICdhY2NlcHQtY2hhcnNldCcsXG4gICdhY2NlcHQtZW5jb2RpbmcnLFxuICAnYWNjZXB0LWxhbmd1YWdlJyxcbiAgJ2FjY2VwdC1yYW5nZXMnLFxuICAnY2FjaGUtY29udHJvbCcsXG4gICdjb250ZW50LWVuY29kaW5nJyxcbiAgJ2NvbnRlbnQtbGFuZ3VhZ2UnLFxuICAnY29udGVudC1sb2NhdGlvbicsXG4gICdjb250ZW50LW1kNScsXG4gICdjb250ZW50LXJhbmdlJyxcbiAgJ2NvbnRlbnQtdHlwZScsXG4gICdjb25uZWN0aW9uJyxcbiAgJ2RhdGUnLFxuICAnZXhwZWN0JyxcbiAgJ21heC1mb3J3YXJkcycsXG4gICdwcmFnbWEnLFxuICAncmVmZXJlcicsXG4gICd0ZScsXG4gICd1c2VyLWFnZW50JyxcbiAgJ3ZpYSdcbl1cblxudmFyIGRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBbXG4gICdwcm94eS1hdXRob3JpemF0aW9uJ1xuXVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RQcm94eUhvc3QgKHVyaU9iamVjdCkge1xuICB2YXIgcG9ydCA9IHVyaU9iamVjdC5wb3J0XG4gIHZhciBwcm90b2NvbCA9IHVyaU9iamVjdC5wcm90b2NvbFxuICB2YXIgcHJveHlIb3N0ID0gdXJpT2JqZWN0Lmhvc3RuYW1lICsgJzonXG5cbiAgaWYgKHBvcnQpIHtcbiAgICBwcm94eUhvc3QgKz0gcG9ydFxuICB9IGVsc2UgaWYgKHByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIHByb3h5SG9zdCArPSAnNDQzJ1xuICB9IGVsc2Uge1xuICAgIHByb3h5SG9zdCArPSAnODAnXG4gIH1cblxuICByZXR1cm4gcHJveHlIb3N0XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFByb3h5SGVhZGVyV2hpdGVMaXN0IChoZWFkZXJzLCBwcm94eUhlYWRlcldoaXRlTGlzdCkge1xuICB2YXIgd2hpdGVMaXN0ID0gcHJveHlIZWFkZXJXaGl0ZUxpc3RcbiAgICAucmVkdWNlKGZ1bmN0aW9uIChzZXQsIGhlYWRlcikge1xuICAgICAgc2V0W2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHRydWVcbiAgICAgIHJldHVybiBzZXRcbiAgICB9LCB7fSlcblxuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgIHJldHVybiB3aGl0ZUxpc3RbaGVhZGVyLnRvTG93ZXJDYXNlKCldXG4gICAgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uIChzZXQsIGhlYWRlcikge1xuICAgICAgc2V0W2hlYWRlcl0gPSBoZWFkZXJzW2hlYWRlcl1cbiAgICAgIHJldHVybiBzZXRcbiAgICB9LCB7fSlcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0VHVubmVsT3B0aW9ucyAocmVxdWVzdCwgcHJveHlIZWFkZXJzKSB7XG4gIHZhciBwcm94eSA9IHJlcXVlc3QucHJveHlcblxuICB2YXIgdHVubmVsT3B0aW9ucyA9IHtcbiAgICBwcm94eToge1xuICAgICAgaG9zdDogcHJveHkuaG9zdG5hbWUsXG4gICAgICBwb3J0OiArcHJveHkucG9ydCxcbiAgICAgIHByb3h5QXV0aDogcHJveHkuYXV0aCxcbiAgICAgIGhlYWRlcnM6IHByb3h5SGVhZGVyc1xuICAgIH0sXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgIGNhOiByZXF1ZXN0LmNhLFxuICAgIGNlcnQ6IHJlcXVlc3QuY2VydCxcbiAgICBrZXk6IHJlcXVlc3Qua2V5LFxuICAgIHBhc3NwaHJhc2U6IHJlcXVlc3QucGFzc3BocmFzZSxcbiAgICBwZng6IHJlcXVlc3QucGZ4LFxuICAgIGNpcGhlcnM6IHJlcXVlc3QuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHJlcXVlc3QucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHNlY3VyZU9wdGlvbnM6IHJlcXVlc3Quc2VjdXJlT3B0aW9ucyxcbiAgICBzZWN1cmVQcm90b2NvbDogcmVxdWVzdC5zZWN1cmVQcm90b2NvbFxuICB9XG5cbiAgcmV0dXJuIHR1bm5lbE9wdGlvbnNcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0VHVubmVsRm5OYW1lICh1cmksIHByb3h5KSB7XG4gIHZhciB1cmlQcm90b2NvbCA9ICh1cmkucHJvdG9jb2wgPT09ICdodHRwczonID8gJ2h0dHBzJyA6ICdodHRwJylcbiAgdmFyIHByb3h5UHJvdG9jb2wgPSAocHJveHkucHJvdG9jb2wgPT09ICdodHRwczonID8gJ0h0dHBzJyA6ICdIdHRwJylcbiAgcmV0dXJuIFt1cmlQcm90b2NvbCwgcHJveHlQcm90b2NvbF0uam9pbignT3ZlcicpXG59XG5cbmZ1bmN0aW9uIGdldFR1bm5lbEZuIChyZXF1ZXN0KSB7XG4gIHZhciB1cmkgPSByZXF1ZXN0LnVyaVxuICB2YXIgcHJveHkgPSByZXF1ZXN0LnByb3h5XG4gIHZhciB0dW5uZWxGbk5hbWUgPSBjb25zdHJ1Y3RUdW5uZWxGbk5hbWUodXJpLCBwcm94eSlcbiAgcmV0dXJuIHR1bm5lbFt0dW5uZWxGbk5hbWVdXG59XG5cbmZ1bmN0aW9uIFR1bm5lbCAocmVxdWVzdCkge1xuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gIHRoaXMucHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBkZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3RcbiAgdGhpcy5wcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBbXVxuICBpZiAodHlwZW9mIHJlcXVlc3QudHVubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMudHVubmVsT3ZlcnJpZGUgPSByZXF1ZXN0LnR1bm5lbFxuICB9XG59XG5cblR1bm5lbC5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlcXVlc3QgPSBzZWxmLnJlcXVlc3RcbiAgICAvLyBUdW5uZWwgSFRUUFMgYnkgZGVmYXVsdC4gQWxsb3cgdGhlIHVzZXIgdG8gb3ZlcnJpZGUgdGhpcyBzZXR0aW5nLlxuXG4gIC8vIElmIHNlbGYudHVubmVsT3ZlcnJpZGUgaXMgc2V0ICh0aGUgdXNlciBzcGVjaWZpZWQgYSB2YWx1ZSksIHVzZSBpdC5cbiAgaWYgKHR5cGVvZiBzZWxmLnR1bm5lbE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBzZWxmLnR1bm5lbE92ZXJyaWRlXG4gIH1cblxuICAvLyBJZiB0aGUgZGVzdGluYXRpb24gaXMgSFRUUFMsIHR1bm5lbC5cbiAgaWYgKHJlcXVlc3QudXJpLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGRvIG5vdCB1c2UgdHVubmVsLlxuICByZXR1cm4gZmFsc2Vcbn1cblxuVHVubmVsLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcmVxdWVzdCA9IHNlbGYucmVxdWVzdFxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHR5cGVvZiByZXF1ZXN0LnByb3h5ID09PSAnc3RyaW5nJykge1xuICAgIHJlcXVlc3QucHJveHkgPSB1cmwucGFyc2UocmVxdWVzdC5wcm94eSlcbiAgfVxuXG4gIGlmICghcmVxdWVzdC5wcm94eSB8fCAhcmVxdWVzdC50dW5uZWwpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFNldHVwIFByb3h5IEhlYWRlciBFeGNsdXNpdmUgTGlzdCBhbmQgV2hpdGUgTGlzdFxuICBpZiAob3B0aW9ucy5wcm94eUhlYWRlcldoaXRlTGlzdCkge1xuICAgIHNlbGYucHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBvcHRpb25zLnByb3h5SGVhZGVyV2hpdGVMaXN0XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0KSB7XG4gICAgc2VsZi5wcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBvcHRpb25zLnByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdFxuICB9XG5cbiAgdmFyIHByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCA9IHNlbGYucHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LmNvbmNhdChkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0KVxuICB2YXIgcHJveHlIZWFkZXJXaGl0ZUxpc3QgPSBzZWxmLnByb3h5SGVhZGVyV2hpdGVMaXN0LmNvbmNhdChwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QpXG5cbiAgLy8gU2V0dXAgUHJveHkgSGVhZGVycyBhbmQgUHJveHkgSGVhZGVycyBIb3N0XG4gIC8vIE9ubHkgc2VuZCB0aGUgUHJveHkgV2hpdGUgTGlzdGVkIEhlYWRlciBuYW1lc1xuICB2YXIgcHJveHlIZWFkZXJzID0gY29uc3RydWN0UHJveHlIZWFkZXJXaGl0ZUxpc3QocmVxdWVzdC5oZWFkZXJzLCBwcm94eUhlYWRlcldoaXRlTGlzdClcbiAgcHJveHlIZWFkZXJzLmhvc3QgPSBjb25zdHJ1Y3RQcm94eUhvc3QocmVxdWVzdC51cmkpXG5cbiAgcHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LmZvckVhY2gocmVxdWVzdC5yZW1vdmVIZWFkZXIsIHJlcXVlc3QpXG5cbiAgLy8gU2V0IEFnZW50IGZyb20gVHVubmVsIERhdGFcbiAgdmFyIHR1bm5lbEZuID0gZ2V0VHVubmVsRm4ocmVxdWVzdClcbiAgdmFyIHR1bm5lbE9wdGlvbnMgPSBjb25zdHJ1Y3RUdW5uZWxPcHRpb25zKHJlcXVlc3QsIHByb3h5SGVhZGVycylcbiAgcmVxdWVzdC5hZ2VudCA9IHR1bm5lbEZuKHR1bm5lbE9wdGlvbnMpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuVHVubmVsLmRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdCA9IGRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdFxuVHVubmVsLmRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0XG5leHBvcnRzLlR1bm5lbCA9IFR1bm5lbFxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbnZhciB6bGliID0gcmVxdWlyZSgnemxpYicpXG52YXIgYXdzMiA9IHJlcXVpcmUoJ2F3cy1zaWduMicpXG52YXIgYXdzNCA9IHJlcXVpcmUoJ2F3czQnKVxudmFyIGh0dHBTaWduYXR1cmUgPSByZXF1aXJlKCdodHRwLXNpZ25hdHVyZScpXG52YXIgbWltZSA9IHJlcXVpcmUoJ21pbWUtdHlwZXMnKVxudmFyIGNhc2VsZXNzID0gcmVxdWlyZSgnY2FzZWxlc3MnKVxudmFyIEZvcmV2ZXJBZ2VudCA9IHJlcXVpcmUoJ2ZvcmV2ZXItYWdlbnQnKVxudmFyIEZvcm1EYXRhID0gcmVxdWlyZSgnZm9ybS1kYXRhJylcbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQnKVxudmFyIGlzc3RyZWFtID0gcmVxdWlyZSgnaXNzdHJlYW0nKVxudmFyIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJ2lzLXR5cGVkYXJyYXknKS5zdHJpY3RcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9saWIvaGVscGVycycpXG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vbGliL2Nvb2tpZXMnKVxudmFyIGdldFByb3h5RnJvbVVSSSA9IHJlcXVpcmUoJy4vbGliL2dldFByb3h5RnJvbVVSSScpXG52YXIgUXVlcnlzdHJpbmcgPSByZXF1aXJlKCcuL2xpYi9xdWVyeXN0cmluZycpLlF1ZXJ5c3RyaW5nXG52YXIgSGFyID0gcmVxdWlyZSgnLi9saWIvaGFyJykuSGFyXG52YXIgQXV0aCA9IHJlcXVpcmUoJy4vbGliL2F1dGgnKS5BdXRoXG52YXIgT0F1dGggPSByZXF1aXJlKCcuL2xpYi9vYXV0aCcpLk9BdXRoXG52YXIgaGF3ayA9IHJlcXVpcmUoJy4vbGliL2hhd2snKVxudmFyIE11bHRpcGFydCA9IHJlcXVpcmUoJy4vbGliL211bHRpcGFydCcpLk11bHRpcGFydFxudmFyIFJlZGlyZWN0ID0gcmVxdWlyZSgnLi9saWIvcmVkaXJlY3QnKS5SZWRpcmVjdFxudmFyIFR1bm5lbCA9IHJlcXVpcmUoJy4vbGliL3R1bm5lbCcpLlR1bm5lbFxudmFyIG5vdyA9IHJlcXVpcmUoJ3BlcmZvcm1hbmNlLW5vdycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIHNhZmVTdHJpbmdpZnkgPSBoZWxwZXJzLnNhZmVTdHJpbmdpZnlcbnZhciBpc1JlYWRTdHJlYW0gPSBoZWxwZXJzLmlzUmVhZFN0cmVhbVxudmFyIHRvQmFzZTY0ID0gaGVscGVycy50b0Jhc2U2NFxudmFyIGRlZmVyID0gaGVscGVycy5kZWZlclxudmFyIGNvcHkgPSBoZWxwZXJzLmNvcHlcbnZhciB2ZXJzaW9uID0gaGVscGVycy52ZXJzaW9uXG52YXIgZ2xvYmFsQ29va2llSmFyID0gY29va2llcy5qYXIoKVxuXG52YXIgZ2xvYmFsUG9vbCA9IHt9XG5cbmZ1bmN0aW9uIGZpbHRlckZvck5vblJlc2VydmVkIChyZXNlcnZlZCwgb3B0aW9ucykge1xuICAvLyBGaWx0ZXIgb3V0IHByb3BlcnRpZXMgdGhhdCBhcmUgbm90IHJlc2VydmVkLlxuICAvLyBSZXNlcnZlZCB2YWx1ZXMgYXJlIHBhc3NlZCBpbiBhdCBjYWxsIHNpdGUuXG5cbiAgdmFyIG9iamVjdCA9IHt9XG4gIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgIHZhciBub3RSZXNlcnZlZCA9IChyZXNlcnZlZC5pbmRleE9mKGkpID09PSAtMSlcbiAgICBpZiAobm90UmVzZXJ2ZWQpIHtcbiAgICAgIG9iamVjdFtpXSA9IG9wdGlvbnNbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdFxufVxuXG5mdW5jdGlvbiBmaWx0ZXJPdXRSZXNlcnZlZEZ1bmN0aW9ucyAocmVzZXJ2ZWQsIG9wdGlvbnMpIHtcbiAgLy8gRmlsdGVyIG91dCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGZ1bmN0aW9ucyBhbmQgYXJlIHJlc2VydmVkLlxuICAvLyBSZXNlcnZlZCB2YWx1ZXMgYXJlIHBhc3NlZCBpbiBhdCBjYWxsIHNpdGUuXG5cbiAgdmFyIG9iamVjdCA9IHt9XG4gIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgIHZhciBpc1Jlc2VydmVkID0gIShyZXNlcnZlZC5pbmRleE9mKGkpID09PSAtMSlcbiAgICB2YXIgaXNGdW5jdGlvbiA9ICh0eXBlb2Ygb3B0aW9uc1tpXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBpZiAoIShpc1Jlc2VydmVkICYmIGlzRnVuY3Rpb24pKSB7XG4gICAgICBvYmplY3RbaV0gPSBvcHRpb25zW2ldXG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Rcbn1cblxuLy8gUmV0dXJuIGEgc2ltcGxlciByZXF1ZXN0IG9iamVjdCB0byBhbGxvdyBzZXJpYWxpemF0aW9uXG5mdW5jdGlvbiByZXF1ZXN0VG9KU09OICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiB7XG4gICAgdXJpOiBzZWxmLnVyaSxcbiAgICBtZXRob2Q6IHNlbGYubWV0aG9kLFxuICAgIGhlYWRlcnM6IHNlbGYuaGVhZGVyc1xuICB9XG59XG5cbi8vIFJldHVybiBhIHNpbXBsZXIgcmVzcG9uc2Ugb2JqZWN0IHRvIGFsbG93IHNlcmlhbGl6YXRpb25cbmZ1bmN0aW9uIHJlc3BvbnNlVG9KU09OICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHJldHVybiB7XG4gICAgc3RhdHVzQ29kZTogc2VsZi5zdGF0dXNDb2RlLFxuICAgIGJvZHk6IHNlbGYuYm9keSxcbiAgICBoZWFkZXJzOiBzZWxmLmhlYWRlcnMsXG4gICAgcmVxdWVzdDogcmVxdWVzdFRvSlNPTi5jYWxsKHNlbGYucmVxdWVzdClcbiAgfVxufVxuXG5mdW5jdGlvbiBSZXF1ZXN0IChvcHRpb25zKSB7XG4gIC8vIGlmIGdpdmVuIHRoZSBtZXRob2QgcHJvcGVydHkgaW4gb3B0aW9ucywgc2V0IHByb3BlcnR5IGV4cGxpY2l0TWV0aG9kIHRvIHRydWVcblxuICAvLyBleHRlbmQgdGhlIFJlcXVlc3QgaW5zdGFuY2Ugd2l0aCBhbnkgbm9uLXJlc2VydmVkIHByb3BlcnRpZXNcbiAgLy8gcmVtb3ZlIGFueSByZXNlcnZlZCBmdW5jdGlvbnMgZnJvbSB0aGUgb3B0aW9ucyBvYmplY3RcbiAgLy8gc2V0IFJlcXVlc3QgaW5zdGFuY2UgdG8gYmUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4gIC8vIGNhbGwgaW5pdFxuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIC8vIHN0YXJ0IHdpdGggSEFSLCB0aGVuIG92ZXJyaWRlIHdpdGggYWRkaXRpb25hbCBvcHRpb25zXG4gIGlmIChvcHRpb25zLmhhcikge1xuICAgIHNlbGYuX2hhciA9IG5ldyBIYXIoc2VsZilcbiAgICBvcHRpb25zID0gc2VsZi5faGFyLm9wdGlvbnMob3B0aW9ucylcbiAgfVxuXG4gIHN0cmVhbS5TdHJlYW0uY2FsbChzZWxmKVxuICB2YXIgcmVzZXJ2ZWQgPSBPYmplY3Qua2V5cyhSZXF1ZXN0LnByb3RvdHlwZSlcbiAgdmFyIG5vblJlc2VydmVkID0gZmlsdGVyRm9yTm9uUmVzZXJ2ZWQocmVzZXJ2ZWQsIG9wdGlvbnMpXG5cbiAgZXh0ZW5kKHNlbGYsIG5vblJlc2VydmVkKVxuICBvcHRpb25zID0gZmlsdGVyT3V0UmVzZXJ2ZWRGdW5jdGlvbnMocmVzZXJ2ZWQsIG9wdGlvbnMpXG5cbiAgc2VsZi5yZWFkYWJsZSA9IHRydWVcbiAgc2VsZi53cml0YWJsZSA9IHRydWVcbiAgaWYgKG9wdGlvbnMubWV0aG9kKSB7XG4gICAgc2VsZi5leHBsaWNpdE1ldGhvZCA9IHRydWVcbiAgfVxuICBzZWxmLl9xcyA9IG5ldyBRdWVyeXN0cmluZyhzZWxmKVxuICBzZWxmLl9hdXRoID0gbmV3IEF1dGgoc2VsZilcbiAgc2VsZi5fb2F1dGggPSBuZXcgT0F1dGgoc2VsZilcbiAgc2VsZi5fbXVsdGlwYXJ0ID0gbmV3IE11bHRpcGFydChzZWxmKVxuICBzZWxmLl9yZWRpcmVjdCA9IG5ldyBSZWRpcmVjdChzZWxmKVxuICBzZWxmLl90dW5uZWwgPSBuZXcgVHVubmVsKHNlbGYpXG4gIHNlbGYuaW5pdChvcHRpb25zKVxufVxuXG51dGlsLmluaGVyaXRzKFJlcXVlc3QsIHN0cmVhbS5TdHJlYW0pXG5cbi8vIERlYnVnZ2luZ1xuUmVxdWVzdC5kZWJ1ZyA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiYgL1xcYnJlcXVlc3RcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRylcbmZ1bmN0aW9uIGRlYnVnICgpIHtcbiAgaWYgKFJlcXVlc3QuZGVidWcpIHtcbiAgICBjb25zb2xlLmVycm9yKCdSRVFVRVNUICVzJywgdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSlcbiAgfVxufVxuUmVxdWVzdC5wcm90b3R5cGUuZGVidWcgPSBkZWJ1Z1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gaW5pdCgpIGNvbnRhaW5zIGFsbCB0aGUgY29kZSB0byBzZXR1cCB0aGUgcmVxdWVzdCBvYmplY3QuXG4gIC8vIHRoZSBhY3R1YWwgb3V0Z29pbmcgcmVxdWVzdCBpcyBub3Qgc3RhcnRlZCB1bnRpbCBzdGFydCgpIGlzIGNhbGxlZFxuICAvLyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmcm9tIGJvdGggdGhlIGNvbnN0cnVjdG9yIGFuZCBvbiByZWRpcmVjdC5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG4gIHNlbGYuaGVhZGVycyA9IHNlbGYuaGVhZGVycyA/IGNvcHkoc2VsZi5oZWFkZXJzKSA6IHt9XG5cbiAgLy8gRGVsZXRlIGhlYWRlcnMgd2l0aCB2YWx1ZSB1bmRlZmluZWQgc2luY2UgdGhleSBicmVha1xuICAvLyBDbGllbnRSZXF1ZXN0Lk91dGdvaW5nTWVzc2FnZS5zZXRIZWFkZXIgaW4gbm9kZSAwLjEyXG4gIGZvciAodmFyIGhlYWRlck5hbWUgaW4gc2VsZi5oZWFkZXJzKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmLmhlYWRlcnNbaGVhZGVyTmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWxldGUgc2VsZi5oZWFkZXJzW2hlYWRlck5hbWVdXG4gICAgfVxuICB9XG5cbiAgY2FzZWxlc3MuaHR0cGlmeShzZWxmLCBzZWxmLmhlYWRlcnMpXG5cbiAgaWYgKCFzZWxmLm1ldGhvZCkge1xuICAgIHNlbGYubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCdcbiAgfVxuICBpZiAoIXNlbGYubG9jYWxBZGRyZXNzKSB7XG4gICAgc2VsZi5sb2NhbEFkZHJlc3MgPSBvcHRpb25zLmxvY2FsQWRkcmVzc1xuICB9XG5cbiAgc2VsZi5fcXMuaW5pdChvcHRpb25zKVxuXG4gIGRlYnVnKG9wdGlvbnMpXG4gIGlmICghc2VsZi5wb29sICYmIHNlbGYucG9vbCAhPT0gZmFsc2UpIHtcbiAgICBzZWxmLnBvb2wgPSBnbG9iYWxQb29sXG4gIH1cbiAgc2VsZi5kZXN0cyA9IHNlbGYuZGVzdHMgfHwgW11cbiAgc2VsZi5fX2lzUmVxdWVzdFJlcXVlc3QgPSB0cnVlXG5cbiAgLy8gUHJvdGVjdCBhZ2FpbnN0IGRvdWJsZSBjYWxsYmFja1xuICBpZiAoIXNlbGYuX2NhbGxiYWNrICYmIHNlbGYuY2FsbGJhY2spIHtcbiAgICBzZWxmLl9jYWxsYmFjayA9IHNlbGYuY2FsbGJhY2tcbiAgICBzZWxmLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX2NhbGxiYWNrQ2FsbGVkKSB7XG4gICAgICAgIHJldHVybiAvLyBQcmludCBhIHdhcm5pbmcgbWF5YmU/XG4gICAgICB9XG4gICAgICBzZWxmLl9jYWxsYmFja0NhbGxlZCA9IHRydWVcbiAgICAgIHNlbGYuX2NhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICB9XG4gICAgc2VsZi5vbignZXJyb3InLCBzZWxmLmNhbGxiYWNrLmJpbmQoKSlcbiAgICBzZWxmLm9uKCdjb21wbGV0ZScsIHNlbGYuY2FsbGJhY2suYmluZChzZWxmLCBudWxsKSlcbiAgfVxuXG4gIC8vIFBlb3BsZSB1c2UgdGhpcyBwcm9wZXJ0eSBpbnN0ZWFkIGFsbCB0aGUgdGltZSwgc28gc3VwcG9ydCBpdFxuICBpZiAoIXNlbGYudXJpICYmIHNlbGYudXJsKSB7XG4gICAgc2VsZi51cmkgPSBzZWxmLnVybFxuICAgIGRlbGV0ZSBzZWxmLnVybFxuICB9XG5cbiAgLy8gSWYgdGhlcmUncyBhIGJhc2VVcmwsIHRoZW4gdXNlIGl0IGFzIHRoZSBiYXNlIFVSTCAoaS5lLiB1cmkgbXVzdCBiZVxuICAvLyBzcGVjaWZpZWQgYXMgYSByZWxhdGl2ZSBwYXRoIGFuZCBpcyBhcHBlbmRlZCB0byBiYXNlVXJsKS5cbiAgaWYgKHNlbGYuYmFzZVVybCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZi5iYXNlVXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ29wdGlvbnMuYmFzZVVybCBtdXN0IGJlIGEgc3RyaW5nJykpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZWxmLnVyaSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdvcHRpb25zLnVyaSBtdXN0IGJlIGEgc3RyaW5nIHdoZW4gdXNpbmcgb3B0aW9ucy5iYXNlVXJsJykpXG4gICAgfVxuXG4gICAgaWYgKHNlbGYudXJpLmluZGV4T2YoJy8vJykgPT09IDAgfHwgc2VsZi51cmkuaW5kZXhPZignOi8vJykgIT09IC0xKSB7XG4gICAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb3B0aW9ucy51cmkgbXVzdCBiZSBhIHBhdGggd2hlbiB1c2luZyBvcHRpb25zLmJhc2VVcmwnKSlcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYWxsIGNhc2VzIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZXJlJ3Mgb25seSBvbmUgc2xhc2ggYmV0d2VlblxuICAgIC8vIGJhc2VVcmwgYW5kIHVyaS5cbiAgICB2YXIgYmFzZVVybEVuZHNXaXRoU2xhc2ggPSBzZWxmLmJhc2VVcmwubGFzdEluZGV4T2YoJy8nKSA9PT0gc2VsZi5iYXNlVXJsLmxlbmd0aCAtIDFcbiAgICB2YXIgdXJpU3RhcnRzV2l0aFNsYXNoID0gc2VsZi51cmkuaW5kZXhPZignLycpID09PSAwXG5cbiAgICBpZiAoYmFzZVVybEVuZHNXaXRoU2xhc2ggJiYgdXJpU3RhcnRzV2l0aFNsYXNoKSB7XG4gICAgICBzZWxmLnVyaSA9IHNlbGYuYmFzZVVybCArIHNlbGYudXJpLnNsaWNlKDEpXG4gICAgfSBlbHNlIGlmIChiYXNlVXJsRW5kc1dpdGhTbGFzaCB8fCB1cmlTdGFydHNXaXRoU2xhc2gpIHtcbiAgICAgIHNlbGYudXJpID0gc2VsZi5iYXNlVXJsICsgc2VsZi51cmlcbiAgICB9IGVsc2UgaWYgKHNlbGYudXJpID09PSAnJykge1xuICAgICAgc2VsZi51cmkgPSBzZWxmLmJhc2VVcmxcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi51cmkgPSBzZWxmLmJhc2VVcmwgKyAnLycgKyBzZWxmLnVyaVxuICAgIH1cbiAgICBkZWxldGUgc2VsZi5iYXNlVXJsXG4gIH1cblxuICAvLyBBIFVSSSBpcyBuZWVkZWQgYnkgdGhpcyBwb2ludCwgZW1pdCBlcnJvciBpZiB3ZSBoYXZlbid0IGJlZW4gYWJsZSB0byBnZXQgb25lXG4gIGlmICghc2VsZi51cmkpIHtcbiAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignb3B0aW9ucy51cmkgaXMgYSByZXF1aXJlZCBhcmd1bWVudCcpKVxuICB9XG5cbiAgLy8gSWYgYSBzdHJpbmcgVVJJL1VSTCB3YXMgZ2l2ZW4sIHBhcnNlIGl0IGludG8gYSBVUkwgb2JqZWN0XG4gIGlmICh0eXBlb2Ygc2VsZi51cmkgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VsZi51cmkgPSB1cmwucGFyc2Uoc2VsZi51cmkpXG4gIH1cblxuICAvLyBTb21lIFVSTCBvYmplY3RzIGFyZSBub3QgZnJvbSBhIFVSTCBwYXJzZWQgc3RyaW5nIGFuZCBuZWVkIGhyZWYgYWRkZWRcbiAgaWYgKCFzZWxmLnVyaS5ocmVmKSB7XG4gICAgc2VsZi51cmkuaHJlZiA9IHVybC5mb3JtYXQoc2VsZi51cmkpXG4gIH1cblxuICAvLyBERVBSRUNBVEVEOiBXYXJuaW5nIGZvciB1c2VycyBvZiB0aGUgb2xkIFVuaXggU29ja2V0cyBVUkwgU2NoZW1lXG4gIGlmIChzZWxmLnVyaS5wcm90b2NvbCA9PT0gJ3VuaXg6Jykge1xuICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdgdW5peDovL2AgVVJMIHNjaGVtZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIHRoZSBmb3JtYXQgYGh0dHA6Ly91bml4OlNPQ0tFVDpQQVRIYCcpKVxuICB9XG5cbiAgLy8gU3VwcG9ydCBVbml4IFNvY2tldHNcbiAgaWYgKHNlbGYudXJpLmhvc3QgPT09ICd1bml4Jykge1xuICAgIHNlbGYuZW5hYmxlVW5peFNvY2tldCgpXG4gIH1cblxuICBpZiAoc2VsZi5zdHJpY3RTU0wgPT09IGZhbHNlKSB7XG4gICAgc2VsZi5yZWplY3RVbmF1dGhvcml6ZWQgPSBmYWxzZVxuICB9XG5cbiAgaWYgKCFzZWxmLnVyaS5wYXRobmFtZSkgeyBzZWxmLnVyaS5wYXRobmFtZSA9ICcvJyB9XG5cbiAgaWYgKCEoc2VsZi51cmkuaG9zdCB8fCAoc2VsZi51cmkuaG9zdG5hbWUgJiYgc2VsZi51cmkucG9ydCkpICYmICFzZWxmLnVyaS5pc1VuaXgpIHtcbiAgICAvLyBJbnZhbGlkIFVSSTogaXQgbWF5IGdlbmVyYXRlIGxvdCBvZiBiYWQgZXJyb3JzLCBsaWtlICdUeXBlRXJyb3I6IENhbm5vdCBjYWxsIG1ldGhvZCBgaW5kZXhPZmAgb2YgdW5kZWZpbmVkJyBpbiBDb29raWVKYXJcbiAgICAvLyBEZXRlY3QgYW5kIHJlamVjdCBpdCBhcyBzb29uIGFzIHBvc3NpYmxlXG4gICAgdmFyIGZhdWx0eVVyaSA9IHVybC5mb3JtYXQoc2VsZi51cmkpXG4gICAgdmFyIG1lc3NhZ2UgPSAnSW52YWxpZCBVUkkgXCInICsgZmF1bHR5VXJpICsgJ1wiJ1xuICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIG9wdGlvbiA/IFRoaXMgY2FuIGJlIHRoZSBzaWduIG9mIGEgcmVkaXJlY3RcbiAgICAgIC8vIEFzIHRoaXMgaXMgYSBjYXNlIHdoZXJlIHRoZSB1c2VyIGNhbm5vdCBkbyBhbnl0aGluZyAodGhleSBkaWRuJ3QgY2FsbCByZXF1ZXN0IGRpcmVjdGx5IHdpdGggdGhpcyBVUkwpXG4gICAgICAvLyB0aGV5IHNob3VsZCBiZSB3YXJuZWQgdGhhdCBpdCBjYW4gYmUgY2F1c2VkIGJ5IGEgcmVkaXJlY3Rpb24gKGNhbiBzYXZlIHNvbWUgaGFpcilcbiAgICAgIG1lc3NhZ2UgKz0gJy4gVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgY3JhcHB5IHJlZGlyZWN0aW9uLidcbiAgICB9XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgZmF0YWxcbiAgICBzZWxmLmFib3J0KClcbiAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSlcbiAgfVxuXG4gIGlmICghc2VsZi5oYXNPd25Qcm9wZXJ0eSgncHJveHknKSkge1xuICAgIHNlbGYucHJveHkgPSBnZXRQcm94eUZyb21VUkkoc2VsZi51cmkpXG4gIH1cblxuICBzZWxmLnR1bm5lbCA9IHNlbGYuX3R1bm5lbC5pc0VuYWJsZWQoKVxuICBpZiAoc2VsZi5wcm94eSkge1xuICAgIHNlbGYuX3R1bm5lbC5zZXR1cChvcHRpb25zKVxuICB9XG5cbiAgc2VsZi5fcmVkaXJlY3Qub25SZXF1ZXN0KG9wdGlvbnMpXG5cbiAgc2VsZi5zZXRIb3N0ID0gZmFsc2VcbiAgaWYgKCFzZWxmLmhhc0hlYWRlcignaG9zdCcpKSB7XG4gICAgdmFyIGhvc3RIZWFkZXJOYW1lID0gc2VsZi5vcmlnaW5hbEhvc3RIZWFkZXJOYW1lIHx8ICdob3N0J1xuICAgIHNlbGYuc2V0SGVhZGVyKGhvc3RIZWFkZXJOYW1lLCBzZWxmLnVyaS5ob3N0KVxuICAgIC8vIERyb3AgOnBvcnQgc3VmZml4IGZyb20gSG9zdCBoZWFkZXIgaWYga25vd24gcHJvdG9jb2wuXG4gICAgaWYgKHNlbGYudXJpLnBvcnQpIHtcbiAgICAgIGlmICgoc2VsZi51cmkucG9ydCA9PT0gJzgwJyAmJiBzZWxmLnVyaS5wcm90b2NvbCA9PT0gJ2h0dHA6JykgfHxcbiAgICAgICAgICAoc2VsZi51cmkucG9ydCA9PT0gJzQ0MycgJiYgc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwczonKSkge1xuICAgICAgICBzZWxmLnNldEhlYWRlcihob3N0SGVhZGVyTmFtZSwgc2VsZi51cmkuaG9zdG5hbWUpXG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuc2V0SG9zdCA9IHRydWVcbiAgfVxuXG4gIHNlbGYuamFyKHNlbGYuX2phciB8fCBvcHRpb25zLmphcilcblxuICBpZiAoIXNlbGYudXJpLnBvcnQpIHtcbiAgICBpZiAoc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwOicpIHsgc2VsZi51cmkucG9ydCA9IDgwIH0gZWxzZSBpZiAoc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwczonKSB7IHNlbGYudXJpLnBvcnQgPSA0NDMgfVxuICB9XG5cbiAgaWYgKHNlbGYucHJveHkgJiYgIXNlbGYudHVubmVsKSB7XG4gICAgc2VsZi5wb3J0ID0gc2VsZi5wcm94eS5wb3J0XG4gICAgc2VsZi5ob3N0ID0gc2VsZi5wcm94eS5ob3N0bmFtZVxuICB9IGVsc2Uge1xuICAgIHNlbGYucG9ydCA9IHNlbGYudXJpLnBvcnRcbiAgICBzZWxmLmhvc3QgPSBzZWxmLnVyaS5ob3N0bmFtZVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZm9ybSkge1xuICAgIHNlbGYuZm9ybShvcHRpb25zLmZvcm0pXG4gIH1cblxuICBpZiAob3B0aW9ucy5mb3JtRGF0YSkge1xuICAgIHZhciBmb3JtRGF0YSA9IG9wdGlvbnMuZm9ybURhdGFcbiAgICB2YXIgcmVxdWVzdEZvcm0gPSBzZWxmLmZvcm0oKVxuICAgIHZhciBhcHBlbmRGb3JtVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmhhc093blByb3BlcnR5KCd2YWx1ZScpICYmIHZhbHVlLmhhc093blByb3BlcnR5KCdvcHRpb25zJykpIHtcbiAgICAgICAgcmVxdWVzdEZvcm0uYXBwZW5kKGtleSwgdmFsdWUudmFsdWUsIHZhbHVlLm9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0Rm9ybS5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgZm9ybUtleSBpbiBmb3JtRGF0YSkge1xuICAgICAgaWYgKGZvcm1EYXRhLmhhc093blByb3BlcnR5KGZvcm1LZXkpKSB7XG4gICAgICAgIHZhciBmb3JtVmFsdWUgPSBmb3JtRGF0YVtmb3JtS2V5XVxuICAgICAgICBpZiAoZm9ybVZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvcm1WYWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgYXBwZW5kRm9ybVZhbHVlKGZvcm1LZXksIGZvcm1WYWx1ZVtqXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwZW5kRm9ybVZhbHVlKGZvcm1LZXksIGZvcm1WYWx1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnFzKSB7XG4gICAgc2VsZi5xcyhvcHRpb25zLnFzKVxuICB9XG5cbiAgaWYgKHNlbGYudXJpLnBhdGgpIHtcbiAgICBzZWxmLnBhdGggPSBzZWxmLnVyaS5wYXRoXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5wYXRoID0gc2VsZi51cmkucGF0aG5hbWUgKyAoc2VsZi51cmkuc2VhcmNoIHx8ICcnKVxuICB9XG5cbiAgaWYgKHNlbGYucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICBzZWxmLnBhdGggPSAnLydcbiAgfVxuXG4gIC8vIEF1dGggbXVzdCBoYXBwZW4gbGFzdCBpbiBjYXNlIHNpZ25pbmcgaXMgZGVwZW5kZW50IG9uIG90aGVyIGhlYWRlcnNcbiAgaWYgKG9wdGlvbnMuYXdzKSB7XG4gICAgc2VsZi5hd3Mob3B0aW9ucy5hd3MpXG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXdrKSB7XG4gICAgc2VsZi5oYXdrKG9wdGlvbnMuaGF3aylcbiAgfVxuXG4gIGlmIChvcHRpb25zLmh0dHBTaWduYXR1cmUpIHtcbiAgICBzZWxmLmh0dHBTaWduYXR1cmUob3B0aW9ucy5odHRwU2lnbmF0dXJlKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuYXV0aCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucy5hdXRoLCAndXNlcm5hbWUnKSkge1xuICAgICAgb3B0aW9ucy5hdXRoLnVzZXIgPSBvcHRpb25zLmF1dGgudXNlcm5hbWVcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLmF1dGgsICdwYXNzd29yZCcpKSB7XG4gICAgICBvcHRpb25zLmF1dGgucGFzcyA9IG9wdGlvbnMuYXV0aC5wYXNzd29yZFxuICAgIH1cblxuICAgIHNlbGYuYXV0aChcbiAgICAgIG9wdGlvbnMuYXV0aC51c2VyLFxuICAgICAgb3B0aW9ucy5hdXRoLnBhc3MsXG4gICAgICBvcHRpb25zLmF1dGguc2VuZEltbWVkaWF0ZWx5LFxuICAgICAgb3B0aW9ucy5hdXRoLmJlYXJlclxuICAgIClcbiAgfVxuXG4gIGlmIChzZWxmLmd6aXAgJiYgIXNlbGYuaGFzSGVhZGVyKCdhY2NlcHQtZW5jb2RpbmcnKSkge1xuICAgIHNlbGYuc2V0SGVhZGVyKCdhY2NlcHQtZW5jb2RpbmcnLCAnZ3ppcCwgZGVmbGF0ZScpXG4gIH1cblxuICBpZiAoc2VsZi51cmkuYXV0aCAmJiAhc2VsZi5oYXNIZWFkZXIoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgIHZhciB1cmlBdXRoUGllY2VzID0gc2VsZi51cmkuYXV0aC5zcGxpdCgnOicpLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gc2VsZi5fcXMudW5lc2NhcGUoaXRlbSkgfSlcbiAgICBzZWxmLmF1dGgodXJpQXV0aFBpZWNlc1swXSwgdXJpQXV0aFBpZWNlcy5zbGljZSgxKS5qb2luKCc6JyksIHRydWUpXG4gIH1cblxuICBpZiAoIXNlbGYudHVubmVsICYmIHNlbGYucHJveHkgJiYgc2VsZi5wcm94eS5hdXRoICYmICFzZWxmLmhhc0hlYWRlcigncHJveHktYXV0aG9yaXphdGlvbicpKSB7XG4gICAgdmFyIHByb3h5QXV0aFBpZWNlcyA9IHNlbGYucHJveHkuYXV0aC5zcGxpdCgnOicpLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gc2VsZi5fcXMudW5lc2NhcGUoaXRlbSkgfSlcbiAgICB2YXIgYXV0aEhlYWRlciA9ICdCYXNpYyAnICsgdG9CYXNlNjQocHJveHlBdXRoUGllY2VzLmpvaW4oJzonKSlcbiAgICBzZWxmLnNldEhlYWRlcigncHJveHktYXV0aG9yaXphdGlvbicsIGF1dGhIZWFkZXIpXG4gIH1cblxuICBpZiAoc2VsZi5wcm94eSAmJiAhc2VsZi50dW5uZWwpIHtcbiAgICBzZWxmLnBhdGggPSAoc2VsZi51cmkucHJvdG9jb2wgKyAnLy8nICsgc2VsZi51cmkuaG9zdCArIHNlbGYucGF0aClcbiAgfVxuXG4gIGlmIChvcHRpb25zLmpzb24pIHtcbiAgICBzZWxmLmpzb24ob3B0aW9ucy5qc29uKVxuICB9XG4gIGlmIChvcHRpb25zLm11bHRpcGFydCkge1xuICAgIHNlbGYubXVsdGlwYXJ0KG9wdGlvbnMubXVsdGlwYXJ0KVxuICB9XG5cbiAgaWYgKG9wdGlvbnMudGltZSkge1xuICAgIHNlbGYudGltaW5nID0gdHJ1ZVxuXG4gICAgLy8gTk9URTogZWxhcHNlZFRpbWUgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiAudGltaW5nc1xuICAgIHNlbGYuZWxhcHNlZFRpbWUgPSBzZWxmLmVsYXBzZWRUaW1lIHx8IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbnRlbnRMZW5ndGggKCkge1xuICAgIGlmIChpc1R5cGVkQXJyYXkoc2VsZi5ib2R5KSkge1xuICAgICAgc2VsZi5ib2R5ID0gQnVmZmVyLmZyb20oc2VsZi5ib2R5KVxuICAgIH1cblxuICAgIGlmICghc2VsZi5oYXNIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICAgIHZhciBsZW5ndGhcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5ib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzZWxmLmJvZHkpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VsZi5ib2R5KSkge1xuICAgICAgICBsZW5ndGggPSBzZWxmLmJvZHkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYi5sZW5ndGggfSwgMClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9IHNlbGYuYm9keS5sZW5ndGhcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC1sZW5ndGgnLCBsZW5ndGgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdBcmd1bWVudCBlcnJvciwgb3B0aW9ucy5ib2R5LicpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2VsZi5ib2R5ICYmICFpc3N0cmVhbShzZWxmLmJvZHkpKSB7XG4gICAgc2V0Q29udGVudExlbmd0aCgpXG4gIH1cblxuICBpZiAob3B0aW9ucy5vYXV0aCkge1xuICAgIHNlbGYub2F1dGgob3B0aW9ucy5vYXV0aClcbiAgfSBlbHNlIGlmIChzZWxmLl9vYXV0aC5wYXJhbXMgJiYgc2VsZi5oYXNIZWFkZXIoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgIHNlbGYub2F1dGgoc2VsZi5fb2F1dGgucGFyYW1zKVxuICB9XG5cbiAgdmFyIHByb3RvY29sID0gc2VsZi5wcm94eSAmJiAhc2VsZi50dW5uZWwgPyBzZWxmLnByb3h5LnByb3RvY29sIDogc2VsZi51cmkucHJvdG9jb2xcbiAgdmFyIGRlZmF1bHRNb2R1bGVzID0geydodHRwOic6IGh0dHAsICdodHRwczonOiBodHRwc31cbiAgdmFyIGh0dHBNb2R1bGVzID0gc2VsZi5odHRwTW9kdWxlcyB8fCB7fVxuXG4gIHNlbGYuaHR0cE1vZHVsZSA9IGh0dHBNb2R1bGVzW3Byb3RvY29sXSB8fCBkZWZhdWx0TW9kdWxlc1twcm90b2NvbF1cblxuICBpZiAoIXNlbGYuaHR0cE1vZHVsZSkge1xuICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sOiAnICsgcHJvdG9jb2wpKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuY2EpIHtcbiAgICBzZWxmLmNhID0gb3B0aW9ucy5jYVxuICB9XG5cbiAgaWYgKCFzZWxmLmFnZW50KSB7XG4gICAgaWYgKG9wdGlvbnMuYWdlbnRPcHRpb25zKSB7XG4gICAgICBzZWxmLmFnZW50T3B0aW9ucyA9IG9wdGlvbnMuYWdlbnRPcHRpb25zXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWdlbnRDbGFzcykge1xuICAgICAgc2VsZi5hZ2VudENsYXNzID0gb3B0aW9ucy5hZ2VudENsYXNzXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmZvcmV2ZXIpIHtcbiAgICAgIHZhciB2ID0gdmVyc2lvbigpXG4gICAgICAvLyB1c2UgRm9yZXZlckFnZW50IGluIG5vZGUgMC4xMC0gb25seVxuICAgICAgaWYgKHYubWFqb3IgPT09IDAgJiYgdi5taW5vciA8PSAxMCkge1xuICAgICAgICBzZWxmLmFnZW50Q2xhc3MgPSBwcm90b2NvbCA9PT0gJ2h0dHA6JyA/IEZvcmV2ZXJBZ2VudCA6IEZvcmV2ZXJBZ2VudC5TU0xcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuYWdlbnRDbGFzcyA9IHNlbGYuaHR0cE1vZHVsZS5BZ2VudFxuICAgICAgICBzZWxmLmFnZW50T3B0aW9ucyA9IHNlbGYuYWdlbnRPcHRpb25zIHx8IHt9XG4gICAgICAgIHNlbGYuYWdlbnRPcHRpb25zLmtlZXBBbGl2ZSA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5hZ2VudENsYXNzID0gc2VsZi5odHRwTW9kdWxlLkFnZW50XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYucG9vbCA9PT0gZmFsc2UpIHtcbiAgICBzZWxmLmFnZW50ID0gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmFnZW50ID0gc2VsZi5hZ2VudCB8fCBzZWxmLmdldE5ld0FnZW50KClcbiAgfVxuXG4gIHNlbGYub24oJ3BpcGUnLCBmdW5jdGlvbiAoc3JjKSB7XG4gICAgaWYgKHNlbGYubnRpY2sgJiYgc2VsZi5fc3RhcnRlZCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignWW91IGNhbm5vdCBwaXBlIHRvIHRoaXMgc3RyZWFtIGFmdGVyIHRoZSBvdXRib3VuZCByZXF1ZXN0IGhhcyBzdGFydGVkLicpKVxuICAgIH1cbiAgICBzZWxmLnNyYyA9IHNyY1xuICAgIGlmIChpc1JlYWRTdHJlYW0oc3JjKSkge1xuICAgICAgaWYgKCFzZWxmLmhhc0hlYWRlcignY29udGVudC10eXBlJykpIHtcbiAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIG1pbWUubG9va3VwKHNyYy5wYXRoKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNyYy5oZWFkZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gc3JjLmhlYWRlcnMpIHtcbiAgICAgICAgICBpZiAoIXNlbGYuaGFzSGVhZGVyKGkpKSB7XG4gICAgICAgICAgICBzZWxmLnNldEhlYWRlcihpLCBzcmMuaGVhZGVyc1tpXSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLl9qc29uICYmICFzZWxmLmhhc0hlYWRlcignY29udGVudC10eXBlJykpIHtcbiAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJylcbiAgICAgIH1cbiAgICAgIGlmIChzcmMubWV0aG9kICYmICFzZWxmLmV4cGxpY2l0TWV0aG9kKSB7XG4gICAgICAgIHNlbGYubWV0aG9kID0gc3JjLm1ldGhvZFxuICAgICAgfVxuICAgIH1cblxuICAvLyBzZWxmLm9uKCdwaXBlJywgZnVuY3Rpb24gKCkge1xuICAvLyAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBoYXZlIGFscmVhZHkgcGlwZWQgdG8gdGhpcyBzdHJlYW0uIFBpcGVpbmcgdHdpY2UgaXMgbGlrZWx5IHRvIGJyZWFrIHRoZSByZXF1ZXN0LicpXG4gIC8vIH0pXG4gIH0pXG5cbiAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9hYm9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX2Zvcm0pIHtcbiAgICAgICAgaWYgKCFzZWxmLl9hdXRoLmhhc0F1dGgpIHtcbiAgICAgICAgICBzZWxmLl9mb3JtLnBpcGUoc2VsZilcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLl9hdXRoLmhhc0F1dGggJiYgc2VsZi5fYXV0aC5zZW50QXV0aCkge1xuICAgICAgICAgIHNlbGYuX2Zvcm0ucGlwZShzZWxmKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5fbXVsdGlwYXJ0ICYmIHNlbGYuX211bHRpcGFydC5jaHVua2VkKSB7XG4gICAgICAgIHNlbGYuX211bHRpcGFydC5ib2R5LnBpcGUoc2VsZilcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLmJvZHkpIHtcbiAgICAgICAgaWYgKGlzc3RyZWFtKHNlbGYuYm9keSkpIHtcbiAgICAgICAgICBzZWxmLmJvZHkucGlwZShzZWxmKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldENvbnRlbnRMZW5ndGgoKVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGYuYm9keSkpIHtcbiAgICAgICAgICAgIHNlbGYuYm9keS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgICAgIHNlbGYud3JpdGUocGFydClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYud3JpdGUoc2VsZi5ib2R5KVxuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLmVuZCgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5yZXF1ZXN0Qm9keVN0cmVhbSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ29wdGlvbnMucmVxdWVzdEJvZHlTdHJlYW0gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHBhc3MgdGhlIHJlcXVlc3Qgb2JqZWN0IHRvIHN0cmVhbS5waXBlLicpXG4gICAgICAgIHNlbGYucmVxdWVzdEJvZHlTdHJlYW0ucGlwZShzZWxmKVxuICAgICAgfSBlbHNlIGlmICghc2VsZi5zcmMpIHtcbiAgICAgICAgaWYgKHNlbGYuX2F1dGguaGFzQXV0aCAmJiAhc2VsZi5fYXV0aC5zZW50QXV0aCkge1xuICAgICAgICAgIHNlbGYuZW5kKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5tZXRob2QgIT09ICdHRVQnICYmIHR5cGVvZiBzZWxmLm1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC1sZW5ndGgnLCAwKVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuZW5kKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZm9ybSAmJiAhc2VsZi5oYXNIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcbiAgICAgIC8vIEJlZm9yZSBlbmRpbmcgdGhlIHJlcXVlc3QsIHdlIGhhZCB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIHdob2xlIGZvcm0sIGFzeW5jbHlcbiAgICAgIHNlbGYuc2V0SGVhZGVyKHNlbGYuX2Zvcm0uZ2V0SGVhZGVycygpLCB0cnVlKVxuICAgICAgc2VsZi5fZm9ybS5nZXRMZW5ndGgoZnVuY3Rpb24gKGVyciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmICghZXJyICYmICFpc05hTihsZW5ndGgpKSB7XG4gICAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJywgbGVuZ3RoKVxuICAgICAgICB9XG4gICAgICAgIGVuZCgpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBlbmQoKVxuICAgIH1cblxuICAgIHNlbGYubnRpY2sgPSB0cnVlXG4gIH0pXG59XG5cblJlcXVlc3QucHJvdG90eXBlLmdldE5ld0FnZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIEFnZW50ID0gc2VsZi5hZ2VudENsYXNzXG4gIHZhciBvcHRpb25zID0ge31cbiAgaWYgKHNlbGYuYWdlbnRPcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSBpbiBzZWxmLmFnZW50T3B0aW9ucykge1xuICAgICAgb3B0aW9uc1tpXSA9IHNlbGYuYWdlbnRPcHRpb25zW2ldXG4gICAgfVxuICB9XG4gIGlmIChzZWxmLmNhKSB7XG4gICAgb3B0aW9ucy5jYSA9IHNlbGYuY2FcbiAgfVxuICBpZiAoc2VsZi5jaXBoZXJzKSB7XG4gICAgb3B0aW9ucy5jaXBoZXJzID0gc2VsZi5jaXBoZXJzXG4gIH1cbiAgaWYgKHNlbGYuc2VjdXJlUHJvdG9jb2wpIHtcbiAgICBvcHRpb25zLnNlY3VyZVByb3RvY29sID0gc2VsZi5zZWN1cmVQcm90b2NvbFxuICB9XG4gIGlmIChzZWxmLnNlY3VyZU9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnNlY3VyZU9wdGlvbnMgPSBzZWxmLnNlY3VyZU9wdGlvbnNcbiAgfVxuICBpZiAodHlwZW9mIHNlbGYucmVqZWN0VW5hdXRob3JpemVkICE9PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gc2VsZi5yZWplY3RVbmF1dGhvcml6ZWRcbiAgfVxuXG4gIGlmIChzZWxmLmNlcnQgJiYgc2VsZi5rZXkpIHtcbiAgICBvcHRpb25zLmtleSA9IHNlbGYua2V5XG4gICAgb3B0aW9ucy5jZXJ0ID0gc2VsZi5jZXJ0XG4gIH1cblxuICBpZiAoc2VsZi5wZngpIHtcbiAgICBvcHRpb25zLnBmeCA9IHNlbGYucGZ4XG4gIH1cblxuICBpZiAoc2VsZi5wYXNzcGhyYXNlKSB7XG4gICAgb3B0aW9ucy5wYXNzcGhyYXNlID0gc2VsZi5wYXNzcGhyYXNlXG4gIH1cblxuICB2YXIgcG9vbEtleSA9ICcnXG5cbiAgLy8gZGlmZmVyZW50IHR5cGVzIG9mIGFnZW50cyBhcmUgaW4gZGlmZmVyZW50IHBvb2xzXG4gIGlmIChBZ2VudCAhPT0gc2VsZi5odHRwTW9kdWxlLkFnZW50KSB7XG4gICAgcG9vbEtleSArPSBBZ2VudC5uYW1lXG4gIH1cblxuICAvLyBjYSBvcHRpb24gaXMgb25seSByZWxldmFudCBpZiBwcm94eSBvciBkZXN0aW5hdGlvbiBhcmUgaHR0cHNcbiAgdmFyIHByb3h5ID0gc2VsZi5wcm94eVxuICBpZiAodHlwZW9mIHByb3h5ID09PSAnc3RyaW5nJykge1xuICAgIHByb3h5ID0gdXJsLnBhcnNlKHByb3h5KVxuICB9XG4gIHZhciBpc0h0dHBzID0gKHByb3h5ICYmIHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6JykgfHwgdGhpcy51cmkucHJvdG9jb2wgPT09ICdodHRwczonXG5cbiAgaWYgKGlzSHR0cHMpIHtcbiAgICBpZiAob3B0aW9ucy5jYSkge1xuICAgICAgaWYgKHBvb2xLZXkpIHtcbiAgICAgICAgcG9vbEtleSArPSAnOidcbiAgICAgIH1cbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5jYVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAocG9vbEtleSkge1xuICAgICAgICBwb29sS2V5ICs9ICc6J1xuICAgICAgfVxuICAgICAgcG9vbEtleSArPSBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZFxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNlcnQpIHtcbiAgICAgIGlmIChwb29sS2V5KSB7XG4gICAgICAgIHBvb2xLZXkgKz0gJzonXG4gICAgICB9XG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMuY2VydC50b1N0cmluZygnYXNjaWknKSArIG9wdGlvbnMua2V5LnRvU3RyaW5nKCdhc2NpaScpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGZ4KSB7XG4gICAgICBpZiAocG9vbEtleSkge1xuICAgICAgICBwb29sS2V5ICs9ICc6J1xuICAgICAgfVxuICAgICAgcG9vbEtleSArPSBvcHRpb25zLnBmeC50b1N0cmluZygnYXNjaWknKVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNpcGhlcnMpIHtcbiAgICAgIGlmIChwb29sS2V5KSB7XG4gICAgICAgIHBvb2xLZXkgKz0gJzonXG4gICAgICB9XG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMuY2lwaGVyc1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNlY3VyZVByb3RvY29sKSB7XG4gICAgICBpZiAocG9vbEtleSkge1xuICAgICAgICBwb29sS2V5ICs9ICc6J1xuICAgICAgfVxuICAgICAgcG9vbEtleSArPSBvcHRpb25zLnNlY3VyZVByb3RvY29sXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2VjdXJlT3B0aW9ucykge1xuICAgICAgaWYgKHBvb2xLZXkpIHtcbiAgICAgICAgcG9vbEtleSArPSAnOidcbiAgICAgIH1cbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5zZWN1cmVPcHRpb25zXG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYucG9vbCA9PT0gZ2xvYmFsUG9vbCAmJiAhcG9vbEtleSAmJiBPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPT09IDAgJiYgc2VsZi5odHRwTW9kdWxlLmdsb2JhbEFnZW50KSB7XG4gICAgLy8gbm90IGRvaW5nIGFueXRoaW5nIHNwZWNpYWwuICBVc2UgdGhlIGdsb2JhbEFnZW50XG4gICAgcmV0dXJuIHNlbGYuaHR0cE1vZHVsZS5nbG9iYWxBZ2VudFxuICB9XG5cbiAgLy8gd2UncmUgdXNpbmcgYSBzdG9yZWQgYWdlbnQuICBNYWtlIHN1cmUgaXQncyBwcm90b2NvbC1zcGVjaWZpY1xuICBwb29sS2V5ID0gc2VsZi51cmkucHJvdG9jb2wgKyBwb29sS2V5XG5cbiAgLy8gZ2VuZXJhdGUgYSBuZXcgYWdlbnQgZm9yIHRoaXMgc2V0dGluZyBpZiBub25lIHlldCBleGlzdHNcbiAgaWYgKCFzZWxmLnBvb2xbcG9vbEtleV0pIHtcbiAgICBzZWxmLnBvb2xbcG9vbEtleV0gPSBuZXcgQWdlbnQob3B0aW9ucylcbiAgICAvLyBwcm9wZXJseSBzZXQgbWF4U29ja2V0cyBvbiBuZXcgYWdlbnRzXG4gICAgaWYgKHNlbGYucG9vbC5tYXhTb2NrZXRzKSB7XG4gICAgICBzZWxmLnBvb2xbcG9vbEtleV0ubWF4U29ja2V0cyA9IHNlbGYucG9vbC5tYXhTb2NrZXRzXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGYucG9vbFtwb29sS2V5XVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gc3RhcnQoKSBpcyBjYWxsZWQgb25jZSB3ZSBhcmUgcmVhZHkgdG8gc2VuZCB0aGUgb3V0Z29pbmcgSFRUUCByZXF1ZXN0LlxuICAvLyB0aGlzIGlzIHVzdWFsbHkgY2FsbGVkIG9uIHRoZSBmaXJzdCB3cml0ZSgpLCBlbmQoKSBvciBvbiBuZXh0VGljaygpXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChzZWxmLnRpbWluZykge1xuICAgIC8vIEFsbCB0aW1pbmdzIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcyByZXF1ZXN0J3Mgc3RhcnRUaW1lLiAgSW4gb3JkZXIgdG8gZG8gdGhpcyxcbiAgICAvLyB3ZSBuZWVkIHRvIGNhcHR1cmUgdGhlIHdhbGwtY2xvY2sgc3RhcnQgdGltZSAodmlhIERhdGUpLCBpbW1lZGlhdGVseSBmb2xsb3dlZFxuICAgIC8vIGJ5IHRoZSBoaWdoLXJlc29sdXRpb24gdGltZXIgKHZpYSBub3coKSkuICBXaGlsZSB0aGVzZSB0d28gd29uJ3QgYmUgc2V0XG4gICAgLy8gYXQgdGhlIF9leGFjdF8gc2FtZSB0aW1lLCB0aGV5IHNob3VsZCBiZSBjbG9zZSBlbm91Z2ggdG8gYmUgYWJsZSB0byBjYWxjdWxhdGVcbiAgICAvLyBoaWdoLXJlc29sdXRpb24sIG1vbm90b25pY2FsbHkgbm9uLWRlY3JlYXNpbmcgdGltZXN0YW1wcyByZWxhdGl2ZSB0byBzdGFydFRpbWUuXG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgdmFyIHN0YXJ0VGltZU5vdyA9IG5vdygpXG4gIH1cblxuICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgc2VsZi5fc3RhcnRlZCA9IHRydWVcbiAgc2VsZi5tZXRob2QgPSBzZWxmLm1ldGhvZCB8fCAnR0VUJ1xuICBzZWxmLmhyZWYgPSBzZWxmLnVyaS5ocmVmXG5cbiAgaWYgKHNlbGYuc3JjICYmIHNlbGYuc3JjLnN0YXQgJiYgc2VsZi5zcmMuc3RhdC5zaXplICYmICFzZWxmLmhhc0hlYWRlcignY29udGVudC1sZW5ndGgnKSkge1xuICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIHNlbGYuc3JjLnN0YXQuc2l6ZSlcbiAgfVxuICBpZiAoc2VsZi5fYXdzKSB7XG4gICAgc2VsZi5hd3Moc2VsZi5fYXdzLCB0cnVlKVxuICB9XG5cbiAgLy8gV2UgaGF2ZSBhIG1ldGhvZCBuYW1lZCBhdXRoLCB3aGljaCBpcyBjb21wbGV0ZWx5IGRpZmZlcmVudCBmcm9tIHRoZSBodHRwLnJlcXVlc3RcbiAgLy8gYXV0aCBvcHRpb24uICBJZiB3ZSBkb24ndCByZW1vdmUgaXQsIHdlJ3JlIGdvbm5hIGhhdmUgYSBiYWQgdGltZS5cbiAgdmFyIHJlcU9wdGlvbnMgPSBjb3B5KHNlbGYpXG4gIGRlbGV0ZSByZXFPcHRpb25zLmF1dGhcblxuICBkZWJ1ZygnbWFrZSByZXF1ZXN0Jywgc2VsZi51cmkuaHJlZilcblxuICAvLyBub2RlIHY2LjguMCBub3cgc3VwcG9ydHMgYSBgdGltZW91dGAgdmFsdWUgaW4gYGh0dHAucmVxdWVzdCgpYCwgYnV0IHdlXG4gIC8vIHNob3VsZCBkZWxldGUgaXQgZm9yIG5vdyBzaW5jZSB3ZSBoYW5kbGUgdGltZW91dHMgbWFudWFsbHkgZm9yIGJldHRlclxuICAvLyBjb25zaXN0ZW5jeSB3aXRoIG5vZGUgdmVyc2lvbnMgYmVmb3JlIHY2LjguMFxuICBkZWxldGUgcmVxT3B0aW9ucy50aW1lb3V0XG5cbiAgdHJ5IHtcbiAgICBzZWxmLnJlcSA9IHNlbGYuaHR0cE1vZHVsZS5yZXF1ZXN0KHJlcU9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoc2VsZi50aW1pbmcpIHtcbiAgICBzZWxmLnN0YXJ0VGltZSA9IHN0YXJ0VGltZVxuICAgIHNlbGYuc3RhcnRUaW1lTm93ID0gc3RhcnRUaW1lTm93XG5cbiAgICAvLyBUaW1pbmcgdmFsdWVzIHdpbGwgYWxsIGJlIHJlbGF0aXZlIHRvIHN0YXJ0VGltZSAoYnkgY29tcGFyaW5nIHRvIHN0YXJ0VGltZU5vd1xuICAgIC8vIHNvIHdlIGhhdmUgYW4gYWNjdXJhdGUgY2xvY2spXG4gICAgc2VsZi50aW1pbmdzID0ge31cbiAgfVxuXG4gIHZhciB0aW1lb3V0XG4gIGlmIChzZWxmLnRpbWVvdXQgJiYgIXNlbGYudGltZW91dFRpbWVyKSB7XG4gICAgaWYgKHNlbGYudGltZW91dCA8IDApIHtcbiAgICAgIHRpbWVvdXQgPSAwXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZi50aW1lb3V0ID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShzZWxmLnRpbWVvdXQpKSB7XG4gICAgICB0aW1lb3V0ID0gc2VsZi50aW1lb3V0XG4gICAgfVxuICB9XG5cbiAgc2VsZi5yZXEub24oJ3Jlc3BvbnNlJywgc2VsZi5vblJlcXVlc3RSZXNwb25zZS5iaW5kKHNlbGYpKVxuICBzZWxmLnJlcS5vbignZXJyb3InLCBzZWxmLm9uUmVxdWVzdEVycm9yLmJpbmQoc2VsZikpXG4gIHNlbGYucmVxLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJylcbiAgfSlcblxuICBzZWxmLnJlcS5vbignc29ja2V0JywgZnVuY3Rpb24gKHNvY2tldCkge1xuICAgIC8vIGAuX2Nvbm5lY3RpbmdgIHdhcyB0aGUgb2xkIHByb3BlcnR5IHdoaWNoIHdhcyBtYWRlIHB1YmxpYyBpbiBub2RlIHY2LjEuMFxuICAgIHZhciBpc0Nvbm5lY3RpbmcgPSBzb2NrZXQuX2Nvbm5lY3RpbmcgfHwgc29ja2V0LmNvbm5lY3RpbmdcbiAgICBpZiAoc2VsZi50aW1pbmcpIHtcbiAgICAgIHNlbGYudGltaW5ncy5zb2NrZXQgPSBub3coKSAtIHNlbGYuc3RhcnRUaW1lTm93XG5cbiAgICAgIGlmIChpc0Nvbm5lY3RpbmcpIHtcbiAgICAgICAgdmFyIG9uTG9va3VwVGltaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYudGltaW5ncy5sb29rdXAgPSBub3coKSAtIHNlbGYuc3RhcnRUaW1lTm93XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb25Db25uZWN0VGltaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlbGYudGltaW5ncy5jb25uZWN0ID0gbm93KCkgLSBzZWxmLnN0YXJ0VGltZU5vd1xuICAgICAgICB9XG5cbiAgICAgICAgc29ja2V0Lm9uY2UoJ2xvb2t1cCcsIG9uTG9va3VwVGltaW5nKVxuICAgICAgICBzb2NrZXQub25jZSgnY29ubmVjdCcsIG9uQ29ubmVjdFRpbWluZylcblxuICAgICAgICAvLyBjbGVhbiB1cCB0aW1pbmcgZXZlbnQgbGlzdGVuZXJzIGlmIG5lZWRlZCBvbiBlcnJvclxuICAgICAgICBzZWxmLnJlcS5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2xvb2t1cCcsIG9uTG9va3VwVGltaW5nKVxuICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIG9uQ29ubmVjdFRpbWluZylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2V0UmVxVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFRoaXMgdGltZW91dCBzZXRzIHRoZSBhbW91bnQgb2YgdGltZSB0byB3YWl0ICpiZXR3ZWVuKiBieXRlcyBzZW50XG4gICAgICAvLyBmcm9tIHRoZSBzZXJ2ZXIgb25jZSBjb25uZWN0ZWQuXG4gICAgICAvL1xuICAgICAgLy8gSW4gcGFydGljdWxhciwgaXQncyB1c2VmdWwgZm9yIGVycm9yaW5nIGlmIHRoZSBzZXJ2ZXIgZmFpbHMgdG8gc2VuZFxuICAgICAgLy8gZGF0YSBoYWxmd2F5IHRocm91Z2ggc3RyZWFtaW5nIGEgcmVzcG9uc2UuXG4gICAgICBzZWxmLnJlcS5zZXRUaW1lb3V0KHRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYucmVxKSB7XG4gICAgICAgICAgc2VsZi5hYm9ydCgpXG4gICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ0VTT0NLRVRUSU1FRE9VVCcpXG4gICAgICAgICAgZS5jb2RlID0gJ0VTT0NLRVRUSU1FRE9VVCdcbiAgICAgICAgICBlLmNvbm5lY3QgPSBmYWxzZVxuICAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAodGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPbmx5IHN0YXJ0IHRoZSBjb25uZWN0aW9uIHRpbWVyIGlmIHdlJ3JlIGFjdHVhbGx5IGNvbm5lY3RpbmcgYSBuZXdcbiAgICAgIC8vIHNvY2tldCwgb3RoZXJ3aXNlIGlmIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkIChiZWNhdXNlIHRoaXMgaXMgYVxuICAgICAgLy8ga2VlcC1hbGl2ZSBjb25uZWN0aW9uKSBkbyBub3QgYm90aGVyLiBUaGlzIGlzIGltcG9ydGFudCBzaW5jZSB3ZSB3b24ndFxuICAgICAgLy8gZ2V0IGEgJ2Nvbm5lY3QnIGV2ZW50IGZvciBhbiBhbHJlYWR5IGNvbm5lY3RlZCBzb2NrZXQuXG4gICAgICBpZiAoaXNDb25uZWN0aW5nKSB7XG4gICAgICAgIHZhciBvblJlcVNvY2tDb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIG9uUmVxU29ja0Nvbm5lY3QpXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dFRpbWVyKVxuICAgICAgICAgIHNlbGYudGltZW91dFRpbWVyID0gbnVsbFxuICAgICAgICAgIHNldFJlcVRpbWVvdXQoKVxuICAgICAgICB9XG5cbiAgICAgICAgc29ja2V0Lm9uKCdjb25uZWN0Jywgb25SZXFTb2NrQ29ubmVjdClcblxuICAgICAgICBzZWxmLnJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaGFuZGxlLWNhbGxiYWNrLWVyclxuICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIG9uUmVxU29ja0Nvbm5lY3QpXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gU2V0IGEgdGltZW91dCBpbiBtZW1vcnkgLSB0aGlzIGJsb2NrIHdpbGwgdGhyb3cgaWYgdGhlIHNlcnZlciB0YWtlcyBtb3JlXG4gICAgICAgIC8vIHRoYW4gYHRpbWVvdXRgIHRvIHdyaXRlIHRoZSBIVFRQIHN0YXR1cyBhbmQgaGVhZGVycyAoY29ycmVzcG9uZGluZyB0b1xuICAgICAgICAvLyB0aGUgb24oJ3Jlc3BvbnNlJykgZXZlbnQgb24gdGhlIGNsaWVudCkuIE5COiB0aGlzIG1lYXN1cmVzIHdhbGwtY2xvY2tcbiAgICAgICAgLy8gdGltZSwgbm90IHRoZSB0aW1lIGJldHdlZW4gYnl0ZXMgc2VudCBieSB0aGUgc2VydmVyLlxuICAgICAgICBzZWxmLnRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIG9uUmVxU29ja0Nvbm5lY3QpXG4gICAgICAgICAgc2VsZi5hYm9ydCgpXG4gICAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ0VUSU1FRE9VVCcpXG4gICAgICAgICAgZS5jb2RlID0gJ0VUSU1FRE9VVCdcbiAgICAgICAgICBlLmNvbm5lY3QgPSB0cnVlXG4gICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGUpXG4gICAgICAgIH0sIHRpbWVvdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSdyZSBhbHJlYWR5IGNvbm5lY3RlZFxuICAgICAgICBzZXRSZXFUaW1lb3V0KClcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5lbWl0KCdzb2NrZXQnLCBzb2NrZXQpXG4gIH0pXG5cbiAgc2VsZi5lbWl0KCdyZXF1ZXN0Jywgc2VsZi5yZXEpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLm9uUmVxdWVzdEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChzZWxmLnJlcSAmJiBzZWxmLnJlcS5fcmV1c2VkU29ja2V0ICYmIGVycm9yLmNvZGUgPT09ICdFQ09OTlJFU0VUJyAmJlxuICAgIHNlbGYuYWdlbnQuYWRkUmVxdWVzdE5vcmV1c2UpIHtcbiAgICBzZWxmLmFnZW50ID0geyBhZGRSZXF1ZXN0OiBzZWxmLmFnZW50LmFkZFJlcXVlc3ROb3JldXNlLmJpbmQoc2VsZi5hZ2VudCkgfVxuICAgIHNlbGYuc3RhcnQoKVxuICAgIHNlbGYucmVxLmVuZCgpXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHNlbGYudGltZW91dCAmJiBzZWxmLnRpbWVvdXRUaW1lcikge1xuICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXRUaW1lcilcbiAgICBzZWxmLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgfVxuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLm9uUmVxdWVzdFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmIChzZWxmLnRpbWluZykge1xuICAgIHNlbGYudGltaW5ncy5yZXNwb25zZSA9IG5vdygpIC0gc2VsZi5zdGFydFRpbWVOb3dcbiAgfVxuXG4gIGRlYnVnKCdvblJlcXVlc3RSZXNwb25zZScsIHNlbGYudXJpLmhyZWYsIHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlc3BvbnNlLmhlYWRlcnMpXG4gIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYudGltaW5nKSB7XG4gICAgICBzZWxmLnRpbWluZ3MuZW5kID0gbm93KCkgLSBzZWxmLnN0YXJ0VGltZU5vd1xuICAgICAgcmVzcG9uc2UudGltaW5nU3RhcnQgPSBzZWxmLnN0YXJ0VGltZVxuXG4gICAgICAvLyBmaWxsIGluIHRoZSBibGFua3MgZm9yIGFueSBwZXJpb2RzIHRoYXQgZGlkbid0IHRyaWdnZXIsIHN1Y2ggYXNcbiAgICAgIC8vIG5vIGxvb2t1cCBvciBjb25uZWN0IGR1ZSB0byBrZWVwIGFsaXZlXG4gICAgICBpZiAoIXNlbGYudGltaW5ncy5zb2NrZXQpIHtcbiAgICAgICAgc2VsZi50aW1pbmdzLnNvY2tldCA9IDBcbiAgICAgIH1cbiAgICAgIGlmICghc2VsZi50aW1pbmdzLmxvb2t1cCkge1xuICAgICAgICBzZWxmLnRpbWluZ3MubG9va3VwID0gc2VsZi50aW1pbmdzLnNvY2tldFxuICAgICAgfVxuICAgICAgaWYgKCFzZWxmLnRpbWluZ3MuY29ubmVjdCkge1xuICAgICAgICBzZWxmLnRpbWluZ3MuY29ubmVjdCA9IHNlbGYudGltaW5ncy5sb29rdXBcbiAgICAgIH1cbiAgICAgIGlmICghc2VsZi50aW1pbmdzLnJlc3BvbnNlKSB7XG4gICAgICAgIHNlbGYudGltaW5ncy5yZXNwb25zZSA9IHNlbGYudGltaW5ncy5jb25uZWN0XG4gICAgICB9XG5cbiAgICAgIGRlYnVnKCdlbGFwc2VkIHRpbWUnLCBzZWxmLnRpbWluZ3MuZW5kKVxuXG4gICAgICAvLyBlbGFwc2VkVGltZSBpbmNsdWRlcyBhbGwgcmVkaXJlY3RzXG4gICAgICBzZWxmLmVsYXBzZWRUaW1lICs9IE1hdGgucm91bmQoc2VsZi50aW1pbmdzLmVuZClcblxuICAgICAgLy8gTk9URTogZWxhcHNlZFRpbWUgaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiAudGltaW5nc1xuICAgICAgcmVzcG9uc2UuZWxhcHNlZFRpbWUgPSBzZWxmLmVsYXBzZWRUaW1lXG5cbiAgICAgIC8vIHRpbWluZ3MgaXMganVzdCBmb3IgdGhlIGZpbmFsIGZldGNoXG4gICAgICByZXNwb25zZS50aW1pbmdzID0gc2VsZi50aW1pbmdzXG5cbiAgICAgIC8vIHByZS1jYWxjdWxhdGUgcGhhc2UgdGltaW5ncyBhcyB3ZWxsXG4gICAgICByZXNwb25zZS50aW1pbmdQaGFzZXMgPSB7XG4gICAgICAgIHdhaXQ6IHNlbGYudGltaW5ncy5zb2NrZXQsXG4gICAgICAgIGRuczogc2VsZi50aW1pbmdzLmxvb2t1cCAtIHNlbGYudGltaW5ncy5zb2NrZXQsXG4gICAgICAgIHRjcDogc2VsZi50aW1pbmdzLmNvbm5lY3QgLSBzZWxmLnRpbWluZ3MubG9va3VwLFxuICAgICAgICBmaXJzdEJ5dGU6IHNlbGYudGltaW5ncy5yZXNwb25zZSAtIHNlbGYudGltaW5ncy5jb25uZWN0LFxuICAgICAgICBkb3dubG9hZDogc2VsZi50aW1pbmdzLmVuZCAtIHNlbGYudGltaW5ncy5yZXNwb25zZSxcbiAgICAgICAgdG90YWw6IHNlbGYudGltaW5ncy5lbmRcbiAgICAgIH1cbiAgICB9XG4gICAgZGVidWcoJ3Jlc3BvbnNlIGVuZCcsIHNlbGYudXJpLmhyZWYsIHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlc3BvbnNlLmhlYWRlcnMpXG4gIH0pXG5cbiAgaWYgKHNlbGYuX2Fib3J0ZWQpIHtcbiAgICBkZWJ1ZygnYWJvcnRlZCcsIHNlbGYudXJpLmhyZWYpXG4gICAgcmVzcG9uc2UucmVzdW1lKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNlbGYucmVzcG9uc2UgPSByZXNwb25zZVxuICByZXNwb25zZS5yZXF1ZXN0ID0gc2VsZlxuICByZXNwb25zZS50b0pTT04gPSByZXNwb25zZVRvSlNPTlxuXG4gIC8vIFhYWCBUaGlzIGlzIGRpZmZlcmVudCBvbiAwLjEwLCBiZWNhdXNlIFNTTCBpcyBzdHJpY3QgYnkgZGVmYXVsdFxuICBpZiAoc2VsZi5odHRwTW9kdWxlID09PSBodHRwcyAmJlxuICAgIHNlbGYuc3RyaWN0U1NMICYmICghcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ3NvY2tldCcpIHx8XG4gICAgIXJlc3BvbnNlLnNvY2tldC5hdXRob3JpemVkKSkge1xuICAgIGRlYnVnKCdzdHJpY3Qgc3NsIGVycm9yJywgc2VsZi51cmkuaHJlZilcbiAgICB2YXIgc3NsRXJyID0gcmVzcG9uc2UuaGFzT3duUHJvcGVydHkoJ3NvY2tldCcpID8gcmVzcG9uc2Uuc29ja2V0LmF1dGhvcml6YXRpb25FcnJvciA6IHNlbGYudXJpLmhyZWYgKyAnIGRvZXMgbm90IHN1cHBvcnQgU1NMJ1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1NTTCBFcnJvcjogJyArIHNzbEVycikpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBTYXZlIHRoZSBvcmlnaW5hbCBob3N0IGJlZm9yZSBhbnkgcmVkaXJlY3QgKGlmIGl0IGNoYW5nZXMsIHdlIG5lZWQgdG9cbiAgLy8gcmVtb3ZlIGFueSBhdXRob3JpemF0aW9uIGhlYWRlcnMpLiAgQWxzbyByZW1lbWJlciB0aGUgY2FzZSBvZiB0aGUgaGVhZGVyXG4gIC8vIG5hbWUgYmVjYXVzZSBsb3RzIG9mIGJyb2tlbiBzZXJ2ZXJzIGV4cGVjdCBIb3N0IGluc3RlYWQgb2YgaG9zdCBhbmQgd2VcbiAgLy8gd2FudCB0aGUgY2FsbGVyIHRvIGJlIGFibGUgdG8gc3BlY2lmeSB0aGlzLlxuICBzZWxmLm9yaWdpbmFsSG9zdCA9IHNlbGYuZ2V0SGVhZGVyKCdob3N0JylcbiAgaWYgKCFzZWxmLm9yaWdpbmFsSG9zdEhlYWRlck5hbWUpIHtcbiAgICBzZWxmLm9yaWdpbmFsSG9zdEhlYWRlck5hbWUgPSBzZWxmLmhhc0hlYWRlcignaG9zdCcpXG4gIH1cbiAgaWYgKHNlbGYuc2V0SG9zdCkge1xuICAgIHNlbGYucmVtb3ZlSGVhZGVyKCdob3N0JylcbiAgfVxuICBpZiAoc2VsZi50aW1lb3V0ICYmIHNlbGYudGltZW91dFRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dFRpbWVyKVxuICAgIHNlbGYudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG5cbiAgdmFyIHRhcmdldENvb2tpZUphciA9IChzZWxmLl9qYXIgJiYgc2VsZi5famFyLnNldENvb2tpZSkgPyBzZWxmLl9qYXIgOiBnbG9iYWxDb29raWVKYXJcbiAgdmFyIGFkZENvb2tpZSA9IGZ1bmN0aW9uIChjb29raWUpIHtcbiAgICAvLyBzZXQgdGhlIGNvb2tpZSBpZiBpdCdzIGRvbWFpbiBpbiB0aGUgaHJlZidzIGRvbWFpbi5cbiAgICB0cnkge1xuICAgICAgdGFyZ2V0Q29va2llSmFyLnNldENvb2tpZShjb29raWUsIHNlbGYudXJpLmhyZWYsIHtpZ25vcmVFcnJvcjogdHJ1ZX0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGUpXG4gICAgfVxuICB9XG5cbiAgcmVzcG9uc2UuY2FzZWxlc3MgPSBjYXNlbGVzcyhyZXNwb25zZS5oZWFkZXJzKVxuXG4gIGlmIChyZXNwb25zZS5jYXNlbGVzcy5oYXMoJ3NldC1jb29raWUnKSAmJiAoIXNlbGYuX2Rpc2FibGVDb29raWVzKSkge1xuICAgIHZhciBoZWFkZXJOYW1lID0gcmVzcG9uc2UuY2FzZWxlc3MuaGFzKCdzZXQtY29va2llJylcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZS5oZWFkZXJzW2hlYWRlck5hbWVdKSkge1xuICAgICAgcmVzcG9uc2UuaGVhZGVyc1toZWFkZXJOYW1lXS5mb3JFYWNoKGFkZENvb2tpZSlcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQ29va2llKHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyTmFtZV0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGYuX3JlZGlyZWN0Lm9uUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgcmV0dXJuIC8vIElnbm9yZSB0aGUgcmVzdCBvZiB0aGUgcmVzcG9uc2VcbiAgfSBlbHNlIHtcbiAgICAvLyBCZSBhIGdvb2Qgc3RyZWFtIGFuZCBlbWl0IGVuZCB3aGVuIHRoZSByZXNwb25zZSBpcyBmaW5pc2hlZC5cbiAgICAvLyBIYWNrIHRvIGVtaXQgZW5kIG9uIGNsb3NlIGJlY2F1c2Ugb2YgYSBjb3JlIGJ1ZyB0aGF0IG5ldmVyIGZpcmVzIGVuZFxuICAgIHJlc3BvbnNlLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc2VsZi5fZW5kZWQpIHtcbiAgICAgICAgc2VsZi5yZXNwb25zZS5lbWl0KCdlbmQnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXNwb25zZS5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLl9lbmRlZCA9IHRydWVcbiAgICB9KVxuXG4gICAgdmFyIG5vQm9keSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzZWxmLm1ldGhvZCA9PT0gJ0hFQUQnIHx8XG4gICAgICAgIC8vIEluZm9ybWF0aW9uYWxcbiAgICAgICAgKGNvZGUgPj0gMTAwICYmIGNvZGUgPCAyMDApIHx8XG4gICAgICAgIC8vIE5vIENvbnRlbnRcbiAgICAgICAgY29kZSA9PT0gMjA0IHx8XG4gICAgICAgIC8vIE5vdCBNb2RpZmllZFxuICAgICAgICBjb2RlID09PSAzMDRcbiAgICAgIClcbiAgICB9XG5cbiAgICB2YXIgcmVzcG9uc2VDb250ZW50XG4gICAgaWYgKHNlbGYuZ3ppcCAmJiAhbm9Cb2R5KHJlc3BvbnNlLnN0YXR1c0NvZGUpKSB7XG4gICAgICB2YXIgY29udGVudEVuY29kaW5nID0gcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddIHx8ICdpZGVudGl0eSdcbiAgICAgIGNvbnRlbnRFbmNvZGluZyA9IGNvbnRlbnRFbmNvZGluZy50cmltKCkudG9Mb3dlckNhc2UoKVxuXG4gICAgICAvLyBCZSBtb3JlIGxlbmllbnQgd2l0aCBkZWNvZGluZyBjb21wcmVzc2VkIHJlc3BvbnNlcywgc2luY2UgKHZlcnkgcmFyZWx5KVxuICAgICAgLy8gc2VydmVycyBzZW5kIHNsaWdodGx5IGludmFsaWQgZ3ppcCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcbiAgICAgIC8vIGJ5IGNvbW1vbiBicm93c2Vycy5cbiAgICAgIC8vIEFsd2F5cyB1c2luZyBaX1NZTkNfRkxVU0ggaXMgd2hhdCBjVVJMIGRvZXMuXG4gICAgICB2YXIgemxpYk9wdGlvbnMgPSB7XG4gICAgICAgIGZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSCxcbiAgICAgICAgZmluaXNoRmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNIXG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZW50RW5jb2RpbmcgPT09ICdnemlwJykge1xuICAgICAgICByZXNwb25zZUNvbnRlbnQgPSB6bGliLmNyZWF0ZUd1bnppcCh6bGliT3B0aW9ucylcbiAgICAgICAgcmVzcG9uc2UucGlwZShyZXNwb25zZUNvbnRlbnQpXG4gICAgICB9IGVsc2UgaWYgKGNvbnRlbnRFbmNvZGluZyA9PT0gJ2RlZmxhdGUnKSB7XG4gICAgICAgIHJlc3BvbnNlQ29udGVudCA9IHpsaWIuY3JlYXRlSW5mbGF0ZSh6bGliT3B0aW9ucylcbiAgICAgICAgcmVzcG9uc2UucGlwZShyZXNwb25zZUNvbnRlbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaW5jZSBwcmV2aW91cyB2ZXJzaW9ucyBkaWRuJ3QgY2hlY2sgZm9yIENvbnRlbnQtRW5jb2RpbmcgaGVhZGVyLFxuICAgICAgICAvLyBpZ25vcmUgYW55IGludmFsaWQgdmFsdWVzIHRvIHByZXNlcnZlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5XG4gICAgICAgIGlmIChjb250ZW50RW5jb2RpbmcgIT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICBkZWJ1ZygnaWdub3JpbmcgdW5yZWNvZ25pemVkIENvbnRlbnQtRW5jb2RpbmcgJyArIGNvbnRlbnRFbmNvZGluZylcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZUNvbnRlbnQgPSByZXNwb25zZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZUNvbnRlbnQgPSByZXNwb25zZVxuICAgIH1cblxuICAgIGlmIChzZWxmLmVuY29kaW5nKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSWdub3JpbmcgZW5jb2RpbmcgcGFyYW1ldGVyIGFzIHRoaXMgc3RyZWFtIGlzIGJlaW5nIHBpcGVkIHRvIGFub3RoZXIgc3RyZWFtIHdoaWNoIG1ha2VzIHRoZSBlbmNvZGluZyBvcHRpb24gaW52YWxpZC4nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2VDb250ZW50LnNldEVuY29kaW5nKHNlbGYuZW5jb2RpbmcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX3BhdXNlZCkge1xuICAgICAgcmVzcG9uc2VDb250ZW50LnBhdXNlKClcbiAgICB9XG5cbiAgICBzZWxmLnJlc3BvbnNlQ29udGVudCA9IHJlc3BvbnNlQ29udGVudFxuXG4gICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlc3BvbnNlKVxuXG4gICAgc2VsZi5kZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChkZXN0KSB7XG4gICAgICBzZWxmLnBpcGVEZXN0KGRlc3QpXG4gICAgfSlcblxuICAgIHJlc3BvbnNlQ29udGVudC5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgaWYgKHNlbGYudGltaW5nICYmICFzZWxmLnJlc3BvbnNlU3RhcnRlZCkge1xuICAgICAgICBzZWxmLnJlc3BvbnNlU3RhcnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKVxuXG4gICAgICAgIC8vIE5PVEU6IHJlc3BvbnNlU3RhcnRUaW1lIGlzIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgLnRpbWluZ3NcbiAgICAgICAgcmVzcG9uc2UucmVzcG9uc2VTdGFydFRpbWUgPSBzZWxmLnJlc3BvbnNlU3RhcnRUaW1lXG4gICAgICB9XG4gICAgICBzZWxmLl9kZXN0ZGF0YSA9IHRydWVcbiAgICAgIHNlbGYuZW1pdCgnZGF0YScsIGNodW5rKVxuICAgIH0pXG4gICAgcmVzcG9uc2VDb250ZW50Lm9uY2UoJ2VuZCcsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgc2VsZi5lbWl0KCdlbmQnLCBjaHVuaylcbiAgICB9KVxuICAgIHJlc3BvbnNlQ29udGVudC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICB9KVxuICAgIHJlc3BvbnNlQ29udGVudC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7IHNlbGYuZW1pdCgnY2xvc2UnKSB9KVxuXG4gICAgaWYgKHNlbGYuY2FsbGJhY2spIHtcbiAgICAgIHNlbGYucmVhZFJlc3BvbnNlQm9keShyZXNwb25zZSlcbiAgICB9IGVsc2UgeyAvLyBpZiBubyBjYWxsYmFja1xuICAgICAgc2VsZi5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgICAgICAgIGRlYnVnKCdhYm9ydGVkJywgc2VsZi51cmkuaHJlZilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzZWxmLmVtaXQoJ2NvbXBsZXRlJywgcmVzcG9uc2UpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuICBkZWJ1ZygnZmluaXNoIGluaXQgZnVuY3Rpb24nLCBzZWxmLnVyaS5ocmVmKVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5yZWFkUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1ZyhcInJlYWRpbmcgcmVzcG9uc2UncyBib2R5XCIpXG4gIHZhciBidWZmZXJzID0gW11cbiAgdmFyIGJ1ZmZlckxlbmd0aCA9IDBcbiAgdmFyIHN0cmluZ3MgPSBbXVxuXG4gIHNlbGYub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIHN0cmluZ3MucHVzaChjaHVuaylcbiAgICB9IGVsc2UgaWYgKGNodW5rLmxlbmd0aCkge1xuICAgICAgYnVmZmVyTGVuZ3RoICs9IGNodW5rLmxlbmd0aFxuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKVxuICAgIH1cbiAgfSlcbiAgc2VsZi5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCdlbmQgZXZlbnQnLCBzZWxmLnVyaS5ocmVmKVxuICAgIGlmIChzZWxmLl9hYm9ydGVkKSB7XG4gICAgICBkZWJ1ZygnYWJvcnRlZCcsIHNlbGYudXJpLmhyZWYpXG4gICAgICAvLyBgYnVmZmVyYCBpcyBkZWZpbmVkIGluIHRoZSBwYXJlbnQgc2NvcGUgYW5kIHVzZWQgaW4gYSBjbG9zdXJlIGl0IGV4aXN0cyBmb3IgdGhlIGxpZmUgb2YgdGhlIHJlcXVlc3QuXG4gICAgICAvLyBUaGlzIGNhbiBsZWFkIHRvIGxlYWt5IGJlaGF2aW9yIGlmIHRoZSB1c2VyIHJldGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAgYnVmZmVycyA9IFtdXG4gICAgICBidWZmZXJMZW5ndGggPSAwXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyTGVuZ3RoKSB7XG4gICAgICBkZWJ1ZygnaGFzIGJvZHknLCBzZWxmLnVyaS5ocmVmLCBidWZmZXJMZW5ndGgpXG4gICAgICByZXNwb25zZS5ib2R5ID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBidWZmZXJMZW5ndGgpXG4gICAgICBpZiAoc2VsZi5lbmNvZGluZyAhPT0gbnVsbCkge1xuICAgICAgICByZXNwb25zZS5ib2R5ID0gcmVzcG9uc2UuYm9keS50b1N0cmluZyhzZWxmLmVuY29kaW5nKVxuICAgICAgfVxuICAgICAgLy8gYGJ1ZmZlcmAgaXMgZGVmaW5lZCBpbiB0aGUgcGFyZW50IHNjb3BlIGFuZCB1c2VkIGluIGEgY2xvc3VyZSBpdCBleGlzdHMgZm9yIHRoZSBsaWZlIG9mIHRoZSBSZXF1ZXN0LlxuICAgICAgLy8gVGhpcyBjYW4gbGVhZCB0byBsZWFreSBiZWhhdmlvciBpZiB0aGUgdXNlciByZXRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICAgIGJ1ZmZlcnMgPSBbXVxuICAgICAgYnVmZmVyTGVuZ3RoID0gMFxuICAgIH0gZWxzZSBpZiAoc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgIC8vIFRoZSBVVEY4IEJPTSBbMHhFRiwweEJCLDB4QkZdIGlzIGNvbnZlcnRlZCB0byBbMHhGRSwweEZGXSBpbiB0aGUgSlMgVVRDMTYvVUNTMiByZXByZXNlbnRhdGlvbi5cbiAgICAgIC8vIFN0cmlwIHRoaXMgdmFsdWUgb3V0IHdoZW4gdGhlIGVuY29kaW5nIGlzIHNldCB0byAndXRmOCcsIGFzIHVwc3RyZWFtIGNvbnN1bWVycyB3b24ndCBleHBlY3QgaXQgYW5kIGl0IGJyZWFrcyBKU09OLnBhcnNlKCkuXG4gICAgICBpZiAoc2VsZi5lbmNvZGluZyA9PT0gJ3V0ZjgnICYmIHN0cmluZ3NbMF0ubGVuZ3RoID4gMCAmJiBzdHJpbmdzWzBdWzBdID09PSAnXFx1RkVGRicpIHtcbiAgICAgICAgc3RyaW5nc1swXSA9IHN0cmluZ3NbMF0uc3Vic3RyaW5nKDEpXG4gICAgICB9XG4gICAgICByZXNwb25zZS5ib2R5ID0gc3RyaW5ncy5qb2luKCcnKVxuICAgIH1cblxuICAgIGlmIChzZWxmLl9qc29uKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZS5ib2R5ID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5LCBzZWxmLl9qc29uUmV2aXZlcilcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoJ2ludmFsaWQgSlNPTiByZWNlaXZlZCcsIHNlbGYudXJpLmhyZWYpXG4gICAgICB9XG4gICAgfVxuICAgIGRlYnVnKCdlbWl0dGluZyBjb21wbGV0ZScsIHNlbGYudXJpLmhyZWYpXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZS5ib2R5ID09PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5fanNvbikge1xuICAgICAgcmVzcG9uc2UuYm9keSA9IHNlbGYuZW5jb2RpbmcgPT09IG51bGwgPyBCdWZmZXIuYWxsb2MoMCkgOiAnJ1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2NvbXBsZXRlJywgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gIH0pXG59XG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5fYWJvcnRlZCA9IHRydWVcblxuICBpZiAoc2VsZi5yZXEpIHtcbiAgICBzZWxmLnJlcS5hYm9ydCgpXG4gIH0gZWxzZSBpZiAoc2VsZi5yZXNwb25zZSkge1xuICAgIHNlbGYucmVzcG9uc2UuZGVzdHJveSgpXG4gIH1cblxuICBzZWxmLmVtaXQoJ2Fib3J0Jylcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUucGlwZURlc3QgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdmFyIHJlc3BvbnNlID0gc2VsZi5yZXNwb25zZVxuICAvLyBDYWxsZWQgYWZ0ZXIgdGhlIHJlc3BvbnNlIGlzIHJlY2VpdmVkXG4gIGlmIChkZXN0LmhlYWRlcnMgJiYgIWRlc3QuaGVhZGVyc1NlbnQpIHtcbiAgICBpZiAocmVzcG9uc2UuY2FzZWxlc3MuaGFzKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgdmFyIGN0bmFtZSA9IHJlc3BvbnNlLmNhc2VsZXNzLmhhcygnY29udGVudC10eXBlJylcbiAgICAgIGlmIChkZXN0LnNldEhlYWRlcikge1xuICAgICAgICBkZXN0LnNldEhlYWRlcihjdG5hbWUsIHJlc3BvbnNlLmhlYWRlcnNbY3RuYW1lXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3QuaGVhZGVyc1tjdG5hbWVdID0gcmVzcG9uc2UuaGVhZGVyc1tjdG5hbWVdXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLmNhc2VsZXNzLmhhcygnY29udGVudC1sZW5ndGgnKSkge1xuICAgICAgdmFyIGNsbmFtZSA9IHJlc3BvbnNlLmNhc2VsZXNzLmhhcygnY29udGVudC1sZW5ndGgnKVxuICAgICAgaWYgKGRlc3Quc2V0SGVhZGVyKSB7XG4gICAgICAgIGRlc3Quc2V0SGVhZGVyKGNsbmFtZSwgcmVzcG9uc2UuaGVhZGVyc1tjbG5hbWVdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzdC5oZWFkZXJzW2NsbmFtZV0gPSByZXNwb25zZS5oZWFkZXJzW2NsbmFtZV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRlc3Quc2V0SGVhZGVyICYmICFkZXN0LmhlYWRlcnNTZW50KSB7XG4gICAgZm9yICh2YXIgaSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAvLyBJZiB0aGUgcmVzcG9uc2UgY29udGVudCBpcyBiZWluZyBkZWNvZGVkLCB0aGUgQ29udGVudC1FbmNvZGluZyBoZWFkZXJcbiAgICAgIC8vIG9mIHRoZSByZXNwb25zZSBkb2Vzbid0IHJlcHJlc2VudCB0aGUgcGlwZWQgY29udGVudCwgc28gZG9uJ3QgcGFzcyBpdC5cbiAgICAgIGlmICghc2VsZi5nemlwIHx8IGkgIT09ICdjb250ZW50LWVuY29kaW5nJykge1xuICAgICAgICBkZXN0LnNldEhlYWRlcihpLCByZXNwb25zZS5oZWFkZXJzW2ldKVxuICAgICAgfVxuICAgIH1cbiAgICBkZXN0LnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlXG4gIH1cbiAgaWYgKHNlbGYucGlwZWZpbHRlcikge1xuICAgIHNlbGYucGlwZWZpbHRlcihyZXNwb25zZSwgZGVzdClcbiAgfVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5xcyA9IGZ1bmN0aW9uIChxLCBjbG9iYmVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgYmFzZVxuICBpZiAoIWNsb2JiZXIgJiYgc2VsZi51cmkucXVlcnkpIHtcbiAgICBiYXNlID0gc2VsZi5fcXMucGFyc2Uoc2VsZi51cmkucXVlcnkpXG4gIH0gZWxzZSB7XG4gICAgYmFzZSA9IHt9XG4gIH1cblxuICBmb3IgKHZhciBpIGluIHEpIHtcbiAgICBiYXNlW2ldID0gcVtpXVxuICB9XG5cbiAgdmFyIHFzID0gc2VsZi5fcXMuc3RyaW5naWZ5KGJhc2UpXG5cbiAgaWYgKHFzID09PSAnJykge1xuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICBzZWxmLnVyaSA9IHVybC5wYXJzZShzZWxmLnVyaS5ocmVmLnNwbGl0KCc/JylbMF0gKyAnPycgKyBxcylcbiAgc2VsZi51cmwgPSBzZWxmLnVyaVxuICBzZWxmLnBhdGggPSBzZWxmLnVyaS5wYXRoXG5cbiAgaWYgKHNlbGYudXJpLmhvc3QgPT09ICd1bml4Jykge1xuICAgIHNlbGYuZW5hYmxlVW5peFNvY2tldCgpXG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuUmVxdWVzdC5wcm90b3R5cGUuZm9ybSA9IGZ1bmN0aW9uIChmb3JtKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoZm9ybSkge1xuICAgIGlmICghL15hcHBsaWNhdGlvblxcL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcYi8udGVzdChzZWxmLmdldEhlYWRlcignY29udGVudC10eXBlJykpKSB7XG4gICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpXG4gICAgfVxuICAgIHNlbGYuYm9keSA9ICh0eXBlb2YgZm9ybSA9PT0gJ3N0cmluZycpXG4gICAgICA/IHNlbGYuX3FzLnJmYzM5ODYoZm9ybS50b1N0cmluZygndXRmOCcpKVxuICAgICAgOiBzZWxmLl9xcy5zdHJpbmdpZnkoZm9ybSkudG9TdHJpbmcoJ3V0ZjgnKVxuICAgIHJldHVybiBzZWxmXG4gIH1cbiAgLy8gY3JlYXRlIGZvcm0tZGF0YSBvYmplY3RcbiAgc2VsZi5fZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gIHNlbGYuX2Zvcm0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIGVyci5tZXNzYWdlID0gJ2Zvcm0tZGF0YTogJyArIGVyci5tZXNzYWdlXG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICBzZWxmLmFib3J0KClcbiAgfSlcbiAgcmV0dXJuIHNlbGYuX2Zvcm1cbn1cblJlcXVlc3QucHJvdG90eXBlLm11bHRpcGFydCA9IGZ1bmN0aW9uIChtdWx0aXBhcnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgc2VsZi5fbXVsdGlwYXJ0Lm9uUmVxdWVzdChtdWx0aXBhcnQpXG5cbiAgaWYgKCFzZWxmLl9tdWx0aXBhcnQuY2h1bmtlZCkge1xuICAgIHNlbGYuYm9keSA9IHNlbGYuX211bHRpcGFydC5ib2R5XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuUmVxdWVzdC5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKCFzZWxmLmhhc0hlYWRlcignYWNjZXB0JykpIHtcbiAgICBzZWxmLnNldEhlYWRlcignYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzZWxmLmpzb25SZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuX2pzb25SZXBsYWNlciA9IHNlbGYuanNvblJlcGxhY2VyXG4gIH1cblxuICBzZWxmLl9qc29uID0gdHJ1ZVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgaWYgKHNlbGYuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIS9eYXBwbGljYXRpb25cXC94LXd3dy1mb3JtLXVybGVuY29kZWRcXGIvLnRlc3Qoc2VsZi5nZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKSkge1xuICAgICAgICBzZWxmLmJvZHkgPSBzYWZlU3RyaW5naWZ5KHNlbGYuYm9keSwgc2VsZi5fanNvblJlcGxhY2VyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5fcXMucmZjMzk4NihzZWxmLmJvZHkpXG4gICAgICB9XG4gICAgICBpZiAoIXNlbGYuaGFzSGVhZGVyKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxmLmJvZHkgPSBzYWZlU3RyaW5naWZ5KHZhbCwgc2VsZi5fanNvblJlcGxhY2VyKVxuICAgIGlmICghc2VsZi5oYXNIZWFkZXIoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICBzZWxmLnNldEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZi5qc29uUmV2aXZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNlbGYuX2pzb25SZXZpdmVyID0gc2VsZi5qc29uUmV2aXZlclxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblJlcXVlc3QucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCBoZWFkZXJzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcmVzdWx0LCByZSwgbWF0Y2hcbiAgaWYgKCFoZWFkZXJzKSB7XG4gICAgaGVhZGVycyA9IHNlbGYuaGVhZGVyc1xuICB9XG4gIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkubGVuZ3RoICE9PSBuYW1lLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJlID0gbmV3IFJlZ0V4cChuYW1lLCAnaScpXG4gICAgbWF0Y2ggPSBrZXkubWF0Y2gocmUpXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXN1bHQgPSBoZWFkZXJzW2tleV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblJlcXVlc3QucHJvdG90eXBlLmVuYWJsZVVuaXhTb2NrZXQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIEdldCB0aGUgc29ja2V0ICYgcmVxdWVzdCBwYXRocyBmcm9tIHRoZSBVUkxcbiAgdmFyIHVuaXhQYXJ0cyA9IHRoaXMudXJpLnBhdGguc3BsaXQoJzonKVxuICB2YXIgaG9zdCA9IHVuaXhQYXJ0c1swXVxuICB2YXIgcGF0aCA9IHVuaXhQYXJ0c1sxXVxuICAvLyBBcHBseSB1bml4IHByb3BlcnRpZXMgdG8gcmVxdWVzdFxuICB0aGlzLnNvY2tldFBhdGggPSBob3N0XG4gIHRoaXMudXJpLnBhdGhuYW1lID0gcGF0aFxuICB0aGlzLnVyaS5wYXRoID0gcGF0aFxuICB0aGlzLnVyaS5ob3N0ID0gaG9zdFxuICB0aGlzLnVyaS5ob3N0bmFtZSA9IGhvc3RcbiAgdGhpcy51cmkuaXNVbml4ID0gdHJ1ZVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24gKHVzZXIsIHBhc3MsIHNlbmRJbW1lZGlhdGVseSwgYmVhcmVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHNlbGYuX2F1dGgub25SZXF1ZXN0KHVzZXIsIHBhc3MsIHNlbmRJbW1lZGlhdGVseSwgYmVhcmVyKVxuXG4gIHJldHVybiBzZWxmXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5hd3MgPSBmdW5jdGlvbiAob3B0cywgbm93KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmICghbm93KSB7XG4gICAgc2VsZi5fYXdzID0gb3B0c1xuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICBpZiAob3B0cy5zaWduX3ZlcnNpb24gPT09IDQgfHwgb3B0cy5zaWduX3ZlcnNpb24gPT09ICc0Jykge1xuICAgIC8vIHVzZSBhd3M0XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBob3N0OiBzZWxmLnVyaS5ob3N0LFxuICAgICAgcGF0aDogc2VsZi51cmkucGF0aCxcbiAgICAgIG1ldGhvZDogc2VsZi5tZXRob2QsXG4gICAgICBoZWFkZXJzOiBzZWxmLmhlYWRlcnMsXG4gICAgICBib2R5OiBzZWxmLmJvZHlcbiAgICB9XG4gICAgaWYgKG9wdHMuc2VydmljZSkge1xuICAgICAgb3B0aW9ucy5zZXJ2aWNlID0gb3B0cy5zZXJ2aWNlXG4gICAgfVxuICAgIHZhciBzaWduUmVzID0gYXdzNC5zaWduKG9wdGlvbnMsIHtcbiAgICAgIGFjY2Vzc0tleUlkOiBvcHRzLmtleSxcbiAgICAgIHNlY3JldEFjY2Vzc0tleTogb3B0cy5zZWNyZXQsXG4gICAgICBzZXNzaW9uVG9rZW46IG9wdHMuc2Vzc2lvblxuICAgIH0pXG4gICAgc2VsZi5zZXRIZWFkZXIoJ2F1dGhvcml6YXRpb24nLCBzaWduUmVzLmhlYWRlcnMuQXV0aG9yaXphdGlvbilcbiAgICBzZWxmLnNldEhlYWRlcigneC1hbXotZGF0ZScsIHNpZ25SZXMuaGVhZGVyc1snWC1BbXotRGF0ZSddKVxuICAgIGlmIChzaWduUmVzLmhlYWRlcnNbJ1gtQW16LVNlY3VyaXR5LVRva2VuJ10pIHtcbiAgICAgIHNlbGYuc2V0SGVhZGVyKCd4LWFtei1zZWN1cml0eS10b2tlbicsIHNpZ25SZXMuaGVhZGVyc1snWC1BbXotU2VjdXJpdHktVG9rZW4nXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVmYXVsdDogdXNlIGF3cy1zaWduMlxuICAgIHZhciBkYXRlID0gbmV3IERhdGUoKVxuICAgIHNlbGYuc2V0SGVhZGVyKCdkYXRlJywgZGF0ZS50b1VUQ1N0cmluZygpKVxuICAgIHZhciBhdXRoID0ge1xuICAgICAga2V5OiBvcHRzLmtleSxcbiAgICAgIHNlY3JldDogb3B0cy5zZWNyZXQsXG4gICAgICB2ZXJiOiBzZWxmLm1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgIGNvbnRlbnRUeXBlOiBzZWxmLmdldEhlYWRlcignY29udGVudC10eXBlJykgfHwgJycsXG4gICAgICBtZDU6IHNlbGYuZ2V0SGVhZGVyKCdjb250ZW50LW1kNScpIHx8ICcnLFxuICAgICAgYW1hem9uSGVhZGVyczogYXdzMi5jYW5vbmljYWxpemVIZWFkZXJzKHNlbGYuaGVhZGVycylcbiAgICB9XG4gICAgdmFyIHBhdGggPSBzZWxmLnVyaS5wYXRoXG4gICAgaWYgKG9wdHMuYnVja2V0ICYmIHBhdGgpIHtcbiAgICAgIGF1dGgucmVzb3VyY2UgPSAnLycgKyBvcHRzLmJ1Y2tldCArIHBhdGhcbiAgICB9IGVsc2UgaWYgKG9wdHMuYnVja2V0ICYmICFwYXRoKSB7XG4gICAgICBhdXRoLnJlc291cmNlID0gJy8nICsgb3B0cy5idWNrZXRcbiAgICB9IGVsc2UgaWYgKCFvcHRzLmJ1Y2tldCAmJiBwYXRoKSB7XG4gICAgICBhdXRoLnJlc291cmNlID0gcGF0aFxuICAgIH0gZWxzZSBpZiAoIW9wdHMuYnVja2V0ICYmICFwYXRoKSB7XG4gICAgICBhdXRoLnJlc291cmNlID0gJy8nXG4gICAgfVxuICAgIGF1dGgucmVzb3VyY2UgPSBhd3MyLmNhbm9uaWNhbGl6ZVJlc291cmNlKGF1dGgucmVzb3VyY2UpXG4gICAgc2VsZi5zZXRIZWFkZXIoJ2F1dGhvcml6YXRpb24nLCBhd3MyLmF1dGhvcml6YXRpb24oYXV0aCkpXG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuUmVxdWVzdC5wcm90b3R5cGUuaHR0cFNpZ25hdHVyZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBodHRwU2lnbmF0dXJlLnNpZ25SZXF1ZXN0KHtcbiAgICBnZXRIZWFkZXI6IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgIHJldHVybiBzZWxmLmdldEhlYWRlcihoZWFkZXIsIHNlbGYuaGVhZGVycylcbiAgICB9LFxuICAgIHNldEhlYWRlcjogZnVuY3Rpb24gKGhlYWRlciwgdmFsdWUpIHtcbiAgICAgIHNlbGYuc2V0SGVhZGVyKGhlYWRlciwgdmFsdWUpXG4gICAgfSxcbiAgICBtZXRob2Q6IHNlbGYubWV0aG9kLFxuICAgIHBhdGg6IHNlbGYucGF0aFxuICB9LCBvcHRzKVxuICBkZWJ1ZygnaHR0cFNpZ25hdHVyZSBhdXRob3JpemF0aW9uJywgc2VsZi5nZXRIZWFkZXIoJ2F1dGhvcml6YXRpb24nKSlcblxuICByZXR1cm4gc2VsZlxufVxuUmVxdWVzdC5wcm90b3R5cGUuaGF3ayA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBzZWxmLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsIGhhd2suaGVhZGVyKHNlbGYudXJpLCBzZWxmLm1ldGhvZCwgb3B0cykpXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5vYXV0aCA9IGZ1bmN0aW9uIChfb2F1dGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgc2VsZi5fb2F1dGgub25SZXF1ZXN0KF9vYXV0aClcblxuICByZXR1cm4gc2VsZlxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5qYXIgPSBmdW5jdGlvbiAoamFyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgY29va2llc1xuXG4gIGlmIChzZWxmLl9yZWRpcmVjdC5yZWRpcmVjdHNGb2xsb3dlZCA9PT0gMCkge1xuICAgIHNlbGYub3JpZ2luYWxDb29raWVIZWFkZXIgPSBzZWxmLmdldEhlYWRlcignY29va2llJylcbiAgfVxuXG4gIGlmICghamFyKSB7XG4gICAgLy8gZGlzYWJsZSBjb29raWVzXG4gICAgY29va2llcyA9IGZhbHNlXG4gICAgc2VsZi5fZGlzYWJsZUNvb2tpZXMgPSB0cnVlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldENvb2tpZUphciA9IChqYXIgJiYgamFyLmdldENvb2tpZVN0cmluZykgPyBqYXIgOiBnbG9iYWxDb29raWVKYXJcbiAgICB2YXIgdXJpaHJlZiA9IHNlbGYudXJpLmhyZWZcbiAgICAvLyBmZXRjaCBjb29raWUgaW4gdGhlIFNwZWNpZmllZCBob3N0XG4gICAgaWYgKHRhcmdldENvb2tpZUphcikge1xuICAgICAgY29va2llcyA9IHRhcmdldENvb2tpZUphci5nZXRDb29raWVTdHJpbmcodXJpaHJlZilcbiAgICB9XG4gIH1cblxuICAvLyBpZiBuZWVkIGNvb2tpZSBhbmQgY29va2llIGlzIG5vdCBlbXB0eVxuICBpZiAoY29va2llcyAmJiBjb29raWVzLmxlbmd0aCkge1xuICAgIGlmIChzZWxmLm9yaWdpbmFsQ29va2llSGVhZGVyKSB7XG4gICAgICAvLyBEb24ndCBvdmVyd3JpdGUgZXhpc3RpbmcgQ29va2llIGhlYWRlclxuICAgICAgc2VsZi5zZXRIZWFkZXIoJ2Nvb2tpZScsIHNlbGYub3JpZ2luYWxDb29raWVIZWFkZXIgKyAnOyAnICsgY29va2llcylcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXRIZWFkZXIoJ2Nvb2tpZScsIGNvb2tpZXMpXG4gICAgfVxuICB9XG4gIHNlbGYuX2phciA9IGphclxuICByZXR1cm4gc2VsZlxufVxuXG4vLyBTdHJlYW0gQVBJXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYucmVzcG9uc2UpIHtcbiAgICBpZiAoc2VsZi5fZGVzdGRhdGEpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgcGlwZSBhZnRlciBkYXRhIGhhcyBiZWVuIGVtaXR0ZWQgZnJvbSB0aGUgcmVzcG9uc2UuJykpXG4gICAgfSBlbHNlIGlmIChzZWxmLl9lbmRlZCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignWW91IGNhbm5vdCBwaXBlIGFmdGVyIHRoZSByZXNwb25zZSBoYXMgYmVlbiBlbmRlZC4nKSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLlN0cmVhbS5wcm90b3R5cGUucGlwZS5jYWxsKHNlbGYsIGRlc3QsIG9wdHMpXG4gICAgICBzZWxmLnBpcGVEZXN0KGRlc3QpXG4gICAgICByZXR1cm4gZGVzdFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxmLmRlc3RzLnB1c2goZGVzdClcbiAgICBzdHJlYW0uU3RyZWFtLnByb3RvdHlwZS5waXBlLmNhbGwoc2VsZiwgZGVzdCwgb3B0cylcbiAgICByZXR1cm4gZGVzdFxuICB9XG59XG5SZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLl9hYm9ydGVkKSB7IHJldHVybiB9XG5cbiAgaWYgKCFzZWxmLl9zdGFydGVkKSB7XG4gICAgc2VsZi5zdGFydCgpXG4gIH1cbiAgaWYgKHNlbGYucmVxKSB7XG4gICAgcmV0dXJuIHNlbGYucmVxLndyaXRlLmFwcGx5KHNlbGYucmVxLCBhcmd1bWVudHMpXG4gIH1cbn1cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHNlbGYuX2Fib3J0ZWQpIHsgcmV0dXJuIH1cblxuICBpZiAoY2h1bmspIHtcbiAgICBzZWxmLndyaXRlKGNodW5rKVxuICB9XG4gIGlmICghc2VsZi5fc3RhcnRlZCkge1xuICAgIHNlbGYuc3RhcnQoKVxuICB9XG4gIGlmIChzZWxmLnJlcSkge1xuICAgIHNlbGYucmVxLmVuZCgpXG4gIH1cbn1cblJlcXVlc3QucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCFzZWxmLnJlc3BvbnNlQ29udGVudCkge1xuICAgIHNlbGYuX3BhdXNlZCA9IHRydWVcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnJlc3BvbnNlQ29udGVudC5wYXVzZS5hcHBseShzZWxmLnJlc3BvbnNlQ29udGVudCwgYXJndW1lbnRzKVxuICB9XG59XG5SZXF1ZXN0LnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIXNlbGYucmVzcG9uc2VDb250ZW50KSB7XG4gICAgc2VsZi5fcGF1c2VkID0gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnJlc3BvbnNlQ29udGVudC5yZXN1bWUuYXBwbHkoc2VsZi5yZXNwb25zZUNvbnRlbnQsIGFyZ3VtZW50cylcbiAgfVxufVxuUmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghc2VsZi5fZW5kZWQpIHtcbiAgICBzZWxmLmVuZCgpXG4gIH0gZWxzZSBpZiAoc2VsZi5yZXNwb25zZSkge1xuICAgIHNlbGYucmVzcG9uc2UuZGVzdHJveSgpXG4gIH1cbn1cblxuUmVxdWVzdC5kZWZhdWx0UHJveHlIZWFkZXJXaGl0ZUxpc3QgPVxuICBUdW5uZWwuZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0LnNsaWNlKClcblxuUmVxdWVzdC5kZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID1cbiAgVHVubmVsLmRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3Quc2xpY2UoKVxuXG4vLyBFeHBvcnRzXG5cblJlcXVlc3QucHJvdG90eXBlLnRvSlNPTiA9IHJlcXVlc3RUb0pTT05cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdFxuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxudmFyIHNhZmVyID0ge31cblxudmFyIGtleVxuXG5mb3IgKGtleSBpbiBidWZmZXIpIHtcbiAgaWYgKCFidWZmZXIuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWVcbiAgaWYgKGtleSA9PT0gJ1Nsb3dCdWZmZXInIHx8IGtleSA9PT0gJ0J1ZmZlcicpIGNvbnRpbnVlXG4gIHNhZmVyW2tleV0gPSBidWZmZXJba2V5XVxufVxuXG52YXIgU2FmZXIgPSBzYWZlci5CdWZmZXIgPSB7fVxuZm9yIChrZXkgaW4gQnVmZmVyKSB7XG4gIGlmICghQnVmZmVyLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlXG4gIGlmIChrZXkgPT09ICdhbGxvY1Vuc2FmZScgfHwga2V5ID09PSAnYWxsb2NVbnNhZmVTbG93JykgY29udGludWVcbiAgU2FmZXJba2V5XSA9IEJ1ZmZlcltrZXldXG59XG5cbnNhZmVyLkJ1ZmZlci5wcm90b3R5cGUgPSBCdWZmZXIucHJvdG90eXBlXG5cbmlmICghU2FmZXIuZnJvbSB8fCBTYWZlci5mcm9tID09PSBVaW50OEFycmF5LmZyb20pIHtcbiAgU2FmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiB2YWx1ZSlcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cbn1cblxuaWYgKCFTYWZlci5hbGxvYykge1xuICBTYWZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc2l6ZSlcbiAgICB9XG4gICAgaWYgKHNpemUgPCAwIHx8IHNpemUgPj0gMiAqICgxIDw8IDMwKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gICAgfVxuICAgIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgICBpZiAoIWZpbGwgfHwgZmlsbC5sZW5ndGggPT09IDApIHtcbiAgICAgIGJ1Zi5maWxsKDApXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG59XG5cbmlmICghc2FmZXIua1N0cmluZ01heExlbmd0aCkge1xuICB0cnkge1xuICAgIHNhZmVyLmtTdHJpbmdNYXhMZW5ndGggPSBwcm9jZXNzLmJpbmRpbmcoJ2J1ZmZlcicpLmtTdHJpbmdNYXhMZW5ndGhcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHdlIGNhbid0IGRldGVybWluZSBrU3RyaW5nTWF4TGVuZ3RoIGluIGVudmlyb25tZW50cyB3aGVyZSBwcm9jZXNzLmJpbmRpbmdcbiAgICAvLyBpcyB1bnN1cHBvcnRlZCwgc28gbGV0J3Mgbm90IHNldCBpdFxuICB9XG59XG5cbmlmICghc2FmZXIuY29uc3RhbnRzKSB7XG4gIHNhZmVyLmNvbnN0YW50cyA9IHtcbiAgICBNQVhfTEVOR1RIOiBzYWZlci5rTWF4TGVuZ3RoXG4gIH1cbiAgaWYgKHNhZmVyLmtTdHJpbmdNYXhMZW5ndGgpIHtcbiAgICBzYWZlci5jb25zdGFudHMuTUFYX1NUUklOR19MRU5HVEggPSBzYWZlci5rU3RyaW5nTWF4TGVuZ3RoXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlclxuIiwiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG5cbnZhciBhbGdJbmZvID0ge1xuXHQnZHNhJzoge1xuXHRcdHBhcnRzOiBbJ3AnLCAncScsICdnJywgJ3knXSxcblx0XHRzaXplUGFydDogJ3AnXG5cdH0sXG5cdCdyc2EnOiB7XG5cdFx0cGFydHM6IFsnZScsICduJ10sXG5cdFx0c2l6ZVBhcnQ6ICduJ1xuXHR9LFxuXHQnZWNkc2EnOiB7XG5cdFx0cGFydHM6IFsnY3VydmUnLCAnUSddLFxuXHRcdHNpemVQYXJ0OiAnUSdcblx0fSxcblx0J2VkMjU1MTknOiB7XG5cdFx0cGFydHM6IFsnQSddLFxuXHRcdHNpemVQYXJ0OiAnQSdcblx0fVxufTtcbmFsZ0luZm9bJ2N1cnZlMjU1MTknXSA9IGFsZ0luZm9bJ2VkMjU1MTknXTtcblxudmFyIGFsZ1ByaXZJbmZvID0ge1xuXHQnZHNhJzoge1xuXHRcdHBhcnRzOiBbJ3AnLCAncScsICdnJywgJ3knLCAneCddXG5cdH0sXG5cdCdyc2EnOiB7XG5cdFx0cGFydHM6IFsnbicsICdlJywgJ2QnLCAnaXFtcCcsICdwJywgJ3EnXVxuXHR9LFxuXHQnZWNkc2EnOiB7XG5cdFx0cGFydHM6IFsnY3VydmUnLCAnUScsICdkJ11cblx0fSxcblx0J2VkMjU1MTknOiB7XG5cdFx0cGFydHM6IFsnQScsICdrJ11cblx0fVxufTtcbmFsZ1ByaXZJbmZvWydjdXJ2ZTI1NTE5J10gPSBhbGdQcml2SW5mb1snZWQyNTUxOSddO1xuXG52YXIgaGFzaEFsZ3MgPSB7XG5cdCdtZDUnOiB0cnVlLFxuXHQnc2hhMSc6IHRydWUsXG5cdCdzaGEyNTYnOiB0cnVlLFxuXHQnc2hhMzg0JzogdHJ1ZSxcblx0J3NoYTUxMic6IHRydWVcbn07XG5cbi8qXG4gKiBUYWtlbiBmcm9tXG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9ncm91cHMvU1QvdG9vbGtpdC9kb2N1bWVudHMvZHNzL05JU1RSZUN1ci5wZGZcbiAqL1xudmFyIGN1cnZlcyA9IHtcblx0J25pc3RwMjU2Jzoge1xuXHRcdHNpemU6IDI1Nixcblx0XHRwa2NzOG9pZDogJzEuMi44NDAuMTAwNDUuMy4xLjcnLFxuXHRcdHA6IEJ1ZmZlci5mcm9tKCgnMDAnICtcblx0XHQgICAgJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwJyArXG5cdFx0ICAgICcwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdGE6IEJ1ZmZlci5mcm9tKCgnMDAnICtcblx0XHQgICAgJ0ZGRkZGRkZGIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwJyArXG5cdFx0ICAgICcwMDAwMDAwMCBGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGQycpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdGI6IEJ1ZmZlci5mcm9tKChcblx0XHQgICAgJzVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjJyArXG5cdFx0ICAgICc2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdHM6IEJ1ZmZlci5mcm9tKCgnMDAnICtcblx0XHQgICAgJ2M0OWQzNjA4IDg2ZTcwNDkzIDZhNjY3OGUxIDEzOWQyNmI3JyArXG5cdFx0ICAgICc4MTlmN2U5MCcpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdG46IEJ1ZmZlci5mcm9tKCgnMDAnICtcblx0XHQgICAgJ2ZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmJyArXG5cdFx0ICAgICdiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdEc6IEJ1ZmZlci5mcm9tKCgnMDQnICtcblx0XHQgICAgJzZiMTdkMWYyIGUxMmM0MjQ3IGY4YmNlNmU1IDYzYTQ0MGYyJyArXG5cdFx0ICAgICc3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicgK1xuXHRcdCAgICAnNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYnICtcblx0XHQgICAgJzJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1JykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4Jylcblx0fSxcblx0J25pc3RwMzg0Jzoge1xuXHRcdHNpemU6IDM4NCxcblx0XHRwa2NzOG9pZDogJzEuMy4xMzIuMC4zNCcsXG5cdFx0cDogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnICtcblx0XHQgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlJyArXG5cdFx0ICAgICdmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZicpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdGE6IEJ1ZmZlci5mcm9tKCgnMDAnICtcblx0XHQgICAgJ0ZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGJyArXG5cdFx0ICAgICdGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRScgK1xuXHRcdCAgICAnRkZGRkZGRkYgMDAwMDAwMDAgMDAwMDAwMDAgRkZGRkZGRkMnKS5cblx0XHQgICAgcmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKSxcblx0XHRiOiBCdWZmZXIuZnJvbSgoXG5cdFx0ICAgICdiMzMxMmZhNyBlMjNlZTdlNCA5ODhlMDU2YiBlM2Y4MmQxOScgK1xuXHRcdCAgICAnMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgNTAxMzg3NWEnICtcblx0XHQgICAgJ2M2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0czogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnYTMzNTkyNmEgYTMxOWEyN2EgMWQwMDg5NmEgNjc3M2E0ODInICtcblx0XHQgICAgJzdhY2RhYzczJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0bjogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnICtcblx0XHQgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGM3NjM0ZDgxIGY0MzcyZGRmJyArXG5cdFx0ICAgICc1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3MycpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdEc6IEJ1ZmZlci5mcm9tKCgnMDQnICtcblx0XHQgICAgJ2FhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0JyArXG5cdFx0ICAgICc2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCcgK1xuXHRcdCAgICAnNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjcnICtcblx0XHQgICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5JyArXG5cdFx0ICAgICdmOGY0MWRiZCAyODlhMTQ3YyBlOWRhMzExMyBiNWYwYjhjMCcgK1xuXHRcdCAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnKS5cblx0XHQgICAgcmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKVxuXHR9LFxuXHQnbmlzdHA1MjEnOiB7XG5cdFx0c2l6ZTogNTIxLFxuXHRcdHBrY3M4b2lkOiAnMS4zLjEzMi4wLjM1Jyxcblx0XHRwOiBCdWZmZXIuZnJvbSgoXG5cdFx0ICAgICcwMWZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicgK1xuXHRcdCAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnICtcblx0XHQgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyArXG5cdFx0ICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicgK1xuXHRcdCAgICAnZmZmZicpLnJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0YTogQnVmZmVyLmZyb20oKCcwMUZGJyArXG5cdFx0ICAgICdGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRicgK1xuXHRcdCAgICAnRkZGRkZGRkYgRkZGRkZGRkYgRkZGRkZGRkYgRkZGRkZGRkYnICtcblx0XHQgICAgJ0ZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGIEZGRkZGRkZGJyArXG5cdFx0ICAgICdGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGRiBGRkZGRkZGQycpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpLFxuXHRcdGI6IEJ1ZmZlci5mcm9tKCgnNTEnICtcblx0XHQgICAgJzk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlJyArXG5cdFx0ICAgICdhMmRhNzI1YiA5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMScgK1xuXHRcdCAgICAnNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgM2JiMWJmMDcnICtcblx0XHQgICAgJzM1NzNkZjg4IDNkMmMzNGYxIGVmNDUxZmQ0IDZiNTAzZjAwJykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0czogQnVmZmVyLmZyb20oKCcwMCcgK1xuXHRcdCAgICAnZDA5ZTg4MDAgMjkxY2I4NTMgOTZjYzY3MTcgMzkzMjg0YWEnICtcblx0XHQgICAgJ2EwZGE2NGJhJykucmVwbGFjZSgvIC9nLCAnJyksICdoZXgnKSxcblx0XHRuOiBCdWZmZXIuZnJvbSgoJzAxZmYnICtcblx0XHQgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyArXG5cdFx0ICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYScgK1xuXHRcdCAgICAnNTE4Njg3ODMgYmYyZjk2NmIgN2ZjYzAxNDggZjcwOWE1ZDAnICtcblx0XHQgICAgJzNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5JykuXG5cdFx0ICAgIHJlcGxhY2UoLyAvZywgJycpLCAnaGV4JyksXG5cdFx0RzogQnVmZmVyLmZyb20oKCcwNCcgK1xuXHRcdCAgICAnMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MicgK1xuXHRcdCAgICAgICAgICc5YzY0ODEzOSAwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYScgK1xuXHRcdCAgICAgICAgICdhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyBhMmZmYThkZScgK1xuXHRcdCAgICAgICAgICczMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicgK1xuXHRcdCAgICAnMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOScgK1xuXHRcdCAgICAgICAgICc5OGY1NDQ0OSA1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYycgK1xuXHRcdCAgICAgICAgICc5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAzZmFkMDc2MScgK1xuXHRcdCAgICAgICAgICczNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MCcpLlxuXHRcdCAgICByZXBsYWNlKC8gL2csICcnKSwgJ2hleCcpXG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRpbmZvOiBhbGdJbmZvLFxuXHRwcml2SW5mbzogYWxnUHJpdkluZm8sXG5cdGhhc2hBbGdzOiBoYXNoQWxncyxcblx0Y3VydmVzOiBjdXJ2ZXNcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAxNiBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSBDZXJ0aWZpY2F0ZTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuL2FsZ3MnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBGaW5nZXJwcmludCA9IHJlcXVpcmUoJy4vZmluZ2VycHJpbnQnKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuL3NpZ25hdHVyZScpO1xudmFyIGVycnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9wcml2YXRlLWtleScpO1xudmFyIElkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG52YXIgZm9ybWF0cyA9IHt9O1xuZm9ybWF0c1snb3BlbnNzaCddID0gcmVxdWlyZSgnLi9mb3JtYXRzL29wZW5zc2gtY2VydCcpO1xuZm9ybWF0c1sneDUwOSddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3g1MDknKTtcbmZvcm1hdHNbJ3BlbSddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3g1MDktcGVtJyk7XG5cbnZhciBDZXJ0aWZpY2F0ZVBhcnNlRXJyb3IgPSBlcnJzLkNlcnRpZmljYXRlUGFyc2VFcnJvcjtcbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSBlcnJzLkludmFsaWRBbGdvcml0aG1FcnJvcjtcblxuZnVuY3Rpb24gQ2VydGlmaWNhdGUob3B0cykge1xuXHRhc3NlcnQub2JqZWN0KG9wdHMsICdvcHRpb25zJyk7XG5cdGFzc2VydC5hcnJheU9mT2JqZWN0KG9wdHMuc3ViamVjdHMsICdvcHRpb25zLnN1YmplY3RzJyk7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUob3B0cy5zdWJqZWN0c1swXSwgSWRlbnRpdHksIFsxLCAwXSxcblx0ICAgICdvcHRpb25zLnN1YmplY3RzJyk7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUob3B0cy5zdWJqZWN0S2V5LCBLZXksIFsxLCAwXSxcblx0ICAgICdvcHRpb25zLnN1YmplY3RLZXknKTtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShvcHRzLmlzc3VlciwgSWRlbnRpdHksIFsxLCAwXSwgJ29wdGlvbnMuaXNzdWVyJyk7XG5cdGlmIChvcHRzLmlzc3VlcktleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShvcHRzLmlzc3VlcktleSwgS2V5LCBbMSwgMF0sXG5cdFx0ICAgICdvcHRpb25zLmlzc3VlcktleScpO1xuXHR9XG5cdGFzc2VydC5vYmplY3Qob3B0cy5zaWduYXR1cmVzLCAnb3B0aW9ucy5zaWduYXR1cmVzJyk7XG5cdGFzc2VydC5idWZmZXIob3B0cy5zZXJpYWwsICdvcHRpb25zLnNlcmlhbCcpO1xuXHRhc3NlcnQuZGF0ZShvcHRzLnZhbGlkRnJvbSwgJ29wdGlvbnMudmFsaWRGcm9tJyk7XG5cdGFzc2VydC5kYXRlKG9wdHMudmFsaWRVbnRpbCwgJ29wdG9ucy52YWxpZFVudGlsJyk7XG5cblx0YXNzZXJ0Lm9wdGlvbmFsQXJyYXlPZlN0cmluZyhvcHRzLnB1cnBvc2VzLCAnb3B0aW9ucy5wdXJwb3NlcycpO1xuXG5cdHRoaXMuX2hhc2hDYWNoZSA9IHt9O1xuXG5cdHRoaXMuc3ViamVjdHMgPSBvcHRzLnN1YmplY3RzO1xuXHR0aGlzLmlzc3VlciA9IG9wdHMuaXNzdWVyO1xuXHR0aGlzLnN1YmplY3RLZXkgPSBvcHRzLnN1YmplY3RLZXk7XG5cdHRoaXMuaXNzdWVyS2V5ID0gb3B0cy5pc3N1ZXJLZXk7XG5cdHRoaXMuc2lnbmF0dXJlcyA9IG9wdHMuc2lnbmF0dXJlcztcblx0dGhpcy5zZXJpYWwgPSBvcHRzLnNlcmlhbDtcblx0dGhpcy52YWxpZEZyb20gPSBvcHRzLnZhbGlkRnJvbTtcblx0dGhpcy52YWxpZFVudGlsID0gb3B0cy52YWxpZFVudGlsO1xuXHR0aGlzLnB1cnBvc2VzID0gb3B0cy5wdXJwb3Nlcztcbn1cblxuQ2VydGlmaWNhdGUuZm9ybWF0cyA9IGZvcm1hdHM7XG5cbkNlcnRpZmljYXRlLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIChmb3JtYXQsIG9wdGlvbnMpIHtcblx0aWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKVxuXHRcdGZvcm1hdCA9ICd4NTA5Jztcblx0YXNzZXJ0LnN0cmluZyhmb3JtYXQsICdmb3JtYXQnKTtcblx0YXNzZXJ0Lm9iamVjdChmb3JtYXRzW2Zvcm1hdF0sICdmb3JtYXRzW2Zvcm1hdF0nKTtcblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cblx0cmV0dXJuIChmb3JtYXRzW2Zvcm1hdF0ud3JpdGUodGhpcywgb3B0aW9ucykpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGZvcm1hdCwgb3B0aW9ucykge1xuXHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0Zm9ybWF0ID0gJ3BlbSc7XG5cdHJldHVybiAodGhpcy50b0J1ZmZlcihmb3JtYXQsIG9wdGlvbnMpLnRvU3RyaW5nKCkpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmZpbmdlcnByaW50ID0gZnVuY3Rpb24gKGFsZ28pIHtcblx0aWYgKGFsZ28gPT09IHVuZGVmaW5lZClcblx0XHRhbGdvID0gJ3NoYTI1Nic7XG5cdGFzc2VydC5zdHJpbmcoYWxnbywgJ2FsZ29yaXRobScpO1xuXHR2YXIgb3B0cyA9IHtcblx0XHR0eXBlOiAnY2VydGlmaWNhdGUnLFxuXHRcdGhhc2g6IHRoaXMuaGFzaChhbGdvKSxcblx0XHRhbGdvcml0aG06IGFsZ29cblx0fTtcblx0cmV0dXJuIChuZXcgRmluZ2VycHJpbnQob3B0cykpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoYWxnbykge1xuXHRhc3NlcnQuc3RyaW5nKGFsZ28sICdhbGdvcml0aG0nKTtcblx0YWxnbyA9IGFsZ28udG9Mb3dlckNhc2UoKTtcblx0aWYgKGFsZ3MuaGFzaEFsZ3NbYWxnb10gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcihhbGdvKSk7XG5cblx0aWYgKHRoaXMuX2hhc2hDYWNoZVthbGdvXSlcblx0XHRyZXR1cm4gKHRoaXMuX2hhc2hDYWNoZVthbGdvXSk7XG5cblx0dmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvKS5cblx0ICAgIHVwZGF0ZSh0aGlzLnRvQnVmZmVyKCd4NTA5JykpLmRpZ2VzdCgpO1xuXHR0aGlzLl9oYXNoQ2FjaGVbYWxnb10gPSBoYXNoO1xuXHRyZXR1cm4gKGhhc2gpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmlzRXhwaXJlZCA9IGZ1bmN0aW9uICh3aGVuKSB7XG5cdGlmICh3aGVuID09PSB1bmRlZmluZWQpXG5cdFx0d2hlbiA9IG5ldyBEYXRlKCk7XG5cdHJldHVybiAoISgod2hlbi5nZXRUaW1lKCkgPj0gdGhpcy52YWxpZEZyb20uZ2V0VGltZSgpKSAmJlxuXHRcdCh3aGVuLmdldFRpbWUoKSA8IHRoaXMudmFsaWRVbnRpbC5nZXRUaW1lKCkpKSk7XG59O1xuXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuaXNTaWduZWRCeSA9IGZ1bmN0aW9uIChpc3N1ZXJDZXJ0KSB7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUoaXNzdWVyQ2VydCwgQ2VydGlmaWNhdGUsIFsxLCAwXSwgJ2lzc3VlcicpO1xuXG5cdGlmICghdGhpcy5pc3N1ZXIuZXF1YWxzKGlzc3VlckNlcnQuc3ViamVjdHNbMF0pKVxuXHRcdHJldHVybiAoZmFsc2UpO1xuXHRpZiAodGhpcy5pc3N1ZXIucHVycG9zZXMgJiYgdGhpcy5pc3N1ZXIucHVycG9zZXMubGVuZ3RoID4gMCAmJlxuXHQgICAgdGhpcy5pc3N1ZXIucHVycG9zZXMuaW5kZXhPZignY2EnKSA9PT0gLTEpIHtcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiAodGhpcy5pc1NpZ25lZEJ5S2V5KGlzc3VlckNlcnQuc3ViamVjdEtleSkpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmdldEV4dGVuc2lvbiA9IGZ1bmN0aW9uIChrZXlPck9pZCkge1xuXHRhc3NlcnQuc3RyaW5nKGtleU9yT2lkLCAna2V5T3JPaWQnKTtcblx0dmFyIGV4dCA9IHRoaXMuZ2V0RXh0ZW5zaW9ucygpLmZpbHRlcihmdW5jdGlvbiAobWF5YmVFeHQpIHtcblx0XHRpZiAobWF5YmVFeHQuZm9ybWF0ID09PSAneDUwOScpXG5cdFx0XHRyZXR1cm4gKG1heWJlRXh0Lm9pZCA9PT0ga2V5T3JPaWQpO1xuXHRcdGlmIChtYXliZUV4dC5mb3JtYXQgPT09ICdvcGVuc3NoJylcblx0XHRcdHJldHVybiAobWF5YmVFeHQubmFtZSA9PT0ga2V5T3JPaWQpO1xuXHRcdHJldHVybiAoZmFsc2UpO1xuXHR9KVswXTtcblx0cmV0dXJuIChleHQpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmdldEV4dGVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBleHRzID0gW107XG5cdHZhciB4NTA5ID0gdGhpcy5zaWduYXR1cmVzLng1MDk7XG5cdGlmICh4NTA5ICYmIHg1MDkuZXh0cmFzICYmIHg1MDkuZXh0cmFzLmV4dHMpIHtcblx0XHR4NTA5LmV4dHJhcy5leHRzLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuXHRcdFx0ZXh0LmZvcm1hdCA9ICd4NTA5Jztcblx0XHRcdGV4dHMucHVzaChleHQpO1xuXHRcdH0pO1xuXHR9XG5cdHZhciBvcGVuc3NoID0gdGhpcy5zaWduYXR1cmVzLm9wZW5zc2g7XG5cdGlmIChvcGVuc3NoICYmIG9wZW5zc2guZXh0cykge1xuXHRcdG9wZW5zc2guZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcblx0XHRcdGV4dC5mb3JtYXQgPSAnb3BlbnNzaCc7XG5cdFx0XHRleHRzLnB1c2goZXh0KTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gKGV4dHMpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLmlzU2lnbmVkQnlLZXkgPSBmdW5jdGlvbiAoaXNzdWVyS2V5KSB7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUoaXNzdWVyS2V5LCBLZXksIFsxLCAyXSwgJ2lzc3VlcktleScpO1xuXG5cdGlmICh0aGlzLmlzc3VlcktleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuICh0aGlzLmlzc3VlcktleS5cblx0XHQgICAgZmluZ2VycHJpbnQoJ3NoYTUxMicpLm1hdGNoZXMoaXNzdWVyS2V5KSk7XG5cdH1cblxuXHR2YXIgZm10ID0gT2JqZWN0LmtleXModGhpcy5zaWduYXR1cmVzKVswXTtcblx0dmFyIHZhbGlkID0gZm9ybWF0c1tmbXRdLnZlcmlmeSh0aGlzLCBpc3N1ZXJLZXkpO1xuXHRpZiAodmFsaWQpXG5cdFx0dGhpcy5pc3N1ZXJLZXkgPSBpc3N1ZXJLZXk7XG5cdHJldHVybiAodmFsaWQpO1xufTtcblxuQ2VydGlmaWNhdGUucHJvdG90eXBlLnNpZ25XaXRoID0gZnVuY3Rpb24gKGtleSkge1xuXHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKGtleSwgUHJpdmF0ZUtleSwgWzEsIDJdLCAna2V5Jyk7XG5cdHZhciBmbXRzID0gT2JqZWN0LmtleXMoZm9ybWF0cyk7XG5cdHZhciBkaWRPbmUgPSBmYWxzZTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmbXRzLmxlbmd0aDsgKytpKSB7XG5cdFx0aWYgKGZtdHNbaV0gIT09ICdwZW0nKSB7XG5cdFx0XHR2YXIgcmV0ID0gZm9ybWF0c1tmbXRzW2ldXS5zaWduKHRoaXMsIGtleSk7XG5cdFx0XHRpZiAocmV0ID09PSB0cnVlKVxuXHRcdFx0XHRkaWRPbmUgPSB0cnVlO1xuXHRcdH1cblx0fVxuXHRpZiAoIWRpZE9uZSkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzaWduIHRoZSBjZXJ0aWZpY2F0ZSBmb3IgYW55ICcgK1xuXHRcdCAgICAnYXZhaWxhYmxlIGNlcnRpZmljYXRlIGZvcm1hdHMnKSk7XG5cdH1cbn07XG5cbkNlcnRpZmljYXRlLmNyZWF0ZVNlbGZTaWduZWQgPSBmdW5jdGlvbiAoc3ViamVjdE9yU3ViamVjdHMsIGtleSwgb3B0aW9ucykge1xuXHR2YXIgc3ViamVjdHM7XG5cdGlmIChBcnJheS5pc0FycmF5KHN1YmplY3RPclN1YmplY3RzKSlcblx0XHRzdWJqZWN0cyA9IHN1YmplY3RPclN1YmplY3RzO1xuXHRlbHNlXG5cdFx0c3ViamVjdHMgPSBbc3ViamVjdE9yU3ViamVjdHNdO1xuXG5cdGFzc2VydC5hcnJheU9mT2JqZWN0KHN1YmplY3RzKTtcblx0c3ViamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoc3ViamVjdCkge1xuXHRcdHV0aWxzLmFzc2VydENvbXBhdGlibGUoc3ViamVjdCwgSWRlbnRpdHksIFsxLCAwXSwgJ3N1YmplY3QnKTtcblx0fSk7XG5cblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShrZXksIFByaXZhdGVLZXksIFsxLCAyXSwgJ3ByaXZhdGUga2V5Jyk7XG5cblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cdGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucy52YWxpZEZyb20sICdvcHRpb25zLnZhbGlkRnJvbScpO1xuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucy52YWxpZFVudGlsLCAnb3B0aW9ucy52YWxpZFVudGlsJyk7XG5cdHZhciB2YWxpZEZyb20gPSBvcHRpb25zLnZhbGlkRnJvbTtcblx0dmFyIHZhbGlkVW50aWwgPSBvcHRpb25zLnZhbGlkVW50aWw7XG5cdGlmICh2YWxpZEZyb20gPT09IHVuZGVmaW5lZClcblx0XHR2YWxpZEZyb20gPSBuZXcgRGF0ZSgpO1xuXHRpZiAodmFsaWRVbnRpbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0YXNzZXJ0Lm9wdGlvbmFsTnVtYmVyKG9wdGlvbnMubGlmZXRpbWUsICdvcHRpb25zLmxpZmV0aW1lJyk7XG5cdFx0dmFyIGxpZmV0aW1lID0gb3B0aW9ucy5saWZldGltZTtcblx0XHRpZiAobGlmZXRpbWUgPT09IHVuZGVmaW5lZClcblx0XHRcdGxpZmV0aW1lID0gMTAqMzY1KjI0KjM2MDA7XG5cdFx0dmFsaWRVbnRpbCA9IG5ldyBEYXRlKCk7XG5cdFx0dmFsaWRVbnRpbC5zZXRUaW1lKHZhbGlkVW50aWwuZ2V0VGltZSgpICsgbGlmZXRpbWUqMTAwMCk7XG5cdH1cblx0YXNzZXJ0Lm9wdGlvbmFsQnVmZmVyKG9wdGlvbnMuc2VyaWFsLCAnb3B0aW9ucy5zZXJpYWwnKTtcblx0dmFyIHNlcmlhbCA9IG9wdGlvbnMuc2VyaWFsO1xuXHRpZiAoc2VyaWFsID09PSB1bmRlZmluZWQpXG5cdFx0c2VyaWFsID0gQnVmZmVyLmZyb20oJzAwMDAwMDAwMDAwMDAwMDEnLCAnaGV4Jyk7XG5cblx0dmFyIHB1cnBvc2VzID0gb3B0aW9ucy5wdXJwb3Nlcztcblx0aWYgKHB1cnBvc2VzID09PSB1bmRlZmluZWQpXG5cdFx0cHVycG9zZXMgPSBbXTtcblxuXHRpZiAocHVycG9zZXMuaW5kZXhPZignc2lnbmF0dXJlJykgPT09IC0xKVxuXHRcdHB1cnBvc2VzLnB1c2goJ3NpZ25hdHVyZScpO1xuXG5cdC8qIFNlbGYtc2lnbmVkIGNlcnRzIGFyZSBhbHdheXMgQ0FzLiAqL1xuXHRpZiAocHVycG9zZXMuaW5kZXhPZignY2EnKSA9PT0gLTEpXG5cdFx0cHVycG9zZXMucHVzaCgnY2EnKTtcblx0aWYgKHB1cnBvc2VzLmluZGV4T2YoJ2NybCcpID09PSAtMSlcblx0XHRwdXJwb3Nlcy5wdXNoKCdjcmwnKTtcblxuXHQvKlxuXHQgKiBJZiB3ZSB3ZXJlbid0IGV4cGxpY2l0bHkgZ2l2ZW4gYW55IG90aGVyIHB1cnBvc2VzLCBkbyB0aGUgc2Vuc2libGVcblx0ICogdGhpbmcgYW5kIGFkZCBzb21lIGJhc2ljIG9uZXMgZGVwZW5kaW5nIG9uIHRoZSBzdWJqZWN0IHR5cGUuXG5cdCAqL1xuXHRpZiAocHVycG9zZXMubGVuZ3RoIDw9IDMpIHtcblx0XHR2YXIgaG9zdFN1YmplY3RzID0gc3ViamVjdHMuZmlsdGVyKGZ1bmN0aW9uIChzdWJqZWN0KSB7XG5cdFx0XHRyZXR1cm4gKHN1YmplY3QudHlwZSA9PT0gJ2hvc3QnKTtcblx0XHR9KTtcblx0XHR2YXIgdXNlclN1YmplY3RzID0gc3ViamVjdHMuZmlsdGVyKGZ1bmN0aW9uIChzdWJqZWN0KSB7XG5cdFx0XHRyZXR1cm4gKHN1YmplY3QudHlwZSA9PT0gJ3VzZXInKTtcblx0XHR9KTtcblx0XHRpZiAoaG9zdFN1YmplY3RzLmxlbmd0aCA+IDApIHtcblx0XHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdzZXJ2ZXJBdXRoJykgPT09IC0xKVxuXHRcdFx0XHRwdXJwb3Nlcy5wdXNoKCdzZXJ2ZXJBdXRoJyk7XG5cdFx0fVxuXHRcdGlmICh1c2VyU3ViamVjdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0aWYgKHB1cnBvc2VzLmluZGV4T2YoJ2NsaWVudEF1dGgnKSA9PT0gLTEpXG5cdFx0XHRcdHB1cnBvc2VzLnB1c2goJ2NsaWVudEF1dGgnKTtcblx0XHR9XG5cdFx0aWYgKHVzZXJTdWJqZWN0cy5sZW5ndGggPiAwIHx8IGhvc3RTdWJqZWN0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAocHVycG9zZXMuaW5kZXhPZigna2V5QWdyZWVtZW50JykgPT09IC0xKVxuXHRcdFx0XHRwdXJwb3Nlcy5wdXNoKCdrZXlBZ3JlZW1lbnQnKTtcblx0XHRcdGlmIChrZXkudHlwZSA9PT0gJ3JzYScgJiZcblx0XHRcdCAgICBwdXJwb3Nlcy5pbmRleE9mKCdlbmNyeXB0aW9uJykgPT09IC0xKVxuXHRcdFx0XHRwdXJwb3Nlcy5wdXNoKCdlbmNyeXB0aW9uJyk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGNlcnQgPSBuZXcgQ2VydGlmaWNhdGUoe1xuXHRcdHN1YmplY3RzOiBzdWJqZWN0cyxcblx0XHRpc3N1ZXI6IHN1YmplY3RzWzBdLFxuXHRcdHN1YmplY3RLZXk6IGtleS50b1B1YmxpYygpLFxuXHRcdGlzc3VlcktleToga2V5LnRvUHVibGljKCksXG5cdFx0c2lnbmF0dXJlczoge30sXG5cdFx0c2VyaWFsOiBzZXJpYWwsXG5cdFx0dmFsaWRGcm9tOiB2YWxpZEZyb20sXG5cdFx0dmFsaWRVbnRpbDogdmFsaWRVbnRpbCxcblx0XHRwdXJwb3NlczogcHVycG9zZXNcblx0fSk7XG5cdGNlcnQuc2lnbldpdGgoa2V5KTtcblxuXHRyZXR1cm4gKGNlcnQpO1xufTtcblxuQ2VydGlmaWNhdGUuY3JlYXRlID1cbiAgICBmdW5jdGlvbiAoc3ViamVjdE9yU3ViamVjdHMsIGtleSwgaXNzdWVyLCBpc3N1ZXJLZXksIG9wdGlvbnMpIHtcblx0dmFyIHN1YmplY3RzO1xuXHRpZiAoQXJyYXkuaXNBcnJheShzdWJqZWN0T3JTdWJqZWN0cykpXG5cdFx0c3ViamVjdHMgPSBzdWJqZWN0T3JTdWJqZWN0cztcblx0ZWxzZVxuXHRcdHN1YmplY3RzID0gW3N1YmplY3RPclN1YmplY3RzXTtcblxuXHRhc3NlcnQuYXJyYXlPZk9iamVjdChzdWJqZWN0cyk7XG5cdHN1YmplY3RzLmZvckVhY2goZnVuY3Rpb24gKHN1YmplY3QpIHtcblx0XHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKHN1YmplY3QsIElkZW50aXR5LCBbMSwgMF0sICdzdWJqZWN0Jyk7XG5cdH0pO1xuXG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUoa2V5LCBLZXksIFsxLCAwXSwgJ2tleScpO1xuXHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRrZXkgPSBrZXkudG9QdWJsaWMoKTtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShpc3N1ZXIsIElkZW50aXR5LCBbMSwgMF0sICdpc3N1ZXInKTtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShpc3N1ZXJLZXksIFByaXZhdGVLZXksIFsxLCAyXSwgJ2lzc3VlciBrZXknKTtcblxuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zID0ge307XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLnZhbGlkRnJvbSwgJ29wdGlvbnMudmFsaWRGcm9tJyk7XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLnZhbGlkVW50aWwsICdvcHRpb25zLnZhbGlkVW50aWwnKTtcblx0dmFyIHZhbGlkRnJvbSA9IG9wdGlvbnMudmFsaWRGcm9tO1xuXHR2YXIgdmFsaWRVbnRpbCA9IG9wdGlvbnMudmFsaWRVbnRpbDtcblx0aWYgKHZhbGlkRnJvbSA9PT0gdW5kZWZpbmVkKVxuXHRcdHZhbGlkRnJvbSA9IG5ldyBEYXRlKCk7XG5cdGlmICh2YWxpZFVudGlsID09PSB1bmRlZmluZWQpIHtcblx0XHRhc3NlcnQub3B0aW9uYWxOdW1iZXIob3B0aW9ucy5saWZldGltZSwgJ29wdGlvbnMubGlmZXRpbWUnKTtcblx0XHR2YXIgbGlmZXRpbWUgPSBvcHRpb25zLmxpZmV0aW1lO1xuXHRcdGlmIChsaWZldGltZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bGlmZXRpbWUgPSAxMCozNjUqMjQqMzYwMDtcblx0XHR2YWxpZFVudGlsID0gbmV3IERhdGUoKTtcblx0XHR2YWxpZFVudGlsLnNldFRpbWUodmFsaWRVbnRpbC5nZXRUaW1lKCkgKyBsaWZldGltZSoxMDAwKTtcblx0fVxuXHRhc3NlcnQub3B0aW9uYWxCdWZmZXIob3B0aW9ucy5zZXJpYWwsICdvcHRpb25zLnNlcmlhbCcpO1xuXHR2YXIgc2VyaWFsID0gb3B0aW9ucy5zZXJpYWw7XG5cdGlmIChzZXJpYWwgPT09IHVuZGVmaW5lZClcblx0XHRzZXJpYWwgPSBCdWZmZXIuZnJvbSgnMDAwMDAwMDAwMDAwMDAwMScsICdoZXgnKTtcblxuXHR2YXIgcHVycG9zZXMgPSBvcHRpb25zLnB1cnBvc2VzO1xuXHRpZiAocHVycG9zZXMgPT09IHVuZGVmaW5lZClcblx0XHRwdXJwb3NlcyA9IFtdO1xuXG5cdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdzaWduYXR1cmUnKSA9PT0gLTEpXG5cdFx0cHVycG9zZXMucHVzaCgnc2lnbmF0dXJlJyk7XG5cblx0aWYgKG9wdGlvbnMuY2EgPT09IHRydWUpIHtcblx0XHRpZiAocHVycG9zZXMuaW5kZXhPZignY2EnKSA9PT0gLTEpXG5cdFx0XHRwdXJwb3Nlcy5wdXNoKCdjYScpO1xuXHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdjcmwnKSA9PT0gLTEpXG5cdFx0XHRwdXJwb3Nlcy5wdXNoKCdjcmwnKTtcblx0fVxuXG5cdHZhciBob3N0U3ViamVjdHMgPSBzdWJqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHN1YmplY3QpIHtcblx0XHRyZXR1cm4gKHN1YmplY3QudHlwZSA9PT0gJ2hvc3QnKTtcblx0fSk7XG5cdHZhciB1c2VyU3ViamVjdHMgPSBzdWJqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHN1YmplY3QpIHtcblx0XHRyZXR1cm4gKHN1YmplY3QudHlwZSA9PT0gJ3VzZXInKTtcblx0fSk7XG5cdGlmIChob3N0U3ViamVjdHMubGVuZ3RoID4gMCkge1xuXHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdzZXJ2ZXJBdXRoJykgPT09IC0xKVxuXHRcdFx0cHVycG9zZXMucHVzaCgnc2VydmVyQXV0aCcpO1xuXHR9XG5cdGlmICh1c2VyU3ViamVjdHMubGVuZ3RoID4gMCkge1xuXHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdjbGllbnRBdXRoJykgPT09IC0xKVxuXHRcdFx0cHVycG9zZXMucHVzaCgnY2xpZW50QXV0aCcpO1xuXHR9XG5cdGlmICh1c2VyU3ViamVjdHMubGVuZ3RoID4gMCB8fCBob3N0U3ViamVjdHMubGVuZ3RoID4gMCkge1xuXHRcdGlmIChwdXJwb3Nlcy5pbmRleE9mKCdrZXlBZ3JlZW1lbnQnKSA9PT0gLTEpXG5cdFx0XHRwdXJwb3Nlcy5wdXNoKCdrZXlBZ3JlZW1lbnQnKTtcblx0XHRpZiAoa2V5LnR5cGUgPT09ICdyc2EnICYmXG5cdFx0ICAgIHB1cnBvc2VzLmluZGV4T2YoJ2VuY3J5cHRpb24nKSA9PT0gLTEpXG5cdFx0XHRwdXJwb3Nlcy5wdXNoKCdlbmNyeXB0aW9uJyk7XG5cdH1cblxuXHR2YXIgY2VydCA9IG5ldyBDZXJ0aWZpY2F0ZSh7XG5cdFx0c3ViamVjdHM6IHN1YmplY3RzLFxuXHRcdGlzc3VlcjogaXNzdWVyLFxuXHRcdHN1YmplY3RLZXk6IGtleSxcblx0XHRpc3N1ZXJLZXk6IGlzc3VlcktleS50b1B1YmxpYygpLFxuXHRcdHNpZ25hdHVyZXM6IHt9LFxuXHRcdHNlcmlhbDogc2VyaWFsLFxuXHRcdHZhbGlkRnJvbTogdmFsaWRGcm9tLFxuXHRcdHZhbGlkVW50aWw6IHZhbGlkVW50aWwsXG5cdFx0cHVycG9zZXM6IHB1cnBvc2VzXG5cdH0pO1xuXHRjZXJ0LnNpZ25XaXRoKGlzc3VlcktleSk7XG5cblx0cmV0dXJuIChjZXJ0KTtcbn07XG5cbkNlcnRpZmljYXRlLnBhcnNlID0gZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIChkYXRhKSAhPT0gJ3N0cmluZycpXG5cdFx0YXNzZXJ0LmJ1ZmZlcihkYXRhLCAnZGF0YScpO1xuXHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0Zm9ybWF0ID0gJ2F1dG8nO1xuXHRhc3NlcnQuc3RyaW5nKGZvcm1hdCwgJ2Zvcm1hdCcpO1xuXHRpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpXG5cdFx0b3B0aW9ucyA9IHsgZmlsZW5hbWU6IG9wdGlvbnMgfTtcblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cdGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0aW9ucy5maWxlbmFtZSwgJ29wdGlvbnMuZmlsZW5hbWUnKTtcblx0aWYgKG9wdGlvbnMuZmlsZW5hbWUgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zLmZpbGVuYW1lID0gJyh1bm5hbWVkKSc7XG5cblx0YXNzZXJ0Lm9iamVjdChmb3JtYXRzW2Zvcm1hdF0sICdmb3JtYXRzW2Zvcm1hdF0nKTtcblxuXHR0cnkge1xuXHRcdHZhciBrID0gZm9ybWF0c1tmb3JtYXRdLnJlYWQoZGF0YSwgb3B0aW9ucyk7XG5cdFx0cmV0dXJuIChrKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHRocm93IChuZXcgQ2VydGlmaWNhdGVQYXJzZUVycm9yKG9wdGlvbnMuZmlsZW5hbWUsIGZvcm1hdCwgZSkpO1xuXHR9XG59O1xuXG5DZXJ0aWZpY2F0ZS5pc0NlcnRpZmljYXRlID0gZnVuY3Rpb24gKG9iaiwgdmVyKSB7XG5cdHJldHVybiAodXRpbHMuaXNDb21wYXRpYmxlKG9iaiwgQ2VydGlmaWNhdGUsIHZlcikpO1xufTtcblxuLypcbiAqIEFQSSB2ZXJzaW9ucyBmb3IgQ2VydGlmaWNhdGU6XG4gKiBbMSwwXSAtLSBpbml0aWFsIHZlclxuICogWzEsMV0gLS0gb3BlbnNzaCBmb3JtYXQgbm93IHVucGFja3MgZXh0ZW5zaW9uc1xuICovXG5DZXJ0aWZpY2F0ZS5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbiA9IFsxLCAxXTtcblxuQ2VydGlmaWNhdGUuX29sZFZlcnNpb25EZXRlY3QgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHJldHVybiAoWzEsIDBdKTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAxNyBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdERpZmZpZUhlbGxtYW46IERpZmZpZUhlbGxtYW4sXG5cdGdlbmVyYXRlRUNEU0E6IGdlbmVyYXRlRUNEU0EsXG5cdGdlbmVyYXRlRUQyNTUxOTogZ2VuZXJhdGVFRDI1NTE5XG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4vYWxncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5hY2wgPSByZXF1aXJlKCd0d2VldG5hY2wnKTtcblxudmFyIEtleSA9IHJlcXVpcmUoJy4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vcHJpdmF0ZS1rZXknKTtcblxudmFyIENSWVBUT19IQVZFX0VDREggPSAoY3J5cHRvLmNyZWF0ZUVDREggIT09IHVuZGVmaW5lZCk7XG5cbnZhciBlY2RoID0gcmVxdWlyZSgnZWNjLWpzYm4nKTtcbnZhciBlYyA9IHJlcXVpcmUoJ2VjYy1qc2JuL2xpYi9lYycpO1xudmFyIGpzYm4gPSByZXF1aXJlKCdqc2JuJykuQmlnSW50ZWdlcjtcblxuZnVuY3Rpb24gRGlmZmllSGVsbG1hbihrZXkpIHtcblx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShrZXksIEtleSwgWzEsIDRdLCAna2V5Jyk7XG5cdHRoaXMuX2lzUHJpdiA9IFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSwgWzEsIDNdKTtcblx0dGhpcy5fYWxnbyA9IGtleS50eXBlO1xuXHR0aGlzLl9jdXJ2ZSA9IGtleS5jdXJ2ZTtcblx0dGhpcy5fa2V5ID0ga2V5O1xuXHRpZiAoa2V5LnR5cGUgPT09ICdkc2EnKSB7XG5cdFx0aWYgKCFDUllQVE9fSEFWRV9FQ0RIKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdEdWUgdG8gYnVncyBpbiB0aGUgbm9kZSAwLjEwICcgK1xuXHRcdFx0ICAgICdjcnlwdG8gQVBJLCBub2RlIDAuMTIueCBvciBsYXRlciBpcyByZXF1aXJlZCAnICtcblx0XHRcdCAgICAndG8gdXNlIERIJykpO1xuXHRcdH1cblx0XHR0aGlzLl9kaCA9IGNyeXB0by5jcmVhdGVEaWZmaWVIZWxsbWFuKFxuXHRcdCAgICBrZXkucGFydC5wLmRhdGEsIHVuZGVmaW5lZCxcblx0XHQgICAga2V5LnBhcnQuZy5kYXRhLCB1bmRlZmluZWQpO1xuXHRcdHRoaXMuX3AgPSBrZXkucGFydC5wO1xuXHRcdHRoaXMuX2cgPSBrZXkucGFydC5nO1xuXHRcdGlmICh0aGlzLl9pc1ByaXYpXG5cdFx0XHR0aGlzLl9kaC5zZXRQcml2YXRlS2V5KGtleS5wYXJ0LnguZGF0YSk7XG5cdFx0dGhpcy5fZGguc2V0UHVibGljS2V5KGtleS5wYXJ0LnkuZGF0YSk7XG5cblx0fSBlbHNlIGlmIChrZXkudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdGlmICghQ1JZUFRPX0hBVkVfRUNESCkge1xuXHRcdFx0dGhpcy5fZWNQYXJhbXMgPSBuZXcgWDlFQ1BhcmFtZXRlcnModGhpcy5fY3VydmUpO1xuXG5cdFx0XHRpZiAodGhpcy5faXNQcml2KSB7XG5cdFx0XHRcdHRoaXMuX3ByaXYgPSBuZXcgRUNQcml2YXRlKFxuXHRcdFx0XHQgICAgdGhpcy5fZWNQYXJhbXMsIGtleS5wYXJ0LmQuZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGN1cnZlID0ge1xuXHRcdFx0J25pc3RwMjU2JzogJ3ByaW1lMjU2djEnLFxuXHRcdFx0J25pc3RwMzg0JzogJ3NlY3AzODRyMScsXG5cdFx0XHQnbmlzdHA1MjEnOiAnc2VjcDUyMXIxJ1xuXHRcdH1ba2V5LmN1cnZlXTtcblx0XHR0aGlzLl9kaCA9IGNyeXB0by5jcmVhdGVFQ0RIKGN1cnZlKTtcblx0XHRpZiAodHlwZW9mICh0aGlzLl9kaCkgIT09ICdvYmplY3QnIHx8XG5cdFx0ICAgIHR5cGVvZiAodGhpcy5fZGguc2V0UHJpdmF0ZUtleSkgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdENSWVBUT19IQVZFX0VDREggPSBmYWxzZTtcblx0XHRcdERpZmZpZUhlbGxtYW4uY2FsbCh0aGlzLCBrZXkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAodGhpcy5faXNQcml2KVxuXHRcdFx0dGhpcy5fZGguc2V0UHJpdmF0ZUtleShrZXkucGFydC5kLmRhdGEpO1xuXHRcdHRoaXMuX2RoLnNldFB1YmxpY0tleShrZXkucGFydC5RLmRhdGEpO1xuXG5cdH0gZWxzZSBpZiAoa2V5LnR5cGUgPT09ICdjdXJ2ZTI1NTE5Jykge1xuXHRcdGlmICh0aGlzLl9pc1ByaXYpIHtcblx0XHRcdHV0aWxzLmFzc2VydENvbXBhdGlibGUoa2V5LCBQcml2YXRlS2V5LCBbMSwgNV0sICdrZXknKTtcblx0XHRcdHRoaXMuX3ByaXYgPSBrZXkucGFydC5rLmRhdGE7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignREggbm90IHN1cHBvcnRlZCBmb3IgJyArIGtleS50eXBlICsgJyBrZXlzJykpO1xuXHR9XG59XG5cbkRpZmZpZUhlbGxtYW4ucHJvdG90eXBlLmdldFB1YmxpY0tleSA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHRoaXMuX2lzUHJpdilcblx0XHRyZXR1cm4gKHRoaXMuX2tleS50b1B1YmxpYygpKTtcblx0cmV0dXJuICh0aGlzLl9rZXkpO1xufTtcblxuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleSA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHRoaXMuX2lzUHJpdilcblx0XHRyZXR1cm4gKHRoaXMuX2tleSk7XG5cdGVsc2Vcblx0XHRyZXR1cm4gKHVuZGVmaW5lZCk7XG59O1xuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuZ2V0S2V5ID0gRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuZ2V0UHJpdmF0ZUtleTtcblxuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuX2tleUNoZWNrID0gZnVuY3Rpb24gKHBrLCBpc1B1Yikge1xuXHRhc3NlcnQub2JqZWN0KHBrLCAna2V5Jyk7XG5cdGlmICghaXNQdWIpXG5cdFx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShwaywgUHJpdmF0ZUtleSwgWzEsIDNdLCAna2V5Jyk7XG5cdHV0aWxzLmFzc2VydENvbXBhdGlibGUocGssIEtleSwgWzEsIDRdLCAna2V5Jyk7XG5cblx0aWYgKHBrLnR5cGUgIT09IHRoaXMuX2FsZ28pIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdBICcgKyBway50eXBlICsgJyBrZXkgY2Fubm90IGJlIHVzZWQgaW4gJyArXG5cdFx0ICAgIHRoaXMuX2FsZ28gKyAnIERpZmZpZS1IZWxsbWFuJykpO1xuXHR9XG5cblx0aWYgKHBrLmN1cnZlICE9PSB0aGlzLl9jdXJ2ZSkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0Ega2V5IGZyb20gdGhlICcgKyBway5jdXJ2ZSArICcgY3VydmUgJyArXG5cdFx0ICAgICdjYW5ub3QgYmUgdXNlZCB3aXRoIGEgJyArIHRoaXMuX2N1cnZlICtcblx0XHQgICAgJyBEaWZmaWUtSGVsbG1hbicpKTtcblx0fVxuXG5cdGlmIChway50eXBlID09PSAnZHNhJykge1xuXHRcdGFzc2VydC5kZWVwRXF1YWwocGsucGFydC5wLCB0aGlzLl9wLFxuXHRcdCAgICAnRFNBIGtleSBwcmltZSBkb2VzIG5vdCBtYXRjaCcpO1xuXHRcdGFzc2VydC5kZWVwRXF1YWwocGsucGFydC5nLCB0aGlzLl9nLFxuXHRcdCAgICAnRFNBIGtleSBnZW5lcmF0b3IgZG9lcyBub3QgbWF0Y2gnKTtcblx0fVxufTtcblxuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuc2V0S2V5ID0gZnVuY3Rpb24gKHBrKSB7XG5cdHRoaXMuX2tleUNoZWNrKHBrKTtcblxuXHRpZiAocGsudHlwZSA9PT0gJ2RzYScpIHtcblx0XHR0aGlzLl9kaC5zZXRQcml2YXRlS2V5KHBrLnBhcnQueC5kYXRhKTtcblx0XHR0aGlzLl9kaC5zZXRQdWJsaWNLZXkocGsucGFydC55LmRhdGEpO1xuXG5cdH0gZWxzZSBpZiAocGsudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdGlmIChDUllQVE9fSEFWRV9FQ0RIKSB7XG5cdFx0XHR0aGlzLl9kaC5zZXRQcml2YXRlS2V5KHBrLnBhcnQuZC5kYXRhKTtcblx0XHRcdHRoaXMuX2RoLnNldFB1YmxpY0tleShway5wYXJ0LlEuZGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3ByaXYgPSBuZXcgRUNQcml2YXRlKFxuXHRcdFx0ICAgIHRoaXMuX2VjUGFyYW1zLCBway5wYXJ0LmQuZGF0YSk7XG5cdFx0fVxuXG5cdH0gZWxzZSBpZiAocGsudHlwZSA9PT0gJ2N1cnZlMjU1MTknKSB7XG5cdFx0dmFyIGsgPSBway5wYXJ0Lms7XG5cdFx0aWYgKCFway5wYXJ0LmspXG5cdFx0XHRrID0gcGsucGFydC5yO1xuXHRcdHRoaXMuX3ByaXYgPSBrLmRhdGE7XG5cdFx0aWYgKHRoaXMuX3ByaXZbMF0gPT09IDB4MDApXG5cdFx0XHR0aGlzLl9wcml2ID0gdGhpcy5fcHJpdi5zbGljZSgxKTtcblx0XHR0aGlzLl9wcml2ID0gdGhpcy5fcHJpdi5zbGljZSgwLCAzMik7XG5cdH1cblx0dGhpcy5fa2V5ID0gcGs7XG5cdHRoaXMuX2lzUHJpdiA9IHRydWU7XG59O1xuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuc2V0UHJpdmF0ZUtleSA9IERpZmZpZUhlbGxtYW4ucHJvdG90eXBlLnNldEtleTtcblxuRGlmZmllSGVsbG1hbi5wcm90b3R5cGUuY29tcHV0ZVNlY3JldCA9IGZ1bmN0aW9uIChvdGhlcnBrKSB7XG5cdHRoaXMuX2tleUNoZWNrKG90aGVycGssIHRydWUpO1xuXHRpZiAoIXRoaXMuX2lzUHJpdilcblx0XHR0aHJvdyAobmV3IEVycm9yKCdESCBleGNoYW5nZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgd2l0aCAnICtcblx0XHQgICAgJ2EgcHJpdmF0ZSBrZXkgeWV0JykpO1xuXG5cdHZhciBwdWI7XG5cdGlmICh0aGlzLl9hbGdvID09PSAnZHNhJykge1xuXHRcdHJldHVybiAodGhpcy5fZGguY29tcHV0ZVNlY3JldChcblx0XHQgICAgb3RoZXJway5wYXJ0LnkuZGF0YSkpO1xuXG5cdH0gZWxzZSBpZiAodGhpcy5fYWxnbyA9PT0gJ2VjZHNhJykge1xuXHRcdGlmIChDUllQVE9fSEFWRV9FQ0RIKSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMuX2RoLmNvbXB1dGVTZWNyZXQoXG5cdFx0XHQgICAgb3RoZXJway5wYXJ0LlEuZGF0YSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwdWIgPSBuZXcgRUNQdWJsaWMoXG5cdFx0XHQgICAgdGhpcy5fZWNQYXJhbXMsIG90aGVycGsucGFydC5RLmRhdGEpO1xuXHRcdFx0cmV0dXJuICh0aGlzLl9wcml2LmRlcml2ZVNoYXJlZFNlY3JldChwdWIpKTtcblx0XHR9XG5cblx0fSBlbHNlIGlmICh0aGlzLl9hbGdvID09PSAnY3VydmUyNTUxOScpIHtcblx0XHRwdWIgPSBvdGhlcnBrLnBhcnQuQS5kYXRhO1xuXHRcdHdoaWxlIChwdWJbMF0gPT09IDB4MDAgJiYgcHViLmxlbmd0aCA+IDMyKVxuXHRcdFx0cHViID0gcHViLnNsaWNlKDEpO1xuXHRcdHZhciBwcml2ID0gdGhpcy5fcHJpdjtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwocHViLmxlbmd0aCwgMzIpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChwcml2Lmxlbmd0aCwgMzIpO1xuXG5cdFx0dmFyIHNlY3JldCA9IG5hY2wuYm94LmJlZm9yZShuZXcgVWludDhBcnJheShwdWIpLFxuXHRcdCAgICBuZXcgVWludDhBcnJheShwcml2KSk7XG5cblx0XHRyZXR1cm4gKEJ1ZmZlci5mcm9tKHNlY3JldCkpO1xuXHR9XG5cblx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBhbGdvcml0aG06ICcgKyB0aGlzLl9hbGdvKSk7XG59O1xuXG5EaWZmaWVIZWxsbWFuLnByb3RvdHlwZS5nZW5lcmF0ZUtleSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHBhcnRzID0gW107XG5cdHZhciBwcml2LCBwdWI7XG5cdGlmICh0aGlzLl9hbGdvID09PSAnZHNhJykge1xuXHRcdHRoaXMuX2RoLmdlbmVyYXRlS2V5cygpO1xuXG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ3AnLCBkYXRhOiB0aGlzLl9wLmRhdGF9KTtcblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAncScsIGRhdGE6IHRoaXMuX2tleS5wYXJ0LnEuZGF0YX0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdnJywgZGF0YTogdGhpcy5fZy5kYXRhfSk7XG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ3knLCBkYXRhOiB0aGlzLl9kaC5nZXRQdWJsaWNLZXkoKX0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICd4JywgZGF0YTogdGhpcy5fZGguZ2V0UHJpdmF0ZUtleSgpfSk7XG5cdFx0dGhpcy5fa2V5ID0gbmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0dHlwZTogJ2RzYScsXG5cdFx0XHRwYXJ0czogcGFydHNcblx0XHR9KTtcblx0XHR0aGlzLl9pc1ByaXYgPSB0cnVlO1xuXHRcdHJldHVybiAodGhpcy5fa2V5KTtcblxuXHR9IGVsc2UgaWYgKHRoaXMuX2FsZ28gPT09ICdlY2RzYScpIHtcblx0XHRpZiAoQ1JZUFRPX0hBVkVfRUNESCkge1xuXHRcdFx0dGhpcy5fZGguZ2VuZXJhdGVLZXlzKCk7XG5cblx0XHRcdHBhcnRzLnB1c2goe25hbWU6ICdjdXJ2ZScsXG5cdFx0XHQgICAgZGF0YTogQnVmZmVyLmZyb20odGhpcy5fY3VydmUpfSk7XG5cdFx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnUScsIGRhdGE6IHRoaXMuX2RoLmdldFB1YmxpY0tleSgpfSk7XG5cdFx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnZCcsIGRhdGE6IHRoaXMuX2RoLmdldFByaXZhdGVLZXkoKX0pO1xuXHRcdFx0dGhpcy5fa2V5ID0gbmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0XHR0eXBlOiAnZWNkc2EnLFxuXHRcdFx0XHRjdXJ2ZTogdGhpcy5fY3VydmUsXG5cdFx0XHRcdHBhcnRzOiBwYXJ0c1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9pc1ByaXYgPSB0cnVlO1xuXHRcdFx0cmV0dXJuICh0aGlzLl9rZXkpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBuID0gdGhpcy5fZWNQYXJhbXMuZ2V0TigpO1xuXHRcdFx0dmFyIHIgPSBuZXcganNibihjcnlwdG8ucmFuZG9tQnl0ZXMobi5iaXRMZW5ndGgoKSkpO1xuXHRcdFx0dmFyIG4xID0gbi5zdWJ0cmFjdChqc2JuLk9ORSk7XG5cdFx0XHRwcml2ID0gci5tb2QobjEpLmFkZChqc2JuLk9ORSk7XG5cdFx0XHRwdWIgPSB0aGlzLl9lY1BhcmFtcy5nZXRHKCkubXVsdGlwbHkocHJpdik7XG5cblx0XHRcdHByaXYgPSBCdWZmZXIuZnJvbShwcml2LnRvQnl0ZUFycmF5KCkpO1xuXHRcdFx0cHViID0gQnVmZmVyLmZyb20odGhpcy5fZWNQYXJhbXMuZ2V0Q3VydmUoKS5cblx0XHRcdCAgICBlbmNvZGVQb2ludEhleChwdWIpLCAnaGV4Jyk7XG5cblx0XHRcdHRoaXMuX3ByaXYgPSBuZXcgRUNQcml2YXRlKHRoaXMuX2VjUGFyYW1zLCBwcml2KTtcblxuXHRcdFx0cGFydHMucHVzaCh7bmFtZTogJ2N1cnZlJyxcblx0XHRcdCAgICBkYXRhOiBCdWZmZXIuZnJvbSh0aGlzLl9jdXJ2ZSl9KTtcblx0XHRcdHBhcnRzLnB1c2goe25hbWU6ICdRJywgZGF0YTogcHVifSk7XG5cdFx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnZCcsIGRhdGE6IHByaXZ9KTtcblxuXHRcdFx0dGhpcy5fa2V5ID0gbmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0XHR0eXBlOiAnZWNkc2EnLFxuXHRcdFx0XHRjdXJ2ZTogdGhpcy5fY3VydmUsXG5cdFx0XHRcdHBhcnRzOiBwYXJ0c1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLl9pc1ByaXYgPSB0cnVlO1xuXHRcdFx0cmV0dXJuICh0aGlzLl9rZXkpO1xuXHRcdH1cblxuXHR9IGVsc2UgaWYgKHRoaXMuX2FsZ28gPT09ICdjdXJ2ZTI1NTE5Jykge1xuXHRcdHZhciBwYWlyID0gbmFjbC5ib3gua2V5UGFpcigpO1xuXHRcdHByaXYgPSBCdWZmZXIuZnJvbShwYWlyLnNlY3JldEtleSk7XG5cdFx0cHViID0gQnVmZmVyLmZyb20ocGFpci5wdWJsaWNLZXkpO1xuXHRcdHByaXYgPSBCdWZmZXIuY29uY2F0KFtwcml2LCBwdWJdKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwocHJpdi5sZW5ndGgsIDY0KTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwocHViLmxlbmd0aCwgMzIpO1xuXG5cdFx0cGFydHMucHVzaCh7bmFtZTogJ0EnLCBkYXRhOiBwdWJ9KTtcblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnaycsIGRhdGE6IHByaXZ9KTtcblx0XHR0aGlzLl9rZXkgPSBuZXcgUHJpdmF0ZUtleSh7XG5cdFx0XHR0eXBlOiAnY3VydmUyNTUxOScsXG5cdFx0XHRwYXJ0czogcGFydHNcblx0XHR9KTtcblx0XHR0aGlzLl9pc1ByaXYgPSB0cnVlO1xuXHRcdHJldHVybiAodGhpcy5fa2V5KTtcblx0fVxuXG5cdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgYWxnb3JpdGhtOiAnICsgdGhpcy5fYWxnbykpO1xufTtcbkRpZmZpZUhlbGxtYW4ucHJvdG90eXBlLmdlbmVyYXRlS2V5cyA9IERpZmZpZUhlbGxtYW4ucHJvdG90eXBlLmdlbmVyYXRlS2V5O1xuXG4vKiBUaGVzZSBhcmUgaGVscGVycyBmb3IgdXNpbmcgZWNjLWpzYm4gKGZvciBub2RlIDAuMTAgY29tcGF0aWJpbGl0eSkuICovXG5cbmZ1bmN0aW9uIFg5RUNQYXJhbWV0ZXJzKG5hbWUpIHtcblx0dmFyIHBhcmFtcyA9IGFsZ3MuY3VydmVzW25hbWVdO1xuXHRhc3NlcnQub2JqZWN0KHBhcmFtcyk7XG5cblx0dmFyIHAgPSBuZXcganNibihwYXJhbXMucCk7XG5cdHZhciBhID0gbmV3IGpzYm4ocGFyYW1zLmEpO1xuXHR2YXIgYiA9IG5ldyBqc2JuKHBhcmFtcy5iKTtcblx0dmFyIG4gPSBuZXcganNibihwYXJhbXMubik7XG5cdHZhciBoID0ganNibi5PTkU7XG5cdHZhciBjdXJ2ZSA9IG5ldyBlYy5FQ0N1cnZlRnAocCwgYSwgYik7XG5cdHZhciBHID0gY3VydmUuZGVjb2RlUG9pbnRIZXgocGFyYW1zLkcudG9TdHJpbmcoJ2hleCcpKTtcblxuXHR0aGlzLmN1cnZlID0gY3VydmU7XG5cdHRoaXMuZyA9IEc7XG5cdHRoaXMubiA9IG47XG5cdHRoaXMuaCA9IGg7XG59XG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0Q3VydmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJ2ZSk7IH07XG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0RyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLmcpOyB9O1xuWDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldE4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5uKTsgfTtcblg5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRIID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuaCk7IH07XG5cbmZ1bmN0aW9uIEVDUHVibGljKHBhcmFtcywgYnVmZmVyKSB7XG5cdHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcblx0aWYgKGJ1ZmZlclswXSA9PT0gMHgwMClcblx0XHRidWZmZXIgPSBidWZmZXIuc2xpY2UoMSk7XG5cdHRoaXMuX3B1YiA9IHBhcmFtcy5nZXRDdXJ2ZSgpLmRlY29kZVBvaW50SGV4KGJ1ZmZlci50b1N0cmluZygnaGV4JykpO1xufVxuXG5mdW5jdGlvbiBFQ1ByaXZhdGUocGFyYW1zLCBidWZmZXIpIHtcblx0dGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuXHR0aGlzLl9wcml2ID0gbmV3IGpzYm4odXRpbHMubXBOb3JtYWxpemUoYnVmZmVyKSk7XG59XG5FQ1ByaXZhdGUucHJvdG90eXBlLmRlcml2ZVNoYXJlZFNlY3JldCA9IGZ1bmN0aW9uIChwdWJLZXkpIHtcblx0YXNzZXJ0Lm9rKHB1YktleSBpbnN0YW5jZW9mIEVDUHVibGljKTtcblx0dmFyIFMgPSBwdWJLZXkuX3B1Yi5tdWx0aXBseSh0aGlzLl9wcml2KTtcblx0cmV0dXJuIChCdWZmZXIuZnJvbShTLmdldFgoKS50b0JpZ0ludGVnZXIoKS50b0J5dGVBcnJheSgpKSk7XG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUVEMjU1MTkoKSB7XG5cdHZhciBwYWlyID0gbmFjbC5zaWduLmtleVBhaXIoKTtcblx0dmFyIHByaXYgPSBCdWZmZXIuZnJvbShwYWlyLnNlY3JldEtleSk7XG5cdHZhciBwdWIgPSBCdWZmZXIuZnJvbShwYWlyLnB1YmxpY0tleSk7XG5cdGFzc2VydC5zdHJpY3RFcXVhbChwcml2Lmxlbmd0aCwgNjQpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwocHViLmxlbmd0aCwgMzIpO1xuXG5cdHZhciBwYXJ0cyA9IFtdO1xuXHRwYXJ0cy5wdXNoKHtuYW1lOiAnQScsIGRhdGE6IHB1Yn0pO1xuXHRwYXJ0cy5wdXNoKHtuYW1lOiAnaycsIGRhdGE6IHByaXYuc2xpY2UoMCwgMzIpfSk7XG5cdHZhciBrZXkgPSBuZXcgUHJpdmF0ZUtleSh7XG5cdFx0dHlwZTogJ2VkMjU1MTknLFxuXHRcdHBhcnRzOiBwYXJ0c1xuXHR9KTtcblx0cmV0dXJuIChrZXkpO1xufVxuXG4vKiBHZW5lcmF0ZXMgYSBuZXcgRUNEU0EgcHJpdmF0ZSBrZXkgb24gYSBnaXZlbiBjdXJ2ZS4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRUNEU0EoY3VydmUpIHtcblx0dmFyIHBhcnRzID0gW107XG5cdHZhciBrZXk7XG5cblx0aWYgKENSWVBUT19IQVZFX0VDREgpIHtcblx0XHQvKlxuXHRcdCAqIE5vZGUgY3J5cHRvIGRvZXNuJ3QgZXhwb3NlIGtleSBnZW5lcmF0aW9uIGRpcmVjdGx5LCBidXQgdGhlXG5cdFx0ICogRUNESCBpbnN0YW5jZXMgY2FuIGdlbmVyYXRlIGtleXMuIEl0IHR1cm5zIG91dCB0aGlzIGp1c3Rcblx0XHQgKiBjYWxscyBpbnRvIHRoZSBPcGVuU1NMIGdlbmVyaWMga2V5IGdlbmVyYXRvciwgYW5kIHdlIGNhblxuXHRcdCAqIHJlYWQgaXRzIG91dHB1dCBoYXBwaWx5IHdpdGhvdXQgZG9pbmcgYW4gYWN0dWFsIERILiBTbyB3ZVxuXHRcdCAqIHVzZSB0aGF0IGhlcmUuXG5cdFx0ICovXG5cdFx0dmFyIG9zQ3VydmUgPSB7XG5cdFx0XHQnbmlzdHAyNTYnOiAncHJpbWUyNTZ2MScsXG5cdFx0XHQnbmlzdHAzODQnOiAnc2VjcDM4NHIxJyxcblx0XHRcdCduaXN0cDUyMSc6ICdzZWNwNTIxcjEnXG5cdFx0fVtjdXJ2ZV07XG5cblx0XHR2YXIgZGggPSBjcnlwdG8uY3JlYXRlRUNESChvc0N1cnZlKTtcblx0XHRkaC5nZW5lcmF0ZUtleXMoKTtcblxuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdjdXJ2ZScsXG5cdFx0ICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGN1cnZlKX0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdRJywgZGF0YTogZGguZ2V0UHVibGljS2V5KCl9KTtcblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnZCcsIGRhdGE6IGRoLmdldFByaXZhdGVLZXkoKX0pO1xuXG5cdFx0a2V5ID0gbmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRcdGN1cnZlOiBjdXJ2ZSxcblx0XHRcdHBhcnRzOiBwYXJ0c1xuXHRcdH0pO1xuXHRcdHJldHVybiAoa2V5KTtcblx0fSBlbHNlIHtcblxuXHRcdHZhciBlY1BhcmFtcyA9IG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSk7XG5cblx0XHQvKiBUaGlzIGFsZ29yaXRobSB0YWtlbiBmcm9tIEZJUFMgUFVCIDE4Ni00IChzZWN0aW9uIEIuNC4xKSAqL1xuXHRcdHZhciBuID0gZWNQYXJhbXMuZ2V0TigpO1xuXHRcdC8qXG5cdFx0ICogVGhlIGNyeXB0by5yYW5kb21CeXRlcygpIGZ1bmN0aW9uIGNhbiBvbmx5IGdpdmUgdXMgd2hvbGVcblx0XHQgKiBieXRlcywgc28gdGFraW5nIGEgbm9kIGZyb20gWDkuNjIsIHdlIHJvdW5kIHVwLlxuXHRcdCAqL1xuXHRcdHZhciBjQnl0ZUxlbiA9IE1hdGguY2VpbCgobi5iaXRMZW5ndGgoKSArIDY0KSAvIDgpO1xuXHRcdHZhciBjID0gbmV3IGpzYm4oY3J5cHRvLnJhbmRvbUJ5dGVzKGNCeXRlTGVuKSk7XG5cblx0XHR2YXIgbjEgPSBuLnN1YnRyYWN0KGpzYm4uT05FKTtcblx0XHR2YXIgcHJpdiA9IGMubW9kKG4xKS5hZGQoanNibi5PTkUpO1xuXHRcdHZhciBwdWIgPSBlY1BhcmFtcy5nZXRHKCkubXVsdGlwbHkocHJpdik7XG5cblx0XHRwcml2ID0gQnVmZmVyLmZyb20ocHJpdi50b0J5dGVBcnJheSgpKTtcblx0XHRwdWIgPSBCdWZmZXIuZnJvbShlY1BhcmFtcy5nZXRDdXJ2ZSgpLlxuXHRcdCAgICBlbmNvZGVQb2ludEhleChwdWIpLCAnaGV4Jyk7XG5cblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZSl9KTtcblx0XHRwYXJ0cy5wdXNoKHtuYW1lOiAnUScsIGRhdGE6IHB1Yn0pO1xuXHRcdHBhcnRzLnB1c2goe25hbWU6ICdkJywgZGF0YTogcHJpdn0pO1xuXG5cdFx0a2V5ID0gbmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRcdGN1cnZlOiBjdXJ2ZSxcblx0XHRcdHBhcnRzOiBwYXJ0c1xuXHRcdH0pO1xuXHRcdHJldHVybiAoa2V5KTtcblx0fVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRWZXJpZmllcjogVmVyaWZpZXIsXG5cdFNpZ25lcjogU2lnbmVyXG59O1xuXG52YXIgbmFjbCA9IHJlcXVpcmUoJ3R3ZWV0bmFjbCcpO1xudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcblxuZnVuY3Rpb24gVmVyaWZpZXIoa2V5LCBoYXNoQWxnbykge1xuXHRpZiAoaGFzaEFsZ28udG9Mb3dlckNhc2UoKSAhPT0gJ3NoYTUxMicpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignRUQyNTUxOSBvbmx5IHN1cHBvcnRzIHRoZSB1c2Ugb2YgJyArXG5cdFx0ICAgICdTSEEtNTEyIGhhc2hlcycpKTtcblxuXHR0aGlzLmtleSA9IGtleTtcblx0dGhpcy5jaHVua3MgPSBbXTtcblxuXHRzdHJlYW0uV3JpdGFibGUuY2FsbCh0aGlzLCB7fSk7XG59XG51dGlsLmluaGVyaXRzKFZlcmlmaWVyLCBzdHJlYW0uV3JpdGFibGUpO1xuXG5WZXJpZmllci5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmMsIGNiKSB7XG5cdHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuXHRjYigpO1xufTtcblxuVmVyaWZpZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuXHRpZiAodHlwZW9mIChjaHVuaykgPT09ICdzdHJpbmcnKVxuXHRcdGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssICdiaW5hcnknKTtcblx0dGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5WZXJpZmllci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSwgZm10KSB7XG5cdHZhciBzaWc7XG5cdGlmIChTaWduYXR1cmUuaXNTaWduYXR1cmUoc2lnbmF0dXJlLCBbMiwgMF0pKSB7XG5cdFx0aWYgKHNpZ25hdHVyZS50eXBlICE9PSAnZWQyNTUxOScpXG5cdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0XHRzaWcgPSBzaWduYXR1cmUudG9CdWZmZXIoJ3JhdycpO1xuXG5cdH0gZWxzZSBpZiAodHlwZW9mIChzaWduYXR1cmUpID09PSAnc3RyaW5nJykge1xuXHRcdHNpZyA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgJ2Jhc2U2NCcpO1xuXG5cdH0gZWxzZSBpZiAoU2lnbmF0dXJlLmlzU2lnbmF0dXJlKHNpZ25hdHVyZSwgWzEsIDBdKSkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ3NpZ25hdHVyZSB3YXMgY3JlYXRlZCBieSB0b28gb2xkICcgK1xuXHRcdCAgICAnYSB2ZXJzaW9uIG9mIHNzaHBrIGFuZCBjYW5ub3QgYmUgdmVyaWZpZWQnKSk7XG5cdH1cblxuXHRhc3NlcnQuYnVmZmVyKHNpZyk7XG5cdHJldHVybiAobmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeShcblx0ICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQodGhpcy5jaHVua3MpKSxcblx0ICAgIG5ldyBVaW50OEFycmF5KHNpZyksXG5cdCAgICBuZXcgVWludDhBcnJheSh0aGlzLmtleS5wYXJ0LkEuZGF0YSkpKTtcbn07XG5cbmZ1bmN0aW9uIFNpZ25lcihrZXksIGhhc2hBbGdvKSB7XG5cdGlmIChoYXNoQWxnby50b0xvd2VyQ2FzZSgpICE9PSAnc2hhNTEyJylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdFRDI1NTE5IG9ubHkgc3VwcG9ydHMgdGhlIHVzZSBvZiAnICtcblx0XHQgICAgJ1NIQS01MTIgaGFzaGVzJykpO1xuXG5cdHRoaXMua2V5ID0ga2V5O1xuXHR0aGlzLmNodW5rcyA9IFtdO1xuXG5cdHN0cmVhbS5Xcml0YWJsZS5jYWxsKHRoaXMsIHt9KTtcbn1cbnV0aWwuaW5oZXJpdHMoU2lnbmVyLCBzdHJlYW0uV3JpdGFibGUpO1xuXG5TaWduZXIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jLCBjYikge1xuXHR0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcblx0Y2IoKTtcbn07XG5cblNpZ25lci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cdGlmICh0eXBlb2YgKGNodW5rKSA9PT0gJ3N0cmluZycpXG5cdFx0Y2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgJ2JpbmFyeScpO1xuXHR0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblNpZ25lci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNpZyA9IG5hY2wuc2lnbi5kZXRhY2hlZChcblx0ICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQodGhpcy5jaHVua3MpKSxcblx0ICAgIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQoW1xuXHRcdHRoaXMua2V5LnBhcnQuay5kYXRhLCB0aGlzLmtleS5wYXJ0LkEuZGF0YV0pKSk7XG5cdHZhciBzaWdCdWYgPSBCdWZmZXIuZnJvbShzaWcpO1xuXHR2YXIgc2lnT2JqID0gU2lnbmF0dXJlLnBhcnNlKHNpZ0J1ZiwgJ2VkMjU1MTknLCAncmF3Jyk7XG5cdHNpZ09iai5oYXNoQWxnb3JpdGhtID0gJ3NoYTUxMic7XG5cdHJldHVybiAoc2lnT2JqKTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAxNSBKb3llbnQsIEluYy5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gRmluZ2VycHJpbnRGb3JtYXRFcnJvcihmcCwgZm9ybWF0KSB7XG5cdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcblx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBGaW5nZXJwcmludEZvcm1hdEVycm9yKTtcblx0dGhpcy5uYW1lID0gJ0ZpbmdlcnByaW50Rm9ybWF0RXJyb3InO1xuXHR0aGlzLmZpbmdlcnByaW50ID0gZnA7XG5cdHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuXHR0aGlzLm1lc3NhZ2UgPSAnRmluZ2VycHJpbnQgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQsIG9yIGlzIGludmFsaWQ6ICc7XG5cdGlmIChmcCAhPT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMubWVzc2FnZSArPSAnIGZpbmdlcnByaW50ID0gJyArIGZwO1xuXHRpZiAoZm9ybWF0ICE9PSB1bmRlZmluZWQpXG5cdFx0dGhpcy5tZXNzYWdlICs9ICcgZm9ybWF0ID0gJyArIGZvcm1hdDtcbn1cbnV0aWwuaW5oZXJpdHMoRmluZ2VycHJpbnRGb3JtYXRFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBJbnZhbGlkQWxnb3JpdGhtRXJyb3IoYWxnKSB7XG5cdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcblx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnZhbGlkQWxnb3JpdGhtRXJyb3IpO1xuXHR0aGlzLm5hbWUgPSAnSW52YWxpZEFsZ29yaXRobUVycm9yJztcblx0dGhpcy5hbGdvcml0aG0gPSBhbGc7XG5cdHRoaXMubWVzc2FnZSA9ICdBbGdvcml0aG0gXCInICsgYWxnICsgJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnO1xufVxudXRpbC5pbmhlcml0cyhJbnZhbGlkQWxnb3JpdGhtRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gS2V5UGFyc2VFcnJvcihuYW1lLCBmb3JtYXQsIGlubmVyRXJyKSB7XG5cdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcblx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBLZXlQYXJzZUVycm9yKTtcblx0dGhpcy5uYW1lID0gJ0tleVBhcnNlRXJyb3InO1xuXHR0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblx0dGhpcy5rZXlOYW1lID0gbmFtZTtcblx0dGhpcy5pbm5lckVyciA9IGlubmVyRXJyO1xuXHR0aGlzLm1lc3NhZ2UgPSAnRmFpbGVkIHRvIHBhcnNlICcgKyBuYW1lICsgJyBhcyBhIHZhbGlkICcgKyBmb3JtYXQgK1xuXHQgICAgJyBmb3JtYXQga2V5OiAnICsgaW5uZXJFcnIubWVzc2FnZTtcbn1cbnV0aWwuaW5oZXJpdHMoS2V5UGFyc2VFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBTaWduYXR1cmVQYXJzZUVycm9yKHR5cGUsIGZvcm1hdCwgaW5uZXJFcnIpIHtcblx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFNpZ25hdHVyZVBhcnNlRXJyb3IpO1xuXHR0aGlzLm5hbWUgPSAnU2lnbmF0dXJlUGFyc2VFcnJvcic7XG5cdHRoaXMudHlwZSA9IHR5cGU7XG5cdHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuXHR0aGlzLmlubmVyRXJyID0gaW5uZXJFcnI7XG5cdHRoaXMubWVzc2FnZSA9ICdGYWlsZWQgdG8gcGFyc2UgdGhlIGdpdmVuIGRhdGEgYXMgYSAnICsgdHlwZSArXG5cdCAgICAnIHNpZ25hdHVyZSBpbiAnICsgZm9ybWF0ICsgJyBmb3JtYXQ6ICcgKyBpbm5lckVyci5tZXNzYWdlO1xufVxudXRpbC5pbmhlcml0cyhTaWduYXR1cmVQYXJzZUVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIENlcnRpZmljYXRlUGFyc2VFcnJvcihuYW1lLCBmb3JtYXQsIGlubmVyRXJyKSB7XG5cdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcblx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDZXJ0aWZpY2F0ZVBhcnNlRXJyb3IpO1xuXHR0aGlzLm5hbWUgPSAnQ2VydGlmaWNhdGVQYXJzZUVycm9yJztcblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG5cdHRoaXMuY2VydE5hbWUgPSBuYW1lO1xuXHR0aGlzLmlubmVyRXJyID0gaW5uZXJFcnI7XG5cdHRoaXMubWVzc2FnZSA9ICdGYWlsZWQgdG8gcGFyc2UgJyArIG5hbWUgKyAnIGFzIGEgdmFsaWQgJyArIGZvcm1hdCArXG5cdCAgICAnIGZvcm1hdCBjZXJ0aWZpY2F0ZTogJyArIGlubmVyRXJyLm1lc3NhZ2U7XG59XG51dGlsLmluaGVyaXRzKENlcnRpZmljYXRlUGFyc2VFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBLZXlFbmNyeXB0ZWRFcnJvcihuYW1lLCBmb3JtYXQpIHtcblx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuXHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEtleUVuY3J5cHRlZEVycm9yKTtcblx0dGhpcy5uYW1lID0gJ0tleUVuY3J5cHRlZEVycm9yJztcblx0dGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG5cdHRoaXMua2V5TmFtZSA9IG5hbWU7XG5cdHRoaXMubWVzc2FnZSA9ICdUaGUgJyArIGZvcm1hdCArICcgZm9ybWF0IGtleSAnICsgbmFtZSArICcgaXMgJyArXG5cdCAgICAnZW5jcnlwdGVkIChwYXNzd29yZC1wcm90ZWN0ZWQpLCBhbmQgbm8gcGFzc3BocmFzZSB3YXMgJyArXG5cdCAgICAncHJvdmlkZWQgaW4gYG9wdGlvbnNgJztcbn1cbnV0aWwuaW5oZXJpdHMoS2V5RW5jcnlwdGVkRXJyb3IsIEVycm9yKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdEZpbmdlcnByaW50Rm9ybWF0RXJyb3I6IEZpbmdlcnByaW50Rm9ybWF0RXJyb3IsXG5cdEludmFsaWRBbGdvcml0aG1FcnJvcjogSW52YWxpZEFsZ29yaXRobUVycm9yLFxuXHRLZXlQYXJzZUVycm9yOiBLZXlQYXJzZUVycm9yLFxuXHRTaWduYXR1cmVQYXJzZUVycm9yOiBTaWduYXR1cmVQYXJzZUVycm9yLFxuXHRLZXlFbmNyeXB0ZWRFcnJvcjogS2V5RW5jcnlwdGVkRXJyb3IsXG5cdENlcnRpZmljYXRlUGFyc2VFcnJvcjogQ2VydGlmaWNhdGVQYXJzZUVycm9yXG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTggSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0gRmluZ2VycHJpbnQ7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi9hbGdzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgZXJycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9wcml2YXRlLWtleScpO1xudmFyIENlcnRpZmljYXRlID0gcmVxdWlyZSgnLi9jZXJ0aWZpY2F0ZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgRmluZ2VycHJpbnRGb3JtYXRFcnJvciA9IGVycnMuRmluZ2VycHJpbnRGb3JtYXRFcnJvcjtcbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSBlcnJzLkludmFsaWRBbGdvcml0aG1FcnJvcjtcblxuZnVuY3Rpb24gRmluZ2VycHJpbnQob3B0cykge1xuXHRhc3NlcnQub2JqZWN0KG9wdHMsICdvcHRpb25zJyk7XG5cdGFzc2VydC5zdHJpbmcob3B0cy50eXBlLCAnb3B0aW9ucy50eXBlJyk7XG5cdGFzc2VydC5idWZmZXIob3B0cy5oYXNoLCAnb3B0aW9ucy5oYXNoJyk7XG5cdGFzc2VydC5zdHJpbmcob3B0cy5hbGdvcml0aG0sICdvcHRpb25zLmFsZ29yaXRobScpO1xuXG5cdHRoaXMuYWxnb3JpdGhtID0gb3B0cy5hbGdvcml0aG0udG9Mb3dlckNhc2UoKTtcblx0aWYgKGFsZ3MuaGFzaEFsZ3NbdGhpcy5hbGdvcml0aG1dICE9PSB0cnVlKVxuXHRcdHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKHRoaXMuYWxnb3JpdGhtKSk7XG5cblx0dGhpcy5oYXNoID0gb3B0cy5oYXNoO1xuXHR0aGlzLnR5cGUgPSBvcHRzLnR5cGU7XG5cdHRoaXMuaGFzaFR5cGUgPSBvcHRzLmhhc2hUeXBlO1xufVxuXG5GaW5nZXJwcmludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmICh0aGlzLmFsZ29yaXRobSA9PT0gJ21kNScgfHwgdGhpcy5oYXNoVHlwZSA9PT0gJ3Nwa2knKVxuXHRcdFx0Zm9ybWF0ID0gJ2hleCc7XG5cdFx0ZWxzZVxuXHRcdFx0Zm9ybWF0ID0gJ2Jhc2U2NCc7XG5cdH1cblx0YXNzZXJ0LnN0cmluZyhmb3JtYXQpO1xuXG5cdHN3aXRjaCAoZm9ybWF0KSB7XG5cdGNhc2UgJ2hleCc6XG5cdFx0aWYgKHRoaXMuaGFzaFR5cGUgPT09ICdzcGtpJylcblx0XHRcdHJldHVybiAodGhpcy5oYXNoLnRvU3RyaW5nKCdoZXgnKSk7XG5cdFx0cmV0dXJuIChhZGRDb2xvbnModGhpcy5oYXNoLnRvU3RyaW5nKCdoZXgnKSkpO1xuXHRjYXNlICdiYXNlNjQnOlxuXHRcdGlmICh0aGlzLmhhc2hUeXBlID09PSAnc3BraScpXG5cdFx0XHRyZXR1cm4gKHRoaXMuaGFzaC50b1N0cmluZygnYmFzZTY0JykpO1xuXHRcdHJldHVybiAoc3NoQmFzZTY0Rm9ybWF0KHRoaXMuYWxnb3JpdGhtLFxuXHRcdCAgICB0aGlzLmhhc2gudG9TdHJpbmcoJ2Jhc2U2NCcpKSk7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBGaW5nZXJwcmludEZvcm1hdEVycm9yKHVuZGVmaW5lZCwgZm9ybWF0KSk7XG5cdH1cbn07XG5cbkZpbmdlcnByaW50LnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdGFzc2VydC5vYmplY3Qob3RoZXIsICdrZXkgb3IgY2VydGlmaWNhdGUnKTtcblx0aWYgKHRoaXMudHlwZSA9PT0gJ2tleScgJiYgdGhpcy5oYXNoVHlwZSAhPT0gJ3NzaCcpIHtcblx0XHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKG90aGVyLCBLZXksIFsxLCA3XSwgJ2tleSB3aXRoIHNwa2knKTtcblx0XHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkob3RoZXIpKSB7XG5cdFx0XHR1dGlscy5hc3NlcnRDb21wYXRpYmxlKG90aGVyLCBQcml2YXRlS2V5LCBbMSwgNl0sXG5cdFx0XHQgICAgJ3ByaXZhdGVrZXkgd2l0aCBzcGtpIHN1cHBvcnQnKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAna2V5Jykge1xuXHRcdHV0aWxzLmFzc2VydENvbXBhdGlibGUob3RoZXIsIEtleSwgWzEsIDBdLCAna2V5Jyk7XG5cdH0gZWxzZSB7XG5cdFx0dXRpbHMuYXNzZXJ0Q29tcGF0aWJsZShvdGhlciwgQ2VydGlmaWNhdGUsIFsxLCAwXSxcblx0XHQgICAgJ2NlcnRpZmljYXRlJyk7XG5cdH1cblxuXHR2YXIgdGhlaXJIYXNoID0gb3RoZXIuaGFzaCh0aGlzLmFsZ29yaXRobSwgdGhpcy5oYXNoVHlwZSk7XG5cdHZhciB0aGVpckhhc2gyID0gY3J5cHRvLmNyZWF0ZUhhc2godGhpcy5hbGdvcml0aG0pLlxuXHQgICAgdXBkYXRlKHRoZWlySGFzaCkuZGlnZXN0KCdiYXNlNjQnKTtcblxuXHRpZiAodGhpcy5oYXNoMiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRoaXMuaGFzaDIgPSBjcnlwdG8uY3JlYXRlSGFzaCh0aGlzLmFsZ29yaXRobSkuXG5cdFx0ICAgIHVwZGF0ZSh0aGlzLmhhc2gpLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cblx0cmV0dXJuICh0aGlzLmhhc2gyID09PSB0aGVpckhhc2gyKTtcbn07XG5cbi8qSlNTVFlMRUQqL1xudmFyIGJhc2U2NFJFID0gL15bQS1aYS16MC05K1xcLz1dKyQvO1xuLypKU1NUWUxFRCovXG52YXIgaGV4UkUgPSAvXlthLWZBLUYwLTldKyQvO1xuXG5GaW5nZXJwcmludC5wYXJzZSA9IGZ1bmN0aW9uIChmcCwgb3B0aW9ucykge1xuXHRhc3NlcnQuc3RyaW5nKGZwLCAnZmluZ2VycHJpbnQnKTtcblxuXHR2YXIgYWxnLCBoYXNoLCBlbkFsZ3M7XG5cdGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG5cdFx0ZW5BbGdzID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0ge307XG5cdH1cblx0YXNzZXJ0Lm9wdGlvbmFsT2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cdGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRpZiAob3B0aW9ucy5lbkFsZ3MgIT09IHVuZGVmaW5lZClcblx0XHRlbkFsZ3MgPSBvcHRpb25zLmVuQWxncztcblx0aWYgKG9wdGlvbnMuYWxnb3JpdGhtcyAhPT0gdW5kZWZpbmVkKVxuXHRcdGVuQWxncyA9IG9wdGlvbnMuYWxnb3JpdGhtcztcblx0YXNzZXJ0Lm9wdGlvbmFsQXJyYXlPZlN0cmluZyhlbkFsZ3MsICdhbGdvcml0aG1zJyk7XG5cblx0dmFyIGhhc2hUeXBlID0gJ3NzaCc7XG5cdGlmIChvcHRpb25zLmhhc2hUeXBlICE9PSB1bmRlZmluZWQpXG5cdFx0aGFzaFR5cGUgPSBvcHRpb25zLmhhc2hUeXBlO1xuXHRhc3NlcnQuc3RyaW5nKGhhc2hUeXBlLCAnb3B0aW9ucy5oYXNoVHlwZScpO1xuXG5cdHZhciBwYXJ0cyA9IGZwLnNwbGl0KCc6Jyk7XG5cdGlmIChwYXJ0cy5sZW5ndGggPT0gMikge1xuXHRcdGFsZyA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKCFiYXNlNjRSRS50ZXN0KHBhcnRzWzFdKSlcblx0XHRcdHRocm93IChuZXcgRmluZ2VycHJpbnRGb3JtYXRFcnJvcihmcCkpO1xuXHRcdHRyeSB7XG5cdFx0XHRoYXNoID0gQnVmZmVyLmZyb20ocGFydHNbMV0sICdiYXNlNjQnKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR0aHJvdyAobmV3IEZpbmdlcnByaW50Rm9ybWF0RXJyb3IoZnApKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAocGFydHMubGVuZ3RoID4gMikge1xuXHRcdGFsZyA9ICdtZDUnO1xuXHRcdGlmIChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpID09PSAnbWQ1Jylcblx0XHRcdHBhcnRzID0gcGFydHMuc2xpY2UoMSk7XG5cdFx0cGFydHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24gKHApIHtcblx0XHRcdHdoaWxlIChwLmxlbmd0aCA8IDIpXG5cdFx0XHRcdHAgPSAnMCcgKyBwO1xuXHRcdFx0aWYgKHAubGVuZ3RoID4gMilcblx0XHRcdFx0dGhyb3cgKG5ldyBGaW5nZXJwcmludEZvcm1hdEVycm9yKGZwKSk7XG5cdFx0XHRyZXR1cm4gKHApO1xuXHRcdH0pO1xuXHRcdHBhcnRzID0gcGFydHMuam9pbignJyk7XG5cdFx0aWYgKCFoZXhSRS50ZXN0KHBhcnRzKSB8fCBwYXJ0cy5sZW5ndGggJSAyICE9PSAwKVxuXHRcdFx0dGhyb3cgKG5ldyBGaW5nZXJwcmludEZvcm1hdEVycm9yKGZwKSk7XG5cdFx0dHJ5IHtcblx0XHRcdGhhc2ggPSBCdWZmZXIuZnJvbShwYXJ0cywgJ2hleCcpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHRocm93IChuZXcgRmluZ2VycHJpbnRGb3JtYXRFcnJvcihmcCkpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRpZiAoaGV4UkUudGVzdChmcCkpIHtcblx0XHRcdGhhc2ggPSBCdWZmZXIuZnJvbShmcCwgJ2hleCcpO1xuXHRcdH0gZWxzZSBpZiAoYmFzZTY0UkUudGVzdChmcCkpIHtcblx0XHRcdGhhc2ggPSBCdWZmZXIuZnJvbShmcCwgJ2Jhc2U2NCcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyAobmV3IEZpbmdlcnByaW50Rm9ybWF0RXJyb3IoZnApKTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGhhc2gubGVuZ3RoKSB7XG5cdFx0Y2FzZSAzMjpcblx0XHRcdGFsZyA9ICdzaGEyNTYnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxNjpcblx0XHRcdGFsZyA9ICdtZDUnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyMDpcblx0XHRcdGFsZyA9ICdzaGExJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgNjQ6XG5cdFx0XHRhbGcgPSAnc2hhNTEyJztcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyAobmV3IEZpbmdlcnByaW50Rm9ybWF0RXJyb3IoZnApKTtcblx0XHR9XG5cblx0XHQvKiBQbGFpbiBoZXgvYmFzZTY0OiBndWVzcyBpdCdzIHByb2JhYmx5IFNQS0kgdW5sZXNzIHRvbGQuICovXG5cdFx0aWYgKG9wdGlvbnMuaGFzaFR5cGUgPT09IHVuZGVmaW5lZClcblx0XHRcdGhhc2hUeXBlID0gJ3Nwa2knO1xuXHR9XG5cblx0aWYgKGFsZyA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRmluZ2VycHJpbnRGb3JtYXRFcnJvcihmcCkpO1xuXG5cdGlmIChhbGdzLmhhc2hBbGdzW2FsZ10gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcihhbGcpKTtcblxuXHRpZiAoZW5BbGdzICE9PSB1bmRlZmluZWQpIHtcblx0XHRlbkFsZ3MgPSBlbkFsZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnRvTG93ZXJDYXNlKCk7IH0pO1xuXHRcdGlmIChlbkFsZ3MuaW5kZXhPZihhbGcpID09PSAtMSlcblx0XHRcdHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGFsZykpO1xuXHR9XG5cblx0cmV0dXJuIChuZXcgRmluZ2VycHJpbnQoe1xuXHRcdGFsZ29yaXRobTogYWxnLFxuXHRcdGhhc2g6IGhhc2gsXG5cdFx0dHlwZTogb3B0aW9ucy50eXBlIHx8ICdrZXknLFxuXHRcdGhhc2hUeXBlOiBoYXNoVHlwZVxuXHR9KSk7XG59O1xuXG5mdW5jdGlvbiBhZGRDb2xvbnMocykge1xuXHQvKkpTU1RZTEVEKi9cblx0cmV0dXJuIChzLnJlcGxhY2UoLyguezJ9KSg/PS4pL2csICckMTonKSk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFN0cmlwKHMpIHtcblx0LypKU1NUWUxFRCovXG5cdHJldHVybiAocy5yZXBsYWNlKC89KiQvLCAnJykpO1xufVxuXG5mdW5jdGlvbiBzc2hCYXNlNjRGb3JtYXQoYWxnLCBoKSB7XG5cdHJldHVybiAoYWxnLnRvVXBwZXJDYXNlKCkgKyAnOicgKyBiYXNlNjRTdHJpcChoKSk7XG59XG5cbkZpbmdlcnByaW50LmlzRmluZ2VycHJpbnQgPSBmdW5jdGlvbiAob2JqLCB2ZXIpIHtcblx0cmV0dXJuICh1dGlscy5pc0NvbXBhdGlibGUob2JqLCBGaW5nZXJwcmludCwgdmVyKSk7XG59O1xuXG4vKlxuICogQVBJIHZlcnNpb25zIGZvciBGaW5nZXJwcmludDpcbiAqIFsxLDBdIC0tIGluaXRpYWwgdmVyXG4gKiBbMSwxXSAtLSBmaXJzdCB0YWdnZWQgdmVyXG4gKiBbMSwyXSAtLSBoYXNoVHlwZSBhbmQgc3BraSBzdXBwb3J0XG4gKi9cbkZpbmdlcnByaW50LnByb3RvdHlwZS5fc3NocGtBcGlWZXJzaW9uID0gWzEsIDJdO1xuXG5GaW5nZXJwcmludC5fb2xkVmVyc2lvbkRldGVjdCA9IGZ1bmN0aW9uIChvYmopIHtcblx0YXNzZXJ0LmZ1bmMob2JqLnRvU3RyaW5nKTtcblx0YXNzZXJ0LmZ1bmMob2JqLm1hdGNoZXMpO1xuXHRyZXR1cm4gKFsxLCAwXSk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTggSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGVcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG5cbnZhciBwZW0gPSByZXF1aXJlKCcuL3BlbScpO1xudmFyIHNzaCA9IHJlcXVpcmUoJy4vc3NoJyk7XG52YXIgcmZjNDI1MyA9IHJlcXVpcmUoJy4vcmZjNDI1MycpO1xudmFyIGRuc3NlYyA9IHJlcXVpcmUoJy4vZG5zc2VjJyk7XG52YXIgcHV0dHkgPSByZXF1aXJlKCcuL3B1dHR5Jyk7XG5cbnZhciBETlNTRUNfUFJJVktFWV9IRUFERVJfUFJFRklYID0gJ1ByaXZhdGUta2V5LWZvcm1hdDogdjEnO1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIChidWYpID09PSAnc3RyaW5nJykge1xuXHRcdGlmIChidWYudHJpbSgpLm1hdGNoKC9eWy1dK1sgXSpCRUdJTi8pKVxuXHRcdFx0cmV0dXJuIChwZW0ucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRpZiAoYnVmLm1hdGNoKC9eXFxzKnNzaC1bYS16XS8pKVxuXHRcdFx0cmV0dXJuIChzc2gucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRpZiAoYnVmLm1hdGNoKC9eXFxzKmVjZHNhLS8pKVxuXHRcdFx0cmV0dXJuIChzc2gucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRpZiAoYnVmLm1hdGNoKC9ecHV0dHktdXNlci1rZXktZmlsZS0yOi9pKSlcblx0XHRcdHJldHVybiAocHV0dHkucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRpZiAoZmluZEROU1NFQ0hlYWRlcihidWYpKVxuXHRcdFx0cmV0dXJuIChkbnNzZWMucmVhZChidWYsIG9wdGlvbnMpKTtcblx0XHRidWYgPSBCdWZmZXIuZnJvbShidWYsICdiaW5hcnknKTtcblx0fSBlbHNlIHtcblx0XHRhc3NlcnQuYnVmZmVyKGJ1Zik7XG5cdFx0aWYgKGZpbmRQRU1IZWFkZXIoYnVmKSlcblx0XHRcdHJldHVybiAocGVtLnJlYWQoYnVmLCBvcHRpb25zKSk7XG5cdFx0aWYgKGZpbmRTU0hIZWFkZXIoYnVmKSlcblx0XHRcdHJldHVybiAoc3NoLnJlYWQoYnVmLCBvcHRpb25zKSk7XG5cdFx0aWYgKGZpbmRQdVRUWUhlYWRlcihidWYpKVxuXHRcdFx0cmV0dXJuIChwdXR0eS5yZWFkKGJ1Ziwgb3B0aW9ucykpO1xuXHRcdGlmIChmaW5kRE5TU0VDSGVhZGVyKGJ1ZikpXG5cdFx0XHRyZXR1cm4gKGRuc3NlYy5yZWFkKGJ1Ziwgb3B0aW9ucykpO1xuXHR9XG5cdGlmIChidWYucmVhZFVJbnQzMkJFKDApIDwgYnVmLmxlbmd0aClcblx0XHRyZXR1cm4gKHJmYzQyNTMucmVhZChidWYsIG9wdGlvbnMpKTtcblx0dGhyb3cgKG5ldyBFcnJvcignRmFpbGVkIHRvIGF1dG8tZGV0ZWN0IGZvcm1hdCBvZiBrZXknKSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRQdVRUWUhlYWRlcihidWYpIHtcblx0dmFyIG9mZnNldCA9IDA7XG5cdHdoaWxlIChvZmZzZXQgPCBidWYubGVuZ3RoICYmXG5cdCAgICAoYnVmW29mZnNldF0gPT09IDMyIHx8IGJ1ZltvZmZzZXRdID09PSAxMCB8fCBidWZbb2Zmc2V0XSA9PT0gOSkpXG5cdFx0KytvZmZzZXQ7XG5cdGlmIChvZmZzZXQgKyAyMiA8PSBidWYubGVuZ3RoICYmXG5cdCAgICBidWYuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyAyMikudG9TdHJpbmcoJ2FzY2lpJykudG9Mb3dlckNhc2UoKSA9PT1cblx0ICAgICdwdXR0eS11c2VyLWtleS1maWxlLTI6Jylcblx0XHRyZXR1cm4gKHRydWUpO1xuXHRyZXR1cm4gKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZmluZFNTSEhlYWRlcihidWYpIHtcblx0dmFyIG9mZnNldCA9IDA7XG5cdHdoaWxlIChvZmZzZXQgPCBidWYubGVuZ3RoICYmXG5cdCAgICAoYnVmW29mZnNldF0gPT09IDMyIHx8IGJ1ZltvZmZzZXRdID09PSAxMCB8fCBidWZbb2Zmc2V0XSA9PT0gOSkpXG5cdFx0KytvZmZzZXQ7XG5cdGlmIChvZmZzZXQgKyA0IDw9IGJ1Zi5sZW5ndGggJiZcblx0ICAgIGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIDQpLnRvU3RyaW5nKCdhc2NpaScpID09PSAnc3NoLScpXG5cdFx0cmV0dXJuICh0cnVlKTtcblx0aWYgKG9mZnNldCArIDYgPD0gYnVmLmxlbmd0aCAmJlxuXHQgICAgYnVmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNikudG9TdHJpbmcoJ2FzY2lpJykgPT09ICdlY2RzYS0nKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cdHJldHVybiAoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBmaW5kUEVNSGVhZGVyKGJ1Zikge1xuXHR2YXIgb2Zmc2V0ID0gMDtcblx0d2hpbGUgKG9mZnNldCA8IGJ1Zi5sZW5ndGggJiZcblx0ICAgIChidWZbb2Zmc2V0XSA9PT0gMzIgfHwgYnVmW29mZnNldF0gPT09IDEwKSlcblx0XHQrK29mZnNldDtcblx0aWYgKGJ1ZltvZmZzZXRdICE9PSA0NSlcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0d2hpbGUgKG9mZnNldCA8IGJ1Zi5sZW5ndGggJiZcblx0ICAgIChidWZbb2Zmc2V0XSA9PT0gNDUpKVxuXHRcdCsrb2Zmc2V0O1xuXHR3aGlsZSAob2Zmc2V0IDwgYnVmLmxlbmd0aCAmJlxuXHQgICAgKGJ1ZltvZmZzZXRdID09PSAzMikpXG5cdFx0KytvZmZzZXQ7XG5cdGlmIChvZmZzZXQgKyA1ID4gYnVmLmxlbmd0aCB8fFxuXHQgICAgYnVmLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNSkudG9TdHJpbmcoJ2FzY2lpJykgIT09ICdCRUdJTicpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdHJldHVybiAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRETlNTRUNIZWFkZXIoYnVmKSB7XG5cdC8vIHByaXZhdGUgY2FzZSBmaXJzdFxuXHRpZiAoYnVmLmxlbmd0aCA8PSBETlNTRUNfUFJJVktFWV9IRUFERVJfUFJFRklYLmxlbmd0aClcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0dmFyIGhlYWRlckNoZWNrID0gYnVmLnNsaWNlKDAsIEROU1NFQ19QUklWS0VZX0hFQURFUl9QUkVGSVgubGVuZ3RoKTtcblx0aWYgKGhlYWRlckNoZWNrLnRvU3RyaW5nKCdhc2NpaScpID09PSBETlNTRUNfUFJJVktFWV9IRUFERVJfUFJFRklYKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cblx0Ly8gcHVibGljLWtleSBSRkMzMTEwID9cblx0Ly8gJ2RvbWFpbi5jb20uIElOIEtFWSAuLi4nIG9yICdkb21haW4uY29tLiBJTiBETlNLRVkgLi4uJ1xuXHQvLyBza2lwIGFueSBjb21tZW50LWxpbmVzXG5cdGlmICh0eXBlb2YgKGJ1ZikgIT09ICdzdHJpbmcnKSB7XG5cdFx0YnVmID0gYnVmLnRvU3RyaW5nKCdhc2NpaScpO1xuXHR9XG5cdHZhciBsaW5lcyA9IGJ1Zi5zcGxpdCgnXFxuJyk7XG5cdHZhciBsaW5lID0gMDtcblx0LyogSlNTVFlMRUQgKi9cblx0d2hpbGUgKGxpbmVzW2xpbmVdLm1hdGNoKC9eXFw7LykpXG5cdFx0bGluZSsrO1xuXHRpZiAobGluZXNbbGluZV0udG9TdHJpbmcoJ2FzY2lpJykubWF0Y2goL1xcLiBJTiBLRVkgLykpXG5cdFx0cmV0dXJuICh0cnVlKTtcblx0aWYgKGxpbmVzW2xpbmVdLnRvU3RyaW5nKCdhc2NpaScpLm1hdGNoKC9cXC4gSU4gRE5TS0VZIC8pKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cdHJldHVybiAoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0dGhyb3cgKG5ldyBFcnJvcignXCJhdXRvXCIgZm9ybWF0IGNhbm5vdCBiZSB1c2VkIGZvciB3cml0aW5nJykpO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTcgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHR3cml0ZTogd3JpdGVcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgU1NIQnVmZmVyID0gcmVxdWlyZSgnLi4vc3NoLWJ1ZmZlcicpO1xudmFyIERoZSA9IHJlcXVpcmUoJy4uL2RoZScpO1xuXG52YXIgc3VwcG9ydGVkQWxnb3MgPSB7XG5cdCdyc2Etc2hhMScgOiA1LFxuXHQncnNhLXNoYTI1NicgOiA4LFxuXHQncnNhLXNoYTUxMicgOiAxMCxcblx0J2VjZHNhLXAyNTYtc2hhMjU2JyA6IDEzLFxuXHQnZWNkc2EtcDM4NC1zaGEzODQnIDogMTRcblx0Lypcblx0ICogZWQyNTUxOSBpcyBoeXBvdGhldGljYWxseSBzdXBwb3J0ZWQgd2l0aCBpZCAxNVxuXHQgKiBidXQgdGhlIGNvbW1vbiB0b29scyBhdmFpbGFibGUgZG9uJ3QgYXBwZWFyIHRvIGJlXG5cdCAqIGNhcGFibGUgb2YgZ2VuZXJhdGluZy91c2luZyBlZDI1NTE5IGtleXNcblx0ICovXG59O1xuXG52YXIgc3VwcG9ydGVkQWxnb3NCeUlkID0ge307XG5PYmplY3Qua2V5cyhzdXBwb3J0ZWRBbGdvcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRzdXBwb3J0ZWRBbGdvc0J5SWRbc3VwcG9ydGVkQWxnb3Nba11dID0gay50b1VwcGVyQ2FzZSgpO1xufSk7XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGJ1ZikgIT09ICdzdHJpbmcnKSB7XG5cdFx0YXNzZXJ0LmJ1ZmZlcihidWYsICdidWYnKTtcblx0XHRidWYgPSBidWYudG9TdHJpbmcoJ2FzY2lpJyk7XG5cdH1cblx0dmFyIGxpbmVzID0gYnVmLnNwbGl0KCdcXG4nKTtcblx0aWYgKGxpbmVzWzBdLm1hdGNoKC9eUHJpdmF0ZS1rZXktZm9ybWF0XFw6IHYxLykpIHtcblx0XHR2YXIgYWxnRWxlbXMgPSBsaW5lc1sxXS5zcGxpdCgnICcpO1xuXHRcdHZhciBhbGdvTnVtID0gcGFyc2VJbnQoYWxnRWxlbXNbMV0sIDEwKTtcblx0XHR2YXIgYWxnb05hbWUgPSBhbGdFbGVtc1syXTtcblx0XHRpZiAoIXN1cHBvcnRlZEFsZ29zQnlJZFthbGdvTnVtXSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGFsZ29yaXRobTogJyArIGFsZ29OYW1lKSk7XG5cdFx0cmV0dXJuIChyZWFkRE5TU0VDUHJpdmF0ZUtleShhbGdvTnVtLCBsaW5lcy5zbGljZSgyKSkpO1xuXHR9XG5cblx0Ly8gc2tpcCBhbnkgY29tbWVudC1saW5lc1xuXHR2YXIgbGluZSA9IDA7XG5cdC8qIEpTU1RZTEVEICovXG5cdHdoaWxlIChsaW5lc1tsaW5lXS5tYXRjaCgvXlxcOy8pKVxuXHRcdGxpbmUrKztcblx0Ly8gd2Ugc2hvdWxkIG5vdyBoYXZlICpvbmUgc2luZ2xlKiBsaW5lIGxlZnQgd2l0aCBvdXIgS0VZIG9uIGl0LlxuXHRpZiAoKGxpbmVzW2xpbmVdLm1hdGNoKC9cXC4gSU4gS0VZIC8pIHx8XG5cdCAgICBsaW5lc1tsaW5lXS5tYXRjaCgvXFwuIElOIEROU0tFWSAvKSkgJiYgbGluZXNbbGluZSsxXS5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gKHJlYWRSRkMzMTEwKGxpbmVzW2xpbmVdKSk7XG5cdH1cblx0dGhyb3cgKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIGRuc3NlYyBrZXknKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRSRkMzMTEwKGtleVN0cmluZykge1xuXHR2YXIgZWxlbXMgPSBrZXlTdHJpbmcuc3BsaXQoJyAnKTtcblx0Ly91bnVzZWQgdmFyIGZsYWdzID0gcGFyc2VJbnQoZWxlbXNbM10sIDEwKTtcblx0Ly91bnVzZWQgdmFyIHByb3RvY29sID0gcGFyc2VJbnQoZWxlbXNbNF0sIDEwKTtcblx0dmFyIGFsZ29yaXRobSA9IHBhcnNlSW50KGVsZW1zWzVdLCAxMCk7XG5cdGlmICghc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ29yaXRobV0pXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKSk7XG5cdHZhciBiYXNlNjRrZXkgPSBlbGVtcy5zbGljZSg2LCBlbGVtcy5sZW5ndGgpLmpvaW4oKTtcblx0dmFyIGtleUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJhc2U2NGtleSwgJ2Jhc2U2NCcpO1xuXHRpZiAoc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ29yaXRobV0ubWF0Y2goL15SU0EtLykpIHtcblx0XHQvLyBqb2luIHRoZSByZXN0IG9mIHRoZSBib2R5IGludG8gYSBzaW5nbGUgYmFzZTY0LWJsb2Jcblx0XHR2YXIgcHVibGljRXhwb25lbnRMZW4gPSBrZXlCdWZmZXIucmVhZFVJbnQ4KDApO1xuXHRcdGlmIChwdWJsaWNFeHBvbmVudExlbiAhPSAzICYmIHB1YmxpY0V4cG9uZW50TGVuICE9IDEpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgZG5zc2VjIGtleTogJyArXG5cdFx0XHQgICAgJ3Vuc3VwcG9ydGVkIGV4cG9uZW50IGxlbmd0aCcpKTtcblxuXHRcdHZhciBwdWJsaWNFeHBvbmVudCA9IGtleUJ1ZmZlci5zbGljZSgxLCBwdWJsaWNFeHBvbmVudExlbisxKTtcblx0XHRwdWJsaWNFeHBvbmVudCA9IHV0aWxzLm1wTm9ybWFsaXplKHB1YmxpY0V4cG9uZW50KTtcblx0XHR2YXIgbW9kdWx1cyA9IGtleUJ1ZmZlci5zbGljZSgxK3B1YmxpY0V4cG9uZW50TGVuKTtcblx0XHRtb2R1bHVzID0gdXRpbHMubXBOb3JtYWxpemUobW9kdWx1cyk7XG5cdFx0Ly8gbm93LCBtYWtlIHRoZSBrZXlcblx0XHR2YXIgcnNhS2V5ID0ge1xuXHRcdFx0dHlwZTogJ3JzYScsXG5cdFx0XHRwYXJ0czogW11cblx0XHR9O1xuXHRcdHJzYUtleS5wYXJ0cy5wdXNoKHsgbmFtZTogJ2UnLCBkYXRhOiBwdWJsaWNFeHBvbmVudH0pO1xuXHRcdHJzYUtleS5wYXJ0cy5wdXNoKHsgbmFtZTogJ24nLCBkYXRhOiBtb2R1bHVzfSk7XG5cdFx0cmV0dXJuIChuZXcgS2V5KHJzYUtleSkpO1xuXHR9XG5cdGlmIChzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnb3JpdGhtXSA9PT0gJ0VDRFNBLVAzODQtU0hBMzg0JyB8fFxuXHQgICAgc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ29yaXRobV0gPT09ICdFQ0RTQS1QMjU2LVNIQTI1NicpIHtcblx0XHR2YXIgY3VydmUgPSAnbmlzdHAzODQnO1xuXHRcdHZhciBzaXplID0gMzg0O1xuXHRcdGlmIChzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnb3JpdGhtXS5tYXRjaCgvXkVDRFNBLVAyNTYtU0hBMjU2LykpIHtcblx0XHRcdGN1cnZlID0gJ25pc3RwMjU2Jztcblx0XHRcdHNpemUgPSAyNTY7XG5cdFx0fVxuXG5cdFx0dmFyIGVjZHNhS2V5ID0ge1xuXHRcdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRcdGN1cnZlOiBjdXJ2ZSxcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRwYXJ0czogW1xuXHRcdFx0XHR7bmFtZTogJ2N1cnZlJywgZGF0YTogQnVmZmVyLmZyb20oY3VydmUpIH0sXG5cdFx0XHRcdHtuYW1lOiAnUScsIGRhdGE6IHV0aWxzLmVjTm9ybWFsaXplKGtleUJ1ZmZlcikgfVxuXHRcdFx0XVxuXHRcdH07XG5cdFx0cmV0dXJuIChuZXcgS2V5KGVjZHNhS2V5KSk7XG5cdH1cblx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiAnICtcblx0ICAgIHN1cHBvcnRlZEFsZ29zQnlJZFthbGdvcml0aG1dKSk7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRUb0J1ZihlKSB7XG5cdHJldHVybiAoQnVmZmVyLmZyb20oZS5zcGxpdCgnICcpWzFdLCAnYmFzZTY0JykpO1xufVxuXG5mdW5jdGlvbiByZWFkRE5TU0VDUlNBUHJpdmF0ZUtleShlbGVtZW50cykge1xuXHR2YXIgcnNhUGFyYW1zID0ge307XG5cdGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudC5zcGxpdCgnICcpWzBdID09PSAnTW9kdWx1czonKVxuXHRcdFx0cnNhUGFyYW1zWyduJ10gPSBlbGVtZW50VG9CdWYoZWxlbWVudCk7XG5cdFx0ZWxzZSBpZiAoZWxlbWVudC5zcGxpdCgnICcpWzBdID09PSAnUHVibGljRXhwb25lbnQ6Jylcblx0XHRcdHJzYVBhcmFtc1snZSddID0gZWxlbWVudFRvQnVmKGVsZW1lbnQpO1xuXHRcdGVsc2UgaWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ1ByaXZhdGVFeHBvbmVudDonKVxuXHRcdFx0cnNhUGFyYW1zWydkJ10gPSBlbGVtZW50VG9CdWYoZWxlbWVudCk7XG5cdFx0ZWxzZSBpZiAoZWxlbWVudC5zcGxpdCgnICcpWzBdID09PSAnUHJpbWUxOicpXG5cdFx0XHRyc2FQYXJhbXNbJ3AnXSA9IGVsZW1lbnRUb0J1ZihlbGVtZW50KTtcblx0XHRlbHNlIGlmIChlbGVtZW50LnNwbGl0KCcgJylbMF0gPT09ICdQcmltZTI6Jylcblx0XHRcdHJzYVBhcmFtc1sncSddID0gZWxlbWVudFRvQnVmKGVsZW1lbnQpO1xuXHRcdGVsc2UgaWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ0V4cG9uZW50MTonKVxuXHRcdFx0cnNhUGFyYW1zWydkbW9kcCddID0gZWxlbWVudFRvQnVmKGVsZW1lbnQpO1xuXHRcdGVsc2UgaWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ0V4cG9uZW50MjonKVxuXHRcdFx0cnNhUGFyYW1zWydkbW9kcSddID0gZWxlbWVudFRvQnVmKGVsZW1lbnQpO1xuXHRcdGVsc2UgaWYgKGVsZW1lbnQuc3BsaXQoJyAnKVswXSA9PT0gJ0NvZWZmaWNpZW50OicpXG5cdFx0XHRyc2FQYXJhbXNbJ2lxbXAnXSA9IGVsZW1lbnRUb0J1ZihlbGVtZW50KTtcblx0fSk7XG5cdC8vIG5vdywgbWFrZSB0aGUga2V5XG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ3JzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ2UnLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShyc2FQYXJhbXNbJ2UnXSl9LFxuXHRcdFx0eyBuYW1lOiAnbicsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHJzYVBhcmFtc1snbiddKX0sXG5cdFx0XHR7IG5hbWU6ICdkJywgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocnNhUGFyYW1zWydkJ10pfSxcblx0XHRcdHsgbmFtZTogJ3AnLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShyc2FQYXJhbXNbJ3AnXSl9LFxuXHRcdFx0eyBuYW1lOiAncScsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHJzYVBhcmFtc1sncSddKX0sXG5cdFx0XHR7IG5hbWU6ICdkbW9kcCcsXG5cdFx0XHQgICAgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocnNhUGFyYW1zWydkbW9kcCddKX0sXG5cdFx0XHR7IG5hbWU6ICdkbW9kcScsXG5cdFx0XHQgICAgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocnNhUGFyYW1zWydkbW9kcSddKX0sXG5cdFx0XHR7IG5hbWU6ICdpcW1wJyxcblx0XHRcdCAgICBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShyc2FQYXJhbXNbJ2lxbXAnXSl9XG5cdFx0XVxuXHR9O1xuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkRE5TU0VDUHJpdmF0ZUtleShhbGcsIGVsZW1lbnRzKSB7XG5cdGlmIChzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnXS5tYXRjaCgvXlJTQS0vKSkge1xuXHRcdHJldHVybiAocmVhZEROU1NFQ1JTQVByaXZhdGVLZXkoZWxlbWVudHMpKTtcblx0fVxuXHRpZiAoc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ10gPT09ICdFQ0RTQS1QMzg0LVNIQTM4NCcgfHxcblx0ICAgIHN1cHBvcnRlZEFsZ29zQnlJZFthbGddID09PSAnRUNEU0EtUDI1Ni1TSEEyNTYnKSB7XG5cdFx0dmFyIGQgPSBCdWZmZXIuZnJvbShlbGVtZW50c1swXS5zcGxpdCgnICcpWzFdLCAnYmFzZTY0Jyk7XG5cdFx0dmFyIGN1cnZlID0gJ25pc3RwMzg0Jztcblx0XHR2YXIgc2l6ZSA9IDM4NDtcblx0XHRpZiAoc3VwcG9ydGVkQWxnb3NCeUlkW2FsZ10gPT09ICdFQ0RTQS1QMjU2LVNIQTI1NicpIHtcblx0XHRcdGN1cnZlID0gJ25pc3RwMjU2Jztcblx0XHRcdHNpemUgPSAyNTY7XG5cdFx0fVxuXHRcdC8vIEROU1NFQyBnZW5lcmF0ZXMgdGhlIHB1YmxpYy1rZXkgb24gdGhlIGZseSAoZ28gY2FsY3VsYXRlIGl0KVxuXHRcdHZhciBwdWJsaWNLZXkgPSB1dGlscy5wdWJsaWNGcm9tUHJpdmF0ZUVDRFNBKGN1cnZlLCBkKTtcblx0XHR2YXIgUSA9IHB1YmxpY0tleS5wYXJ0WydRJ10uZGF0YTtcblx0XHR2YXIgZWNkc2FLZXkgPSB7XG5cdFx0XHR0eXBlOiAnZWNkc2EnLFxuXHRcdFx0Y3VydmU6IGN1cnZlLFxuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdHBhcnRzOiBbXG5cdFx0XHRcdHtuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZSkgfSxcblx0XHRcdFx0e25hbWU6ICdkJywgZGF0YTogZCB9LFxuXHRcdFx0XHR7bmFtZTogJ1EnLCBkYXRhOiBRIH1cblx0XHRcdF1cblx0XHR9O1xuXHRcdHJldHVybiAobmV3IFByaXZhdGVLZXkoZWNkc2FLZXkpKTtcblx0fVxuXHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhbGdvcml0aG06ICcgKyBzdXBwb3J0ZWRBbGdvc0J5SWRbYWxnXSkpO1xufVxuXG5mdW5jdGlvbiBkbnNzZWNUaW1lc3RhbXAoZGF0ZSkge1xuXHR2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKSArICcnOyAvL3N0cmluZ2lmeVxuXHR2YXIgbW9udGggPSAoZGF0ZS5nZXRNb250aCgpICsgMSk7XG5cdHZhciB0aW1lc3RhbXBTdHIgPSB5ZWFyICsgbW9udGggKyBkYXRlLmdldFVUQ0RhdGUoKTtcblx0dGltZXN0YW1wU3RyICs9ICcnICsgZGF0ZS5nZXRVVENIb3VycygpICsgZGF0ZS5nZXRVVENNaW51dGVzKCk7XG5cdHRpbWVzdGFtcFN0ciArPSBkYXRlLmdldFVUQ1NlY29uZHMoKTtcblx0cmV0dXJuICh0aW1lc3RhbXBTdHIpO1xufVxuXG5mdW5jdGlvbiByc2FBbGdGcm9tT3B0aW9ucyhvcHRzKSB7XG5cdGlmICghb3B0cyB8fCAhb3B0cy5oYXNoQWxnbyB8fCBvcHRzLmhhc2hBbGdvID09PSAnc2hhMScpXG5cdFx0cmV0dXJuICgnNSAoUlNBU0hBMSknKTtcblx0ZWxzZSBpZiAob3B0cy5oYXNoQWxnbyA9PT0gJ3NoYTI1NicpXG5cdFx0cmV0dXJuICgnOCAoUlNBU0hBMjU2KScpO1xuXHRlbHNlIGlmIChvcHRzLmhhc2hBbGdvID09PSAnc2hhNTEyJylcblx0XHRyZXR1cm4gKCcxMCAoUlNBU0hBNTEyKScpO1xuXHRlbHNlXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBvciB1bnN1cHBvcnRlZCBoYXNoOiAnICtcblx0XHQgICAgb3B0cy5oYXNoQWxnbykpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVJTQShrZXksIG9wdGlvbnMpIHtcblx0Ly8gaWYgd2UncmUgbWlzc2luZyBwYXJ0cywgYWRkIHRoZW0uXG5cdGlmICgha2V5LnBhcnQuZG1vZHAgfHwgIWtleS5wYXJ0LmRtb2RxKSB7XG5cdFx0dXRpbHMuYWRkUlNBTWlzc2luZyhrZXkpO1xuXHR9XG5cblx0dmFyIG91dCA9ICcnO1xuXHRvdXQgKz0gJ1ByaXZhdGUta2V5LWZvcm1hdDogdjEuM1xcbic7XG5cdG91dCArPSAnQWxnb3JpdGhtOiAnICsgcnNhQWxnRnJvbU9wdGlvbnMob3B0aW9ucykgKyAnXFxuJztcblx0dmFyIG4gPSB1dGlscy5tcERlbm9ybWFsaXplKGtleS5wYXJ0WyduJ10uZGF0YSk7XG5cdG91dCArPSAnTW9kdWx1czogJyArIG4udG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1xcbic7XG5cdHZhciBlID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsnZSddLmRhdGEpO1xuXHRvdXQgKz0gJ1B1YmxpY0V4cG9uZW50OiAnICsgZS50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIGQgPSB1dGlscy5tcERlbm9ybWFsaXplKGtleS5wYXJ0WydkJ10uZGF0YSk7XG5cdG91dCArPSAnUHJpdmF0ZUV4cG9uZW50OiAnICsgZC50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIHAgPSB1dGlscy5tcERlbm9ybWFsaXplKGtleS5wYXJ0WydwJ10uZGF0YSk7XG5cdG91dCArPSAnUHJpbWUxOiAnICsgcC50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIHEgPSB1dGlscy5tcERlbm9ybWFsaXplKGtleS5wYXJ0WydxJ10uZGF0YSk7XG5cdG91dCArPSAnUHJpbWUyOiAnICsgcS50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIGRtb2RwID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsnZG1vZHAnXS5kYXRhKTtcblx0b3V0ICs9ICdFeHBvbmVudDE6ICcgKyBkbW9kcC50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIGRtb2RxID0gdXRpbHMubXBEZW5vcm1hbGl6ZShrZXkucGFydFsnZG1vZHEnXS5kYXRhKTtcblx0b3V0ICs9ICdFeHBvbmVudDI6ICcgKyBkbW9kcS50b1N0cmluZygnYmFzZTY0JykgKyAnXFxuJztcblx0dmFyIGlxbXAgPSB1dGlscy5tcERlbm9ybWFsaXplKGtleS5wYXJ0WydpcW1wJ10uZGF0YSk7XG5cdG91dCArPSAnQ29lZmZpY2llbnQ6ICcgKyBpcW1wLnRvU3RyaW5nKCdiYXNlNjQnKSArICdcXG4nO1xuXHQvLyBBc3N1bWUgdGhhdCB3ZSdyZSB2YWxpZCBhcy1vZiBub3dcblx0dmFyIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cdG91dCArPSAnQ3JlYXRlZDogJyArIGRuc3NlY1RpbWVzdGFtcCh0aW1lc3RhbXApICsgJ1xcbic7XG5cdG91dCArPSAnUHVibGlzaDogJyArIGRuc3NlY1RpbWVzdGFtcCh0aW1lc3RhbXApICsgJ1xcbic7XG5cdG91dCArPSAnQWN0aXZhdGU6ICcgKyBkbnNzZWNUaW1lc3RhbXAodGltZXN0YW1wKSArICdcXG4nO1xuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKG91dCwgJ2FzY2lpJykpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUVDRFNBKGtleSwgb3B0aW9ucykge1xuXHR2YXIgb3V0ID0gJyc7XG5cdG91dCArPSAnUHJpdmF0ZS1rZXktZm9ybWF0OiB2MS4zXFxuJztcblxuXHRpZiAoa2V5LmN1cnZlID09PSAnbmlzdHAyNTYnKSB7XG5cdFx0b3V0ICs9ICdBbGdvcml0aG06IDEzIChFQ0RTQVAyNTZTSEEyNTYpXFxuJztcblx0fSBlbHNlIGlmIChrZXkuY3VydmUgPT09ICduaXN0cDM4NCcpIHtcblx0XHRvdXQgKz0gJ0FsZ29yaXRobTogMTQgKEVDRFNBUDM4NFNIQTM4NClcXG4nO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGN1cnZlJykpO1xuXHR9XG5cdHZhciBiYXNlNjRLZXkgPSBrZXkucGFydFsnZCddLmRhdGEudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHRvdXQgKz0gJ1ByaXZhdGVLZXk6ICcgKyBiYXNlNjRLZXkgKyAnXFxuJztcblxuXHQvLyBBc3N1bWUgdGhhdCB3ZSdyZSB2YWxpZCBhcy1vZiBub3dcblx0dmFyIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cdG91dCArPSAnQ3JlYXRlZDogJyArIGRuc3NlY1RpbWVzdGFtcCh0aW1lc3RhbXApICsgJ1xcbic7XG5cdG91dCArPSAnUHVibGlzaDogJyArIGRuc3NlY1RpbWVzdGFtcCh0aW1lc3RhbXApICsgJ1xcbic7XG5cdG91dCArPSAnQWN0aXZhdGU6ICcgKyBkbnNzZWNUaW1lc3RhbXAodGltZXN0YW1wKSArICdcXG4nO1xuXG5cdHJldHVybiAoQnVmZmVyLmZyb20ob3V0LCAnYXNjaWknKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgb3B0aW9ucykge1xuXHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSkge1xuXHRcdGlmIChrZXkudHlwZSA9PT0gJ3JzYScpIHtcblx0XHRcdHJldHVybiAod3JpdGVSU0Eoa2V5LCBvcHRpb25zKSk7XG5cdFx0fSBlbHNlIGlmIChrZXkudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdFx0cmV0dXJuICh3cml0ZUVDRFNBKGtleSwgb3B0aW9ucykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhbGdvcml0aG06ICcgKyBrZXkudHlwZSkpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChLZXkuaXNLZXkoa2V5KSkge1xuXHRcdC8qXG5cdFx0ICogUkZDMzExMCByZXF1aXJlcyBhIGtleW5hbWUsIGFuZCBhIGtleXR5cGUsIHdoaWNoIHdlXG5cdFx0ICogZG9uJ3QgcmVhbGx5IGhhdmUgYSBtZWNoYW5pc20gZm9yIHNwZWNpZnlpbmcgc3VjaFxuXHRcdCAqIGFkZGl0aW9uYWwgbWV0YWRhdGEuXG5cdFx0ICovXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignRm9ybWF0IFwiZG5zc2VjXCIgb25seSBzdXBwb3J0cyAnICtcblx0XHQgICAgJ3dyaXRpbmcgcHJpdmF0ZSBrZXlzJykpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ2tleSBpcyBub3QgYSBLZXkgb3IgUHJpdmF0ZUtleScpKTtcblx0fVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTcgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHR2ZXJpZnk6IHZlcmlmeSxcblx0c2lnbjogc2lnbixcblx0c2lnbkFzeW5jOiBzaWduQXN5bmMsXG5cdHdyaXRlOiB3cml0ZSxcblxuXHQvKiBJbnRlcm5hbCBwcml2YXRlIEFQSSAqL1xuXHRmcm9tQnVmZmVyOiBmcm9tQnVmZmVyLFxuXHR0b0J1ZmZlcjogdG9CdWZmZXJcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIFNTSEJ1ZmZlciA9IHJlcXVpcmUoJy4uL3NzaC1idWZmZXInKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4uL2FsZ3MnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcbnZhciBJZGVudGl0eSA9IHJlcXVpcmUoJy4uL2lkZW50aXR5Jyk7XG52YXIgcmZjNDI1MyA9IHJlcXVpcmUoJy4vcmZjNDI1MycpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4uL3NpZ25hdHVyZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBDZXJ0aWZpY2F0ZSA9IHJlcXVpcmUoJy4uL2NlcnRpZmljYXRlJyk7XG5cbmZ1bmN0aW9uIHZlcmlmeShjZXJ0LCBrZXkpIHtcblx0Lypcblx0ICogV2UgYWx3YXlzIGdpdmUgYW4gaXNzdWVyS2V5LCBzbyBpZiBvdXIgdmVyaWZ5KCkgaXMgYmVpbmcgY2FsbGVkIHRoZW5cblx0ICogdGhlcmUgd2FzIG5vIHNpZ25hdHVyZS4gUmV0dXJuIGZhbHNlLlxuXHQgKi9cblx0cmV0dXJuIChmYWxzZSk7XG59XG5cbnZhciBUWVBFUyA9IHtcblx0J3VzZXInOiAxLFxuXHQnaG9zdCc6IDJcbn07XG5PYmplY3Qua2V5cyhUWVBFUykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBUWVBFU1tUWVBFU1trXV0gPSBrOyB9KTtcblxudmFyIEVDRFNBX0FMR08gPSAvXmVjZHNhLXNoYTItKFteQC1dKyktY2VydC12MDFAb3BlbnNzaC5jb20kLztcblxuZnVuY3Rpb24gcmVhZChidWYsIG9wdGlvbnMpIHtcblx0aWYgKEJ1ZmZlci5pc0J1ZmZlcihidWYpKVxuXHRcdGJ1ZiA9IGJ1Zi50b1N0cmluZygnYXNjaWknKTtcblx0dmFyIHBhcnRzID0gYnVmLnRyaW0oKS5zcGxpdCgvWyBcXHRcXG5dKy9nKTtcblx0aWYgKHBhcnRzLmxlbmd0aCA8IDIgfHwgcGFydHMubGVuZ3RoID4gMylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdOb3QgYSB2YWxpZCBTU0ggY2VydGlmaWNhdGUgbGluZScpKTtcblxuXHR2YXIgYWxnbyA9IHBhcnRzWzBdO1xuXHR2YXIgZGF0YSA9IHBhcnRzWzFdO1xuXG5cdGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCAnYmFzZTY0Jyk7XG5cdHJldHVybiAoZnJvbUJ1ZmZlcihkYXRhLCBhbGdvKSk7XG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIoZGF0YSwgYWxnbywgcGFydGlhbCkge1xuXHR2YXIgc3NoYnVmID0gbmV3IFNTSEJ1ZmZlcih7IGJ1ZmZlcjogZGF0YSB9KTtcblx0dmFyIGlubmVyQWxnbyA9IHNzaGJ1Zi5yZWFkU3RyaW5nKCk7XG5cdGlmIChhbGdvICE9PSB1bmRlZmluZWQgJiYgaW5uZXJBbGdvICE9PSBhbGdvKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1NTSCBjZXJ0aWZpY2F0ZSBhbGdvcml0aG0gbWlzbWF0Y2gnKSk7XG5cdGlmIChhbGdvID09PSB1bmRlZmluZWQpXG5cdFx0YWxnbyA9IGlubmVyQWxnbztcblxuXHR2YXIgY2VydCA9IHt9O1xuXHRjZXJ0LnNpZ25hdHVyZXMgPSB7fTtcblx0Y2VydC5zaWduYXR1cmVzLm9wZW5zc2ggPSB7fTtcblxuXHRjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaC5ub25jZSA9IHNzaGJ1Zi5yZWFkQnVmZmVyKCk7XG5cblx0dmFyIGtleSA9IHt9O1xuXHR2YXIgcGFydHMgPSAoa2V5LnBhcnRzID0gW10pO1xuXHRrZXkudHlwZSA9IGdldEFsZyhhbGdvKTtcblxuXHR2YXIgcGFydENvdW50ID0gYWxncy5pbmZvW2tleS50eXBlXS5wYXJ0cy5sZW5ndGg7XG5cdHdoaWxlIChwYXJ0cy5sZW5ndGggPCBwYXJ0Q291bnQpXG5cdFx0cGFydHMucHVzaChzc2hidWYucmVhZFBhcnQoKSk7XG5cdGFzc2VydC5vayhwYXJ0cy5sZW5ndGggPj0gMSwgJ2tleSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHBhcnQnKTtcblxuXHR2YXIgYWxnSW5mbyA9IGFsZ3MuaW5mb1trZXkudHlwZV07XG5cdGlmIChrZXkudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdHZhciByZXMgPSBFQ0RTQV9BTEdPLmV4ZWMoYWxnbyk7XG5cdFx0YXNzZXJ0Lm9rKHJlcyAhPT0gbnVsbCk7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHJlc1sxXSwgcGFydHNbMF0uZGF0YS50b1N0cmluZygpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYWxnSW5mby5wYXJ0cy5sZW5ndGg7ICsraSkge1xuXHRcdHBhcnRzW2ldLm5hbWUgPSBhbGdJbmZvLnBhcnRzW2ldO1xuXHRcdGlmIChwYXJ0c1tpXS5uYW1lICE9PSAnY3VydmUnICYmXG5cdFx0ICAgIGFsZ0luZm8ubm9ybWFsaXplICE9PSBmYWxzZSkge1xuXHRcdFx0dmFyIHAgPSBwYXJ0c1tpXTtcblx0XHRcdHAuZGF0YSA9IHV0aWxzLm1wTm9ybWFsaXplKHAuZGF0YSk7XG5cdFx0fVxuXHR9XG5cblx0Y2VydC5zdWJqZWN0S2V5ID0gbmV3IEtleShrZXkpO1xuXG5cdGNlcnQuc2VyaWFsID0gc3NoYnVmLnJlYWRJbnQ2NCgpO1xuXG5cdHZhciB0eXBlID0gVFlQRVNbc3NoYnVmLnJlYWRJbnQoKV07XG5cdGFzc2VydC5zdHJpbmcodHlwZSwgJ3ZhbGlkIGNlcnQgdHlwZScpO1xuXG5cdGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoLmtleUlkID0gc3NoYnVmLnJlYWRTdHJpbmcoKTtcblxuXHR2YXIgcHJpbmNpcGFscyA9IFtdO1xuXHR2YXIgcGJ1ZiA9IHNzaGJ1Zi5yZWFkQnVmZmVyKCk7XG5cdHZhciBwc3NoYnVmID0gbmV3IFNTSEJ1ZmZlcih7IGJ1ZmZlcjogcGJ1ZiB9KTtcblx0d2hpbGUgKCFwc3NoYnVmLmF0RW5kKCkpXG5cdFx0cHJpbmNpcGFscy5wdXNoKHBzc2hidWYucmVhZFN0cmluZygpKTtcblx0aWYgKHByaW5jaXBhbHMubGVuZ3RoID09PSAwKVxuXHRcdHByaW5jaXBhbHMgPSBbJyonXTtcblxuXHRjZXJ0LnN1YmplY3RzID0gcHJpbmNpcGFscy5tYXAoZnVuY3Rpb24gKHByKSB7XG5cdFx0aWYgKHR5cGUgPT09ICd1c2VyJylcblx0XHRcdHJldHVybiAoSWRlbnRpdHkuZm9yVXNlcihwcikpO1xuXHRcdGVsc2UgaWYgKHR5cGUgPT09ICdob3N0Jylcblx0XHRcdHJldHVybiAoSWRlbnRpdHkuZm9ySG9zdChwcikpO1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24gaWRlbnRpdHkgdHlwZSAnICsgdHlwZSkpO1xuXHR9KTtcblxuXHRjZXJ0LnZhbGlkRnJvbSA9IGludDY0VG9EYXRlKHNzaGJ1Zi5yZWFkSW50NjQoKSk7XG5cdGNlcnQudmFsaWRVbnRpbCA9IGludDY0VG9EYXRlKHNzaGJ1Zi5yZWFkSW50NjQoKSk7XG5cblx0dmFyIGV4dHMgPSBbXTtcblx0dmFyIGV4dGJ1ZiA9IG5ldyBTU0hCdWZmZXIoeyBidWZmZXI6IHNzaGJ1Zi5yZWFkQnVmZmVyKCkgfSk7XG5cdHZhciBleHQ7XG5cdHdoaWxlICghZXh0YnVmLmF0RW5kKCkpIHtcblx0XHRleHQgPSB7IGNyaXRpY2FsOiB0cnVlIH07XG5cdFx0ZXh0Lm5hbWUgPSBleHRidWYucmVhZFN0cmluZygpO1xuXHRcdGV4dC5kYXRhID0gZXh0YnVmLnJlYWRCdWZmZXIoKTtcblx0XHRleHRzLnB1c2goZXh0KTtcblx0fVxuXHRleHRidWYgPSBuZXcgU1NIQnVmZmVyKHsgYnVmZmVyOiBzc2hidWYucmVhZEJ1ZmZlcigpIH0pO1xuXHR3aGlsZSAoIWV4dGJ1Zi5hdEVuZCgpKSB7XG5cdFx0ZXh0ID0geyBjcml0aWNhbDogZmFsc2UgfTtcblx0XHRleHQubmFtZSA9IGV4dGJ1Zi5yZWFkU3RyaW5nKCk7XG5cdFx0ZXh0LmRhdGEgPSBleHRidWYucmVhZEJ1ZmZlcigpO1xuXHRcdGV4dHMucHVzaChleHQpO1xuXHR9XG5cdGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoLmV4dHMgPSBleHRzO1xuXG5cdC8qIHJlc2VydmVkICovXG5cdHNzaGJ1Zi5yZWFkQnVmZmVyKCk7XG5cblx0dmFyIHNpZ25pbmdLZXlCdWYgPSBzc2hidWYucmVhZEJ1ZmZlcigpO1xuXHRjZXJ0Lmlzc3VlcktleSA9IHJmYzQyNTMucmVhZChzaWduaW5nS2V5QnVmKTtcblxuXHQvKlxuXHQgKiBPcGVuU1NIIGNlcnRzIGRvbid0IGdpdmUgdGhlIGlkZW50aXR5IG9mIHRoZSBpc3N1ZXIsIGp1c3QgdGhlaXJcblx0ICogcHVibGljIGtleS4gU28sIHdlIHVzZSBhbiBJZGVudGl0eSB0aGF0IG1hdGNoZXMgYW55dGhpbmcuIFRoZVxuXHQgKiBpc1NpZ25lZEJ5KCkgZnVuY3Rpb24gd2lsbCBsYXRlciB0ZWxsIHlvdSBpZiB0aGUga2V5IG1hdGNoZXMuXG5cdCAqL1xuXHRjZXJ0Lmlzc3VlciA9IElkZW50aXR5LmZvckhvc3QoJyoqJyk7XG5cblx0dmFyIHNpZ0J1ZiA9IHNzaGJ1Zi5yZWFkQnVmZmVyKCk7XG5cdGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoLnNpZ25hdHVyZSA9XG5cdCAgICBTaWduYXR1cmUucGFyc2Uoc2lnQnVmLCBjZXJ0Lmlzc3VlcktleS50eXBlLCAnc3NoJyk7XG5cblx0aWYgKHBhcnRpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdHBhcnRpYWwucmVtYWluZGVyID0gc3NoYnVmLnJlbWFpbmRlcigpO1xuXHRcdHBhcnRpYWwuY29uc3VtZWQgPSBzc2hidWYuX29mZnNldDtcblx0fVxuXG5cdHJldHVybiAobmV3IENlcnRpZmljYXRlKGNlcnQpKTtcbn1cblxuZnVuY3Rpb24gaW50NjRUb0RhdGUoYnVmKSB7XG5cdHZhciBpID0gYnVmLnJlYWRVSW50MzJCRSgwKSAqIDQyOTQ5NjcyOTY7XG5cdGkgKz0gYnVmLnJlYWRVSW50MzJCRSg0KTtcblx0dmFyIGQgPSBuZXcgRGF0ZSgpO1xuXHRkLnNldFRpbWUoaSAqIDEwMDApO1xuXHRkLnNvdXJjZUludDY0ID0gYnVmO1xuXHRyZXR1cm4gKGQpO1xufVxuXG5mdW5jdGlvbiBkYXRlVG9JbnQ2NChkYXRlKSB7XG5cdGlmIChkYXRlLnNvdXJjZUludDY0ICE9PSB1bmRlZmluZWQpXG5cdFx0cmV0dXJuIChkYXRlLnNvdXJjZUludDY0KTtcblx0dmFyIGkgPSBNYXRoLnJvdW5kKGRhdGUuZ2V0VGltZSgpIC8gMTAwMCk7XG5cdHZhciB1cHBlciA9IE1hdGguZmxvb3IoaSAvIDQyOTQ5NjcyOTYpO1xuXHR2YXIgbG93ZXIgPSBNYXRoLmZsb29yKGkgJSA0Mjk0OTY3Mjk2KTtcblx0dmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg4KTtcblx0YnVmLndyaXRlVUludDMyQkUodXBwZXIsIDApO1xuXHRidWYud3JpdGVVSW50MzJCRShsb3dlciwgNCk7XG5cdHJldHVybiAoYnVmKTtcbn1cblxuZnVuY3Rpb24gc2lnbihjZXJ0LCBrZXkpIHtcblx0aWYgKGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoID09PSB1bmRlZmluZWQpXG5cdFx0Y2VydC5zaWduYXR1cmVzLm9wZW5zc2ggPSB7fTtcblx0dHJ5IHtcblx0XHR2YXIgYmxvYiA9IHRvQnVmZmVyKGNlcnQsIHRydWUpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0ZGVsZXRlIChjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaCk7XG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdH1cblx0dmFyIHNpZyA9IGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoO1xuXHR2YXIgaGFzaEFsZ28gPSB1bmRlZmluZWQ7XG5cdGlmIChrZXkudHlwZSA9PT0gJ3JzYScgfHwga2V5LnR5cGUgPT09ICdkc2EnKVxuXHRcdGhhc2hBbGdvID0gJ3NoYTEnO1xuXHR2YXIgc2lnbmVyID0ga2V5LmNyZWF0ZVNpZ24oaGFzaEFsZ28pO1xuXHRzaWduZXIud3JpdGUoYmxvYik7XG5cdHNpZy5zaWduYXR1cmUgPSBzaWduZXIuc2lnbigpO1xuXHRyZXR1cm4gKHRydWUpO1xufVxuXG5mdW5jdGlvbiBzaWduQXN5bmMoY2VydCwgc2lnbmVyLCBkb25lKSB7XG5cdGlmIChjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaCA9PT0gdW5kZWZpbmVkKVxuXHRcdGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoID0ge307XG5cdHRyeSB7XG5cdFx0dmFyIGJsb2IgPSB0b0J1ZmZlcihjZXJ0LCB0cnVlKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGRlbGV0ZSAoY2VydC5zaWduYXR1cmVzLm9wZW5zc2gpO1xuXHRcdGRvbmUoZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHZhciBzaWcgPSBjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaDtcblxuXHRzaWduZXIoYmxvYiwgZnVuY3Rpb24gKGVyciwgc2lnbmF0dXJlKSB7XG5cdFx0aWYgKGVycikge1xuXHRcdFx0ZG9uZShlcnIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0Lypcblx0XHRcdCAqIFRoaXMgd2lsbCB0aHJvdyBpZiB0aGUgc2lnbmF0dXJlIGlzbid0IG9mIGFcblx0XHRcdCAqIHR5cGUvYWxnbyB0aGF0IGNhbiBiZSB1c2VkIGZvciBTU0guXG5cdFx0XHQgKi9cblx0XHRcdHNpZ25hdHVyZS50b0J1ZmZlcignc3NoJyk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0ZG9uZShlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c2lnLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcblx0XHRkb25lKCk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiB3cml0ZShjZXJ0LCBvcHRpb25zKSB7XG5cdGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucyA9IHt9O1xuXG5cdHZhciBibG9iID0gdG9CdWZmZXIoY2VydCk7XG5cdHZhciBvdXQgPSBnZXRDZXJ0VHlwZShjZXJ0LnN1YmplY3RLZXkpICsgJyAnICsgYmxvYi50b1N0cmluZygnYmFzZTY0Jyk7XG5cdGlmIChvcHRpb25zLmNvbW1lbnQpXG5cdFx0b3V0ID0gb3V0ICsgJyAnICsgb3B0aW9ucy5jb21tZW50O1xuXHRyZXR1cm4gKG91dCk7XG59XG5cblxuZnVuY3Rpb24gdG9CdWZmZXIoY2VydCwgbm9TaWcpIHtcblx0YXNzZXJ0Lm9iamVjdChjZXJ0LnNpZ25hdHVyZXMub3BlbnNzaCwgJ3NpZ25hdHVyZSBmb3Igb3BlbnNzaCBmb3JtYXQnKTtcblx0dmFyIHNpZyA9IGNlcnQuc2lnbmF0dXJlcy5vcGVuc3NoO1xuXG5cdGlmIChzaWcubm9uY2UgPT09IHVuZGVmaW5lZClcblx0XHRzaWcubm9uY2UgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpO1xuXHR2YXIgYnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdGJ1Zi53cml0ZVN0cmluZyhnZXRDZXJ0VHlwZShjZXJ0LnN1YmplY3RLZXkpKTtcblx0YnVmLndyaXRlQnVmZmVyKHNpZy5ub25jZSk7XG5cblx0dmFyIGtleSA9IGNlcnQuc3ViamVjdEtleTtcblx0dmFyIGFsZ0luZm8gPSBhbGdzLmluZm9ba2V5LnR5cGVdO1xuXHRhbGdJbmZvLnBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcblx0XHRidWYud3JpdGVQYXJ0KGtleS5wYXJ0W3BhcnRdKTtcblx0fSk7XG5cblx0YnVmLndyaXRlSW50NjQoY2VydC5zZXJpYWwpO1xuXG5cdHZhciB0eXBlID0gY2VydC5zdWJqZWN0c1swXS50eXBlO1xuXHRhc3NlcnQubm90U3RyaWN0RXF1YWwodHlwZSwgJ3Vua25vd24nKTtcblx0Y2VydC5zdWJqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChpZC50eXBlLCB0eXBlKTtcblx0fSk7XG5cdHR5cGUgPSBUWVBFU1t0eXBlXTtcblx0YnVmLndyaXRlSW50KHR5cGUpO1xuXG5cdGlmIChzaWcua2V5SWQgPT09IHVuZGVmaW5lZCkge1xuXHRcdHNpZy5rZXlJZCA9IGNlcnQuc3ViamVjdHNbMF0udHlwZSArICdfJyArXG5cdFx0ICAgIChjZXJ0LnN1YmplY3RzWzBdLnVpZCB8fCBjZXJ0LnN1YmplY3RzWzBdLmhvc3RuYW1lKTtcblx0fVxuXHRidWYud3JpdGVTdHJpbmcoc2lnLmtleUlkKTtcblxuXHR2YXIgc3ViID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdGNlcnQuc3ViamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcblx0XHRpZiAodHlwZSA9PT0gVFlQRVMuaG9zdClcblx0XHRcdHN1Yi53cml0ZVN0cmluZyhpZC5ob3N0bmFtZSk7XG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gVFlQRVMudXNlcilcblx0XHRcdHN1Yi53cml0ZVN0cmluZyhpZC51aWQpO1xuXHR9KTtcblx0YnVmLndyaXRlQnVmZmVyKHN1Yi50b0J1ZmZlcigpKTtcblxuXHRidWYud3JpdGVJbnQ2NChkYXRlVG9JbnQ2NChjZXJ0LnZhbGlkRnJvbSkpO1xuXHRidWYud3JpdGVJbnQ2NChkYXRlVG9JbnQ2NChjZXJ0LnZhbGlkVW50aWwpKTtcblxuXHR2YXIgZXh0cyA9IHNpZy5leHRzO1xuXHRpZiAoZXh0cyA9PT0gdW5kZWZpbmVkKVxuXHRcdGV4dHMgPSBbXTtcblxuXHR2YXIgZXh0YnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdGV4dHMuZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG5cdFx0aWYgKGV4dC5jcml0aWNhbCAhPT0gdHJ1ZSlcblx0XHRcdHJldHVybjtcblx0XHRleHRidWYud3JpdGVTdHJpbmcoZXh0Lm5hbWUpO1xuXHRcdGV4dGJ1Zi53cml0ZUJ1ZmZlcihleHQuZGF0YSk7XG5cdH0pO1xuXHRidWYud3JpdGVCdWZmZXIoZXh0YnVmLnRvQnVmZmVyKCkpO1xuXG5cdGV4dGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXHRleHRzLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuXHRcdGlmIChleHQuY3JpdGljYWwgPT09IHRydWUpXG5cdFx0XHRyZXR1cm47XG5cdFx0ZXh0YnVmLndyaXRlU3RyaW5nKGV4dC5uYW1lKTtcblx0XHRleHRidWYud3JpdGVCdWZmZXIoZXh0LmRhdGEpO1xuXHR9KTtcblx0YnVmLndyaXRlQnVmZmVyKGV4dGJ1Zi50b0J1ZmZlcigpKTtcblxuXHQvKiByZXNlcnZlZCAqL1xuXHRidWYud3JpdGVCdWZmZXIoQnVmZmVyLmFsbG9jKDApKTtcblxuXHRzdWIgPSByZmM0MjUzLndyaXRlKGNlcnQuaXNzdWVyS2V5KTtcblx0YnVmLndyaXRlQnVmZmVyKHN1Yik7XG5cblx0aWYgKCFub1NpZylcblx0XHRidWYud3JpdGVCdWZmZXIoc2lnLnNpZ25hdHVyZS50b0J1ZmZlcignc3NoJykpO1xuXG5cdHJldHVybiAoYnVmLnRvQnVmZmVyKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRBbGcoY2VydFR5cGUpIHtcblx0aWYgKGNlcnRUeXBlID09PSAnc3NoLXJzYS1jZXJ0LXYwMUBvcGVuc3NoLmNvbScpXG5cdFx0cmV0dXJuICgncnNhJyk7XG5cdGlmIChjZXJ0VHlwZSA9PT0gJ3NzaC1kc3MtY2VydC12MDFAb3BlbnNzaC5jb20nKVxuXHRcdHJldHVybiAoJ2RzYScpO1xuXHRpZiAoY2VydFR5cGUubWF0Y2goRUNEU0FfQUxHTykpXG5cdFx0cmV0dXJuICgnZWNkc2EnKTtcblx0aWYgKGNlcnRUeXBlID09PSAnc3NoLWVkMjU1MTktY2VydC12MDFAb3BlbnNzaC5jb20nKVxuXHRcdHJldHVybiAoJ2VkMjU1MTknKTtcblx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY2VydCB0eXBlICcgKyBjZXJ0VHlwZSkpO1xufVxuXG5mdW5jdGlvbiBnZXRDZXJ0VHlwZShrZXkpIHtcblx0aWYgKGtleS50eXBlID09PSAncnNhJylcblx0XHRyZXR1cm4gKCdzc2gtcnNhLWNlcnQtdjAxQG9wZW5zc2guY29tJyk7XG5cdGlmIChrZXkudHlwZSA9PT0gJ2RzYScpXG5cdFx0cmV0dXJuICgnc3NoLWRzcy1jZXJ0LXYwMUBvcGVuc3NoLmNvbScpO1xuXHRpZiAoa2V5LnR5cGUgPT09ICdlY2RzYScpXG5cdFx0cmV0dXJuICgnZWNkc2Etc2hhMi0nICsga2V5LmN1cnZlICsgJy1jZXJ0LXYwMUBvcGVuc3NoLmNvbScpO1xuXHRpZiAoa2V5LnR5cGUgPT09ICdlZDI1NTE5Jylcblx0XHRyZXR1cm4gKCdzc2gtZWQyNTUxOS1jZXJ0LXYwMUBvcGVuc3NoLmNvbScpO1xuXHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXkgdHlwZSAnICsga2V5LnR5cGUpKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDE4IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi4vYWxncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcblxudmFyIHBrY3MxID0gcmVxdWlyZSgnLi9wa2NzMScpO1xudmFyIHBrY3M4ID0gcmVxdWlyZSgnLi9wa2NzOCcpO1xudmFyIHNzaHByaXYgPSByZXF1aXJlKCcuL3NzaC1wcml2YXRlJyk7XG52YXIgcmZjNDI1MyA9IHJlcXVpcmUoJy4vcmZjNDI1MycpO1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cbnZhciBPSURfUEJFUzIgPSAnMS4yLjg0MC4xMTM1NDkuMS41LjEzJztcbnZhciBPSURfUEJLREYyID0gJzEuMi44NDAuMTEzNTQ5LjEuNS4xMic7XG5cbnZhciBPSURfVE9fQ0lQSEVSID0ge1xuXHQnMS4yLjg0MC4xMTM1NDkuMy43JzogJzNkZXMtY2JjJyxcblx0JzIuMTYuODQwLjEuMTAxLjMuNC4xLjInOiAnYWVzMTI4LWNiYycsXG5cdCcyLjE2Ljg0MC4xLjEwMS4zLjQuMS40Mic6ICdhZXMyNTYtY2JjJ1xufTtcbnZhciBDSVBIRVJfVE9fT0lEID0ge307XG5PYmplY3Qua2V5cyhPSURfVE9fQ0lQSEVSKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdENJUEhFUl9UT19PSURbT0lEX1RPX0NJUEhFUltrXV0gPSBrO1xufSk7XG5cbnZhciBPSURfVE9fSEFTSCA9IHtcblx0JzEuMi44NDAuMTEzNTQ5LjIuNyc6ICdzaGExJyxcblx0JzEuMi44NDAuMTEzNTQ5LjIuOSc6ICdzaGEyNTYnLFxuXHQnMS4yLjg0MC4xMTM1NDkuMi4xMSc6ICdzaGE1MTInXG59O1xudmFyIEhBU0hfVE9fT0lEID0ge307XG5PYmplY3Qua2V5cyhPSURfVE9fSEFTSCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRIQVNIX1RPX09JRFtPSURfVE9fSEFTSFtrXV0gPSBrO1xufSk7XG5cbi8qXG4gKiBGb3IgcmVhZGluZyB3ZSBzdXBwb3J0IGJvdGggUEtDUyMxIGFuZCBQS0NTIzguIElmIHdlIGZpbmQgYSBwcml2YXRlIGtleSxcbiAqIHdlIGp1c3QgdGFrZSB0aGUgcHVibGljIGNvbXBvbmVudCBvZiBpdCBhbmQgdXNlIHRoYXQuXG4gKi9cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zLCBmb3JjZVR5cGUpIHtcblx0dmFyIGlucHV0ID0gYnVmO1xuXHRpZiAodHlwZW9mIChidWYpICE9PSAnc3RyaW5nJykge1xuXHRcdGFzc2VydC5idWZmZXIoYnVmLCAnYnVmJyk7XG5cdFx0YnVmID0gYnVmLnRvU3RyaW5nKCdhc2NpaScpO1xuXHR9XG5cblx0dmFyIGxpbmVzID0gYnVmLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rL2cpO1xuXG5cdHZhciBtO1xuXHR2YXIgc2kgPSAtMTtcblx0d2hpbGUgKCFtICYmIHNpIDwgbGluZXMubGVuZ3RoKSB7XG5cdFx0bSA9IGxpbmVzWysrc2ldLm1hdGNoKC8qSlNTVFlMRUQqL1xuXHRcdCAgICAvWy1dK1sgXSpCRUdJTiAoW0EtWjAtOV1bQS1aYS16MC05XSsgKT8oUFVCTElDfFBSSVZBVEUpIEtFWVsgXSpbLV0rLyk7XG5cdH1cblx0YXNzZXJ0Lm9rKG0sICdpbnZhbGlkIFBFTSBoZWFkZXInKTtcblxuXHR2YXIgbTI7XG5cdHZhciBlaSA9IGxpbmVzLmxlbmd0aDtcblx0d2hpbGUgKCFtMiAmJiBlaSA+IDApIHtcblx0XHRtMiA9IGxpbmVzWy0tZWldLm1hdGNoKC8qSlNTVFlMRUQqL1xuXHRcdCAgICAvWy1dK1sgXSpFTkQgKFtBLVowLTldW0EtWmEtejAtOV0rICk/KFBVQkxJQ3xQUklWQVRFKSBLRVlbIF0qWy1dKy8pO1xuXHR9XG5cdGFzc2VydC5vayhtMiwgJ2ludmFsaWQgUEVNIGZvb3RlcicpO1xuXG5cdC8qIEJlZ2luIGFuZCBlbmQgYmFubmVycyBtdXN0IG1hdGNoIGtleSB0eXBlICovXG5cdGFzc2VydC5lcXVhbChtWzJdLCBtMlsyXSk7XG5cdHZhciB0eXBlID0gbVsyXS50b0xvd2VyQ2FzZSgpO1xuXG5cdHZhciBhbGc7XG5cdGlmIChtWzFdKSB7XG5cdFx0LyogVGhleSBhbHNvIG11c3QgbWF0Y2ggYWxnb3JpdGhtcywgaWYgZ2l2ZW4gKi9cblx0XHRhc3NlcnQuZXF1YWwobVsxXSwgbTJbMV0sICdQRU0gaGVhZGVyIGFuZCBmb290ZXIgbWlzbWF0Y2gnKTtcblx0XHRhbGcgPSBtWzFdLnRyaW0oKTtcblx0fVxuXG5cdGxpbmVzID0gbGluZXMuc2xpY2Uoc2ksIGVpICsgMSk7XG5cblx0dmFyIGhlYWRlcnMgPSB7fTtcblx0d2hpbGUgKHRydWUpIHtcblx0XHRsaW5lcyA9IGxpbmVzLnNsaWNlKDEpO1xuXHRcdG0gPSBsaW5lc1swXS5tYXRjaCgvKkpTU1RZTEVEKi9cblx0XHQgICAgL14oW0EtWmEtejAtOS1dKyk6ICguKykkLyk7XG5cdFx0aWYgKCFtKVxuXHRcdFx0YnJlYWs7XG5cdFx0aGVhZGVyc1ttWzFdLnRvTG93ZXJDYXNlKCldID0gbVsyXTtcblx0fVxuXG5cdC8qIENob3Agb2ZmIHRoZSBmaXJzdCBhbmQgbGFzdCBsaW5lcyAqL1xuXHRsaW5lcyA9IGxpbmVzLnNsaWNlKDAsIC0xKS5qb2luKCcnKTtcblx0YnVmID0gQnVmZmVyLmZyb20obGluZXMsICdiYXNlNjQnKTtcblxuXHR2YXIgY2lwaGVyLCBrZXksIGl2O1xuXHRpZiAoaGVhZGVyc1sncHJvYy10eXBlJ10pIHtcblx0XHR2YXIgcGFydHMgPSBoZWFkZXJzWydwcm9jLXR5cGUnXS5zcGxpdCgnLCcpO1xuXHRcdGlmIChwYXJ0c1swXSA9PT0gJzQnICYmIHBhcnRzWzFdID09PSAnRU5DUllQVEVEJykge1xuXHRcdFx0aWYgKHR5cGVvZiAob3B0aW9ucy5wYXNzcGhyYXNlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0b3B0aW9ucy5wYXNzcGhyYXNlID0gQnVmZmVyLmZyb20oXG5cdFx0XHRcdCAgICBvcHRpb25zLnBhc3NwaHJhc2UsICd1dGYtOCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5wYXNzcGhyYXNlKSkge1xuXHRcdFx0XHR0aHJvdyAobmV3IGVycm9ycy5LZXlFbmNyeXB0ZWRFcnJvcihcblx0XHRcdFx0ICAgIG9wdGlvbnMuZmlsZW5hbWUsICdQRU0nKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXJ0cyA9IGhlYWRlcnNbJ2Rlay1pbmZvJ10uc3BsaXQoJywnKTtcblx0XHRcdFx0YXNzZXJ0Lm9rKHBhcnRzLmxlbmd0aCA9PT0gMik7XG5cdFx0XHRcdGNpcGhlciA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGl2ID0gQnVmZmVyLmZyb20ocGFydHNbMV0sICdoZXgnKTtcblx0XHRcdFx0a2V5ID0gdXRpbHMub3BlbnNzbEtleURlcml2KGNpcGhlciwgaXYsXG5cdFx0XHRcdCAgICBvcHRpb25zLnBhc3NwaHJhc2UsIDEpLmtleTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoYWxnICYmIGFsZy50b0xvd2VyQ2FzZSgpID09PSAnZW5jcnlwdGVkJykge1xuXHRcdHZhciBlZGVyID0gbmV3IGFzbjEuQmVyUmVhZGVyKGJ1Zik7XG5cdFx0dmFyIHBiZXNFbmQ7XG5cdFx0ZWRlci5yZWFkU2VxdWVuY2UoKTtcblxuXHRcdGVkZXIucmVhZFNlcXVlbmNlKCk7XG5cdFx0cGJlc0VuZCA9IGVkZXIub2Zmc2V0ICsgZWRlci5sZW5ndGg7XG5cblx0XHR2YXIgbWV0aG9kID0gZWRlci5yZWFkT0lEKCk7XG5cdFx0aWYgKG1ldGhvZCAhPT0gT0lEX1BCRVMyKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQRU0vUEtDUzggZW5jcnlwdGlvbiAnICtcblx0XHRcdCAgICAnc2NoZW1lOiAnICsgbWV0aG9kKSk7XG5cdFx0fVxuXG5cdFx0ZWRlci5yZWFkU2VxdWVuY2UoKTtcdC8qIFBCRVMyLXBhcmFtcyAqL1xuXG5cdFx0ZWRlci5yZWFkU2VxdWVuY2UoKTtcdC8qIGtleURlcml2YXRpb25GdW5jICovXG5cdFx0dmFyIGtkZkVuZCA9IGVkZXIub2Zmc2V0ICsgZWRlci5sZW5ndGg7XG5cdFx0dmFyIGtkZk9pZCA9IGVkZXIucmVhZE9JRCgpO1xuXHRcdGlmIChrZGZPaWQgIT09IE9JRF9QQktERjIpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBQQkVTMiBLREY6ICcgKyBrZGZPaWQpKTtcblx0XHRlZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdHZhciBzYWx0ID0gZWRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKTtcblx0XHR2YXIgaXRlcmF0aW9ucyA9IGVkZXIucmVhZEludCgpO1xuXHRcdHZhciBoYXNoQWxnID0gJ3NoYTEnO1xuXHRcdGlmIChlZGVyLm9mZnNldCA8IGtkZkVuZCkge1xuXHRcdFx0ZWRlci5yZWFkU2VxdWVuY2UoKTtcblx0XHRcdHZhciBoYXNoQWxnT2lkID0gZWRlci5yZWFkT0lEKCk7XG5cdFx0XHRoYXNoQWxnID0gT0lEX1RPX0hBU0hbaGFzaEFsZ09pZF07XG5cdFx0XHRpZiAoaGFzaEFsZyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFBCS0RGMiBoYXNoOiAnICtcblx0XHRcdFx0ICAgIGhhc2hBbGdPaWQpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWRlci5fb2Zmc2V0ID0ga2RmRW5kO1xuXG5cdFx0ZWRlci5yZWFkU2VxdWVuY2UoKTtcdC8qIGVuY3J5cHRpb25TY2hlbWUgKi9cblx0XHR2YXIgY2lwaGVyT2lkID0gZWRlci5yZWFkT0lEKCk7XG5cdFx0Y2lwaGVyID0gT0lEX1RPX0NJUEhFUltjaXBoZXJPaWRdO1xuXHRcdGlmIChjaXBoZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgUEJFUzIgY2lwaGVyOiAnICtcblx0XHRcdCAgICBjaXBoZXJPaWQpKTtcblx0XHR9XG5cdFx0aXYgPSBlZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpO1xuXG5cdFx0ZWRlci5fb2Zmc2V0ID0gcGJlc0VuZDtcblx0XHRidWYgPSBlZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpO1xuXG5cdFx0aWYgKHR5cGVvZiAob3B0aW9ucy5wYXNzcGhyYXNlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdG9wdGlvbnMucGFzc3BocmFzZSA9IEJ1ZmZlci5mcm9tKFxuXHRcdFx0ICAgIG9wdGlvbnMucGFzc3BocmFzZSwgJ3V0Zi04Jyk7XG5cdFx0fVxuXHRcdGlmICghQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMucGFzc3BocmFzZSkpIHtcblx0XHRcdHRocm93IChuZXcgZXJyb3JzLktleUVuY3J5cHRlZEVycm9yKFxuXHRcdFx0ICAgIG9wdGlvbnMuZmlsZW5hbWUsICdQRU0nKSk7XG5cdFx0fVxuXG5cdFx0dmFyIGNpbmZvID0gdXRpbHMub3BlbnNzaENpcGhlckluZm8oY2lwaGVyKTtcblxuXHRcdGNpcGhlciA9IGNpbmZvLm9wZW5zc2xOYW1lO1xuXHRcdGtleSA9IHV0aWxzLnBia2RmMihoYXNoQWxnLCBzYWx0LCBpdGVyYXRpb25zLCBjaW5mby5rZXlTaXplLFxuXHRcdCAgICBvcHRpb25zLnBhc3NwaHJhc2UpO1xuXHRcdGFsZyA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmIChjaXBoZXIgJiYga2V5ICYmIGl2KSB7XG5cdFx0dmFyIGNpcGhlclN0cmVhbSA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGNpcGhlciwga2V5LCBpdik7XG5cdFx0dmFyIGNodW5rLCBjaHVua3MgPSBbXTtcblx0XHRjaXBoZXJTdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0aWYgKGUudG9TdHJpbmcoKS5pbmRleE9mKCdiYWQgZGVjcnlwdCcpICE9PSAtMSkge1xuXHRcdFx0XHR0aHJvdyAobmV3IEVycm9yKCdJbmNvcnJlY3QgcGFzc3BocmFzZSAnICtcblx0XHRcdFx0ICAgICdzdXBwbGllZCwgY291bGQgbm90IGRlY3J5cHQga2V5JykpO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgKGUpO1xuXHRcdH0pO1xuXHRcdGNpcGhlclN0cmVhbS53cml0ZShidWYpO1xuXHRcdGNpcGhlclN0cmVhbS5lbmQoKTtcblx0XHR3aGlsZSAoKGNodW5rID0gY2lwaGVyU3RyZWFtLnJlYWQoKSkgIT09IG51bGwpXG5cdFx0XHRjaHVua3MucHVzaChjaHVuayk7XG5cdFx0YnVmID0gQnVmZmVyLmNvbmNhdChjaHVua3MpO1xuXHR9XG5cblx0LyogVGhlIG5ldyBPcGVuU1NIIGludGVybmFsIGZvcm1hdCBhYnVzZXMgUEVNIGhlYWRlcnMgKi9cblx0aWYgKGFsZyAmJiBhbGcudG9Mb3dlckNhc2UoKSA9PT0gJ29wZW5zc2gnKVxuXHRcdHJldHVybiAoc3NocHJpdi5yZWFkU1NIUHJpdmF0ZSh0eXBlLCBidWYsIG9wdGlvbnMpKTtcblx0aWYgKGFsZyAmJiBhbGcudG9Mb3dlckNhc2UoKSA9PT0gJ3NzaDInKVxuXHRcdHJldHVybiAocmZjNDI1My5yZWFkVHlwZSh0eXBlLCBidWYsIG9wdGlvbnMpKTtcblxuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyUmVhZGVyKGJ1Zik7XG5cdGRlci5vcmlnaW5hbElucHV0ID0gaW5wdXQ7XG5cblx0Lypcblx0ICogQWxsIG9mIHRoZSBQRU0gZmlsZSB0eXBlcyBzdGFydCB3aXRoIGEgc2VxdWVuY2UgdGFnLCBzbyBjaG9wIGl0XG5cdCAqIG9mZiBoZXJlXG5cdCAqL1xuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cblx0LyogUEtDUyMxIHR5cGUga2V5cyBuYW1lIGFuIGFsZ29yaXRobSBpbiB0aGUgYmFubmVyIGV4cGxpY2l0bHkgKi9cblx0aWYgKGFsZykge1xuXHRcdGlmIChmb3JjZVR5cGUpXG5cdFx0XHRhc3NlcnQuc3RyaWN0RXF1YWwoZm9yY2VUeXBlLCAncGtjczEnKTtcblx0XHRyZXR1cm4gKHBrY3MxLnJlYWRQa2NzMShhbGcsIHR5cGUsIGRlcikpO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChmb3JjZVR5cGUpXG5cdFx0XHRhc3NlcnQuc3RyaWN0RXF1YWwoZm9yY2VUeXBlLCAncGtjczgnKTtcblx0XHRyZXR1cm4gKHBrY3M4LnJlYWRQa2NzOChhbGcsIHR5cGUsIGRlcikpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgb3B0aW9ucywgdHlwZSkge1xuXHRhc3NlcnQub2JqZWN0KGtleSk7XG5cblx0dmFyIGFsZyA9IHtcblx0ICAgICdlY2RzYSc6ICdFQycsXG5cdCAgICAncnNhJzogJ1JTQScsXG5cdCAgICAnZHNhJzogJ0RTQScsXG5cdCAgICAnZWQyNTUxOSc6ICdFZERTQSdcblx0fVtrZXkudHlwZV07XG5cdHZhciBoZWFkZXI7XG5cblx0dmFyIGRlciA9IG5ldyBhc24xLkJlcldyaXRlcigpO1xuXG5cdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKSB7XG5cdFx0aWYgKHR5cGUgJiYgdHlwZSA9PT0gJ3BrY3M4Jykge1xuXHRcdFx0aGVhZGVyID0gJ1BSSVZBVEUgS0VZJztcblx0XHRcdHBrY3M4LndyaXRlUGtjczgoZGVyLCBrZXkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZSlcblx0XHRcdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHR5cGUsICdwa2NzMScpO1xuXHRcdFx0aGVhZGVyID0gYWxnICsgJyBQUklWQVRFIEtFWSc7XG5cdFx0XHRwa2NzMS53cml0ZVBrY3MxKGRlciwga2V5KTtcblx0XHR9XG5cblx0fSBlbHNlIGlmIChLZXkuaXNLZXkoa2V5KSkge1xuXHRcdGlmICh0eXBlICYmIHR5cGUgPT09ICdwa2NzMScpIHtcblx0XHRcdGhlYWRlciA9IGFsZyArICcgUFVCTElDIEtFWSc7XG5cdFx0XHRwa2NzMS53cml0ZVBrY3MxKGRlciwga2V5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGUpXG5cdFx0XHRcdGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlLCAncGtjczgnKTtcblx0XHRcdGhlYWRlciA9ICdQVUJMSUMgS0VZJztcblx0XHRcdHBrY3M4LndyaXRlUGtjczgoZGVyLCBrZXkpO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ2tleSBpcyBub3QgYSBLZXkgb3IgUHJpdmF0ZUtleScpKTtcblx0fVxuXG5cdHZhciB0bXAgPSBkZXIuYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKTtcblx0dmFyIGxlbiA9IHRtcC5sZW5ndGggKyAodG1wLmxlbmd0aCAvIDY0KSArXG5cdCAgICAxOCArIDE2ICsgaGVhZGVyLmxlbmd0aCoyICsgMTA7XG5cdHZhciBidWYgPSBCdWZmZXIuYWxsb2MobGVuKTtcblx0dmFyIG8gPSAwO1xuXHRvICs9IGJ1Zi53cml0ZSgnLS0tLS1CRUdJTiAnICsgaGVhZGVyICsgJy0tLS0tXFxuJywgbyk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKSB7XG5cdFx0dmFyIGxpbWl0ID0gaSArIDY0O1xuXHRcdGlmIChsaW1pdCA+IHRtcC5sZW5ndGgpXG5cdFx0XHRsaW1pdCA9IHRtcC5sZW5ndGg7XG5cdFx0byArPSBidWYud3JpdGUodG1wLnNsaWNlKGksIGxpbWl0KSwgbyk7XG5cdFx0YnVmW28rK10gPSAxMDtcblx0XHRpID0gbGltaXQ7XG5cdH1cblx0byArPSBidWYud3JpdGUoJy0tLS0tRU5EICcgKyBoZWFkZXIgKyAnLS0tLS1cXG4nLCBvKTtcblxuXHRyZXR1cm4gKGJ1Zi5zbGljZSgwLCBvKSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAxNSBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJlYWQ6IHJlYWQsXG5cdHJlYWRQa2NzMTogcmVhZFBrY3MxLFxuXHR3cml0ZTogd3JpdGUsXG5cdHdyaXRlUGtjczE6IHdyaXRlUGtjczFcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuLi9hbGdzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG52YXIgcGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcblxudmFyIHBrY3M4ID0gcmVxdWlyZSgnLi9wa2NzOCcpO1xudmFyIHJlYWRFQ0RTQUN1cnZlID0gcGtjczgucmVhZEVDRFNBQ3VydmU7XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdHJldHVybiAocGVtLnJlYWQoYnVmLCBvcHRpb25zLCAncGtjczEnKSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKHBlbS53cml0ZShrZXksIG9wdGlvbnMsICdwa2NzMScpKTtcbn1cblxuLyogSGVscGVyIHRvIHJlYWQgaW4gYSBzaW5nbGUgbXBpbnQgKi9cbmZ1bmN0aW9uIHJlYWRNUEludChkZXIsIG5tKSB7XG5cdGFzc2VydC5zdHJpY3RFcXVhbChkZXIucGVlaygpLCBhc24xLkJlci5JbnRlZ2VyLFxuXHQgICAgbm0gKyAnIGlzIG5vdCBhbiBJbnRlZ2VyJyk7XG5cdHJldHVybiAodXRpbHMubXBOb3JtYWxpemUoZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3MxKGFsZywgdHlwZSwgZGVyKSB7XG5cdHN3aXRjaCAoYWxnKSB7XG5cdGNhc2UgJ1JTQSc6XG5cdFx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczFSU0FQdWJsaWMoZGVyKSk7XG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gJ3ByaXZhdGUnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczFSU0FQcml2YXRlKGRlcikpO1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24ga2V5IHR5cGU6ICcgKyB0eXBlKSk7XG5cdGNhc2UgJ0RTQSc6XG5cdFx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczFEU0FQdWJsaWMoZGVyKSk7XG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gJ3ByaXZhdGUnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczFEU0FQcml2YXRlKGRlcikpO1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24ga2V5IHR5cGU6ICcgKyB0eXBlKSk7XG5cdGNhc2UgJ0VDJzpcblx0Y2FzZSAnRUNEU0EnOlxuXHRcdGlmICh0eXBlID09PSAncHJpdmF0ZScpXG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzMUVDRFNBUHJpdmF0ZShkZXIpKTtcblx0XHRlbHNlIGlmICh0eXBlID09PSAncHVibGljJylcblx0XHRcdHJldHVybiAocmVhZFBrY3MxRUNEU0FQdWJsaWMoZGVyKSk7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBrZXkgdHlwZTogJyArIHR5cGUpKTtcblx0Y2FzZSAnRUREU0EnOlxuXHRjYXNlICdFZERTQSc6XG5cdFx0aWYgKHR5cGUgPT09ICdwcml2YXRlJylcblx0XHRcdHJldHVybiAocmVhZFBrY3MxRWREU0FQcml2YXRlKGRlcikpO1xuXHRcdHRocm93IChuZXcgRXJyb3IodHlwZSArICcga2V5cyBub3Qgc3VwcG9ydGVkIHdpdGggRWREU0EnKSk7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBrZXkgYWxnbzogJyArIGFsZykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzMVJTQVB1YmxpYyhkZXIpIHtcblx0Ly8gbW9kdWx1cyBhbmQgZXhwb25lbnRcblx0dmFyIG4gPSByZWFkTVBJbnQoZGVyLCAnbW9kdWx1cycpO1xuXHR2YXIgZSA9IHJlYWRNUEludChkZXIsICdleHBvbmVudCcpO1xuXG5cdC8vIG5vdywgbWFrZSB0aGUga2V5XG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ3JzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ2UnLCBkYXRhOiBlIH0sXG5cdFx0XHR7IG5hbWU6ICduJywgZGF0YTogbiB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3MxUlNBUHJpdmF0ZShkZXIpIHtcblx0dmFyIHZlcnNpb24gPSByZWFkTVBJbnQoZGVyLCAndmVyc2lvbicpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwodmVyc2lvblswXSwgMCk7XG5cblx0Ly8gbW9kdWx1cyB0aGVuIHB1YmxpYyBleHBvbmVudFxuXHR2YXIgbiA9IHJlYWRNUEludChkZXIsICdtb2R1bHVzJyk7XG5cdHZhciBlID0gcmVhZE1QSW50KGRlciwgJ3B1YmxpYyBleHBvbmVudCcpO1xuXHR2YXIgZCA9IHJlYWRNUEludChkZXIsICdwcml2YXRlIGV4cG9uZW50Jyk7XG5cdHZhciBwID0gcmVhZE1QSW50KGRlciwgJ3ByaW1lMScpO1xuXHR2YXIgcSA9IHJlYWRNUEludChkZXIsICdwcmltZTInKTtcblx0dmFyIGRtb2RwID0gcmVhZE1QSW50KGRlciwgJ2V4cG9uZW50MScpO1xuXHR2YXIgZG1vZHEgPSByZWFkTVBJbnQoZGVyLCAnZXhwb25lbnQyJyk7XG5cdHZhciBpcW1wID0gcmVhZE1QSW50KGRlciwgJ2lxbXAnKTtcblxuXHQvLyBub3csIG1ha2UgdGhlIGtleVxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdyc2EnLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICduJywgZGF0YTogbiB9LFxuXHRcdFx0eyBuYW1lOiAnZScsIGRhdGE6IGUgfSxcblx0XHRcdHsgbmFtZTogJ2QnLCBkYXRhOiBkIH0sXG5cdFx0XHR7IG5hbWU6ICdpcW1wJywgZGF0YTogaXFtcCB9LFxuXHRcdFx0eyBuYW1lOiAncCcsIGRhdGE6IHAgfSxcblx0XHRcdHsgbmFtZTogJ3EnLCBkYXRhOiBxIH0sXG5cdFx0XHR7IG5hbWU6ICdkbW9kcCcsIGRhdGE6IGRtb2RwIH0sXG5cdFx0XHR7IG5hbWU6ICdkbW9kcScsIGRhdGE6IGRtb2RxIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3MxRFNBUHJpdmF0ZShkZXIpIHtcblx0dmFyIHZlcnNpb24gPSByZWFkTVBJbnQoZGVyLCAndmVyc2lvbicpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwodmVyc2lvbi5yZWFkVUludDgoMCksIDApO1xuXG5cdHZhciBwID0gcmVhZE1QSW50KGRlciwgJ3AnKTtcblx0dmFyIHEgPSByZWFkTVBJbnQoZGVyLCAncScpO1xuXHR2YXIgZyA9IHJlYWRNUEludChkZXIsICdnJyk7XG5cdHZhciB5ID0gcmVhZE1QSW50KGRlciwgJ3knKTtcblx0dmFyIHggPSByZWFkTVBJbnQoZGVyLCAneCcpO1xuXG5cdC8vIG5vdywgbWFrZSB0aGUga2V5XG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2RzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ3AnLCBkYXRhOiBwIH0sXG5cdFx0XHR7IG5hbWU6ICdxJywgZGF0YTogcSB9LFxuXHRcdFx0eyBuYW1lOiAnZycsIGRhdGE6IGcgfSxcblx0XHRcdHsgbmFtZTogJ3knLCBkYXRhOiB5IH0sXG5cdFx0XHR7IG5hbWU6ICd4JywgZGF0YTogeCB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IFByaXZhdGVLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzMUVkRFNBUHJpdmF0ZShkZXIpIHtcblx0dmFyIHZlcnNpb24gPSByZWFkTVBJbnQoZGVyLCAndmVyc2lvbicpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwodmVyc2lvbi5yZWFkVUludDgoMCksIDEpO1xuXG5cdC8vIHByaXZhdGUga2V5XG5cdHZhciBrID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpO1xuXG5cdGRlci5yZWFkU2VxdWVuY2UoMHhhMCk7XG5cdHZhciBvaWQgPSBkZXIucmVhZE9JRCgpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwob2lkLCAnMS4zLjEwMS4xMTInLCAndGhlIGVkMjU1MTkgY3VydmUgaWRlbnRpZmllcicpO1xuXG5cdGRlci5yZWFkU2VxdWVuY2UoMHhhMSk7XG5cdHZhciBBID0gdXRpbHMucmVhZEJpdFN0cmluZyhkZXIpO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2VkMjU1MTknLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdBJywgZGF0YTogdXRpbHMuemVyb1BhZFRvTGVuZ3RoKEEsIDMyKSB9LFxuXHRcdFx0eyBuYW1lOiAnaycsIGRhdGE6IGsgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczFEU0FQdWJsaWMoZGVyKSB7XG5cdHZhciB5ID0gcmVhZE1QSW50KGRlciwgJ3knKTtcblx0dmFyIHAgPSByZWFkTVBJbnQoZGVyLCAncCcpO1xuXHR2YXIgcSA9IHJlYWRNUEludChkZXIsICdxJyk7XG5cdHZhciBnID0gcmVhZE1QSW50KGRlciwgJ2cnKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdkc2EnLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICd5JywgZGF0YTogeSB9LFxuXHRcdFx0eyBuYW1lOiAncCcsIGRhdGE6IHAgfSxcblx0XHRcdHsgbmFtZTogJ3EnLCBkYXRhOiBxIH0sXG5cdFx0XHR7IG5hbWU6ICdnJywgZGF0YTogZyB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3MxRUNEU0FQdWJsaWMoZGVyKSB7XG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblxuXHR2YXIgb2lkID0gZGVyLnJlYWRPSUQoKTtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKG9pZCwgJzEuMi44NDAuMTAwNDUuMi4xJywgJ211c3QgYmUgZWNQdWJsaWNLZXknKTtcblxuXHR2YXIgY3VydmVPaWQgPSBkZXIucmVhZE9JRCgpO1xuXG5cdHZhciBjdXJ2ZTtcblx0dmFyIGN1cnZlcyA9IE9iamVjdC5rZXlzKGFsZ3MuY3VydmVzKTtcblx0Zm9yICh2YXIgaiA9IDA7IGogPCBjdXJ2ZXMubGVuZ3RoOyArK2opIHtcblx0XHR2YXIgYyA9IGN1cnZlc1tqXTtcblx0XHR2YXIgY2QgPSBhbGdzLmN1cnZlc1tjXTtcblx0XHRpZiAoY2QucGtjczhvaWQgPT09IGN1cnZlT2lkKSB7XG5cdFx0XHRjdXJ2ZSA9IGM7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblx0YXNzZXJ0LnN0cmluZyhjdXJ2ZSwgJ2Ega25vd24gRUNEU0EgbmFtZWQgY3VydmUnKTtcblxuXHR2YXIgUSA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkJpdFN0cmluZywgdHJ1ZSk7XG5cdFEgPSB1dGlscy5lY05vcm1hbGl6ZShRKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdlY2RzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ2N1cnZlJywgZGF0YTogQnVmZmVyLmZyb20oY3VydmUpIH0sXG5cdFx0XHR7IG5hbWU6ICdRJywgZGF0YTogUSB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3MxRUNEU0FQcml2YXRlKGRlcikge1xuXHR2YXIgdmVyc2lvbiA9IHJlYWRNUEludChkZXIsICd2ZXJzaW9uJyk7XG5cdGFzc2VydC5zdHJpY3RFcXVhbCh2ZXJzaW9uLnJlYWRVSW50OCgwKSwgMSk7XG5cblx0Ly8gcHJpdmF0ZSBrZXlcblx0dmFyIGQgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZSgweGEwKTtcblx0dmFyIGN1cnZlID0gcmVhZEVDRFNBQ3VydmUoZGVyKTtcblx0YXNzZXJ0LnN0cmluZyhjdXJ2ZSwgJ2Ega25vd24gZWxsaXB0aWMgY3VydmUnKTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKDB4YTEpO1xuXHR2YXIgUSA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkJpdFN0cmluZywgdHJ1ZSk7XG5cdFEgPSB1dGlscy5lY05vcm1hbGl6ZShRKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdlY2RzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ2N1cnZlJywgZGF0YTogQnVmZmVyLmZyb20oY3VydmUpIH0sXG5cdFx0XHR7IG5hbWU6ICdRJywgZGF0YTogUSB9LFxuXHRcdFx0eyBuYW1lOiAnZCcsIGRhdGE6IGQgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3MxKGRlciwga2V5KSB7XG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cblx0c3dpdGNoIChrZXkudHlwZSkge1xuXHRjYXNlICdyc2EnOlxuXHRcdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdFx0d3JpdGVQa2NzMVJTQVByaXZhdGUoZGVyLCBrZXkpO1xuXHRcdGVsc2Vcblx0XHRcdHdyaXRlUGtjczFSU0FQdWJsaWMoZGVyLCBrZXkpO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdkc2EnOlxuXHRcdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdFx0d3JpdGVQa2NzMURTQVByaXZhdGUoZGVyLCBrZXkpO1xuXHRcdGVsc2Vcblx0XHRcdHdyaXRlUGtjczFEU0FQdWJsaWMoZGVyLCBrZXkpO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdlY2RzYSc6XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR3cml0ZVBrY3MxRUNEU0FQcml2YXRlKGRlciwga2V5KTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZVBrY3MxRUNEU0FQdWJsaWMoZGVyLCBrZXkpO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdlZDI1NTE5Jzpcblx0XHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRcdHdyaXRlUGtjczFFZERTQVByaXZhdGUoZGVyLCBrZXkpO1xuXHRcdGVsc2Vcblx0XHRcdHdyaXRlUGtjczFFZERTQVB1YmxpYyhkZXIsIGtleSk7XG5cdFx0YnJlYWs7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBrZXkgYWxnbzogJyArIGtleS50eXBlKSk7XG5cdH1cblxuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzMVJTQVB1YmxpYyhkZXIsIGtleSkge1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQubi5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmUuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczFSU0FQcml2YXRlKGRlciwga2V5KSB7XG5cdHZhciB2ZXIgPSBCdWZmZXIuZnJvbShbMF0pO1xuXHRkZXIud3JpdGVCdWZmZXIodmVyLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQubi5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmUuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5kLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnEuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGlmICgha2V5LnBhcnQuZG1vZHAgfHwgIWtleS5wYXJ0LmRtb2RxKVxuXHRcdHV0aWxzLmFkZFJTQU1pc3Npbmcoa2V5KTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmRtb2RwLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZG1vZHEuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5pcW1wLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3MxRFNBUHJpdmF0ZShkZXIsIGtleSkge1xuXHR2YXIgdmVyID0gQnVmZmVyLmZyb20oWzBdKTtcblx0ZGVyLndyaXRlQnVmZmVyKHZlciwgYXNuMS5CZXIuSW50ZWdlcik7XG5cblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnAuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5xLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZy5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnkuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC54LmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3MxRFNBUHVibGljKGRlciwga2V5KSB7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC55LmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnEuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5nLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3MxRUNEU0FQdWJsaWMoZGVyLCBrZXkpIHtcblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblxuXHRkZXIud3JpdGVPSUQoJzEuMi44NDAuMTAwNDUuMi4xJyk7IC8qIGVjUHVibGljS2V5ICovXG5cdHZhciBjdXJ2ZSA9IGtleS5wYXJ0LmN1cnZlLmRhdGEudG9TdHJpbmcoKTtcblx0dmFyIGN1cnZlT2lkID0gYWxncy5jdXJ2ZXNbY3VydmVdLnBrY3M4b2lkO1xuXHRhc3NlcnQuc3RyaW5nKGN1cnZlT2lkLCAnYSBrbm93biBFQ0RTQSBuYW1lZCBjdXJ2ZScpO1xuXHRkZXIud3JpdGVPSUQoY3VydmVPaWQpO1xuXG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdHZhciBRID0gdXRpbHMuZWNOb3JtYWxpemUoa2V5LnBhcnQuUS5kYXRhLCB0cnVlKTtcblx0ZGVyLndyaXRlQnVmZmVyKFEsIGFzbjEuQmVyLkJpdFN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczFFQ0RTQVByaXZhdGUoZGVyLCBrZXkpIHtcblx0dmFyIHZlciA9IEJ1ZmZlci5mcm9tKFsxXSk7XG5cdGRlci53cml0ZUJ1ZmZlcih2ZXIsIGFzbjEuQmVyLkludGVnZXIpO1xuXG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5kLmRhdGEsIGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgweGEwKTtcblx0dmFyIGN1cnZlID0ga2V5LnBhcnQuY3VydmUuZGF0YS50b1N0cmluZygpO1xuXHR2YXIgY3VydmVPaWQgPSBhbGdzLmN1cnZlc1tjdXJ2ZV0ucGtjczhvaWQ7XG5cdGFzc2VydC5zdHJpbmcoY3VydmVPaWQsICdhIGtub3duIEVDRFNBIG5hbWVkIGN1cnZlJyk7XG5cdGRlci53cml0ZU9JRChjdXJ2ZU9pZCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKDB4YTEpO1xuXHR2YXIgUSA9IHV0aWxzLmVjTm9ybWFsaXplKGtleS5wYXJ0LlEuZGF0YSwgdHJ1ZSk7XG5cdGRlci53cml0ZUJ1ZmZlcihRLCBhc24xLkJlci5CaXRTdHJpbmcpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzMUVkRFNBUHJpdmF0ZShkZXIsIGtleSkge1xuXHR2YXIgdmVyID0gQnVmZmVyLmZyb20oWzFdKTtcblx0ZGVyLndyaXRlQnVmZmVyKHZlciwgYXNuMS5CZXIuSW50ZWdlcik7XG5cblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmsuZGF0YSwgYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKDB4YTApO1xuXHRkZXIud3JpdGVPSUQoJzEuMy4xMDEuMTEyJyk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKDB4YTEpO1xuXHR1dGlscy53cml0ZUJpdFN0cmluZyhkZXIsIGtleS5wYXJ0LkEuZGF0YSk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3MxRWREU0FQdWJsaWMoZGVyLCBrZXkpIHtcblx0dGhyb3cgKG5ldyBFcnJvcignUHVibGljIGtleXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIEVkRFNBIFBLQ1MjMScpKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDE4IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0cmVhZFBrY3M4OiByZWFkUGtjczgsXG5cdHdyaXRlOiB3cml0ZSxcblx0d3JpdGVQa2NzODogd3JpdGVQa2NzOCxcblx0cGtjczhUb0J1ZmZlcjogcGtjczhUb0J1ZmZlcixcblxuXHRyZWFkRUNEU0FDdXJ2ZTogcmVhZEVDRFNBQ3VydmUsXG5cdHdyaXRlRUNEU0FDdXJ2ZTogd3JpdGVFQ0RTQUN1cnZlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi4vYWxncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcbnZhciBwZW0gPSByZXF1aXJlKCcuL3BlbScpO1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRyZXR1cm4gKHBlbS5yZWFkKGJ1Ziwgb3B0aW9ucywgJ3BrY3M4JykpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0cmV0dXJuIChwZW0ud3JpdGUoa2V5LCBvcHRpb25zLCAncGtjczgnKSk7XG59XG5cbi8qIEhlbHBlciB0byByZWFkIGluIGEgc2luZ2xlIG1waW50ICovXG5mdW5jdGlvbiByZWFkTVBJbnQoZGVyLCBubSkge1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwoZGVyLnBlZWsoKSwgYXNuMS5CZXIuSW50ZWdlcixcblx0ICAgIG5tICsgJyBpcyBub3QgYW4gSW50ZWdlcicpO1xuXHRyZXR1cm4gKHV0aWxzLm1wTm9ybWFsaXplKGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpKSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOChhbGcsIHR5cGUsIGRlcikge1xuXHQvKiBQcml2YXRlIGtleXMgaW4gcGtjcyM4IGZvcm1hdCBoYXZlIGEgd2VpcmQgZXh0cmEgaW50ICovXG5cdGlmIChkZXIucGVlaygpID09PSBhc24xLkJlci5JbnRlZ2VyKSB7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHR5cGUsICdwcml2YXRlJyxcblx0XHQgICAgJ3VuZXhwZWN0ZWQgSW50ZWdlciBhdCBzdGFydCBvZiBwdWJsaWMga2V5Jyk7XG5cdFx0ZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSk7XG5cdH1cblxuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdHZhciBuZXh0ID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cblx0dmFyIG9pZCA9IGRlci5yZWFkT0lEKCk7XG5cdHN3aXRjaCAob2lkKSB7XG5cdGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xJzpcblx0XHRkZXIuX29mZnNldCA9IG5leHQ7XG5cdFx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhSU0FQdWJsaWMoZGVyKSk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhSU0FQcml2YXRlKGRlcikpO1xuXHRjYXNlICcxLjIuODQwLjEwMDQwLjQuMSc6XG5cdFx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhEU0FQdWJsaWMoZGVyKSk7XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhEU0FQcml2YXRlKGRlcikpO1xuXHRjYXNlICcxLjIuODQwLjEwMDQ1LjIuMSc6XG5cdFx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKVxuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhFQ0RTQVB1YmxpYyhkZXIpKTtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzOEVDRFNBUHJpdmF0ZShkZXIpKTtcblx0Y2FzZSAnMS4zLjEwMS4xMTInOlxuXHRcdGlmICh0eXBlID09PSAncHVibGljJykge1xuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhFZERTQVB1YmxpYyhkZXIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhFZERTQVByaXZhdGUoZGVyKSk7XG5cdFx0fVxuXHRjYXNlICcxLjMuMTAxLjExMCc6XG5cdFx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKSB7XG5cdFx0XHRyZXR1cm4gKHJlYWRQa2NzOFgyNTUxOVB1YmxpYyhkZXIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChyZWFkUGtjczhYMjU1MTlQcml2YXRlKGRlcikpO1xuXHRcdH1cblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIGtleSB0eXBlIE9JRCAnICsgb2lkKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4UlNBUHVibGljKGRlcikge1xuXHQvLyBiaXQgc3RyaW5nIHNlcXVlbmNlXG5cdGRlci5yZWFkU2VxdWVuY2UoYXNuMS5CZXIuQml0U3RyaW5nKTtcblx0ZGVyLnJlYWRCeXRlKCk7XG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblxuXHQvLyBtb2R1bHVzXG5cdHZhciBuID0gcmVhZE1QSW50KGRlciwgJ21vZHVsdXMnKTtcblx0dmFyIGUgPSByZWFkTVBJbnQoZGVyLCAnZXhwb25lbnQnKTtcblxuXHQvLyBub3csIG1ha2UgdGhlIGtleVxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdyc2EnLFxuXHRcdHNvdXJjZTogZGVyLm9yaWdpbmFsSW5wdXQsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ2UnLCBkYXRhOiBlIH0sXG5cdFx0XHR7IG5hbWU6ICduJywgZGF0YTogbiB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4UlNBUHJpdmF0ZShkZXIpIHtcblx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblxuXHR2YXIgdmVyID0gcmVhZE1QSW50KGRlciwgJ3ZlcnNpb24nKTtcblx0YXNzZXJ0LmVxdWFsKHZlclswXSwgMHgwLCAndW5rbm93biBSU0EgcHJpdmF0ZSBrZXkgdmVyc2lvbicpO1xuXG5cdC8vIG1vZHVsdXMgdGhlbiBwdWJsaWMgZXhwb25lbnRcblx0dmFyIG4gPSByZWFkTVBJbnQoZGVyLCAnbW9kdWx1cycpO1xuXHR2YXIgZSA9IHJlYWRNUEludChkZXIsICdwdWJsaWMgZXhwb25lbnQnKTtcblx0dmFyIGQgPSByZWFkTVBJbnQoZGVyLCAncHJpdmF0ZSBleHBvbmVudCcpO1xuXHR2YXIgcCA9IHJlYWRNUEludChkZXIsICdwcmltZTEnKTtcblx0dmFyIHEgPSByZWFkTVBJbnQoZGVyLCAncHJpbWUyJyk7XG5cdHZhciBkbW9kcCA9IHJlYWRNUEludChkZXIsICdleHBvbmVudDEnKTtcblx0dmFyIGRtb2RxID0gcmVhZE1QSW50KGRlciwgJ2V4cG9uZW50MicpO1xuXHR2YXIgaXFtcCA9IHJlYWRNUEludChkZXIsICdpcW1wJyk7XG5cblx0Ly8gbm93LCBtYWtlIHRoZSBrZXlcblx0dmFyIGtleSA9IHtcblx0XHR0eXBlOiAncnNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnbicsIGRhdGE6IG4gfSxcblx0XHRcdHsgbmFtZTogJ2UnLCBkYXRhOiBlIH0sXG5cdFx0XHR7IG5hbWU6ICdkJywgZGF0YTogZCB9LFxuXHRcdFx0eyBuYW1lOiAnaXFtcCcsIGRhdGE6IGlxbXAgfSxcblx0XHRcdHsgbmFtZTogJ3AnLCBkYXRhOiBwIH0sXG5cdFx0XHR7IG5hbWU6ICdxJywgZGF0YTogcSB9LFxuXHRcdFx0eyBuYW1lOiAnZG1vZHAnLCBkYXRhOiBkbW9kcCB9LFxuXHRcdFx0eyBuYW1lOiAnZG1vZHEnLCBkYXRhOiBkbW9kcSB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IFByaXZhdGVLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOERTQVB1YmxpYyhkZXIpIHtcblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG5cdHZhciBwID0gcmVhZE1QSW50KGRlciwgJ3AnKTtcblx0dmFyIHEgPSByZWFkTVBJbnQoZGVyLCAncScpO1xuXHR2YXIgZyA9IHJlYWRNUEludChkZXIsICdnJyk7XG5cblx0Ly8gYml0IHN0cmluZyBzZXF1ZW5jZVxuXHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdGRlci5yZWFkQnl0ZSgpO1xuXG5cdHZhciB5ID0gcmVhZE1QSW50KGRlciwgJ3knKTtcblxuXHQvLyBub3csIG1ha2UgdGhlIGtleVxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdkc2EnLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdwJywgZGF0YTogcCB9LFxuXHRcdFx0eyBuYW1lOiAncScsIGRhdGE6IHEgfSxcblx0XHRcdHsgbmFtZTogJ2cnLCBkYXRhOiBnIH0sXG5cdFx0XHR7IG5hbWU6ICd5JywgZGF0YTogeSB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4RFNBUHJpdmF0ZShkZXIpIHtcblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG5cdHZhciBwID0gcmVhZE1QSW50KGRlciwgJ3AnKTtcblx0dmFyIHEgPSByZWFkTVBJbnQoZGVyLCAncScpO1xuXHR2YXIgZyA9IHJlYWRNUEludChkZXIsICdnJyk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdHZhciB4ID0gcmVhZE1QSW50KGRlciwgJ3gnKTtcblxuXHQvKiBUaGUgcGtjcyM4IGZvcm1hdCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBwdWJsaWMga2V5ICovXG5cdHZhciB5ID0gdXRpbHMuY2FsY3VsYXRlRFNBUHVibGljKGcsIHAsIHgpO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2RzYScsXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgbmFtZTogJ3AnLCBkYXRhOiBwIH0sXG5cdFx0XHR7IG5hbWU6ICdxJywgZGF0YTogcSB9LFxuXHRcdFx0eyBuYW1lOiAnZycsIGRhdGE6IGcgfSxcblx0XHRcdHsgbmFtZTogJ3knLCBkYXRhOiB5IH0sXG5cdFx0XHR7IG5hbWU6ICd4JywgZGF0YTogeCB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IFByaXZhdGVLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRFQ0RTQUN1cnZlKGRlcikge1xuXHR2YXIgY3VydmVOYW1lLCBjdXJ2ZU5hbWVzO1xuXHR2YXIgaiwgYywgY2Q7XG5cblx0aWYgKGRlci5wZWVrKCkgPT09IGFzbjEuQmVyLk9JRCkge1xuXHRcdHZhciBvaWQgPSBkZXIucmVhZE9JRCgpO1xuXG5cdFx0Y3VydmVOYW1lcyA9IE9iamVjdC5rZXlzKGFsZ3MuY3VydmVzKTtcblx0XHRmb3IgKGogPSAwOyBqIDwgY3VydmVOYW1lcy5sZW5ndGg7ICsraikge1xuXHRcdFx0YyA9IGN1cnZlTmFtZXNbal07XG5cdFx0XHRjZCA9IGFsZ3MuY3VydmVzW2NdO1xuXHRcdFx0aWYgKGNkLnBrY3M4b2lkID09PSBvaWQpIHtcblx0XHRcdFx0Y3VydmVOYW1lID0gYztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cdFx0Ly8gRUNQYXJhbWV0ZXJzIHNlcXVlbmNlXG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdHZhciB2ZXJzaW9uID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSk7XG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKHZlcnNpb25bMF0sIDEsICdFQ0RTQSBrZXkgbm90IHZlcnNpb24gMScpO1xuXG5cdFx0dmFyIGN1cnZlID0ge307XG5cblx0XHQvLyBGaWVsZElEIHNlcXVlbmNlXG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdHZhciBmaWVsZFR5cGVPaWQgPSBkZXIucmVhZE9JRCgpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChmaWVsZFR5cGVPaWQsICcxLjIuODQwLjEwMDQ1LjEuMScsXG5cdFx0ICAgICdFQ0RTQSBrZXkgaXMgbm90IGZyb20gYSBwcmltZS1maWVsZCcpO1xuXHRcdHZhciBwID0gY3VydmUucCA9IHV0aWxzLm1wTm9ybWFsaXplKFxuXHRcdCAgICBkZXIucmVhZFN0cmluZyhhc24xLkJlci5JbnRlZ2VyLCB0cnVlKSk7XG5cdFx0Lypcblx0XHQgKiBwIGFsd2F5cyBzdGFydHMgd2l0aCBhIDEgYml0LCBzbyBjb3VudCB0aGUgemVyb3MgdG8gZ2V0IGl0c1xuXHRcdCAqIHJlYWwgc2l6ZS5cblx0XHQgKi9cblx0XHRjdXJ2ZS5zaXplID0gcC5sZW5ndGggKiA4IC0gdXRpbHMuY291bnRaZXJvcyhwKTtcblxuXHRcdC8vIEN1cnZlIHNlcXVlbmNlXG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdGN1cnZlLmEgPSB1dGlscy5tcE5vcm1hbGl6ZShcblx0XHQgICAgZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpKTtcblx0XHRjdXJ2ZS5iID0gdXRpbHMubXBOb3JtYWxpemUoXG5cdFx0ICAgIGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKSk7XG5cdFx0aWYgKGRlci5wZWVrKCkgPT09IGFzbjEuQmVyLkJpdFN0cmluZylcblx0XHRcdGN1cnZlLnMgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5CaXRTdHJpbmcsIHRydWUpO1xuXG5cdFx0Ly8gQ29tYmluZWQgR3ggYW5kIEd5XG5cdFx0Y3VydmUuRyA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLk9jdGV0U3RyaW5nLCB0cnVlKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwoY3VydmUuR1swXSwgMHg0LFxuXHRcdCAgICAndW5jb21wcmVzc2VkIEcgaXMgcmVxdWlyZWQnKTtcblxuXHRcdGN1cnZlLm4gPSB1dGlscy5tcE5vcm1hbGl6ZShcblx0XHQgICAgZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSkpO1xuXHRcdGN1cnZlLmggPSB1dGlscy5tcE5vcm1hbGl6ZShcblx0XHQgICAgZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuSW50ZWdlciwgdHJ1ZSkpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChjdXJ2ZS5oWzBdLCAweDEsICdhIGNvZmFjdG9yPTEgY3VydmUgaXMgJyArXG5cdFx0ICAgICdyZXF1aXJlZCcpO1xuXG5cdFx0Y3VydmVOYW1lcyA9IE9iamVjdC5rZXlzKGFsZ3MuY3VydmVzKTtcblx0XHR2YXIga3MgPSBPYmplY3Qua2V5cyhjdXJ2ZSk7XG5cdFx0Zm9yIChqID0gMDsgaiA8IGN1cnZlTmFtZXMubGVuZ3RoOyArK2opIHtcblx0XHRcdGMgPSBjdXJ2ZU5hbWVzW2pdO1xuXHRcdFx0Y2QgPSBhbGdzLmN1cnZlc1tjXTtcblx0XHRcdHZhciBlcXVhbCA9IHRydWU7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHZhciBrID0ga3NbaV07XG5cdFx0XHRcdGlmIChjZFtrXSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRpZiAodHlwZW9mIChjZFtrXSkgPT09ICdvYmplY3QnICYmXG5cdFx0XHRcdCAgICBjZFtrXS5lcXVhbHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmICghY2Rba10uZXF1YWxzKGN1cnZlW2tdKSkge1xuXHRcdFx0XHRcdFx0ZXF1YWwgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoY2Rba10pKSB7XG5cdFx0XHRcdFx0aWYgKGNkW2tdLnRvU3RyaW5nKCdiaW5hcnknKVxuXHRcdFx0XHRcdCAgICAhPT0gY3VydmVba10udG9TdHJpbmcoJ2JpbmFyeScpKSB7XG5cdFx0XHRcdFx0XHRlcXVhbCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChjZFtrXSAhPT0gY3VydmVba10pIHtcblx0XHRcdFx0XHRcdGVxdWFsID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChlcXVhbCkge1xuXHRcdFx0XHRjdXJ2ZU5hbWUgPSBjO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIChjdXJ2ZU5hbWUpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczhFQ0RTQVByaXZhdGUoZGVyKSB7XG5cdHZhciBjdXJ2ZU5hbWUgPSByZWFkRUNEU0FDdXJ2ZShkZXIpO1xuXHRhc3NlcnQuc3RyaW5nKGN1cnZlTmFtZSwgJ2Ega25vd24gZWxsaXB0aWMgY3VydmUnKTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXG5cdHZhciB2ZXJzaW9uID0gcmVhZE1QSW50KGRlciwgJ3ZlcnNpb24nKTtcblx0YXNzZXJ0LmVxdWFsKHZlcnNpb25bMF0sIDEsICd1bmtub3duIHZlcnNpb24gb2YgRUNEU0Ega2V5Jyk7XG5cblx0dmFyIGQgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSk7XG5cdHZhciBRO1xuXG5cdGlmIChkZXIucGVlaygpID09IDB4YTApIHtcblx0XHRkZXIucmVhZFNlcXVlbmNlKDB4YTApO1xuXHRcdGRlci5fb2Zmc2V0ICs9IGRlci5sZW5ndGg7XG5cdH1cblx0aWYgKGRlci5wZWVrKCkgPT0gMHhhMSkge1xuXHRcdGRlci5yZWFkU2VxdWVuY2UoMHhhMSk7XG5cdFx0USA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkJpdFN0cmluZywgdHJ1ZSk7XG5cdFx0USA9IHV0aWxzLmVjTm9ybWFsaXplKFEpO1xuXHR9XG5cblx0aWYgKFEgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBwdWIgPSB1dGlscy5wdWJsaWNGcm9tUHJpdmF0ZUVDRFNBKGN1cnZlTmFtZSwgZCk7XG5cdFx0USA9IHB1Yi5wYXJ0LlEuZGF0YTtcblx0fVxuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZU5hbWUpIH0sXG5cdFx0XHR7IG5hbWU6ICdRJywgZGF0YTogUSB9LFxuXHRcdFx0eyBuYW1lOiAnZCcsIGRhdGE6IGQgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KGtleSkpO1xufVxuXG5mdW5jdGlvbiByZWFkUGtjczhFQ0RTQVB1YmxpYyhkZXIpIHtcblx0dmFyIGN1cnZlTmFtZSA9IHJlYWRFQ0RTQUN1cnZlKGRlcik7XG5cdGFzc2VydC5zdHJpbmcoY3VydmVOYW1lLCAnYSBrbm93biBlbGxpcHRpYyBjdXJ2ZScpO1xuXG5cdHZhciBRID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuQml0U3RyaW5nLCB0cnVlKTtcblx0USA9IHV0aWxzLmVjTm9ybWFsaXplKFEpO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2VjZHNhJyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnY3VydmUnLCBkYXRhOiBCdWZmZXIuZnJvbShjdXJ2ZU5hbWUpIH0sXG5cdFx0XHR7IG5hbWU6ICdRJywgZGF0YTogUSB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4RWREU0FQdWJsaWMoZGVyKSB7XG5cdGlmIChkZXIucGVlaygpID09PSAweDAwKVxuXHRcdGRlci5yZWFkQnl0ZSgpO1xuXG5cdHZhciBBID0gdXRpbHMucmVhZEJpdFN0cmluZyhkZXIpO1xuXG5cdHZhciBrZXkgPSB7XG5cdFx0dHlwZTogJ2VkMjU1MTknLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IG5hbWU6ICdBJywgZGF0YTogdXRpbHMuemVyb1BhZFRvTGVuZ3RoKEEsIDMyKSB9XG5cdFx0XVxuXHR9O1xuXG5cdHJldHVybiAobmV3IEtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4WDI1NTE5UHVibGljKGRlcikge1xuXHR2YXIgQSA9IHV0aWxzLnJlYWRCaXRTdHJpbmcoZGVyKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdjdXJ2ZTI1NTE5Jyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnQScsIGRhdGE6IHV0aWxzLnplcm9QYWRUb0xlbmd0aChBLCAzMikgfVxuXHRcdF1cblx0fTtcblxuXHRyZXR1cm4gKG5ldyBLZXkoa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRQa2NzOEVkRFNBUHJpdmF0ZShkZXIpIHtcblx0aWYgKGRlci5wZWVrKCkgPT09IDB4MDApXG5cdFx0ZGVyLnJlYWRCeXRlKCk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdHZhciBrID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpO1xuXHRrID0gdXRpbHMuemVyb1BhZFRvTGVuZ3RoKGssIDMyKTtcblxuXHR2YXIgQTtcblx0aWYgKGRlci5wZWVrKCkgPT09IGFzbjEuQmVyLkJpdFN0cmluZykge1xuXHRcdEEgPSB1dGlscy5yZWFkQml0U3RyaW5nKGRlcik7XG5cdFx0QSA9IHV0aWxzLnplcm9QYWRUb0xlbmd0aChBLCAzMik7XG5cdH0gZWxzZSB7XG5cdFx0QSA9IHV0aWxzLmNhbGN1bGF0ZUVEMjU1MTlQdWJsaWMoayk7XG5cdH1cblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdlZDI1NTE5Jyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnQScsIGRhdGE6IHV0aWxzLnplcm9QYWRUb0xlbmd0aChBLCAzMikgfSxcblx0XHRcdHsgbmFtZTogJ2snLCBkYXRhOiB1dGlscy56ZXJvUGFkVG9MZW5ndGgoaywgMzIpIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcmVhZFBrY3M4WDI1NTE5UHJpdmF0ZShkZXIpIHtcblx0aWYgKGRlci5wZWVrKCkgPT09IDB4MDApXG5cdFx0ZGVyLnJlYWRCeXRlKCk7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdHZhciBrID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuT2N0ZXRTdHJpbmcsIHRydWUpO1xuXHRrID0gdXRpbHMuemVyb1BhZFRvTGVuZ3RoKGssIDMyKTtcblxuXHR2YXIgQSA9IHV0aWxzLmNhbGN1bGF0ZVgyNTUxOVB1YmxpYyhrKTtcblxuXHR2YXIga2V5ID0ge1xuXHRcdHR5cGU6ICdjdXJ2ZTI1NTE5Jyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBuYW1lOiAnQScsIGRhdGE6IHV0aWxzLnplcm9QYWRUb0xlbmd0aChBLCAzMikgfSxcblx0XHRcdHsgbmFtZTogJ2snLCBkYXRhOiB1dGlscy56ZXJvUGFkVG9MZW5ndGgoaywgMzIpIH1cblx0XHRdXG5cdH07XG5cblx0cmV0dXJuIChuZXcgUHJpdmF0ZUtleShrZXkpKTtcbn1cblxuZnVuY3Rpb24gcGtjczhUb0J1ZmZlcihrZXkpIHtcblx0dmFyIGRlciA9IG5ldyBhc24xLkJlcldyaXRlcigpO1xuXHR3cml0ZVBrY3M4KGRlciwga2V5KTtcblx0cmV0dXJuIChkZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzOChkZXIsIGtleSkge1xuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG5cdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKSB7XG5cdFx0dmFyIHNpbGx5SW50ID0gQnVmZmVyLmZyb20oWzBdKTtcblx0XHRkZXIud3JpdGVCdWZmZXIoc2lsbHlJbnQsIGFzbjEuQmVyLkludGVnZXIpO1xuXHR9XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0c3dpdGNoIChrZXkudHlwZSkge1xuXHRjYXNlICdyc2EnOlxuXHRcdGRlci53cml0ZU9JRCgnMS4yLjg0MC4xMTM1NDkuMS4xLjEnKTtcblx0XHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRcdHdyaXRlUGtjczhSU0FQcml2YXRlKGtleSwgZGVyKTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZVBrY3M4UlNBUHVibGljKGtleSwgZGVyKTtcblx0XHRicmVhaztcblx0Y2FzZSAnZHNhJzpcblx0XHRkZXIud3JpdGVPSUQoJzEuMi44NDAuMTAwNDAuNC4xJyk7XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR3cml0ZVBrY3M4RFNBUHJpdmF0ZShrZXksIGRlcik7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVQa2NzOERTQVB1YmxpYyhrZXksIGRlcik7XG5cdFx0YnJlYWs7XG5cdGNhc2UgJ2VjZHNhJzpcblx0XHRkZXIud3JpdGVPSUQoJzEuMi44NDAuMTAwNDUuMi4xJyk7XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR3cml0ZVBrY3M4RUNEU0FQcml2YXRlKGtleSwgZGVyKTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZVBrY3M4RUNEU0FQdWJsaWMoa2V5LCBkZXIpO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdlZDI1NTE5Jzpcblx0XHRkZXIud3JpdGVPSUQoJzEuMy4xMDEuMTEyJyk7XG5cdFx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdFZDI1NTE5IHByaXZhdGUga2V5cyBpbiBwa2NzOCAnICtcblx0XHRcdCAgICAnZm9ybWF0IGFyZSBub3Qgc3VwcG9ydGVkJykpO1xuXHRcdHdyaXRlUGtjczhFZERTQVB1YmxpYyhrZXksIGRlcik7XG5cdFx0YnJlYWs7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2V5IHR5cGU6ICcgKyBrZXkudHlwZSkpO1xuXHR9XG5cblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczhSU0FQcml2YXRlKGtleSwgZGVyKSB7XG5cdGRlci53cml0ZU51bGwoKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG5cdHZhciB2ZXJzaW9uID0gQnVmZmVyLmZyb20oWzBdKTtcblx0ZGVyLndyaXRlQnVmZmVyKHZlcnNpb24sIGFzbjEuQmVyLkludGVnZXIpO1xuXG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5uLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmQuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5wLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0aWYgKCFrZXkucGFydC5kbW9kcCB8fCAha2V5LnBhcnQuZG1vZHEpXG5cdFx0dXRpbHMuYWRkUlNBTWlzc2luZyhrZXkpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQuZG1vZHAuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5kbW9kcS5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmlxbXAuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3M4UlNBUHVibGljKGtleSwgZGVyKSB7XG5cdGRlci53cml0ZU51bGwoKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuQml0U3RyaW5nKTtcblx0ZGVyLndyaXRlQnl0ZSgweDAwKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQubi5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LmUuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3M4RFNBUHJpdmF0ZShrZXksIGRlcikge1xuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnEuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5nLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC54LmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzOERTQVB1YmxpYyhrZXksIGRlcikge1xuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRkZXIud3JpdGVCdWZmZXIoa2V5LnBhcnQucC5kYXRhLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnEuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5nLmRhdGEsIGFzbjEuQmVyLkludGVnZXIpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuQml0U3RyaW5nKTtcblx0ZGVyLndyaXRlQnl0ZSgweDAwKTtcblx0ZGVyLndyaXRlQnVmZmVyKGtleS5wYXJ0LnkuZGF0YSwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZUVDRFNBQ3VydmUoa2V5LCBkZXIpIHtcblx0dmFyIGN1cnZlID0gYWxncy5jdXJ2ZXNba2V5LmN1cnZlXTtcblx0aWYgKGN1cnZlLnBrY3M4b2lkKSB7XG5cdFx0LyogVGhpcyBvbmUgaGFzIGEgbmFtZSBpbiBwa2NzIzgsIHNvIGp1c3Qgd3JpdGUgdGhlIG9pZCAqL1xuXHRcdGRlci53cml0ZU9JRChjdXJ2ZS5wa2NzOG9pZCk7XG5cblx0fSBlbHNlIHtcblx0XHQvLyBFQ1BhcmFtZXRlcnMgc2VxdWVuY2Vcblx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG5cdFx0dmFyIHZlcnNpb24gPSBCdWZmZXIuZnJvbShbMV0pO1xuXHRcdGRlci53cml0ZUJ1ZmZlcih2ZXJzaW9uLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRcdC8vIEZpZWxkSUQgc2VxdWVuY2Vcblx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdGRlci53cml0ZU9JRCgnMS4yLjg0MC4xMDA0NS4xLjEnKTsgLy8gcHJpbWUtZmllbGRcblx0XHRkZXIud3JpdGVCdWZmZXIoY3VydmUucCwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0XHQvLyBDdXJ2ZSBzZXF1ZW5jZVxuXHRcdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdFx0dmFyIGEgPSBjdXJ2ZS5wO1xuXHRcdGlmIChhWzBdID09PSAweDApXG5cdFx0XHRhID0gYS5zbGljZSgxKTtcblx0XHRkZXIud3JpdGVCdWZmZXIoYSwgYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdGRlci53cml0ZUJ1ZmZlcihjdXJ2ZS5iLCBhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdFx0ZGVyLndyaXRlQnVmZmVyKGN1cnZlLnMsIGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0XHRkZXIud3JpdGVCdWZmZXIoY3VydmUuRywgYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdGRlci53cml0ZUJ1ZmZlcihjdXJ2ZS5uLCBhc24xLkJlci5JbnRlZ2VyKTtcblx0XHR2YXIgaCA9IGN1cnZlLmg7XG5cdFx0aWYgKCFoKSB7XG5cdFx0XHRoID0gQnVmZmVyLmZyb20oWzFdKTtcblx0XHR9XG5cdFx0ZGVyLndyaXRlQnVmZmVyKGgsIGFzbjEuQmVyLkludGVnZXIpO1xuXG5cdFx0Ly8gRUNQYXJhbWV0ZXJzXG5cdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gd3JpdGVQa2NzOEVDRFNBUHVibGljKGtleSwgZGVyKSB7XG5cdHdyaXRlRUNEU0FDdXJ2ZShrZXksIGRlcik7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdHZhciBRID0gdXRpbHMuZWNOb3JtYWxpemUoa2V5LnBhcnQuUS5kYXRhLCB0cnVlKTtcblx0ZGVyLndyaXRlQnVmZmVyKFEsIGFzbjEuQmVyLkJpdFN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlUGtjczhFQ0RTQVByaXZhdGUoa2V5LCBkZXIpIHtcblx0d3JpdGVFQ0RTQUN1cnZlKGtleSwgZGVyKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG5cdHZhciB2ZXJzaW9uID0gQnVmZmVyLmZyb20oWzFdKTtcblx0ZGVyLndyaXRlQnVmZmVyKHZlcnNpb24sIGFzbjEuQmVyLkludGVnZXIpO1xuXG5cdGRlci53cml0ZUJ1ZmZlcihrZXkucGFydC5kLmRhdGEsIGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgweGExKTtcblx0dmFyIFEgPSB1dGlscy5lY05vcm1hbGl6ZShrZXkucGFydC5RLmRhdGEsIHRydWUpO1xuXHRkZXIud3JpdGVCdWZmZXIoUSwgYXNuMS5CZXIuQml0U3RyaW5nKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3M4RWREU0FQdWJsaWMoa2V5LCBkZXIpIHtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0dXRpbHMud3JpdGVCaXRTdHJpbmcoZGVyLCBrZXkucGFydC5BLmRhdGEpO1xufVxuXG5mdW5jdGlvbiB3cml0ZVBrY3M4RWREU0FQcml2YXRlKGtleSwgZGVyKSB7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdHZhciBrID0gdXRpbHMubXBOb3JtYWxpemUoa2V5LnBhcnQuay5kYXRhLCB0cnVlKTtcblx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRkZXIud3JpdGVCdWZmZXIoaywgYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDE4IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgcmZjNDI1MyA9IHJlcXVpcmUoJy4vcmZjNDI1MycpO1xudmFyIEtleSA9IHJlcXVpcmUoJy4uL2tleScpO1xuXG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdHZhciBsaW5lcyA9IGJ1Zi50b1N0cmluZygnYXNjaWknKS5zcGxpdCgvW1xcclxcbl0rLyk7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHR2YXIgcGFydHM7XG5cdHZhciBzaSA9IDA7XG5cdHdoaWxlIChzaSA8IGxpbmVzLmxlbmd0aCkge1xuXHRcdHBhcnRzID0gc3BsaXRIZWFkZXIobGluZXNbc2krK10pO1xuXHRcdGlmIChwYXJ0cyAmJlxuXHRcdCAgICBwYXJ0c1swXS50b0xvd2VyQ2FzZSgpID09PSAncHV0dHktdXNlci1rZXktZmlsZS0yJykge1xuXHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdGlmICghZm91bmQpIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdObyBQdVRUWSBmb3JtYXQgZmlyc3QgbGluZSBmb3VuZCcpKTtcblx0fVxuXHR2YXIgYWxnID0gcGFydHNbMV07XG5cblx0cGFydHMgPSBzcGxpdEhlYWRlcihsaW5lc1tzaSsrXSk7XG5cdGFzc2VydC5lcXVhbChwYXJ0c1swXS50b0xvd2VyQ2FzZSgpLCAnZW5jcnlwdGlvbicpO1xuXG5cdHBhcnRzID0gc3BsaXRIZWFkZXIobGluZXNbc2krK10pO1xuXHRhc3NlcnQuZXF1YWwocGFydHNbMF0udG9Mb3dlckNhc2UoKSwgJ2NvbW1lbnQnKTtcblx0dmFyIGNvbW1lbnQgPSBwYXJ0c1sxXTtcblxuXHRwYXJ0cyA9IHNwbGl0SGVhZGVyKGxpbmVzW3NpKytdKTtcblx0YXNzZXJ0LmVxdWFsKHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksICdwdWJsaWMtbGluZXMnKTtcblx0dmFyIHB1YmxpY0xpbmVzID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcblx0aWYgKCFpc0Zpbml0ZShwdWJsaWNMaW5lcykgfHwgcHVibGljTGluZXMgPCAwIHx8XG5cdCAgICBwdWJsaWNMaW5lcyA+IGxpbmVzLmxlbmd0aCkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgcHVibGljLWxpbmVzIGNvdW50JykpO1xuXHR9XG5cblx0dmFyIHB1YmxpY0J1ZiA9IEJ1ZmZlci5mcm9tKFxuXHQgICAgbGluZXMuc2xpY2Uoc2ksIHNpICsgcHVibGljTGluZXMpLmpvaW4oJycpLCAnYmFzZTY0Jyk7XG5cdHZhciBrZXlUeXBlID0gcmZjNDI1My5hbGdUb0tleVR5cGUoYWxnKTtcblx0dmFyIGtleSA9IHJmYzQyNTMucmVhZChwdWJsaWNCdWYpO1xuXHRpZiAoa2V5LnR5cGUgIT09IGtleVR5cGUpIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdPdXRlciBrZXkgYWxnb3JpdGhtIG1pc21hdGNoJykpO1xuXHR9XG5cdGtleS5jb21tZW50ID0gY29tbWVudDtcblx0cmV0dXJuIChrZXkpO1xufVxuXG5mdW5jdGlvbiBzcGxpdEhlYWRlcihsaW5lKSB7XG5cdHZhciBpZHggPSBsaW5lLmluZGV4T2YoJzonKTtcblx0aWYgKGlkeCA9PT0gLTEpXG5cdFx0cmV0dXJuIChudWxsKTtcblx0dmFyIGhlYWRlciA9IGxpbmUuc2xpY2UoMCwgaWR4KTtcblx0KytpZHg7XG5cdHdoaWxlIChsaW5lW2lkeF0gPT09ICcgJylcblx0XHQrK2lkeDtcblx0dmFyIHJlc3QgPSBsaW5lLnNsaWNlKGlkeCk7XG5cdHJldHVybiAoW2hlYWRlciwgcmVzdF0pO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0YXNzZXJ0Lm9iamVjdChrZXkpO1xuXHRpZiAoIUtleS5pc0tleShrZXkpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ011c3QgYmUgYSBwdWJsaWMga2V5JykpO1xuXG5cdHZhciBhbGcgPSByZmM0MjUzLmtleVR5cGVUb0FsZyhrZXkpO1xuXHR2YXIgYnVmID0gcmZjNDI1My53cml0ZShrZXkpO1xuXHR2YXIgY29tbWVudCA9IGtleS5jb21tZW50IHx8ICcnO1xuXG5cdHZhciBiNjQgPSBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuXHR2YXIgbGluZXMgPSB3cmFwKGI2NCwgNjQpO1xuXG5cdGxpbmVzLnVuc2hpZnQoJ1B1YmxpYy1MaW5lczogJyArIGxpbmVzLmxlbmd0aCk7XG5cdGxpbmVzLnVuc2hpZnQoJ0NvbW1lbnQ6ICcgKyBjb21tZW50KTtcblx0bGluZXMudW5zaGlmdCgnRW5jcnlwdGlvbjogbm9uZScpO1xuXHRsaW5lcy51bnNoaWZ0KCdQdVRUWS1Vc2VyLUtleS1GaWxlLTI6ICcgKyBhbGcpO1xuXG5cdHJldHVybiAoQnVmZmVyLmZyb20obGluZXMuam9pbignXFxuJykgKyAnXFxuJykpO1xufVxuXG5mdW5jdGlvbiB3cmFwKHR4dCwgbGVuKSB7XG5cdHZhciBsaW5lcyA9IFtdO1xuXHR2YXIgcG9zID0gMDtcblx0d2hpbGUgKHBvcyA8IHR4dC5sZW5ndGgpIHtcblx0XHRsaW5lcy5wdXNoKHR4dC5zbGljZShwb3MsIHBvcyArIDY0KSk7XG5cdFx0cG9zICs9IDY0O1xuXHR9XG5cdHJldHVybiAobGluZXMpO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLmJpbmQodW5kZWZpbmVkLCBmYWxzZSwgdW5kZWZpbmVkKSxcblx0cmVhZFR5cGU6IHJlYWQuYmluZCh1bmRlZmluZWQsIGZhbHNlKSxcblx0d3JpdGU6IHdyaXRlLFxuXHQvKiBzZW1pLXByaXZhdGUgYXBpLCB1c2VkIGJ5IHNzaHBrLWFnZW50ICovXG5cdHJlYWRQYXJ0aWFsOiByZWFkLmJpbmQodW5kZWZpbmVkLCB0cnVlKSxcblxuXHQvKiBzaGFyZWQgd2l0aCBzc2ggZm9ybWF0ICovXG5cdHJlYWRJbnRlcm5hbDogcmVhZCxcblx0a2V5VHlwZVRvQWxnOiBrZXlUeXBlVG9BbGcsXG5cdGFsZ1RvS2V5VHlwZTogYWxnVG9LZXlUeXBlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4uL2FsZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG52YXIgU1NIQnVmZmVyID0gcmVxdWlyZSgnLi4vc3NoLWJ1ZmZlcicpO1xuXG5mdW5jdGlvbiBhbGdUb0tleVR5cGUoYWxnKSB7XG5cdGFzc2VydC5zdHJpbmcoYWxnKTtcblx0aWYgKGFsZyA9PT0gJ3NzaC1kc3MnKVxuXHRcdHJldHVybiAoJ2RzYScpO1xuXHRlbHNlIGlmIChhbGcgPT09ICdzc2gtcnNhJylcblx0XHRyZXR1cm4gKCdyc2EnKTtcblx0ZWxzZSBpZiAoYWxnID09PSAnc3NoLWVkMjU1MTknKVxuXHRcdHJldHVybiAoJ2VkMjU1MTknKTtcblx0ZWxzZSBpZiAoYWxnID09PSAnc3NoLWN1cnZlMjU1MTknKVxuXHRcdHJldHVybiAoJ2N1cnZlMjU1MTknKTtcblx0ZWxzZSBpZiAoYWxnLm1hdGNoKC9eZWNkc2Etc2hhMi0vKSlcblx0XHRyZXR1cm4gKCdlY2RzYScpO1xuXHRlbHNlXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBhbGdvcml0aG0gJyArIGFsZykpO1xufVxuXG5mdW5jdGlvbiBrZXlUeXBlVG9BbGcoa2V5KSB7XG5cdGFzc2VydC5vYmplY3Qoa2V5KTtcblx0aWYgKGtleS50eXBlID09PSAnZHNhJylcblx0XHRyZXR1cm4gKCdzc2gtZHNzJyk7XG5cdGVsc2UgaWYgKGtleS50eXBlID09PSAncnNhJylcblx0XHRyZXR1cm4gKCdzc2gtcnNhJyk7XG5cdGVsc2UgaWYgKGtleS50eXBlID09PSAnZWQyNTUxOScpXG5cdFx0cmV0dXJuICgnc3NoLWVkMjU1MTknKTtcblx0ZWxzZSBpZiAoa2V5LnR5cGUgPT09ICdjdXJ2ZTI1NTE5Jylcblx0XHRyZXR1cm4gKCdzc2gtY3VydmUyNTUxOScpO1xuXHRlbHNlIGlmIChrZXkudHlwZSA9PT0gJ2VjZHNhJylcblx0XHRyZXR1cm4gKCdlY2RzYS1zaGEyLScgKyBrZXkucGFydC5jdXJ2ZS5kYXRhLnRvU3RyaW5nKCkpO1xuXHRlbHNlXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBrZXkgdHlwZSAnICsga2V5LnR5cGUpKTtcbn1cblxuZnVuY3Rpb24gcmVhZChwYXJ0aWFsLCB0eXBlLCBidWYsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiAoYnVmKSA9PT0gJ3N0cmluZycpXG5cdFx0YnVmID0gQnVmZmVyLmZyb20oYnVmKTtcblx0YXNzZXJ0LmJ1ZmZlcihidWYsICdidWYnKTtcblxuXHR2YXIga2V5ID0ge307XG5cblx0dmFyIHBhcnRzID0ga2V5LnBhcnRzID0gW107XG5cdHZhciBzc2hidWYgPSBuZXcgU1NIQnVmZmVyKHtidWZmZXI6IGJ1Zn0pO1xuXG5cdHZhciBhbGcgPSBzc2hidWYucmVhZFN0cmluZygpO1xuXHRhc3NlcnQub2soIXNzaGJ1Zi5hdEVuZCgpLCAna2V5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgcGFydCcpO1xuXG5cdGtleS50eXBlID0gYWxnVG9LZXlUeXBlKGFsZyk7XG5cblx0dmFyIHBhcnRDb3VudCA9IGFsZ3MuaW5mb1trZXkudHlwZV0ucGFydHMubGVuZ3RoO1xuXHRpZiAodHlwZSAmJiB0eXBlID09PSAncHJpdmF0ZScpXG5cdFx0cGFydENvdW50ID0gYWxncy5wcml2SW5mb1trZXkudHlwZV0ucGFydHMubGVuZ3RoO1xuXG5cdHdoaWxlICghc3NoYnVmLmF0RW5kKCkgJiYgcGFydHMubGVuZ3RoIDwgcGFydENvdW50KVxuXHRcdHBhcnRzLnB1c2goc3NoYnVmLnJlYWRQYXJ0KCkpO1xuXHR3aGlsZSAoIXBhcnRpYWwgJiYgIXNzaGJ1Zi5hdEVuZCgpKVxuXHRcdHBhcnRzLnB1c2goc3NoYnVmLnJlYWRQYXJ0KCkpO1xuXG5cdGFzc2VydC5vayhwYXJ0cy5sZW5ndGggPj0gMSxcblx0ICAgICdrZXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwYXJ0Jyk7XG5cdGFzc2VydC5vayhwYXJ0aWFsIHx8IHNzaGJ1Zi5hdEVuZCgpLFxuXHQgICAgJ2xlZnRvdmVyIGJ5dGVzIGF0IGVuZCBvZiBrZXknKTtcblxuXHR2YXIgQ29uc3RydWN0b3IgPSBLZXk7XG5cdHZhciBhbGdJbmZvID0gYWxncy5pbmZvW2tleS50eXBlXTtcblx0aWYgKHR5cGUgPT09ICdwcml2YXRlJyB8fCBhbGdJbmZvLnBhcnRzLmxlbmd0aCAhPT0gcGFydHMubGVuZ3RoKSB7XG5cdFx0YWxnSW5mbyA9IGFsZ3MucHJpdkluZm9ba2V5LnR5cGVdO1xuXHRcdENvbnN0cnVjdG9yID0gUHJpdmF0ZUtleTtcblx0fVxuXHRhc3NlcnQuc3RyaWN0RXF1YWwoYWxnSW5mby5wYXJ0cy5sZW5ndGgsIHBhcnRzLmxlbmd0aCk7XG5cblx0aWYgKGtleS50eXBlID09PSAnZWNkc2EnKSB7XG5cdFx0dmFyIHJlcyA9IC9eZWNkc2Etc2hhMi0oLispJC8uZXhlYyhhbGcpO1xuXHRcdGFzc2VydC5vayhyZXMgIT09IG51bGwpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChyZXNbMV0sIHBhcnRzWzBdLmRhdGEudG9TdHJpbmcoKSk7XG5cdH1cblxuXHR2YXIgbm9ybWFsaXplZCA9IHRydWU7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYWxnSW5mby5wYXJ0cy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciBwID0gcGFydHNbaV07XG5cdFx0cC5uYW1lID0gYWxnSW5mby5wYXJ0c1tpXTtcblx0XHQvKlxuXHRcdCAqIE9wZW5TU0ggc3RvcmVzIGVkMjU1MTkgXCJwcml2YXRlXCIga2V5cyBhcyBzZWVkICsgcHVibGljIGtleVxuXHRcdCAqIGNvbmNhdCdkIHRvZ2V0aGVyIChrIGZvbGxvd2VkIGJ5IEEpLiBXZSB3YW50IHRvIGtlZXAgdGhlbVxuXHRcdCAqIHNlcGFyYXRlIGZvciBvdGhlciBmb3JtYXRzIHRoYXQgZG9uJ3QgZG8gdGhpcy5cblx0XHQgKi9cblx0XHRpZiAoa2V5LnR5cGUgPT09ICdlZDI1NTE5JyAmJiBwLm5hbWUgPT09ICdrJylcblx0XHRcdHAuZGF0YSA9IHAuZGF0YS5zbGljZSgwLCAzMik7XG5cblx0XHRpZiAocC5uYW1lICE9PSAnY3VydmUnICYmIGFsZ0luZm8ubm9ybWFsaXplICE9PSBmYWxzZSkge1xuXHRcdFx0dmFyIG5kO1xuXHRcdFx0aWYgKGtleS50eXBlID09PSAnZWQyNTUxOScpIHtcblx0XHRcdFx0bmQgPSB1dGlscy56ZXJvUGFkVG9MZW5ndGgocC5kYXRhLCAzMik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZCA9IHV0aWxzLm1wTm9ybWFsaXplKHAuZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobmQudG9TdHJpbmcoJ2JpbmFyeScpICE9PVxuXHRcdFx0ICAgIHAuZGF0YS50b1N0cmluZygnYmluYXJ5JykpIHtcblx0XHRcdFx0cC5kYXRhID0gbmQ7XG5cdFx0XHRcdG5vcm1hbGl6ZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAobm9ybWFsaXplZClcblx0XHRrZXkuX3JmYzQyNTNDYWNoZSA9IHNzaGJ1Zi50b0J1ZmZlcigpO1xuXG5cdGlmIChwYXJ0aWFsICYmIHR5cGVvZiAocGFydGlhbCkgPT09ICdvYmplY3QnKSB7XG5cdFx0cGFydGlhbC5yZW1haW5kZXIgPSBzc2hidWYucmVtYWluZGVyKCk7XG5cdFx0cGFydGlhbC5jb25zdW1lZCA9IHNzaGJ1Zi5fb2Zmc2V0O1xuXHR9XG5cblx0cmV0dXJuIChuZXcgQ29uc3RydWN0b3Ioa2V5KSk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlKGtleSwgb3B0aW9ucykge1xuXHRhc3NlcnQub2JqZWN0KGtleSk7XG5cblx0dmFyIGFsZyA9IGtleVR5cGVUb0FsZyhrZXkpO1xuXHR2YXIgaTtcblxuXHR2YXIgYWxnSW5mbyA9IGFsZ3MuaW5mb1trZXkudHlwZV07XG5cdGlmIChQcml2YXRlS2V5LmlzUHJpdmF0ZUtleShrZXkpKVxuXHRcdGFsZ0luZm8gPSBhbGdzLnByaXZJbmZvW2tleS50eXBlXTtcblx0dmFyIHBhcnRzID0gYWxnSW5mby5wYXJ0cztcblxuXHR2YXIgYnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cblx0YnVmLndyaXRlU3RyaW5nKGFsZyk7XG5cblx0Zm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIGRhdGEgPSBrZXkucGFydFtwYXJ0c1tpXV0uZGF0YTtcblx0XHRpZiAoYWxnSW5mby5ub3JtYWxpemUgIT09IGZhbHNlKSB7XG5cdFx0XHRpZiAoa2V5LnR5cGUgPT09ICdlZDI1NTE5Jylcblx0XHRcdFx0ZGF0YSA9IHV0aWxzLnplcm9QYWRUb0xlbmd0aChkYXRhLCAzMik7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdGRhdGEgPSB1dGlscy5tcE5vcm1hbGl6ZShkYXRhKTtcblx0XHR9XG5cdFx0aWYgKGtleS50eXBlID09PSAnZWQyNTUxOScgJiYgcGFydHNbaV0gPT09ICdrJylcblx0XHRcdGRhdGEgPSBCdWZmZXIuY29uY2F0KFtkYXRhLCBrZXkucGFydC5BLmRhdGFdKTtcblx0XHRidWYud3JpdGVCdWZmZXIoZGF0YSk7XG5cdH1cblxuXHRyZXR1cm4gKGJ1Zi50b0J1ZmZlcigpKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0cmVhZFNTSFByaXZhdGU6IHJlYWRTU0hQcml2YXRlLFxuXHR3cml0ZTogd3JpdGVcbn07XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuLi9hbGdzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG52YXIgcGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcbnZhciByZmM0MjUzID0gcmVxdWlyZSgnLi9yZmM0MjUzJyk7XG52YXIgU1NIQnVmZmVyID0gcmVxdWlyZSgnLi4vc3NoLWJ1ZmZlcicpO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG52YXIgYmNyeXB0O1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRyZXR1cm4gKHBlbS5yZWFkKGJ1Ziwgb3B0aW9ucykpO1xufVxuXG52YXIgTUFHSUMgPSAnb3BlbnNzaC1rZXktdjEnO1xuXG5mdW5jdGlvbiByZWFkU1NIUHJpdmF0ZSh0eXBlLCBidWYsIG9wdGlvbnMpIHtcblx0YnVmID0gbmV3IFNTSEJ1ZmZlcih7YnVmZmVyOiBidWZ9KTtcblxuXHR2YXIgbWFnaWMgPSBidWYucmVhZENTdHJpbmcoKTtcblx0YXNzZXJ0LnN0cmljdEVxdWFsKG1hZ2ljLCBNQUdJQywgJ2JhZCBtYWdpYyBzdHJpbmcnKTtcblxuXHR2YXIgY2lwaGVyID0gYnVmLnJlYWRTdHJpbmcoKTtcblx0dmFyIGtkZiA9IGJ1Zi5yZWFkU3RyaW5nKCk7XG5cdHZhciBrZGZPcHRzID0gYnVmLnJlYWRCdWZmZXIoKTtcblxuXHR2YXIgbmtleXMgPSBidWYucmVhZEludCgpO1xuXHRpZiAobmtleXMgIT09IDEpIHtcblx0XHR0aHJvdyAobmV3IEVycm9yKCdPcGVuU1NILWZvcm1hdCBrZXkgZmlsZSBjb250YWlucyAnICtcblx0XHQgICAgJ211bHRpcGxlIGtleXM6IHRoaXMgaXMgdW5zdXBwb3J0ZWQuJykpO1xuXHR9XG5cblx0dmFyIHB1YktleSA9IGJ1Zi5yZWFkQnVmZmVyKCk7XG5cblx0aWYgKHR5cGUgPT09ICdwdWJsaWMnKSB7XG5cdFx0YXNzZXJ0Lm9rKGJ1Zi5hdEVuZCgpLCAnZXhjZXNzIGJ5dGVzIGxlZnQgYWZ0ZXIga2V5Jyk7XG5cdFx0cmV0dXJuIChyZmM0MjUzLnJlYWQocHViS2V5KSk7XG5cdH1cblxuXHR2YXIgcHJpdktleUJsb2IgPSBidWYucmVhZEJ1ZmZlcigpO1xuXHRhc3NlcnQub2soYnVmLmF0RW5kKCksICdleGNlc3MgYnl0ZXMgbGVmdCBhZnRlciBrZXknKTtcblxuXHR2YXIga2RmT3B0c0J1ZiA9IG5ldyBTU0hCdWZmZXIoeyBidWZmZXI6IGtkZk9wdHMgfSk7XG5cdHN3aXRjaCAoa2RmKSB7XG5cdGNhc2UgJ25vbmUnOlxuXHRcdGlmIChjaXBoZXIgIT09ICdub25lJykge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignT3BlblNTSC1mb3JtYXQga2V5IHVzZXMgS0RGIFwibm9uZVwiICcgK1xuXHRcdFx0ICAgICAnYnV0IHNwZWNpZmllcyBhIGNpcGhlciBvdGhlciB0aGFuIFwibm9uZVwiJykpO1xuXHRcdH1cblx0XHRicmVhaztcblx0Y2FzZSAnYmNyeXB0Jzpcblx0XHR2YXIgc2FsdCA9IGtkZk9wdHNCdWYucmVhZEJ1ZmZlcigpO1xuXHRcdHZhciByb3VuZHMgPSBrZGZPcHRzQnVmLnJlYWRJbnQoKTtcblx0XHR2YXIgY2luZiA9IHV0aWxzLm9wZW5zc2hDaXBoZXJJbmZvKGNpcGhlcik7XG5cdFx0aWYgKGJjcnlwdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRiY3J5cHQgPSByZXF1aXJlKCdiY3J5cHQtcGJrZGYnKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIChvcHRpb25zLnBhc3NwaHJhc2UpID09PSAnc3RyaW5nJykge1xuXHRcdFx0b3B0aW9ucy5wYXNzcGhyYXNlID0gQnVmZmVyLmZyb20ob3B0aW9ucy5wYXNzcGhyYXNlLFxuXHRcdFx0ICAgICd1dGYtOCcpO1xuXHRcdH1cblx0XHRpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnBhc3NwaHJhc2UpKSB7XG5cdFx0XHR0aHJvdyAobmV3IGVycm9ycy5LZXlFbmNyeXB0ZWRFcnJvcihcblx0XHRcdCAgICBvcHRpb25zLmZpbGVuYW1lLCAnT3BlblNTSCcpKTtcblx0XHR9XG5cblx0XHR2YXIgcGFzcyA9IG5ldyBVaW50OEFycmF5KG9wdGlvbnMucGFzc3BocmFzZSk7XG5cdFx0dmFyIHNhbHRpID0gbmV3IFVpbnQ4QXJyYXkoc2FsdCk7XG5cdFx0LyogVXNlIHRoZSBwYmtkZiB0byBkZXJpdmUgYm90aCB0aGUga2V5IGFuZCB0aGUgSVYuICovXG5cdFx0dmFyIG91dCA9IG5ldyBVaW50OEFycmF5KGNpbmYua2V5U2l6ZSArIGNpbmYuYmxvY2tTaXplKTtcblx0XHR2YXIgcmVzID0gYmNyeXB0LnBia2RmKHBhc3MsIHBhc3MubGVuZ3RoLCBzYWx0aSwgc2FsdGkubGVuZ3RoLFxuXHRcdCAgICBvdXQsIG91dC5sZW5ndGgsIHJvdW5kcyk7XG5cdFx0aWYgKHJlcyAhPT0gMCkge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignYmNyeXB0X3Bia2RmIGZ1bmN0aW9uIHJldHVybmVkICcgK1xuXHRcdFx0ICAgICdmYWlsdXJlLCBwYXJhbWV0ZXJzIGludmFsaWQnKSk7XG5cdFx0fVxuXHRcdG91dCA9IEJ1ZmZlci5mcm9tKG91dCk7XG5cdFx0dmFyIGNrZXkgPSBvdXQuc2xpY2UoMCwgY2luZi5rZXlTaXplKTtcblx0XHR2YXIgaXYgPSBvdXQuc2xpY2UoY2luZi5rZXlTaXplLCBjaW5mLmtleVNpemUgKyBjaW5mLmJsb2NrU2l6ZSk7XG5cdFx0dmFyIGNpcGhlclN0cmVhbSA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGNpbmYub3BlbnNzbE5hbWUsXG5cdFx0ICAgIGNrZXksIGl2KTtcblx0XHRjaXBoZXJTdHJlYW0uc2V0QXV0b1BhZGRpbmcoZmFsc2UpO1xuXHRcdHZhciBjaHVuaywgY2h1bmtzID0gW107XG5cdFx0Y2lwaGVyU3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlLnRvU3RyaW5nKCkuaW5kZXhPZignYmFkIGRlY3J5cHQnKSAhPT0gLTEpIHtcblx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignSW5jb3JyZWN0IHBhc3NwaHJhc2UgJyArXG5cdFx0XHRcdCAgICAnc3VwcGxpZWQsIGNvdWxkIG5vdCBkZWNyeXB0IGtleScpKTtcblx0XHRcdH1cblx0XHRcdHRocm93IChlKTtcblx0XHR9KTtcblx0XHRjaXBoZXJTdHJlYW0ud3JpdGUocHJpdktleUJsb2IpO1xuXHRcdGNpcGhlclN0cmVhbS5lbmQoKTtcblx0XHR3aGlsZSAoKGNodW5rID0gY2lwaGVyU3RyZWFtLnJlYWQoKSkgIT09IG51bGwpXG5cdFx0XHRjaHVua3MucHVzaChjaHVuayk7XG5cdFx0cHJpdktleUJsb2IgPSBCdWZmZXIuY29uY2F0KGNodW5rcyk7XG5cdFx0YnJlYWs7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBFcnJvcihcblx0XHQgICAgJ09wZW5TU0gtZm9ybWF0IGtleSB1c2VzIHVua25vd24gS0RGIFwiJyArIGtkZiArICdcIicpKTtcblx0fVxuXG5cdGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe2J1ZmZlcjogcHJpdktleUJsb2J9KTtcblxuXHR2YXIgY2hlY2tJbnQxID0gYnVmLnJlYWRJbnQoKTtcblx0dmFyIGNoZWNrSW50MiA9IGJ1Zi5yZWFkSW50KCk7XG5cdGlmIChjaGVja0ludDEgIT09IGNoZWNrSW50Mikge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzcGhyYXNlIHN1cHBsaWVkLCBjb3VsZCBub3QgJyArXG5cdFx0ICAgICdkZWNyeXB0IGtleScpKTtcblx0fVxuXG5cdHZhciByZXQgPSB7fTtcblx0dmFyIGtleSA9IHJmYzQyNTMucmVhZEludGVybmFsKHJldCwgJ3ByaXZhdGUnLCBidWYucmVtYWluZGVyKCkpO1xuXG5cdGJ1Zi5za2lwKHJldC5jb25zdW1lZCk7XG5cblx0dmFyIGNvbW1lbnQgPSBidWYucmVhZFN0cmluZygpO1xuXHRrZXkuY29tbWVudCA9IGNvbW1lbnQ7XG5cblx0cmV0dXJuIChrZXkpO1xufVxuXG5mdW5jdGlvbiB3cml0ZShrZXksIG9wdGlvbnMpIHtcblx0dmFyIHB1YktleTtcblx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpXG5cdFx0cHViS2V5ID0ga2V5LnRvUHVibGljKCk7XG5cdGVsc2Vcblx0XHRwdWJLZXkgPSBrZXk7XG5cblx0dmFyIGNpcGhlciA9ICdub25lJztcblx0dmFyIGtkZiA9ICdub25lJztcblx0dmFyIGtkZm9wdHMgPSBCdWZmZXIuYWxsb2MoMCk7XG5cdHZhciBjaW5mID0geyBibG9ja1NpemU6IDggfTtcblx0dmFyIHBhc3NwaHJhc2U7XG5cdGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcblx0XHRwYXNzcGhyYXNlID0gb3B0aW9ucy5wYXNzcGhyYXNlO1xuXHRcdGlmICh0eXBlb2YgKHBhc3NwaHJhc2UpID09PSAnc3RyaW5nJylcblx0XHRcdHBhc3NwaHJhc2UgPSBCdWZmZXIuZnJvbShwYXNzcGhyYXNlLCAndXRmLTgnKTtcblx0XHRpZiAocGFzc3BocmFzZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRhc3NlcnQuYnVmZmVyKHBhc3NwaHJhc2UsICdvcHRpb25zLnBhc3NwaHJhc2UnKTtcblx0XHRcdGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRpb25zLmNpcGhlciwgJ29wdGlvbnMuY2lwaGVyJyk7XG5cdFx0XHRjaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcblx0XHRcdGlmIChjaXBoZXIgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0Y2lwaGVyID0gJ2FlczEyOC1jdHInO1xuXHRcdFx0Y2luZiA9IHV0aWxzLm9wZW5zc2hDaXBoZXJJbmZvKGNpcGhlcik7XG5cdFx0XHRrZGYgPSAnYmNyeXB0Jztcblx0XHR9XG5cdH1cblxuXHR2YXIgcHJpdkJ1Zjtcblx0aWYgKFByaXZhdGVLZXkuaXNQcml2YXRlS2V5KGtleSkpIHtcblx0XHRwcml2QnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdFx0dmFyIGNoZWNrSW50ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLnJlYWRVSW50MzJCRSgwKTtcblx0XHRwcml2QnVmLndyaXRlSW50KGNoZWNrSW50KTtcblx0XHRwcml2QnVmLndyaXRlSW50KGNoZWNrSW50KTtcblx0XHRwcml2QnVmLndyaXRlKGtleS50b0J1ZmZlcigncmZjNDI1MycpKTtcblx0XHRwcml2QnVmLndyaXRlU3RyaW5nKGtleS5jb21tZW50IHx8ICcnKTtcblxuXHRcdHZhciBuID0gMTtcblx0XHR3aGlsZSAocHJpdkJ1Zi5fb2Zmc2V0ICUgY2luZi5ibG9ja1NpemUgIT09IDApXG5cdFx0XHRwcml2QnVmLndyaXRlQ2hhcihuKyspO1xuXHRcdHByaXZCdWYgPSBwcml2QnVmLnRvQnVmZmVyKCk7XG5cdH1cblxuXHRzd2l0Y2ggKGtkZikge1xuXHRjYXNlICdub25lJzpcblx0XHRicmVhaztcblx0Y2FzZSAnYmNyeXB0Jzpcblx0XHR2YXIgc2FsdCA9IGNyeXB0by5yYW5kb21CeXRlcygxNik7XG5cdFx0dmFyIHJvdW5kcyA9IDE2O1xuXHRcdHZhciBrZGZzc2ggPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0XHRrZGZzc2gud3JpdGVCdWZmZXIoc2FsdCk7XG5cdFx0a2Rmc3NoLndyaXRlSW50KHJvdW5kcyk7XG5cdFx0a2Rmb3B0cyA9IGtkZnNzaC50b0J1ZmZlcigpO1xuXG5cdFx0aWYgKGJjcnlwdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRiY3J5cHQgPSByZXF1aXJlKCdiY3J5cHQtcGJrZGYnKTtcblx0XHR9XG5cdFx0dmFyIHBhc3MgPSBuZXcgVWludDhBcnJheShwYXNzcGhyYXNlKTtcblx0XHR2YXIgc2FsdGkgPSBuZXcgVWludDhBcnJheShzYWx0KTtcblx0XHQvKiBVc2UgdGhlIHBia2RmIHRvIGRlcml2ZSBib3RoIHRoZSBrZXkgYW5kIHRoZSBJVi4gKi9cblx0XHR2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoY2luZi5rZXlTaXplICsgY2luZi5ibG9ja1NpemUpO1xuXHRcdHZhciByZXMgPSBiY3J5cHQucGJrZGYocGFzcywgcGFzcy5sZW5ndGgsIHNhbHRpLCBzYWx0aS5sZW5ndGgsXG5cdFx0ICAgIG91dCwgb3V0Lmxlbmd0aCwgcm91bmRzKTtcblx0XHRpZiAocmVzICE9PSAwKSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdiY3J5cHRfcGJrZGYgZnVuY3Rpb24gcmV0dXJuZWQgJyArXG5cdFx0XHQgICAgJ2ZhaWx1cmUsIHBhcmFtZXRlcnMgaW52YWxpZCcpKTtcblx0XHR9XG5cdFx0b3V0ID0gQnVmZmVyLmZyb20ob3V0KTtcblx0XHR2YXIgY2tleSA9IG91dC5zbGljZSgwLCBjaW5mLmtleVNpemUpO1xuXHRcdHZhciBpdiA9IG91dC5zbGljZShjaW5mLmtleVNpemUsIGNpbmYua2V5U2l6ZSArIGNpbmYuYmxvY2tTaXplKTtcblxuXHRcdHZhciBjaXBoZXJTdHJlYW0gPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoY2luZi5vcGVuc3NsTmFtZSxcblx0XHQgICAgY2tleSwgaXYpO1xuXHRcdGNpcGhlclN0cmVhbS5zZXRBdXRvUGFkZGluZyhmYWxzZSk7XG5cdFx0dmFyIGNodW5rLCBjaHVua3MgPSBbXTtcblx0XHRjaXBoZXJTdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dGhyb3cgKGUpO1xuXHRcdH0pO1xuXHRcdGNpcGhlclN0cmVhbS53cml0ZShwcml2QnVmKTtcblx0XHRjaXBoZXJTdHJlYW0uZW5kKCk7XG5cdFx0d2hpbGUgKChjaHVuayA9IGNpcGhlclN0cmVhbS5yZWFkKCkpICE9PSBudWxsKVxuXHRcdFx0Y2h1bmtzLnB1c2goY2h1bmspO1xuXHRcdHByaXZCdWYgPSBCdWZmZXIuY29uY2F0KGNodW5rcyk7XG5cdFx0YnJlYWs7XG5cdGRlZmF1bHQ6XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2RmICcgKyBrZGYpKTtcblx0fVxuXG5cdHZhciBidWYgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblxuXHRidWYud3JpdGVDU3RyaW5nKE1BR0lDKTtcblx0YnVmLndyaXRlU3RyaW5nKGNpcGhlcik7XHQvKiBjaXBoZXIgKi9cblx0YnVmLndyaXRlU3RyaW5nKGtkZik7XHRcdC8qIGtkZiAqL1xuXHRidWYud3JpdGVCdWZmZXIoa2Rmb3B0cyk7XHQvKiBrZGZvcHRpb25zICovXG5cblx0YnVmLndyaXRlSW50KDEpO1x0XHQvKiBua2V5cyAqL1xuXHRidWYud3JpdGVCdWZmZXIocHViS2V5LnRvQnVmZmVyKCdyZmM0MjUzJykpO1xuXG5cdGlmIChwcml2QnVmKVxuXHRcdGJ1Zi53cml0ZUJ1ZmZlcihwcml2QnVmKTtcblxuXHRidWYgPSBidWYudG9CdWZmZXIoKTtcblxuXHR2YXIgaGVhZGVyO1xuXHRpZiAoUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5KSlcblx0XHRoZWFkZXIgPSAnT1BFTlNTSCBQUklWQVRFIEtFWSc7XG5cdGVsc2Vcblx0XHRoZWFkZXIgPSAnT1BFTlNTSCBQVUJMSUMgS0VZJztcblxuXHR2YXIgdG1wID0gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcblx0dmFyIGxlbiA9IHRtcC5sZW5ndGggKyAodG1wLmxlbmd0aCAvIDcwKSArXG5cdCAgICAxOCArIDE2ICsgaGVhZGVyLmxlbmd0aCoyICsgMTA7XG5cdGJ1ZiA9IEJ1ZmZlci5hbGxvYyhsZW4pO1xuXHR2YXIgbyA9IDA7XG5cdG8gKz0gYnVmLndyaXRlKCctLS0tLUJFR0lOICcgKyBoZWFkZXIgKyAnLS0tLS1cXG4nLCBvKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyApIHtcblx0XHR2YXIgbGltaXQgPSBpICsgNzA7XG5cdFx0aWYgKGxpbWl0ID4gdG1wLmxlbmd0aClcblx0XHRcdGxpbWl0ID0gdG1wLmxlbmd0aDtcblx0XHRvICs9IGJ1Zi53cml0ZSh0bXAuc2xpY2UoaSwgbGltaXQpLCBvKTtcblx0XHRidWZbbysrXSA9IDEwO1xuXHRcdGkgPSBsaW1pdDtcblx0fVxuXHRvICs9IGJ1Zi53cml0ZSgnLS0tLS1FTkQgJyArIGhlYWRlciArICctLS0tLVxcbicsIG8pO1xuXG5cdHJldHVybiAoYnVmLnNsaWNlKDAsIG8pKTtcbn1cbiIsIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0cmVhZDogcmVhZCxcblx0d3JpdGU6IHdyaXRlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgcmZjNDI1MyA9IHJlcXVpcmUoJy4vcmZjNDI1MycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcblxudmFyIHNzaHByaXYgPSByZXF1aXJlKCcuL3NzaC1wcml2YXRlJyk7XG5cbi8qSlNTVFlMRUQqL1xudmFyIFNTSEtFWV9SRSA9IC9eKFthLXowLTktXSspWyBcXHRdKyhbYS16QS1aMC05K1xcL10rWz1dKikoWyBcXHRdKyhbXiBcXHRdW15cXG5dKltcXG5dKik/KT8kLztcbi8qSlNTVFlMRUQqL1xudmFyIFNTSEtFWV9SRTIgPSAvXihbYS16MC05LV0rKVsgXFx0XFxuXSsoW2EtekEtWjAtOStcXC9dW2EtekEtWjAtOStcXC8gXFx0XFxuPV0qKShbXmEtekEtWjAtOStcXC8gXFx0XFxuPV0uKik/JC87XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGJ1ZikgIT09ICdzdHJpbmcnKSB7XG5cdFx0YXNzZXJ0LmJ1ZmZlcihidWYsICdidWYnKTtcblx0XHRidWYgPSBidWYudG9TdHJpbmcoJ2FzY2lpJyk7XG5cdH1cblxuXHR2YXIgdHJpbW1lZCA9IGJ1Zi50cmltKCkucmVwbGFjZSgvW1xcXFxcXHJdL2csICcnKTtcblx0dmFyIG0gPSB0cmltbWVkLm1hdGNoKFNTSEtFWV9SRSk7XG5cdGlmICghbSlcblx0XHRtID0gdHJpbW1lZC5tYXRjaChTU0hLRVlfUkUyKTtcblx0YXNzZXJ0Lm9rKG0sICdrZXkgbXVzdCBtYXRjaCByZWdleCcpO1xuXG5cdHZhciB0eXBlID0gcmZjNDI1My5hbGdUb0tleVR5cGUobVsxXSk7XG5cdHZhciBrYnVmID0gQnVmZmVyLmZyb20obVsyXSwgJ2Jhc2U2NCcpO1xuXG5cdC8qXG5cdCAqIFRoaXMgaXMgYSBiaXQgdHJpY2t5LiBJZiB3ZSBtYW5hZ2VkIHRvIHBhcnNlIHRoZSBrZXkgYW5kIGxvY2F0ZSB0aGVcblx0ICoga2V5IGNvbW1lbnQgd2l0aCB0aGUgcmVnZXgsIHRoZW4gZG8gYSBub24tcGFydGlhbCByZWFkIGFuZCBhc3NlcnRcblx0ICogdGhhdCB3ZSBoYXZlIGNvbnN1bWVkIGFsbCBieXRlcy4gSWYgd2UgY291bGRuJ3QgbG9jYXRlIHRoZSBrZXlcblx0ICogY29tbWVudCwgdGhvdWdoLCB0aGVyZSBtYXkgYmUgd2hpdGVzcGFjZSBzaGVuYW5pZ2FucyBnb2luZyBvbiB0aGF0XG5cdCAqIGhhdmUgY29uam9pbmVkIHRoZSBjb21tZW50IHRvIHRoZSByZXN0IG9mIHRoZSBrZXkuIFdlIGRvIGEgcGFydGlhbFxuXHQgKiByZWFkIGluIHRoaXMgY2FzZSB0byB0cnkgdG8gbWFrZSB0aGUgYmVzdCBvdXQgb2YgYSBzb3JyeSBzaXR1YXRpb24uXG5cdCAqL1xuXHR2YXIga2V5O1xuXHR2YXIgcmV0ID0ge307XG5cdGlmIChtWzRdKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGtleSA9IHJmYzQyNTMucmVhZChrYnVmKTtcblxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG0gPSB0cmltbWVkLm1hdGNoKFNTSEtFWV9SRTIpO1xuXHRcdFx0YXNzZXJ0Lm9rKG0sICdrZXkgbXVzdCBtYXRjaCByZWdleCcpO1xuXHRcdFx0a2J1ZiA9IEJ1ZmZlci5mcm9tKG1bMl0sICdiYXNlNjQnKTtcblx0XHRcdGtleSA9IHJmYzQyNTMucmVhZEludGVybmFsKHJldCwgJ3B1YmxpYycsIGtidWYpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRrZXkgPSByZmM0MjUzLnJlYWRJbnRlcm5hbChyZXQsICdwdWJsaWMnLCBrYnVmKTtcblx0fVxuXG5cdGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlLCBrZXkudHlwZSk7XG5cblx0aWYgKG1bNF0gJiYgbVs0XS5sZW5ndGggPiAwKSB7XG5cdFx0a2V5LmNvbW1lbnQgPSBtWzRdO1xuXG5cdH0gZWxzZSBpZiAocmV0LmNvbnN1bWVkKSB7XG5cdFx0Lypcblx0XHQgKiBOb3cgdGhlIG1hZ2ljOiB0cnlpbmcgdG8gcmVjb3ZlciB0aGUga2V5IGNvbW1lbnQgd2hlbiBpdCdzXG5cdFx0ICogZ290dGVuIGNvbmpvaW5lZCB0byB0aGUga2V5IG9yIG90aGVyd2lzZSBzaGVuYW5pZ2FuJ2QuXG5cdFx0ICpcblx0XHQgKiBXb3JrIG91dCBob3cgbXVjaCBiYXNlNjQgd2UgdXNlZCwgdGhlbiBkcm9wIGFsbCBub24tYmFzZTY0XG5cdFx0ICogY2hhcnMgZnJvbSB0aGUgYmVnaW5uaW5nIHVwIHRvIHRoaXMgcG9pbnQgaW4gdGhlIHRoZSBzdHJpbmcuXG5cdFx0ICogVGhlbiBvZmZzZXQgaW4gdGhpcyBhbmQgdHJ5IHRvIG1ha2UgdXAgZm9yIG1pc3NpbmcgPSBjaGFycy5cblx0XHQgKi9cblx0XHR2YXIgZGF0YSA9IG1bMl0gKyAobVszXSA/IG1bM10gOiAnJyk7XG5cdFx0dmFyIHJlYWxPZmZzZXQgPSBNYXRoLmNlaWwocmV0LmNvbnN1bWVkIC8gMykgKiA0O1xuXHRcdGRhdGEgPSBkYXRhLnNsaWNlKDAsIHJlYWxPZmZzZXQgLSAyKS4gLypKU1NUWUxFRCovXG5cdFx0ICAgIHJlcGxhY2UoL1teYS16QS1aMC05K1xcLz1dL2csICcnKSArXG5cdFx0ICAgIGRhdGEuc2xpY2UocmVhbE9mZnNldCAtIDIpO1xuXG5cdFx0dmFyIHBhZGRpbmcgPSByZXQuY29uc3VtZWQgJSAzO1xuXHRcdGlmIChwYWRkaW5nID4gMCAmJlxuXHRcdCAgICBkYXRhLnNsaWNlKHJlYWxPZmZzZXQgLSAxLCByZWFsT2Zmc2V0KSAhPT0gJz0nKVxuXHRcdFx0cmVhbE9mZnNldC0tO1xuXHRcdHdoaWxlIChkYXRhLnNsaWNlKHJlYWxPZmZzZXQsIHJlYWxPZmZzZXQgKyAxKSA9PT0gJz0nKVxuXHRcdFx0cmVhbE9mZnNldCsrO1xuXG5cdFx0LyogRmluYWxseSwgZ3JhYiB3aGF0IHdlIHRoaW5rIGlzIHRoZSBjb21tZW50ICYgY2xlYW4gaXQgdXAuICovXG5cdFx0dmFyIHRyYWlsZXIgPSBkYXRhLnNsaWNlKHJlYWxPZmZzZXQpO1xuXHRcdHRyYWlsZXIgPSB0cmFpbGVyLnJlcGxhY2UoL1tcXHJcXG5dL2csICcgJykuXG5cdFx0ICAgIHJlcGxhY2UoL15cXHMrLywgJycpO1xuXHRcdGlmICh0cmFpbGVyLm1hdGNoKC9eW2EtekEtWjAtOV0vKSlcblx0XHRcdGtleS5jb21tZW50ID0gdHJhaWxlcjtcblx0fVxuXG5cdHJldHVybiAoa2V5KTtcbn1cblxuZnVuY3Rpb24gd3JpdGUoa2V5LCBvcHRpb25zKSB7XG5cdGFzc2VydC5vYmplY3Qoa2V5KTtcblx0aWYgKCFLZXkuaXNLZXkoa2V5KSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNdXN0IGJlIGEgcHVibGljIGtleScpKTtcblxuXHR2YXIgcGFydHMgPSBbXTtcblx0dmFyIGFsZyA9IHJmYzQyNTMua2V5VHlwZVRvQWxnKGtleSk7XG5cdHBhcnRzLnB1c2goYWxnKTtcblxuXHR2YXIgYnVmID0gcmZjNDI1My53cml0ZShrZXkpO1xuXHRwYXJ0cy5wdXNoKGJ1Zi50b1N0cmluZygnYmFzZTY0JykpO1xuXG5cdGlmIChrZXkuY29tbWVudClcblx0XHRwYXJ0cy5wdXNoKGtleS5jb21tZW50KTtcblxuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKHBhcnRzLmpvaW4oJyAnKSkpO1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTYgSm95ZW50LCBJbmMuXG5cbnZhciB4NTA5ID0gcmVxdWlyZSgnLi94NTA5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRyZWFkOiByZWFkLFxuXHR2ZXJpZnk6IHg1MDkudmVyaWZ5LFxuXHRzaWduOiB4NTA5LnNpZ24sXG5cdHdyaXRlOiB3cml0ZVxufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4uL2FsZ3MnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgS2V5ID0gcmVxdWlyZSgnLi4va2V5Jyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4uL3ByaXZhdGUta2V5Jyk7XG52YXIgcGVtID0gcmVxdWlyZSgnLi9wZW0nKTtcbnZhciBJZGVudGl0eSA9IHJlcXVpcmUoJy4uL2lkZW50aXR5Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG52YXIgQ2VydGlmaWNhdGUgPSByZXF1aXJlKCcuLi9jZXJ0aWZpY2F0ZScpO1xuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIChidWYpICE9PSAnc3RyaW5nJykge1xuXHRcdGFzc2VydC5idWZmZXIoYnVmLCAnYnVmJyk7XG5cdFx0YnVmID0gYnVmLnRvU3RyaW5nKCdhc2NpaScpO1xuXHR9XG5cblx0dmFyIGxpbmVzID0gYnVmLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rL2cpO1xuXG5cdHZhciBtO1xuXHR2YXIgc2kgPSAtMTtcblx0d2hpbGUgKCFtICYmIHNpIDwgbGluZXMubGVuZ3RoKSB7XG5cdFx0bSA9IGxpbmVzWysrc2ldLm1hdGNoKC8qSlNTVFlMRUQqL1xuXHRcdCAgICAvWy1dK1sgXSpCRUdJTiBDRVJUSUZJQ0FURVsgXSpbLV0rLyk7XG5cdH1cblx0YXNzZXJ0Lm9rKG0sICdpbnZhbGlkIFBFTSBoZWFkZXInKTtcblxuXHR2YXIgbTI7XG5cdHZhciBlaSA9IGxpbmVzLmxlbmd0aDtcblx0d2hpbGUgKCFtMiAmJiBlaSA+IDApIHtcblx0XHRtMiA9IGxpbmVzWy0tZWldLm1hdGNoKC8qSlNTVFlMRUQqL1xuXHRcdCAgICAvWy1dK1sgXSpFTkQgQ0VSVElGSUNBVEVbIF0qWy1dKy8pO1xuXHR9XG5cdGFzc2VydC5vayhtMiwgJ2ludmFsaWQgUEVNIGZvb3RlcicpO1xuXG5cdGxpbmVzID0gbGluZXMuc2xpY2Uoc2ksIGVpICsgMSk7XG5cblx0dmFyIGhlYWRlcnMgPSB7fTtcblx0d2hpbGUgKHRydWUpIHtcblx0XHRsaW5lcyA9IGxpbmVzLnNsaWNlKDEpO1xuXHRcdG0gPSBsaW5lc1swXS5tYXRjaCgvKkpTU1RZTEVEKi9cblx0XHQgICAgL14oW0EtWmEtejAtOS1dKyk6ICguKykkLyk7XG5cdFx0aWYgKCFtKVxuXHRcdFx0YnJlYWs7XG5cdFx0aGVhZGVyc1ttWzFdLnRvTG93ZXJDYXNlKCldID0gbVsyXTtcblx0fVxuXG5cdC8qIENob3Agb2ZmIHRoZSBmaXJzdCBhbmQgbGFzdCBsaW5lcyAqL1xuXHRsaW5lcyA9IGxpbmVzLnNsaWNlKDAsIC0xKS5qb2luKCcnKTtcblx0YnVmID0gQnVmZmVyLmZyb20obGluZXMsICdiYXNlNjQnKTtcblxuXHRyZXR1cm4gKHg1MDkucmVhZChidWYsIG9wdGlvbnMpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGUoY2VydCwgb3B0aW9ucykge1xuXHR2YXIgZGJ1ZiA9IHg1MDkud3JpdGUoY2VydCwgb3B0aW9ucyk7XG5cblx0dmFyIGhlYWRlciA9ICdDRVJUSUZJQ0FURSc7XG5cdHZhciB0bXAgPSBkYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcblx0dmFyIGxlbiA9IHRtcC5sZW5ndGggKyAodG1wLmxlbmd0aCAvIDY0KSArXG5cdCAgICAxOCArIDE2ICsgaGVhZGVyLmxlbmd0aCoyICsgMTA7XG5cdHZhciBidWYgPSBCdWZmZXIuYWxsb2MobGVuKTtcblx0dmFyIG8gPSAwO1xuXHRvICs9IGJ1Zi53cml0ZSgnLS0tLS1CRUdJTiAnICsgaGVhZGVyICsgJy0tLS0tXFxuJywgbyk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgKSB7XG5cdFx0dmFyIGxpbWl0ID0gaSArIDY0O1xuXHRcdGlmIChsaW1pdCA+IHRtcC5sZW5ndGgpXG5cdFx0XHRsaW1pdCA9IHRtcC5sZW5ndGg7XG5cdFx0byArPSBidWYud3JpdGUodG1wLnNsaWNlKGksIGxpbWl0KSwgbyk7XG5cdFx0YnVmW28rK10gPSAxMDtcblx0XHRpID0gbGltaXQ7XG5cdH1cblx0byArPSBidWYud3JpdGUoJy0tLS0tRU5EICcgKyBoZWFkZXIgKyAnLS0tLS1cXG4nLCBvKTtcblxuXHRyZXR1cm4gKGJ1Zi5zbGljZSgwLCBvKSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAxNyBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJlYWQ6IHJlYWQsXG5cdHZlcmlmeTogdmVyaWZ5LFxuXHRzaWduOiBzaWduLFxuXHRzaWduQXN5bmM6IHNpZ25Bc3luYyxcblx0d3JpdGU6IHdyaXRlXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi4vYWxncycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuLi9rZXknKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi4vcHJpdmF0ZS1rZXknKTtcbnZhciBwZW0gPSByZXF1aXJlKCcuL3BlbScpO1xudmFyIElkZW50aXR5ID0gcmVxdWlyZSgnLi4vaWRlbnRpdHknKTtcbnZhciBTaWduYXR1cmUgPSByZXF1aXJlKCcuLi9zaWduYXR1cmUnKTtcbnZhciBDZXJ0aWZpY2F0ZSA9IHJlcXVpcmUoJy4uL2NlcnRpZmljYXRlJyk7XG52YXIgcGtjczggPSByZXF1aXJlKCcuL3BrY3M4Jyk7XG5cbi8qXG4gKiBUaGlzIGZpbGUgaXMgYmFzZWQgb24gUkZDNTI4MCAoWC41MDkpLlxuICovXG5cbi8qIEhlbHBlciB0byByZWFkIGluIGEgc2luZ2xlIG1waW50ICovXG5mdW5jdGlvbiByZWFkTVBJbnQoZGVyLCBubSkge1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwoZGVyLnBlZWsoKSwgYXNuMS5CZXIuSW50ZWdlcixcblx0ICAgIG5tICsgJyBpcyBub3QgYW4gSW50ZWdlcicpO1xuXHRyZXR1cm4gKHV0aWxzLm1wTm9ybWFsaXplKGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpKSk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmeShjZXJ0LCBrZXkpIHtcblx0dmFyIHNpZyA9IGNlcnQuc2lnbmF0dXJlcy54NTA5O1xuXHRhc3NlcnQub2JqZWN0KHNpZywgJ3g1MDkgc2lnbmF0dXJlJyk7XG5cblx0dmFyIGFsZ1BhcnRzID0gc2lnLmFsZ28uc3BsaXQoJy0nKTtcblx0aWYgKGFsZ1BhcnRzWzBdICE9PSBrZXkudHlwZSlcblx0XHRyZXR1cm4gKGZhbHNlKTtcblxuXHR2YXIgYmxvYiA9IHNpZy5jYWNoZTtcblx0aWYgKGJsb2IgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBkZXIgPSBuZXcgYXNuMS5CZXJXcml0ZXIoKTtcblx0XHR3cml0ZVRCU0NlcnQoY2VydCwgZGVyKTtcblx0XHRibG9iID0gZGVyLmJ1ZmZlcjtcblx0fVxuXG5cdHZhciB2ZXJpZmllciA9IGtleS5jcmVhdGVWZXJpZnkoYWxnUGFydHNbMV0pO1xuXHR2ZXJpZmllci53cml0ZShibG9iKTtcblx0cmV0dXJuICh2ZXJpZmllci52ZXJpZnkoc2lnLnNpZ25hdHVyZSkpO1xufVxuXG5mdW5jdGlvbiBMb2NhbChpKSB7XG5cdHJldHVybiAoYXNuMS5CZXIuQ29udGV4dCB8IGFzbjEuQmVyLkNvbnN0cnVjdG9yIHwgaSk7XG59XG5cbmZ1bmN0aW9uIENvbnRleHQoaSkge1xuXHRyZXR1cm4gKGFzbjEuQmVyLkNvbnRleHQgfCBpKTtcbn1cblxudmFyIFNJR05fQUxHUyA9IHtcblx0J3JzYS1tZDUnOiAnMS4yLjg0MC4xMTM1NDkuMS4xLjQnLFxuXHQncnNhLXNoYTEnOiAnMS4yLjg0MC4xMTM1NDkuMS4xLjUnLFxuXHQncnNhLXNoYTI1Nic6ICcxLjIuODQwLjExMzU0OS4xLjEuMTEnLFxuXHQncnNhLXNoYTM4NCc6ICcxLjIuODQwLjExMzU0OS4xLjEuMTInLFxuXHQncnNhLXNoYTUxMic6ICcxLjIuODQwLjExMzU0OS4xLjEuMTMnLFxuXHQnZHNhLXNoYTEnOiAnMS4yLjg0MC4xMDA0MC40LjMnLFxuXHQnZHNhLXNoYTI1Nic6ICcyLjE2Ljg0MC4xLjEwMS4zLjQuMy4yJyxcblx0J2VjZHNhLXNoYTEnOiAnMS4yLjg0MC4xMDA0NS40LjEnLFxuXHQnZWNkc2Etc2hhMjU2JzogJzEuMi44NDAuMTAwNDUuNC4zLjInLFxuXHQnZWNkc2Etc2hhMzg0JzogJzEuMi44NDAuMTAwNDUuNC4zLjMnLFxuXHQnZWNkc2Etc2hhNTEyJzogJzEuMi44NDAuMTAwNDUuNC4zLjQnLFxuXHQnZWQyNTUxOS1zaGE1MTInOiAnMS4zLjEwMS4xMTInXG59O1xuT2JqZWN0LmtleXMoU0lHTl9BTEdTKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFNJR05fQUxHU1tTSUdOX0FMR1Nba11dID0gaztcbn0pO1xuU0lHTl9BTEdTWycxLjMuMTQuMy4yLjMnXSA9ICdyc2EtbWQ1JztcblNJR05fQUxHU1snMS4zLjE0LjMuMi4yOSddID0gJ3JzYS1zaGExJztcblxudmFyIEVYVFMgPSB7XG5cdCdpc3N1ZXJLZXlJZCc6ICcyLjUuMjkuMzUnLFxuXHQnYWx0TmFtZSc6ICcyLjUuMjkuMTcnLFxuXHQnYmFzaWNDb25zdHJhaW50cyc6ICcyLjUuMjkuMTknLFxuXHQna2V5VXNhZ2UnOiAnMi41LjI5LjE1Jyxcblx0J2V4dEtleVVzYWdlJzogJzIuNS4yOS4zNydcbn07XG5cbmZ1bmN0aW9uIHJlYWQoYnVmLCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGJ1ZikgPT09ICdzdHJpbmcnKSB7XG5cdFx0YnVmID0gQnVmZmVyLmZyb20oYnVmLCAnYmluYXJ5Jyk7XG5cdH1cblx0YXNzZXJ0LmJ1ZmZlcihidWYsICdidWYnKTtcblxuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyUmVhZGVyKGJ1Zik7XG5cblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRpZiAoTWF0aC5hYnMoZGVyLmxlbmd0aCAtIGRlci5yZW1haW4pID4gMSkge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0RFUiBzZXF1ZW5jZSBkb2VzIG5vdCBjb250YWluIHdob2xlIGJ5dGUgJyArXG5cdFx0ICAgICdzdHJlYW0nKSk7XG5cdH1cblxuXHR2YXIgdGJzU3RhcnQgPSBkZXIub2Zmc2V0O1xuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdHZhciBzaWdPZmZzZXQgPSBkZXIub2Zmc2V0ICsgZGVyLmxlbmd0aDtcblx0dmFyIHRic0VuZCA9IHNpZ09mZnNldDtcblxuXHRpZiAoZGVyLnBlZWsoKSA9PT0gTG9jYWwoMCkpIHtcblx0XHRkZXIucmVhZFNlcXVlbmNlKExvY2FsKDApKTtcblx0XHR2YXIgdmVyc2lvbiA9IGRlci5yZWFkSW50KCk7XG5cdFx0YXNzZXJ0Lm9rKHZlcnNpb24gPD0gMyxcblx0XHQgICAgJ29ubHkgeC41MDkgdmVyc2lvbnMgdXAgdG8gdjMgc3VwcG9ydGVkJyk7XG5cdH1cblxuXHR2YXIgY2VydCA9IHt9O1xuXHRjZXJ0LnNpZ25hdHVyZXMgPSB7fTtcblx0dmFyIHNpZyA9IChjZXJ0LnNpZ25hdHVyZXMueDUwOSA9IHt9KTtcblx0c2lnLmV4dHJhcyA9IHt9O1xuXG5cdGNlcnQuc2VyaWFsID0gcmVhZE1QSW50KGRlciwgJ3NlcmlhbCcpO1xuXG5cdGRlci5yZWFkU2VxdWVuY2UoKTtcblx0dmFyIGFmdGVyID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdHZhciBjZXJ0QWxnT2lkID0gZGVyLnJlYWRPSUQoKTtcblx0dmFyIGNlcnRBbGcgPSBTSUdOX0FMR1NbY2VydEFsZ09pZF07XG5cdGlmIChjZXJ0QWxnID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndW5rbm93biBzaWduYXR1cmUgYWxnb3JpdGhtICcgKyBjZXJ0QWxnT2lkKSk7XG5cblx0ZGVyLl9vZmZzZXQgPSBhZnRlcjtcblx0Y2VydC5pc3N1ZXIgPSBJZGVudGl0eS5wYXJzZUFzbjEoZGVyKTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdGNlcnQudmFsaWRGcm9tID0gcmVhZERhdGUoZGVyKTtcblx0Y2VydC52YWxpZFVudGlsID0gcmVhZERhdGUoZGVyKTtcblxuXHRjZXJ0LnN1YmplY3RzID0gW0lkZW50aXR5LnBhcnNlQXNuMShkZXIpXTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdGFmdGVyID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdGNlcnQuc3ViamVjdEtleSA9IHBrY3M4LnJlYWRQa2NzOCh1bmRlZmluZWQsICdwdWJsaWMnLCBkZXIpO1xuXHRkZXIuX29mZnNldCA9IGFmdGVyO1xuXG5cdC8qIGlzc3VlclVuaXF1ZUlEICovXG5cdGlmIChkZXIucGVlaygpID09PSBMb2NhbCgxKSkge1xuXHRcdGRlci5yZWFkU2VxdWVuY2UoTG9jYWwoMSkpO1xuXHRcdHNpZy5leHRyYXMuaXNzdWVyVW5pcXVlSUQgPVxuXHRcdCAgICBidWYuc2xpY2UoZGVyLm9mZnNldCwgZGVyLm9mZnNldCArIGRlci5sZW5ndGgpO1xuXHRcdGRlci5fb2Zmc2V0ICs9IGRlci5sZW5ndGg7XG5cdH1cblxuXHQvKiBzdWJqZWN0VW5pcXVlSUQgKi9cblx0aWYgKGRlci5wZWVrKCkgPT09IExvY2FsKDIpKSB7XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZShMb2NhbCgyKSk7XG5cdFx0c2lnLmV4dHJhcy5zdWJqZWN0VW5pcXVlSUQgPVxuXHRcdCAgICBidWYuc2xpY2UoZGVyLm9mZnNldCwgZGVyLm9mZnNldCArIGRlci5sZW5ndGgpO1xuXHRcdGRlci5fb2Zmc2V0ICs9IGRlci5sZW5ndGg7XG5cdH1cblxuXHQvKiBleHRlbnNpb25zICovXG5cdGlmIChkZXIucGVlaygpID09PSBMb2NhbCgzKSkge1xuXHRcdGRlci5yZWFkU2VxdWVuY2UoTG9jYWwoMykpO1xuXHRcdHZhciBleHRFbmQgPSBkZXIub2Zmc2V0ICsgZGVyLmxlbmd0aDtcblx0XHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cblx0XHR3aGlsZSAoZGVyLm9mZnNldCA8IGV4dEVuZClcblx0XHRcdHJlYWRFeHRlbnNpb24oY2VydCwgYnVmLCBkZXIpO1xuXG5cdFx0YXNzZXJ0LnN0cmljdEVxdWFsKGRlci5vZmZzZXQsIGV4dEVuZCk7XG5cdH1cblxuXHRhc3NlcnQuc3RyaWN0RXF1YWwoZGVyLm9mZnNldCwgc2lnT2Zmc2V0KTtcblxuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdGFmdGVyID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdHZhciBzaWdBbGdPaWQgPSBkZXIucmVhZE9JRCgpO1xuXHR2YXIgc2lnQWxnID0gU0lHTl9BTEdTW3NpZ0FsZ09pZF07XG5cdGlmIChzaWdBbGcgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCd1bmtub3duIHNpZ25hdHVyZSBhbGdvcml0aG0gJyArIHNpZ0FsZ09pZCkpO1xuXHRkZXIuX29mZnNldCA9IGFmdGVyO1xuXG5cdHZhciBzaWdEYXRhID0gZGVyLnJlYWRTdHJpbmcoYXNuMS5CZXIuQml0U3RyaW5nLCB0cnVlKTtcblx0aWYgKHNpZ0RhdGFbMF0gPT09IDApXG5cdFx0c2lnRGF0YSA9IHNpZ0RhdGEuc2xpY2UoMSk7XG5cdHZhciBhbGdQYXJ0cyA9IHNpZ0FsZy5zcGxpdCgnLScpO1xuXG5cdHNpZy5zaWduYXR1cmUgPSBTaWduYXR1cmUucGFyc2Uoc2lnRGF0YSwgYWxnUGFydHNbMF0sICdhc24xJyk7XG5cdHNpZy5zaWduYXR1cmUuaGFzaEFsZ29yaXRobSA9IGFsZ1BhcnRzWzFdO1xuXHRzaWcuYWxnbyA9IHNpZ0FsZztcblx0c2lnLmNhY2hlID0gYnVmLnNsaWNlKHRic1N0YXJ0LCB0YnNFbmQpO1xuXG5cdHJldHVybiAobmV3IENlcnRpZmljYXRlKGNlcnQpKTtcbn1cblxuZnVuY3Rpb24gcmVhZERhdGUoZGVyKSB7XG5cdGlmIChkZXIucGVlaygpID09PSBhc24xLkJlci5VVENUaW1lKSB7XG5cdFx0cmV0dXJuICh1dGNUaW1lVG9EYXRlKGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLlVUQ1RpbWUpKSk7XG5cdH0gZWxzZSBpZiAoZGVyLnBlZWsoKSA9PT0gYXNuMS5CZXIuR2VuZXJhbGl6ZWRUaW1lKSB7XG5cdFx0cmV0dXJuIChnVGltZVRvRGF0ZShkZXIucmVhZFN0cmluZyhhc24xLkJlci5HZW5lcmFsaXplZFRpbWUpKSk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0ZSBmb3JtYXQnKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gd3JpdGVEYXRlKGRlciwgZGF0ZSkge1xuXHRpZiAoZGF0ZS5nZXRVVENGdWxsWWVhcigpID49IDIwNTAgfHwgZGF0ZS5nZXRVVENGdWxsWWVhcigpIDwgMTk1MCkge1xuXHRcdGRlci53cml0ZVN0cmluZyhkYXRlVG9HVGltZShkYXRlKSwgYXNuMS5CZXIuR2VuZXJhbGl6ZWRUaW1lKTtcblx0fSBlbHNlIHtcblx0XHRkZXIud3JpdGVTdHJpbmcoZGF0ZVRvVVRDVGltZShkYXRlKSwgYXNuMS5CZXIuVVRDVGltZSk7XG5cdH1cbn1cblxuLyogUkZDNTI4MCwgc2VjdGlvbiA0LjIuMS42IChHZW5lcmFsTmFtZSB0eXBlKSAqL1xudmFyIEFMVE5BTUUgPSB7XG5cdE90aGVyTmFtZTogTG9jYWwoMCksXG5cdFJGQzgyMk5hbWU6IENvbnRleHQoMSksXG5cdEROU05hbWU6IENvbnRleHQoMiksXG5cdFg0MDBBZGRyZXNzOiBMb2NhbCgzKSxcblx0RGlyZWN0b3J5TmFtZTogTG9jYWwoNCksXG5cdEVESVBhcnR5TmFtZTogTG9jYWwoNSksXG5cdFVSSTogQ29udGV4dCg2KSxcblx0SVBBZGRyZXNzOiBDb250ZXh0KDcpLFxuXHRPSUQ6IENvbnRleHQoOClcbn07XG5cbi8qIFJGQzUyODAsIHNlY3Rpb24gNC4yLjEuMTIgKEtleVB1cnBvc2VJZCkgKi9cbnZhciBFWFRQVVJQT1NFID0ge1xuXHQnc2VydmVyQXV0aCc6ICcxLjMuNi4xLjUuNS43LjMuMScsXG5cdCdjbGllbnRBdXRoJzogJzEuMy42LjEuNS41LjcuMy4yJyxcblx0J2NvZGVTaWduaW5nJzogJzEuMy42LjEuNS41LjcuMy4zJyxcblxuXHQvKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9vaWQtZG9jcy9ibG9iL21hc3Rlci9yb290Lm1kICovXG5cdCdqb3llbnREb2NrZXInOiAnMS4zLjYuMS40LjEuMzg2NzguMS40LjEnLFxuXHQnam95ZW50Q21vbic6ICcxLjMuNi4xLjQuMS4zODY3OC4xLjQuMidcbn07XG52YXIgRVhUUFVSUE9TRV9SRVYgPSB7fTtcbk9iamVjdC5rZXlzKEVYVFBVUlBPU0UpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0RVhUUFVSUE9TRV9SRVZbRVhUUFVSUE9TRVtrXV0gPSBrO1xufSk7XG5cbnZhciBLRVlVU0VCSVRTID0gW1xuXHQnc2lnbmF0dXJlJywgJ2lkZW50aXR5JywgJ2tleUVuY3J5cHRpb24nLFxuXHQnZW5jcnlwdGlvbicsICdrZXlBZ3JlZW1lbnQnLCAnY2EnLCAnY3JsJ1xuXTtcblxuZnVuY3Rpb24gcmVhZEV4dGVuc2lvbihjZXJ0LCBidWYsIGRlcikge1xuXHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdHZhciBhZnRlciA9IGRlci5vZmZzZXQgKyBkZXIubGVuZ3RoO1xuXHR2YXIgZXh0SWQgPSBkZXIucmVhZE9JRCgpO1xuXHR2YXIgaWQ7XG5cdHZhciBzaWcgPSBjZXJ0LnNpZ25hdHVyZXMueDUwOTtcblx0aWYgKCFzaWcuZXh0cmFzLmV4dHMpXG5cdFx0c2lnLmV4dHJhcy5leHRzID0gW107XG5cblx0dmFyIGNyaXRpY2FsO1xuXHRpZiAoZGVyLnBlZWsoKSA9PT0gYXNuMS5CZXIuQm9vbGVhbilcblx0XHRjcml0aWNhbCA9IGRlci5yZWFkQm9vbGVhbigpO1xuXG5cdHN3aXRjaCAoZXh0SWQpIHtcblx0Y2FzZSAoRVhUUy5iYXNpY0NvbnN0cmFpbnRzKTpcblx0XHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdFx0dmFyIGJjRW5kID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdFx0dmFyIGNhID0gZmFsc2U7XG5cdFx0aWYgKGRlci5wZWVrKCkgPT09IGFzbjEuQmVyLkJvb2xlYW4pXG5cdFx0XHRjYSA9IGRlci5yZWFkQm9vbGVhbigpO1xuXHRcdGlmIChjZXJ0LnB1cnBvc2VzID09PSB1bmRlZmluZWQpXG5cdFx0XHRjZXJ0LnB1cnBvc2VzID0gW107XG5cdFx0aWYgKGNhID09PSB0cnVlKVxuXHRcdFx0Y2VydC5wdXJwb3Nlcy5wdXNoKCdjYScpO1xuXHRcdHZhciBiYyA9IHsgb2lkOiBleHRJZCwgY3JpdGljYWw6IGNyaXRpY2FsIH07XG5cdFx0aWYgKGRlci5vZmZzZXQgPCBiY0VuZCAmJiBkZXIucGVlaygpID09PSBhc24xLkJlci5JbnRlZ2VyKVxuXHRcdFx0YmMucGF0aExlbiA9IGRlci5yZWFkSW50KCk7XG5cdFx0c2lnLmV4dHJhcy5leHRzLnB1c2goYmMpO1xuXHRcdGJyZWFrO1xuXHRjYXNlIChFWFRTLmV4dEtleVVzYWdlKTpcblx0XHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdFx0aWYgKGNlcnQucHVycG9zZXMgPT09IHVuZGVmaW5lZClcblx0XHRcdGNlcnQucHVycG9zZXMgPSBbXTtcblx0XHR2YXIgZWtFbmQgPSBkZXIub2Zmc2V0ICsgZGVyLmxlbmd0aDtcblx0XHR3aGlsZSAoZGVyLm9mZnNldCA8IGVrRW5kKSB7XG5cdFx0XHR2YXIgb2lkID0gZGVyLnJlYWRPSUQoKTtcblx0XHRcdGNlcnQucHVycG9zZXMucHVzaChFWFRQVVJQT1NFX1JFVltvaWRdIHx8IG9pZCk7XG5cdFx0fVxuXHRcdC8qXG5cdFx0ICogVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2s6IGluIHRoZSBjYXNlIHdoZXJlIHdlIGhhdmUgYSBjZXJ0XG5cdFx0ICogdGhhdCdzIG9ubHkgYWxsb3dlZCB0byBkbyBzZXJ2ZXJBdXRoIG9yIGNsaWVudEF1dGggKGFuZCBub3Rcblx0XHQgKiB0aGUgb3RoZXIpLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSBhbGwgb3VyIFN1YmplY3RzIGFyZSBvZlxuXHRcdCAqIHRoZSByaWdodCB0eXBlLiBCdXQgd2UgYWxyZWFkeSBwYXJzZWQgb3VyIFN1YmplY3RzIGFuZFxuXHRcdCAqIGRlY2lkZWQgaWYgdGhleSB3ZXJlIGhvc3RzIG9yIHVzZXJzIGVhcmxpZXIgKHNpbmNlIGl0IGFwcGVhcnNcblx0XHQgKiBmaXJzdCBpbiB0aGUgY2VydCkuXG5cdFx0ICpcblx0XHQgKiBTbyB3ZSBnbyB0aHJvdWdoIGFuZCBtdXRhdGUgdGhlbSBpbnRvIHRoZSByaWdodCBraW5kIGhlcmUgaWZcblx0XHQgKiBpdCBkb2Vzbid0IG1hdGNoLiBUaGlzIG1pZ2h0IG5vdCBiZSBodWdlbHkgYmVuZWZpY2lhbCwgYXMgaXRcblx0XHQgKiBzZWVtcyB0aGF0IHNpbmdsZS1wdXJwb3NlIGNlcnRzIGFyZSBub3Qgb2Z0ZW4gc2VlbiBpbiB0aGVcblx0XHQgKiB3aWxkLlxuXHRcdCAqL1xuXHRcdGlmIChjZXJ0LnB1cnBvc2VzLmluZGV4T2YoJ3NlcnZlckF1dGgnKSAhPT0gLTEgJiZcblx0XHQgICAgY2VydC5wdXJwb3Nlcy5pbmRleE9mKCdjbGllbnRBdXRoJykgPT09IC0xKSB7XG5cdFx0XHRjZXJ0LnN1YmplY3RzLmZvckVhY2goZnVuY3Rpb24gKGlkZSkge1xuXHRcdFx0XHRpZiAoaWRlLnR5cGUgIT09ICdob3N0Jykge1xuXHRcdFx0XHRcdGlkZS50eXBlID0gJ2hvc3QnO1xuXHRcdFx0XHRcdGlkZS5ob3N0bmFtZSA9IGlkZS51aWQgfHxcblx0XHRcdFx0XHQgICAgaWRlLmVtYWlsIHx8XG5cdFx0XHRcdFx0ICAgIGlkZS5jb21wb25lbnRzWzBdLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGNlcnQucHVycG9zZXMuaW5kZXhPZignY2xpZW50QXV0aCcpICE9PSAtMSAmJlxuXHRcdCAgICBjZXJ0LnB1cnBvc2VzLmluZGV4T2YoJ3NlcnZlckF1dGgnKSA9PT0gLTEpIHtcblx0XHRcdGNlcnQuc3ViamVjdHMuZm9yRWFjaChmdW5jdGlvbiAoaWRlKSB7XG5cdFx0XHRcdGlmIChpZGUudHlwZSAhPT0gJ3VzZXInKSB7XG5cdFx0XHRcdFx0aWRlLnR5cGUgPSAndXNlcic7XG5cdFx0XHRcdFx0aWRlLnVpZCA9IGlkZS5ob3N0bmFtZSB8fFxuXHRcdFx0XHRcdCAgICBpZGUuZW1haWwgfHxcblx0XHRcdFx0XHQgICAgaWRlLmNvbXBvbmVudHNbMF0udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRzaWcuZXh0cmFzLmV4dHMucHVzaCh7IG9pZDogZXh0SWQsIGNyaXRpY2FsOiBjcml0aWNhbCB9KTtcblx0XHRicmVhaztcblx0Y2FzZSAoRVhUUy5rZXlVc2FnZSk6XG5cdFx0ZGVyLnJlYWRTZXF1ZW5jZShhc24xLkJlci5PY3RldFN0cmluZyk7XG5cdFx0dmFyIGJpdHMgPSBkZXIucmVhZFN0cmluZyhhc24xLkJlci5CaXRTdHJpbmcsIHRydWUpO1xuXHRcdHZhciBzZXRCaXRzID0gcmVhZEJpdEZpZWxkKGJpdHMsIEtFWVVTRUJJVFMpO1xuXHRcdHNldEJpdHMuZm9yRWFjaChmdW5jdGlvbiAoYml0KSB7XG5cdFx0XHRpZiAoY2VydC5wdXJwb3NlcyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRjZXJ0LnB1cnBvc2VzID0gW107XG5cdFx0XHRpZiAoY2VydC5wdXJwb3Nlcy5pbmRleE9mKGJpdCkgPT09IC0xKVxuXHRcdFx0XHRjZXJ0LnB1cnBvc2VzLnB1c2goYml0KTtcblx0XHR9KTtcblx0XHRzaWcuZXh0cmFzLmV4dHMucHVzaCh7IG9pZDogZXh0SWQsIGNyaXRpY2FsOiBjcml0aWNhbCxcblx0XHQgICAgYml0czogYml0cyB9KTtcblx0XHRicmVhaztcblx0Y2FzZSAoRVhUUy5hbHROYW1lKTpcblx0XHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdFx0dmFyIGFlRW5kID0gZGVyLm9mZnNldCArIGRlci5sZW5ndGg7XG5cdFx0d2hpbGUgKGRlci5vZmZzZXQgPCBhZUVuZCkge1xuXHRcdFx0c3dpdGNoIChkZXIucGVlaygpKSB7XG5cdFx0XHRjYXNlIEFMVE5BTUUuT3RoZXJOYW1lOlxuXHRcdFx0Y2FzZSBBTFROQU1FLkVESVBhcnR5TmFtZTpcblx0XHRcdFx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRkZXIuX29mZnNldCArPSBkZXIubGVuZ3RoO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgQUxUTkFNRS5PSUQ6XG5cdFx0XHRcdGRlci5yZWFkT0lEKEFMVE5BTUUuT0lEKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEFMVE5BTUUuUkZDODIyTmFtZTpcblx0XHRcdFx0LyogUkZDODIyIHNwZWNpZmllcyBlbWFpbCBhZGRyZXNzZXMgKi9cblx0XHRcdFx0dmFyIGVtYWlsID0gZGVyLnJlYWRTdHJpbmcoQUxUTkFNRS5SRkM4MjJOYW1lKTtcblx0XHRcdFx0aWQgPSBJZGVudGl0eS5mb3JFbWFpbChlbWFpbCk7XG5cdFx0XHRcdGlmICghY2VydC5zdWJqZWN0c1swXS5lcXVhbHMoaWQpKVxuXHRcdFx0XHRcdGNlcnQuc3ViamVjdHMucHVzaChpZCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBBTFROQU1FLkRpcmVjdG9yeU5hbWU6XG5cdFx0XHRcdGRlci5yZWFkU2VxdWVuY2UoQUxUTkFNRS5EaXJlY3RvcnlOYW1lKTtcblx0XHRcdFx0aWQgPSBJZGVudGl0eS5wYXJzZUFzbjEoZGVyKTtcblx0XHRcdFx0aWYgKCFjZXJ0LnN1YmplY3RzWzBdLmVxdWFscyhpZCkpXG5cdFx0XHRcdFx0Y2VydC5zdWJqZWN0cy5wdXNoKGlkKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIEFMVE5BTUUuRE5TTmFtZTpcblx0XHRcdFx0dmFyIGhvc3QgPSBkZXIucmVhZFN0cmluZyhcblx0XHRcdFx0ICAgIEFMVE5BTUUuRE5TTmFtZSk7XG5cdFx0XHRcdGlkID0gSWRlbnRpdHkuZm9ySG9zdChob3N0KTtcblx0XHRcdFx0aWYgKCFjZXJ0LnN1YmplY3RzWzBdLmVxdWFscyhpZCkpXG5cdFx0XHRcdFx0Y2VydC5zdWJqZWN0cy5wdXNoKGlkKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRkZXIucmVhZFN0cmluZyhkZXIucGVlaygpKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNpZy5leHRyYXMuZXh0cy5wdXNoKHsgb2lkOiBleHRJZCwgY3JpdGljYWw6IGNyaXRpY2FsIH0pO1xuXHRcdGJyZWFrO1xuXHRkZWZhdWx0OlxuXHRcdHNpZy5leHRyYXMuZXh0cy5wdXNoKHtcblx0XHRcdG9pZDogZXh0SWQsXG5cdFx0XHRjcml0aWNhbDogY3JpdGljYWwsXG5cdFx0XHRkYXRhOiBkZXIucmVhZFN0cmluZyhhc24xLkJlci5PY3RldFN0cmluZywgdHJ1ZSlcblx0XHR9KTtcblx0XHRicmVhaztcblx0fVxuXG5cdGRlci5fb2Zmc2V0ID0gYWZ0ZXI7XG59XG5cbnZhciBVVENUSU1FX1JFID1cbiAgICAvXihbMC05XXsyfSkoWzAtOV17Mn0pKFswLTldezJ9KShbMC05XXsyfSkoWzAtOV17Mn0pKFswLTldezJ9KT9aJC87XG5mdW5jdGlvbiB1dGNUaW1lVG9EYXRlKHQpIHtcblx0dmFyIG0gPSB0Lm1hdGNoKFVUQ1RJTUVfUkUpO1xuXHRhc3NlcnQub2sobSwgJ3RpbWVzdGFtcHMgbXVzdCBiZSBpbiBVVEMnKTtcblx0dmFyIGQgPSBuZXcgRGF0ZSgpO1xuXG5cdHZhciB0aGlzWWVhciA9IGQuZ2V0VVRDRnVsbFllYXIoKTtcblx0dmFyIGNlbnR1cnkgPSBNYXRoLmZsb29yKHRoaXNZZWFyIC8gMTAwKSAqIDEwMDtcblxuXHR2YXIgeWVhciA9IHBhcnNlSW50KG1bMV0sIDEwKTtcblx0aWYgKHRoaXNZZWFyICUgMTAwIDwgNTAgJiYgeWVhciA+PSA2MClcblx0XHR5ZWFyICs9IChjZW50dXJ5IC0gMSk7XG5cdGVsc2Vcblx0XHR5ZWFyICs9IGNlbnR1cnk7XG5cdGQuc2V0VVRDRnVsbFllYXIoeWVhciwgcGFyc2VJbnQobVsyXSwgMTApIC0gMSwgcGFyc2VJbnQobVszXSwgMTApKTtcblx0ZC5zZXRVVENIb3VycyhwYXJzZUludChtWzRdLCAxMCksIHBhcnNlSW50KG1bNV0sIDEwKSk7XG5cdGlmIChtWzZdICYmIG1bNl0ubGVuZ3RoID4gMClcblx0XHRkLnNldFVUQ1NlY29uZHMocGFyc2VJbnQobVs2XSwgMTApKTtcblx0cmV0dXJuIChkKTtcbn1cblxudmFyIEdUSU1FX1JFID1cbiAgICAvXihbMC05XXs0fSkoWzAtOV17Mn0pKFswLTldezJ9KShbMC05XXsyfSkoWzAtOV17Mn0pKFswLTldezJ9KT9aJC87XG5mdW5jdGlvbiBnVGltZVRvRGF0ZSh0KSB7XG5cdHZhciBtID0gdC5tYXRjaChHVElNRV9SRSk7XG5cdGFzc2VydC5vayhtKTtcblx0dmFyIGQgPSBuZXcgRGF0ZSgpO1xuXG5cdGQuc2V0VVRDRnVsbFllYXIocGFyc2VJbnQobVsxXSwgMTApLCBwYXJzZUludChtWzJdLCAxMCkgLSAxLFxuXHQgICAgcGFyc2VJbnQobVszXSwgMTApKTtcblx0ZC5zZXRVVENIb3VycyhwYXJzZUludChtWzRdLCAxMCksIHBhcnNlSW50KG1bNV0sIDEwKSk7XG5cdGlmIChtWzZdICYmIG1bNl0ubGVuZ3RoID4gMClcblx0XHRkLnNldFVUQ1NlY29uZHMocGFyc2VJbnQobVs2XSwgMTApKTtcblx0cmV0dXJuIChkKTtcbn1cblxuZnVuY3Rpb24gemVyb1BhZChuLCBtKSB7XG5cdGlmIChtID09PSB1bmRlZmluZWQpXG5cdFx0bSA9IDI7XG5cdHZhciBzID0gJycgKyBuO1xuXHR3aGlsZSAocy5sZW5ndGggPCBtKVxuXHRcdHMgPSAnMCcgKyBzO1xuXHRyZXR1cm4gKHMpO1xufVxuXG5mdW5jdGlvbiBkYXRlVG9VVENUaW1lKGQpIHtcblx0dmFyIHMgPSAnJztcblx0cyArPSB6ZXJvUGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ01vbnRoKCkgKyAxKTtcblx0cyArPSB6ZXJvUGFkKGQuZ2V0VVRDRGF0ZSgpKTtcblx0cyArPSB6ZXJvUGFkKGQuZ2V0VVRDSG91cnMoKSk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ01pbnV0ZXMoKSk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ1NlY29uZHMoKSk7XG5cdHMgKz0gJ1onO1xuXHRyZXR1cm4gKHMpO1xufVxuXG5mdW5jdGlvbiBkYXRlVG9HVGltZShkKSB7XG5cdHZhciBzID0gJyc7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ0Z1bGxZZWFyKCksIDQpO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENNb250aCgpICsgMSk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ0RhdGUoKSk7XG5cdHMgKz0gemVyb1BhZChkLmdldFVUQ0hvdXJzKCkpO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENNaW51dGVzKCkpO1xuXHRzICs9IHplcm9QYWQoZC5nZXRVVENTZWNvbmRzKCkpO1xuXHRzICs9ICdaJztcblx0cmV0dXJuIChzKTtcbn1cblxuZnVuY3Rpb24gc2lnbihjZXJ0LCBrZXkpIHtcblx0aWYgKGNlcnQuc2lnbmF0dXJlcy54NTA5ID09PSB1bmRlZmluZWQpXG5cdFx0Y2VydC5zaWduYXR1cmVzLng1MDkgPSB7fTtcblx0dmFyIHNpZyA9IGNlcnQuc2lnbmF0dXJlcy54NTA5O1xuXG5cdHNpZy5hbGdvID0ga2V5LnR5cGUgKyAnLScgKyBrZXkuZGVmYXVsdEhhc2hBbGdvcml0aG0oKTtcblx0aWYgKFNJR05fQUxHU1tzaWcuYWxnb10gPT09IHVuZGVmaW5lZClcblx0XHRyZXR1cm4gKGZhbHNlKTtcblxuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyV3JpdGVyKCk7XG5cdHdyaXRlVEJTQ2VydChjZXJ0LCBkZXIpO1xuXHR2YXIgYmxvYiA9IGRlci5idWZmZXI7XG5cdHNpZy5jYWNoZSA9IGJsb2I7XG5cblx0dmFyIHNpZ25lciA9IGtleS5jcmVhdGVTaWduKCk7XG5cdHNpZ25lci53cml0ZShibG9iKTtcblx0Y2VydC5zaWduYXR1cmVzLng1MDkuc2lnbmF0dXJlID0gc2lnbmVyLnNpZ24oKTtcblxuXHRyZXR1cm4gKHRydWUpO1xufVxuXG5mdW5jdGlvbiBzaWduQXN5bmMoY2VydCwgc2lnbmVyLCBkb25lKSB7XG5cdGlmIChjZXJ0LnNpZ25hdHVyZXMueDUwOSA9PT0gdW5kZWZpbmVkKVxuXHRcdGNlcnQuc2lnbmF0dXJlcy54NTA5ID0ge307XG5cdHZhciBzaWcgPSBjZXJ0LnNpZ25hdHVyZXMueDUwOTtcblxuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyV3JpdGVyKCk7XG5cdHdyaXRlVEJTQ2VydChjZXJ0LCBkZXIpO1xuXHR2YXIgYmxvYiA9IGRlci5idWZmZXI7XG5cdHNpZy5jYWNoZSA9IGJsb2I7XG5cblx0c2lnbmVyKGJsb2IsIGZ1bmN0aW9uIChlcnIsIHNpZ25hdHVyZSkge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdGRvbmUoZXJyKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c2lnLmFsZ28gPSBzaWduYXR1cmUudHlwZSArICctJyArIHNpZ25hdHVyZS5oYXNoQWxnb3JpdGhtO1xuXHRcdGlmIChTSUdOX0FMR1Nbc2lnLmFsZ29dID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGRvbmUobmV3IEVycm9yKCdJbnZhbGlkIHNpZ25pbmcgYWxnb3JpdGhtIFwiJyArXG5cdFx0XHQgICAgc2lnLmFsZ28gKyAnXCInKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHNpZy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG5cdFx0ZG9uZSgpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gd3JpdGUoY2VydCwgb3B0aW9ucykge1xuXHR2YXIgc2lnID0gY2VydC5zaWduYXR1cmVzLng1MDk7XG5cdGFzc2VydC5vYmplY3Qoc2lnLCAneDUwOSBzaWduYXR1cmUnKTtcblxuXHR2YXIgZGVyID0gbmV3IGFzbjEuQmVyV3JpdGVyKCk7XG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdGlmIChzaWcuY2FjaGUpIHtcblx0XHRkZXIuX2Vuc3VyZShzaWcuY2FjaGUubGVuZ3RoKTtcblx0XHRzaWcuY2FjaGUuY29weShkZXIuX2J1ZiwgZGVyLl9vZmZzZXQpO1xuXHRcdGRlci5fb2Zmc2V0ICs9IHNpZy5jYWNoZS5sZW5ndGg7XG5cdH0gZWxzZSB7XG5cdFx0d3JpdGVUQlNDZXJ0KGNlcnQsIGRlcik7XG5cdH1cblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRkZXIud3JpdGVPSUQoU0lHTl9BTEdTW3NpZy5hbGdvXSk7XG5cdGlmIChzaWcuYWxnby5tYXRjaCgvXnJzYS0vKSlcblx0XHRkZXIud3JpdGVOdWxsKCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdHZhciBzaWdEYXRhID0gc2lnLnNpZ25hdHVyZS50b0J1ZmZlcignYXNuMScpO1xuXHR2YXIgZGF0YSA9IEJ1ZmZlci5hbGxvYyhzaWdEYXRhLmxlbmd0aCArIDEpO1xuXHRkYXRhWzBdID0gMDtcblx0c2lnRGF0YS5jb3B5KGRhdGEsIDEpO1xuXHRkZXIud3JpdGVCdWZmZXIoZGF0YSwgYXNuMS5CZXIuQml0U3RyaW5nKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0cmV0dXJuIChkZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVUQlNDZXJ0KGNlcnQsIGRlcikge1xuXHR2YXIgc2lnID0gY2VydC5zaWduYXR1cmVzLng1MDk7XG5cdGFzc2VydC5vYmplY3Qoc2lnLCAneDUwOSBzaWduYXR1cmUnKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKExvY2FsKDApKTtcblx0ZGVyLndyaXRlSW50KDIpO1xuXHRkZXIuZW5kU2VxdWVuY2UoKTtcblxuXHRkZXIud3JpdGVCdWZmZXIodXRpbHMubXBOb3JtYWxpemUoY2VydC5zZXJpYWwpLCBhc24xLkJlci5JbnRlZ2VyKTtcblxuXHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRkZXIud3JpdGVPSUQoU0lHTl9BTEdTW3NpZy5hbGdvXSk7XG5cdGlmIChzaWcuYWxnby5tYXRjaCgvXnJzYS0vKSlcblx0XHRkZXIud3JpdGVOdWxsKCk7XG5cdGRlci5lbmRTZXF1ZW5jZSgpO1xuXG5cdGNlcnQuaXNzdWVyLnRvQXNuMShkZXIpO1xuXG5cdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdHdyaXRlRGF0ZShkZXIsIGNlcnQudmFsaWRGcm9tKTtcblx0d3JpdGVEYXRlKGRlciwgY2VydC52YWxpZFVudGlsKTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cblx0dmFyIHN1YmplY3QgPSBjZXJ0LnN1YmplY3RzWzBdO1xuXHR2YXIgYWx0TmFtZXMgPSBjZXJ0LnN1YmplY3RzLnNsaWNlKDEpO1xuXHRzdWJqZWN0LnRvQXNuMShkZXIpO1xuXG5cdHBrY3M4LndyaXRlUGtjczgoZGVyLCBjZXJ0LnN1YmplY3RLZXkpO1xuXG5cdGlmIChzaWcuZXh0cmFzICYmIHNpZy5leHRyYXMuaXNzdWVyVW5pcXVlSUQpIHtcblx0XHRkZXIud3JpdGVCdWZmZXIoc2lnLmV4dHJhcy5pc3N1ZXJVbmlxdWVJRCwgTG9jYWwoMSkpO1xuXHR9XG5cblx0aWYgKHNpZy5leHRyYXMgJiYgc2lnLmV4dHJhcy5zdWJqZWN0VW5pcXVlSUQpIHtcblx0XHRkZXIud3JpdGVCdWZmZXIoc2lnLmV4dHJhcy5zdWJqZWN0VW5pcXVlSUQsIExvY2FsKDIpKTtcblx0fVxuXG5cdGlmIChhbHROYW1lcy5sZW5ndGggPiAwIHx8IHN1YmplY3QudHlwZSA9PT0gJ2hvc3QnIHx8XG5cdCAgICAoY2VydC5wdXJwb3NlcyAhPT0gdW5kZWZpbmVkICYmIGNlcnQucHVycG9zZXMubGVuZ3RoID4gMCkgfHxcblx0ICAgIChzaWcuZXh0cmFzICYmIHNpZy5leHRyYXMuZXh0cykpIHtcblx0XHRkZXIuc3RhcnRTZXF1ZW5jZShMb2NhbCgzKSk7XG5cdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblxuXHRcdHZhciBleHRzID0gW107XG5cdFx0aWYgKGNlcnQucHVycG9zZXMgIT09IHVuZGVmaW5lZCAmJiBjZXJ0LnB1cnBvc2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdGV4dHMucHVzaCh7XG5cdFx0XHRcdG9pZDogRVhUUy5iYXNpY0NvbnN0cmFpbnRzLFxuXHRcdFx0XHRjcml0aWNhbDogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0XHRleHRzLnB1c2goe1xuXHRcdFx0XHRvaWQ6IEVYVFMua2V5VXNhZ2UsXG5cdFx0XHRcdGNyaXRpY2FsOiB0cnVlXG5cdFx0XHR9KTtcblx0XHRcdGV4dHMucHVzaCh7XG5cdFx0XHRcdG9pZDogRVhUUy5leHRLZXlVc2FnZSxcblx0XHRcdFx0Y3JpdGljYWw6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRleHRzLnB1c2goeyBvaWQ6IEVYVFMuYWx0TmFtZSB9KTtcblx0XHRpZiAoc2lnLmV4dHJhcyAmJiBzaWcuZXh0cmFzLmV4dHMpXG5cdFx0XHRleHRzID0gc2lnLmV4dHJhcy5leHRzO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdFx0ZGVyLndyaXRlT0lEKGV4dHNbaV0ub2lkKTtcblxuXHRcdFx0aWYgKGV4dHNbaV0uY3JpdGljYWwgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0ZGVyLndyaXRlQm9vbGVhbihleHRzW2ldLmNyaXRpY2FsKTtcblxuXHRcdFx0aWYgKGV4dHNbaV0ub2lkID09PSBFWFRTLmFsdE5hbWUpIHtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdFx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRpZiAoc3ViamVjdC50eXBlID09PSAnaG9zdCcpIHtcblx0XHRcdFx0XHRkZXIud3JpdGVTdHJpbmcoc3ViamVjdC5ob3N0bmFtZSxcblx0XHRcdFx0XHQgICAgQ29udGV4dCgyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhbHROYW1lcy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdGlmIChhbHROYW1lc1tqXS50eXBlID09PSAnaG9zdCcpIHtcblx0XHRcdFx0XHRcdGRlci53cml0ZVN0cmluZyhcblx0XHRcdFx0XHRcdCAgICBhbHROYW1lc1tqXS5ob3N0bmFtZSxcblx0XHRcdFx0XHRcdCAgICBBTFROQU1FLkROU05hbWUpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYWx0TmFtZXNbal0udHlwZSA9PT1cblx0XHRcdFx0XHQgICAgJ2VtYWlsJykge1xuXHRcdFx0XHRcdFx0ZGVyLndyaXRlU3RyaW5nKFxuXHRcdFx0XHRcdFx0ICAgIGFsdE5hbWVzW2pdLmVtYWlsLFxuXHRcdFx0XHRcdFx0ICAgIEFMVE5BTUUuUkZDODIyTmFtZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qXG5cdFx0XHRcdFx0XHQgKiBFbmNvZGUgYW55dGhpbmcgZWxzZSBhcyBhXG5cdFx0XHRcdFx0XHQgKiBETiBzdHlsZSBuYW1lIGZvciBub3cuXG5cdFx0XHRcdFx0XHQgKi9cblx0XHRcdFx0XHRcdGRlci5zdGFydFNlcXVlbmNlKFxuXHRcdFx0XHRcdFx0ICAgIEFMVE5BTUUuRGlyZWN0b3J5TmFtZSk7XG5cdFx0XHRcdFx0XHRhbHROYW1lc1tqXS50b0FzbjEoZGVyKTtcblx0XHRcdFx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGV4dHNbaV0ub2lkID09PSBFWFRTLmJhc2ljQ29uc3RyYWludHMpIHtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdFx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdFx0XHR2YXIgY2EgPSAoY2VydC5wdXJwb3Nlcy5pbmRleE9mKCdjYScpICE9PSAtMSk7XG5cdFx0XHRcdHZhciBwYXRoTGVuID0gZXh0c1tpXS5wYXRoTGVuO1xuXHRcdFx0XHRkZXIud3JpdGVCb29sZWFuKGNhKTtcblx0XHRcdFx0aWYgKHBhdGhMZW4gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRkZXIud3JpdGVJbnQocGF0aExlbik7XG5cdFx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdH0gZWxzZSBpZiAoZXh0c1tpXS5vaWQgPT09IEVYVFMuZXh0S2V5VXNhZ2UpIHtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdFx0XHRkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRjZXJ0LnB1cnBvc2VzLmZvckVhY2goZnVuY3Rpb24gKHB1cnBvc2UpIHtcblx0XHRcdFx0XHRpZiAocHVycG9zZSA9PT0gJ2NhJylcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRpZiAoS0VZVVNFQklUUy5pbmRleE9mKHB1cnBvc2UpICE9PSAtMSlcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR2YXIgb2lkID0gcHVycG9zZTtcblx0XHRcdFx0XHRpZiAoRVhUUFVSUE9TRVtwdXJwb3NlXSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0b2lkID0gRVhUUFVSUE9TRVtwdXJwb3NlXTtcblx0XHRcdFx0XHRkZXIud3JpdGVPSUQob2lkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdH0gZWxzZSBpZiAoZXh0c1tpXS5vaWQgPT09IEVYVFMua2V5VXNhZ2UpIHtcblx0XHRcdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoYXNuMS5CZXIuT2N0ZXRTdHJpbmcpO1xuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBJZiB3ZSBwYXJzZWQgdGhpcyBjZXJ0aWZpY2F0ZSBmcm9tIGEgYnl0ZVxuXHRcdFx0XHQgKiBzdHJlYW0gKGkuZS4gd2UgZGlkbid0IGdlbmVyYXRlIGl0IGluIHNzaHBrKVxuXHRcdFx0XHQgKiB0aGVuIHdlJ2xsIGhhdmUgYSBcIi5iaXRzXCIgcHJvcGVydHkgb24gdGhlXG5cdFx0XHRcdCAqIGV4dCB3aXRoIHRoZSBvcmlnaW5hbCByYXcgYnl0ZSBjb250ZW50cy5cblx0XHRcdFx0ICpcblx0XHRcdFx0ICogSWYgd2UgaGF2ZSB0aGlzLCB1c2UgaXQgaGVyZSBpbnN0ZWFkIG9mXG5cdFx0XHRcdCAqIHJlZ2VuZXJhdGluZyBpdC4gVGhpcyBndWFyYW50ZWVzIHdlIG91dHB1dFxuXHRcdFx0XHQgKiB0aGUgc2FtZSBkYXRhIHdlIHBhcnNlZCwgc28gc2lnbmF0dXJlcyBzdGlsbFxuXHRcdFx0XHQgKiB2YWxpZGF0ZS5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGlmIChleHRzW2ldLmJpdHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGRlci53cml0ZUJ1ZmZlcihleHRzW2ldLmJpdHMsXG5cdFx0XHRcdFx0ICAgIGFzbjEuQmVyLkJpdFN0cmluZyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGJpdHMgPSB3cml0ZUJpdEZpZWxkKGNlcnQucHVycG9zZXMsXG5cdFx0XHRcdFx0ICAgIEtFWVVTRUJJVFMpO1xuXHRcdFx0XHRcdGRlci53cml0ZUJ1ZmZlcihiaXRzLFxuXHRcdFx0XHRcdCAgICBhc24xLkJlci5CaXRTdHJpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVyLndyaXRlQnVmZmVyKGV4dHNbaV0uZGF0YSxcblx0XHRcdFx0ICAgIGFzbjEuQmVyLk9jdGV0U3RyaW5nKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0fVxuXG5cdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdFx0ZGVyLmVuZFNlcXVlbmNlKCk7XG5cdH1cblxuXHRkZXIuZW5kU2VxdWVuY2UoKTtcbn1cblxuLypcbiAqIFJlYWRzIGFuIEFTTi4xIEJFUiBiaXRmaWVsZCBvdXQgb2YgdGhlIEJ1ZmZlciBwcm9kdWNlZCBieSBkb2luZ1xuICogYEJlclJlYWRlciNyZWFkU3RyaW5nKGFzbjEuQmVyLkJpdFN0cmluZylgLiBUaGF0IGZ1bmN0aW9uIGdpdmVzIHVzIHRoZSByYXdcbiAqIGNvbnRlbnRzIG9mIHRoZSBCaXRTdHJpbmcgdGFnLCB3aGljaCBpcyBhIGNvdW50IG9mIHVudXNlZCBiaXRzIGZvbGxvd2VkIGJ5XG4gKiB0aGUgYml0cyBhcyBhIHJpZ2h0LXBhZGRlZCBieXRlIHN0cmluZy5cbiAqXG4gKiBgYml0c2AgaXMgdGhlIEJ1ZmZlciwgYGJpdEluZGV4YCBzaG91bGQgY29udGFpbiBhbiBhcnJheSBvZiBzdHJpbmcgbmFtZXNcbiAqIGZvciB0aGUgYml0cyBpbiB0aGUgc3RyaW5nLCBvcmRlcmVkIHN0YXJ0aW5nIHdpdGggYml0ICMwIGluIHRoZSBBU04uMSBzcGVjLlxuICpcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgU3RyaW5ncywgdGhlIG5hbWVzIG9mIHRoZSBiaXRzIHRoYXQgd2VyZSBzZXQgdG8gMS5cbiAqL1xuZnVuY3Rpb24gcmVhZEJpdEZpZWxkKGJpdHMsIGJpdEluZGV4KSB7XG5cdHZhciBiaXRMZW4gPSA4ICogKGJpdHMubGVuZ3RoIC0gMSkgLSBiaXRzWzBdO1xuXHR2YXIgc2V0Qml0cyA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGJpdExlbjsgKytpKSB7XG5cdFx0dmFyIGJ5dGVOID0gMSArIE1hdGguZmxvb3IoaSAvIDgpO1xuXHRcdHZhciBiaXQgPSA3IC0gKGkgJSA4KTtcblx0XHR2YXIgbWFzayA9IDEgPDwgYml0O1xuXHRcdHZhciBiaXRWYWwgPSAoKGJpdHNbYnl0ZU5dICYgbWFzaykgIT09IDApO1xuXHRcdHZhciBuYW1lID0gYml0SW5kZXhbaV07XG5cdFx0aWYgKGJpdFZhbCAmJiB0eXBlb2YgKG5hbWUpID09PSAnc3RyaW5nJykge1xuXHRcdFx0c2V0Qml0c1tuYW1lXSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAoT2JqZWN0LmtleXMoc2V0Qml0cykpO1xufVxuXG4vKlxuICogYHNldEJpdHNgIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIGNvbnRhaW5pbmcgdGhlIG5hbWVzIGZvciBlYWNoIGJpdCB0aGF0XG4gKiBzb3VsZCBiZSBzZXQgdG8gMS4gYGJpdEluZGV4YCBpcyBzYW1lIGFzIGluIGByZWFkQml0RmllbGQoKWAuXG4gKlxuICogUmV0dXJucyBhIEJ1ZmZlciwgcmVhZHkgdG8gYmUgd3JpdHRlbiBvdXQgd2l0aCBgQmVyV3JpdGVyI3dyaXRlU3RyaW5nKClgLlxuICovXG5mdW5jdGlvbiB3cml0ZUJpdEZpZWxkKHNldEJpdHMsIGJpdEluZGV4KSB7XG5cdHZhciBiaXRMZW4gPSBiaXRJbmRleC5sZW5ndGg7XG5cdHZhciBibGVuID0gTWF0aC5jZWlsKGJpdExlbiAvIDgpO1xuXHR2YXIgdW51c2VkID0gYmxlbiAqIDggLSBiaXRMZW47XG5cdHZhciBiaXRzID0gQnVmZmVyLmFsbG9jKDEgKyBibGVuKTsgLy8gemVyby1maWxsZWRcblx0Yml0c1swXSA9IHVudXNlZDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiaXRMZW47ICsraSkge1xuXHRcdHZhciBieXRlTiA9IDEgKyBNYXRoLmZsb29yKGkgLyA4KTtcblx0XHR2YXIgYml0ID0gNyAtIChpICUgOCk7XG5cdFx0dmFyIG1hc2sgPSAxIDw8IGJpdDtcblx0XHR2YXIgbmFtZSA9IGJpdEluZGV4W2ldO1xuXHRcdGlmIChuYW1lID09PSB1bmRlZmluZWQpXG5cdFx0XHRjb250aW51ZTtcblx0XHR2YXIgYml0VmFsID0gKHNldEJpdHMuaW5kZXhPZihuYW1lKSAhPT0gLTEpO1xuXHRcdGlmIChiaXRWYWwpIHtcblx0XHRcdGJpdHNbYnl0ZU5dIHw9IG1hc2s7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAoYml0cyk7XG59XG4iLCIvLyBDb3B5cmlnaHQgMjAxNyBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSBJZGVudGl0eTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4vYWxncycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIEZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9maW5nZXJwcmludCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgZXJycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcblxuLypKU1NUWUxFRCovXG52YXIgRE5TX05BTUVfUkUgPSAvXihbKl18W2EtejAtOV1bYS16MC05XFwtXXswLDYyfSkoPzpcXC4oWypdfFthLXowLTldW2EtejAtOVxcLV17MCw2Mn0pKSokL2k7XG5cbnZhciBvaWRzID0ge307XG5vaWRzLmNuID0gJzIuNS40LjMnO1xub2lkcy5vID0gJzIuNS40LjEwJztcbm9pZHMub3UgPSAnMi41LjQuMTEnO1xub2lkcy5sID0gJzIuNS40LjcnO1xub2lkcy5zID0gJzIuNS40LjgnO1xub2lkcy5jID0gJzIuNS40LjYnO1xub2lkcy5zbiA9ICcyLjUuNC40Jztcbm9pZHMucG9zdGFsQ29kZSA9ICcyLjUuNC4xNyc7XG5vaWRzLnNlcmlhbE51bWJlciA9ICcyLjUuNC41Jztcbm9pZHMuc3RyZWV0ID0gJzIuNS40LjknO1xub2lkcy54NTAwVW5pcXVlSWRlbnRpZmllciA9ICcyLjUuNC40NSc7XG5vaWRzLnJvbGUgPSAnMi41LjQuNzInO1xub2lkcy50ZWxlcGhvbmVOdW1iZXIgPSAnMi41LjQuMjAnO1xub2lkcy5kZXNjcmlwdGlvbiA9ICcyLjUuNC4xMyc7XG5vaWRzLmRjID0gJzAuOS4yMzQyLjE5MjAwMzAwLjEwMC4xLjI1Jztcbm9pZHMudWlkID0gJzAuOS4yMzQyLjE5MjAwMzAwLjEwMC4xLjEnO1xub2lkcy5tYWlsID0gJzAuOS4yMzQyLjE5MjAwMzAwLjEwMC4xLjMnO1xub2lkcy50aXRsZSA9ICcyLjUuNC4xMic7XG5vaWRzLmduID0gJzIuNS40LjQyJztcbm9pZHMuaW5pdGlhbHMgPSAnMi41LjQuNDMnO1xub2lkcy5wc2V1ZG9ueW0gPSAnMi41LjQuNjUnO1xub2lkcy5lbWFpbEFkZHJlc3MgPSAnMS4yLjg0MC4xMTM1NDkuMS45LjEnO1xuXG52YXIgdW5vaWRzID0ge307XG5PYmplY3Qua2V5cyhvaWRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdHVub2lkc1tvaWRzW2tdXSA9IGs7XG59KTtcblxuZnVuY3Rpb24gSWRlbnRpdHkob3B0cykge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdGFzc2VydC5vYmplY3Qob3B0cywgJ29wdGlvbnMnKTtcblx0YXNzZXJ0LmFycmF5T2ZPYmplY3Qob3B0cy5jb21wb25lbnRzLCAnb3B0aW9ucy5jb21wb25lbnRzJyk7XG5cdHRoaXMuY29tcG9uZW50cyA9IG9wdHMuY29tcG9uZW50cztcblx0dGhpcy5jb21wb25lbnRMb29rdXAgPSB7fTtcblx0dGhpcy5jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0XHRpZiAoYy5uYW1lICYmICFjLm9pZClcblx0XHRcdGMub2lkID0gb2lkc1tjLm5hbWVdO1xuXHRcdGlmIChjLm9pZCAmJiAhYy5uYW1lKVxuXHRcdFx0Yy5uYW1lID0gdW5vaWRzW2Mub2lkXTtcblx0XHRpZiAoc2VsZi5jb21wb25lbnRMb29rdXBbYy5uYW1lXSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0c2VsZi5jb21wb25lbnRMb29rdXBbYy5uYW1lXSA9IFtdO1xuXHRcdHNlbGYuY29tcG9uZW50TG9va3VwW2MubmFtZV0ucHVzaChjKTtcblx0fSk7XG5cdGlmICh0aGlzLmNvbXBvbmVudExvb2t1cC5jbiAmJiB0aGlzLmNvbXBvbmVudExvb2t1cC5jbi5sZW5ndGggPiAwKSB7XG5cdFx0dGhpcy5jbiA9IHRoaXMuY29tcG9uZW50TG9va3VwLmNuWzBdLnZhbHVlO1xuXHR9XG5cdGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRzLnR5cGUsICdvcHRpb25zLnR5cGUnKTtcblx0aWYgKG9wdHMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHRoaXMuY29tcG9uZW50cy5sZW5ndGggPT09IDEgJiZcblx0XHQgICAgdGhpcy5jb21wb25lbnRMb29rdXAuY24gJiZcblx0XHQgICAgdGhpcy5jb21wb25lbnRMb29rdXAuY24ubGVuZ3RoID09PSAxICYmXG5cdFx0ICAgIHRoaXMuY29tcG9uZW50TG9va3VwLmNuWzBdLnZhbHVlLm1hdGNoKEROU19OQU1FX1JFKSkge1xuXHRcdFx0dGhpcy50eXBlID0gJ2hvc3QnO1xuXHRcdFx0dGhpcy5ob3N0bmFtZSA9IHRoaXMuY29tcG9uZW50TG9va3VwLmNuWzBdLnZhbHVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudExvb2t1cC5kYyAmJlxuXHRcdCAgICB0aGlzLmNvbXBvbmVudHMubGVuZ3RoID09PSB0aGlzLmNvbXBvbmVudExvb2t1cC5kYy5sZW5ndGgpIHtcblx0XHRcdHRoaXMudHlwZSA9ICdob3N0Jztcblx0XHRcdHRoaXMuaG9zdG5hbWUgPSB0aGlzLmNvbXBvbmVudExvb2t1cC5kYy5tYXAoXG5cdFx0XHQgICAgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0cmV0dXJuIChjLnZhbHVlKTtcblx0XHRcdH0pLmpvaW4oJy4nKTtcblxuXHRcdH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnRMb29rdXAudWlkICYmXG5cdFx0ICAgIHRoaXMuY29tcG9uZW50cy5sZW5ndGggPT09XG5cdFx0ICAgIHRoaXMuY29tcG9uZW50TG9va3VwLnVpZC5sZW5ndGgpIHtcblx0XHRcdHRoaXMudHlwZSA9ICd1c2VyJztcblx0XHRcdHRoaXMudWlkID0gdGhpcy5jb21wb25lbnRMb29rdXAudWlkWzBdLnZhbHVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudExvb2t1cC5jbiAmJlxuXHRcdCAgICB0aGlzLmNvbXBvbmVudExvb2t1cC5jbi5sZW5ndGggPT09IDEgJiZcblx0XHQgICAgdGhpcy5jb21wb25lbnRMb29rdXAuY25bMF0udmFsdWUubWF0Y2goRE5TX05BTUVfUkUpKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSAnaG9zdCc7XG5cdFx0XHR0aGlzLmhvc3RuYW1lID0gdGhpcy5jb21wb25lbnRMb29rdXAuY25bMF0udmFsdWU7XG5cblx0XHR9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50TG9va3VwLnVpZCAmJlxuXHRcdCAgICB0aGlzLmNvbXBvbmVudExvb2t1cC51aWQubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSAndXNlcic7XG5cdFx0XHR0aGlzLnVpZCA9IHRoaXMuY29tcG9uZW50TG9va3VwLnVpZFswXS52YWx1ZTtcblxuXHRcdH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnRMb29rdXAubWFpbCAmJlxuXHRcdCAgICB0aGlzLmNvbXBvbmVudExvb2t1cC5tYWlsLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dGhpcy50eXBlID0gJ2VtYWlsJztcblx0XHRcdHRoaXMuZW1haWwgPSB0aGlzLmNvbXBvbmVudExvb2t1cC5tYWlsWzBdLnZhbHVlO1xuXG5cdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudExvb2t1cC5jbiAmJlxuXHRcdCAgICB0aGlzLmNvbXBvbmVudExvb2t1cC5jbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdHRoaXMudHlwZSA9ICd1c2VyJztcblx0XHRcdHRoaXMudWlkID0gdGhpcy5jb21wb25lbnRMb29rdXAuY25bMF0udmFsdWU7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50eXBlID0gJ3Vua25vd24nO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBvcHRzLnR5cGU7XG5cdFx0aWYgKHRoaXMudHlwZSA9PT0gJ2hvc3QnKVxuXHRcdFx0dGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG5cdFx0ZWxzZSBpZiAodGhpcy50eXBlID09PSAndXNlcicpXG5cdFx0XHR0aGlzLnVpZCA9IG9wdHMudWlkO1xuXHRcdGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ2VtYWlsJylcblx0XHRcdHRoaXMuZW1haWwgPSBvcHRzLmVtYWlsO1xuXHRcdGVsc2Vcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSAnICsgdGhpcy50eXBlKSk7XG5cdH1cbn1cblxuSWRlbnRpdHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gKHRoaXMuY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGMpIHtcblx0XHR2YXIgbiA9IGMubmFtZS50b1VwcGVyQ2FzZSgpO1xuXHRcdC8qSlNTVFlMRUQqL1xuXHRcdG4gPSBuLnJlcGxhY2UoLz0vZywgJ1xcXFw9Jyk7XG5cdFx0dmFyIHYgPSBjLnZhbHVlO1xuXHRcdC8qSlNTVFlMRUQqL1xuXHRcdHYgPSB2LnJlcGxhY2UoLywvZywgJ1xcXFwsJyk7XG5cdFx0cmV0dXJuIChuICsgJz0nICsgdik7XG5cdH0pLmpvaW4oJywgJykpO1xufTtcblxuSWRlbnRpdHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lLCBhc0FycmF5KSB7XG5cdGFzc2VydC5zdHJpbmcobmFtZSwgJ25hbWUnKTtcblx0dmFyIGFyciA9IHRoaXMuY29tcG9uZW50TG9va3VwW25hbWVdO1xuXHRpZiAoYXJyID09PSB1bmRlZmluZWQgfHwgYXJyLmxlbmd0aCA9PT0gMClcblx0XHRyZXR1cm4gKHVuZGVmaW5lZCk7XG5cdGlmICghYXNBcnJheSAmJiBhcnIubGVuZ3RoID4gMSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNdWx0aXBsZSB2YWx1ZXMgZm9yIGF0dHJpYnV0ZSAnICsgbmFtZSkpO1xuXHRpZiAoIWFzQXJyYXkpXG5cdFx0cmV0dXJuIChhcnJbMF0udmFsdWUpO1xuXHRyZXR1cm4gKGFyci5tYXAoZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gKGMudmFsdWUpO1xuXHR9KSk7XG59O1xuXG5JZGVudGl0eS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIChpZHgpIHtcblx0cmV0dXJuICh0aGlzLmNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICh7XG5cdFx0XHRuYW1lOiBjLm5hbWUsXG5cdFx0XHR2YWx1ZTogYy52YWx1ZVxuXHRcdH0pO1xuXHR9KSk7XG59O1xuXG4vKlxuICogVGhlc2UgYXJlIGZyb20gWC42ODAgLS0gUHJpbnRhYmxlU3RyaW5nIGFsbG93ZWQgY2hhcnMgYXJlIGluIHNlY3Rpb24gMzcuNFxuICogdGFibGUgOC4gU3BlYyBmb3IgSUE1U3RyaW5ncyBpcyBcIjEsNiArIFNQQUNFICsgREVMXCIgd2hlcmUgMSByZWZlcnMgdG9cbiAqIElTTyBJUiAjMDAxIChzdGFuZGFyZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMpIGFuZCA2IHJlZmVycyB0byBJU08gSVIgIzAwNlxuICogKHRoZSBiYXNpYyBBU0NJSSBjaGFyYWN0ZXIgc2V0KS5cbiAqL1xuLyogSlNTVFlMRUQgKi9cbnZhciBOT1RfUFJJTlRBQkxFID0gL1teYS16QS1aMC05ICcoKSwrLlxcLzo9Py1dLztcbi8qIEpTU1RZTEVEICovXG52YXIgTk9UX0lBNSA9IC9bXlxceDAwLVxceDdmXS87XG5cbklkZW50aXR5LnByb3RvdHlwZS50b0FzbjEgPSBmdW5jdGlvbiAoZGVyLCB0YWcpIHtcblx0ZGVyLnN0YXJ0U2VxdWVuY2UodGFnKTtcblx0dGhpcy5jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0XHRkZXIuc3RhcnRTZXF1ZW5jZShhc24xLkJlci5Db25zdHJ1Y3RvciB8IGFzbjEuQmVyLlNldCk7XG5cdFx0ZGVyLnN0YXJ0U2VxdWVuY2UoKTtcblx0XHRkZXIud3JpdGVPSUQoYy5vaWQpO1xuXHRcdC8qXG5cdFx0ICogSWYgd2UgZml0IGluIGEgUHJpbnRhYmxlU3RyaW5nLCB1c2UgdGhhdC4gT3RoZXJ3aXNlIHVzZSBhblxuXHRcdCAqIElBNVN0cmluZyBvciBVVEY4U3RyaW5nLlxuXHRcdCAqXG5cdFx0ICogSWYgdGhpcyBpZGVudGl0eSB3YXMgcGFyc2VkIGZyb20gYSBETiwgdXNlIHRoZSBBU04uMSB0eXBlc1xuXHRcdCAqIGZyb20gdGhlIG9yaWdpbmFsIHJlcHJlc2VudGF0aW9uIChvdGhlcndpc2UgdGhpcyBtaWdodCBub3Rcblx0XHQgKiBiZSBhIGZ1bGwgbWF0Y2ggZm9yIHRoZSBvcmlnaW5hbCBpbiBzb21lIHZhbGlkYXRvcnMpLlxuXHRcdCAqL1xuXHRcdGlmIChjLmFzbjF0eXBlID09PSBhc24xLkJlci5VdGY4U3RyaW5nIHx8XG5cdFx0ICAgIGMudmFsdWUubWF0Y2goTk9UX0lBNSkpIHtcblx0XHRcdHZhciB2ID0gQnVmZmVyLmZyb20oYy52YWx1ZSwgJ3V0ZjgnKTtcblx0XHRcdGRlci53cml0ZUJ1ZmZlcih2LCBhc24xLkJlci5VdGY4U3RyaW5nKTtcblxuXHRcdH0gZWxzZSBpZiAoYy5hc24xdHlwZSA9PT0gYXNuMS5CZXIuSUE1U3RyaW5nIHx8XG5cdFx0ICAgIGMudmFsdWUubWF0Y2goTk9UX1BSSU5UQUJMRSkpIHtcblx0XHRcdGRlci53cml0ZVN0cmluZyhjLnZhbHVlLCBhc24xLkJlci5JQTVTdHJpbmcpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB0eXBlID0gYXNuMS5CZXIuUHJpbnRhYmxlU3RyaW5nO1xuXHRcdFx0aWYgKGMuYXNuMXR5cGUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0dHlwZSA9IGMuYXNuMXR5cGU7XG5cdFx0XHRkZXIud3JpdGVTdHJpbmcoYy52YWx1ZSwgdHlwZSk7XG5cdFx0fVxuXHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHRcdGRlci5lbmRTZXF1ZW5jZSgpO1xuXHR9KTtcblx0ZGVyLmVuZFNlcXVlbmNlKCk7XG59O1xuXG5mdW5jdGlvbiBnbG9iTWF0Y2goYSwgYikge1xuXHRpZiAoYSA9PT0gJyoqJyB8fCBiID09PSAnKionKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cdHZhciBhUGFydHMgPSBhLnNwbGl0KCcuJyk7XG5cdHZhciBiUGFydHMgPSBiLnNwbGl0KCcuJyk7XG5cdGlmIChhUGFydHMubGVuZ3RoICE9PSBiUGFydHMubGVuZ3RoKVxuXHRcdHJldHVybiAoZmFsc2UpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFQYXJ0cy5sZW5ndGg7ICsraSkge1xuXHRcdGlmIChhUGFydHNbaV0gPT09ICcqJyB8fCBiUGFydHNbaV0gPT09ICcqJylcblx0XHRcdGNvbnRpbnVlO1xuXHRcdGlmIChhUGFydHNbaV0gIT09IGJQYXJ0c1tpXSlcblx0XHRcdHJldHVybiAoZmFsc2UpO1xuXHR9XG5cdHJldHVybiAodHJ1ZSk7XG59XG5cbklkZW50aXR5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0aWYgKCFJZGVudGl0eS5pc0lkZW50aXR5KG90aGVyLCBbMSwgMF0pKVxuXHRcdHJldHVybiAoZmFsc2UpO1xuXHRpZiAob3RoZXIuY29tcG9uZW50cy5sZW5ndGggIT09IHRoaXMuY29tcG9uZW50cy5sZW5ndGgpXG5cdFx0cmV0dXJuIChmYWxzZSk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0aWYgKHRoaXMuY29tcG9uZW50c1tpXS5vaWQgIT09IG90aGVyLmNvbXBvbmVudHNbaV0ub2lkKVxuXHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cdFx0aWYgKCFnbG9iTWF0Y2godGhpcy5jb21wb25lbnRzW2ldLnZhbHVlLFxuXHRcdCAgICBvdGhlci5jb21wb25lbnRzW2ldLnZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAodHJ1ZSk7XG59O1xuXG5JZGVudGl0eS5mb3JIb3N0ID0gZnVuY3Rpb24gKGhvc3RuYW1lKSB7XG5cdGFzc2VydC5zdHJpbmcoaG9zdG5hbWUsICdob3N0bmFtZScpO1xuXHRyZXR1cm4gKG5ldyBJZGVudGl0eSh7XG5cdFx0dHlwZTogJ2hvc3QnLFxuXHRcdGhvc3RuYW1lOiBob3N0bmFtZSxcblx0XHRjb21wb25lbnRzOiBbIHsgbmFtZTogJ2NuJywgdmFsdWU6IGhvc3RuYW1lIH0gXVxuXHR9KSk7XG59O1xuXG5JZGVudGl0eS5mb3JVc2VyID0gZnVuY3Rpb24gKHVpZCkge1xuXHRhc3NlcnQuc3RyaW5nKHVpZCwgJ3VpZCcpO1xuXHRyZXR1cm4gKG5ldyBJZGVudGl0eSh7XG5cdFx0dHlwZTogJ3VzZXInLFxuXHRcdHVpZDogdWlkLFxuXHRcdGNvbXBvbmVudHM6IFsgeyBuYW1lOiAndWlkJywgdmFsdWU6IHVpZCB9IF1cblx0fSkpO1xufTtcblxuSWRlbnRpdHkuZm9yRW1haWwgPSBmdW5jdGlvbiAoZW1haWwpIHtcblx0YXNzZXJ0LnN0cmluZyhlbWFpbCwgJ2VtYWlsJyk7XG5cdHJldHVybiAobmV3IElkZW50aXR5KHtcblx0XHR0eXBlOiAnZW1haWwnLFxuXHRcdGVtYWlsOiBlbWFpbCxcblx0XHRjb21wb25lbnRzOiBbIHsgbmFtZTogJ21haWwnLCB2YWx1ZTogZW1haWwgfSBdXG5cdH0pKTtcbn07XG5cbklkZW50aXR5LnBhcnNlRE4gPSBmdW5jdGlvbiAoZG4pIHtcblx0YXNzZXJ0LnN0cmluZyhkbiwgJ2RuJyk7XG5cdHZhciBwYXJ0cyA9IFsnJ107XG5cdHZhciBpZHggPSAwO1xuXHR2YXIgcmVtID0gZG47XG5cdHdoaWxlIChyZW0ubGVuZ3RoID4gMCkge1xuXHRcdHZhciBtO1xuXHRcdC8qSlNTVFlMRUQqL1xuXHRcdGlmICgobSA9IC9eLC8uZXhlYyhyZW0pKSAhPT0gbnVsbCkge1xuXHRcdFx0cGFydHNbKytpZHhdID0gJyc7XG5cdFx0XHRyZW0gPSByZW0uc2xpY2UobVswXS5sZW5ndGgpO1xuXHRcdC8qSlNTVFlMRUQqL1xuXHRcdH0gZWxzZSBpZiAoKG0gPSAvXlxcXFwsLy5leGVjKHJlbSkpICE9PSBudWxsKSB7XG5cdFx0XHRwYXJ0c1tpZHhdICs9ICcsJztcblx0XHRcdHJlbSA9IHJlbS5zbGljZShtWzBdLmxlbmd0aCk7XG5cdFx0LypKU1NUWUxFRCovXG5cdFx0fSBlbHNlIGlmICgobSA9IC9eXFxcXC4vLmV4ZWMocmVtKSkgIT09IG51bGwpIHtcblx0XHRcdHBhcnRzW2lkeF0gKz0gbVswXTtcblx0XHRcdHJlbSA9IHJlbS5zbGljZShtWzBdLmxlbmd0aCk7XG5cdFx0LypKU1NUWUxFRCovXG5cdFx0fSBlbHNlIGlmICgobSA9IC9eW15cXFxcLF0rLy5leGVjKHJlbSkpICE9PSBudWxsKSB7XG5cdFx0XHRwYXJ0c1tpZHhdICs9IG1bMF07XG5cdFx0XHRyZW0gPSByZW0uc2xpY2UobVswXS5sZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgRE4nKSk7XG5cdFx0fVxuXHR9XG5cdHZhciBjbXBzID0gcGFydHMubWFwKGZ1bmN0aW9uIChjKSB7XG5cdFx0YyA9IGMudHJpbSgpO1xuXHRcdHZhciBlcVBvcyA9IGMuaW5kZXhPZignPScpO1xuXHRcdHdoaWxlIChlcVBvcyA+IDAgJiYgYy5jaGFyQXQoZXFQb3MgLSAxKSA9PT0gJ1xcXFwnKVxuXHRcdFx0ZXFQb3MgPSBjLmluZGV4T2YoJz0nLCBlcVBvcyArIDEpO1xuXHRcdGlmIChlcVBvcyA9PT0gLTEpIHtcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBETicpKTtcblx0XHR9XG5cdFx0LypKU1NUWUxFRCovXG5cdFx0dmFyIG5hbWUgPSBjLnNsaWNlKDAsIGVxUG9zKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcXFw9L2csICc9Jyk7XG5cdFx0dmFyIHZhbHVlID0gYy5zbGljZShlcVBvcyArIDEpO1xuXHRcdHJldHVybiAoeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG5cdH0pO1xuXHRyZXR1cm4gKG5ldyBJZGVudGl0eSh7IGNvbXBvbmVudHM6IGNtcHMgfSkpO1xufTtcblxuSWRlbnRpdHkuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcblx0YXNzZXJ0LmFycmF5T2ZPYmplY3QoY29tcG9uZW50cywgJ2NvbXBvbmVudHMnKTtcblx0Y29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjbXApIHtcblx0XHRhc3NlcnQub2JqZWN0KGNtcCwgJ2NvbXBvbmVudCcpO1xuXHRcdGFzc2VydC5zdHJpbmcoY21wLm5hbWUsICdjb21wb25lbnQubmFtZScpO1xuXHRcdGlmICghQnVmZmVyLmlzQnVmZmVyKGNtcC52YWx1ZSkgJiZcblx0XHQgICAgISh0eXBlb2YgKGNtcC52YWx1ZSkgPT09ICdzdHJpbmcnKSkge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBjb21wb25lbnQgdmFsdWUnKSk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIChuZXcgSWRlbnRpdHkoeyBjb21wb25lbnRzOiBjb21wb25lbnRzIH0pKTtcbn07XG5cbklkZW50aXR5LnBhcnNlQXNuMSA9IGZ1bmN0aW9uIChkZXIsIHRvcCkge1xuXHR2YXIgY29tcG9uZW50cyA9IFtdO1xuXHRkZXIucmVhZFNlcXVlbmNlKHRvcCk7XG5cdHZhciBlbmQgPSBkZXIub2Zmc2V0ICsgZGVyLmxlbmd0aDtcblx0d2hpbGUgKGRlci5vZmZzZXQgPCBlbmQpIHtcblx0XHRkZXIucmVhZFNlcXVlbmNlKGFzbjEuQmVyLkNvbnN0cnVjdG9yIHwgYXNuMS5CZXIuU2V0KTtcblx0XHR2YXIgYWZ0ZXIgPSBkZXIub2Zmc2V0ICsgZGVyLmxlbmd0aDtcblx0XHRkZXIucmVhZFNlcXVlbmNlKCk7XG5cdFx0dmFyIG9pZCA9IGRlci5yZWFkT0lEKCk7XG5cdFx0dmFyIHR5cGUgPSBkZXIucGVlaygpO1xuXHRcdHZhciB2YWx1ZTtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRjYXNlIGFzbjEuQmVyLlByaW50YWJsZVN0cmluZzpcblx0XHRjYXNlIGFzbjEuQmVyLklBNVN0cmluZzpcblx0XHRjYXNlIGFzbjEuQmVyLk9jdGV0U3RyaW5nOlxuXHRcdGNhc2UgYXNuMS5CZXIuVDYxU3RyaW5nOlxuXHRcdFx0dmFsdWUgPSBkZXIucmVhZFN0cmluZyh0eXBlKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgYXNuMS5CZXIuVXRmOFN0cmluZzpcblx0XHRcdHZhbHVlID0gZGVyLnJlYWRTdHJpbmcodHlwZSwgdHJ1ZSk7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFzbjEuQmVyLkNoYXJhY3RlclN0cmluZzpcblx0XHRjYXNlIGFzbjEuQmVyLkJNUFN0cmluZzpcblx0XHRcdHZhbHVlID0gZGVyLnJlYWRTdHJpbmcodHlwZSwgdHJ1ZSk7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCd1dGYxNmxlJyk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignVW5rbm93biBhc24xIHR5cGUgJyArIHR5cGUpKTtcblx0XHR9XG5cdFx0Y29tcG9uZW50cy5wdXNoKHsgb2lkOiBvaWQsIGFzbjF0eXBlOiB0eXBlLCB2YWx1ZTogdmFsdWUgfSk7XG5cdFx0ZGVyLl9vZmZzZXQgPSBhZnRlcjtcblx0fVxuXHRkZXIuX29mZnNldCA9IGVuZDtcblx0cmV0dXJuIChuZXcgSWRlbnRpdHkoe1xuXHRcdGNvbXBvbmVudHM6IGNvbXBvbmVudHNcblx0fSkpO1xufTtcblxuSWRlbnRpdHkuaXNJZGVudGl0eSA9IGZ1bmN0aW9uIChvYmosIHZlcikge1xuXHRyZXR1cm4gKHV0aWxzLmlzQ29tcGF0aWJsZShvYmosIElkZW50aXR5LCB2ZXIpKTtcbn07XG5cbi8qXG4gKiBBUEkgdmVyc2lvbnMgZm9yIElkZW50aXR5OlxuICogWzEsMF0gLS0gaW5pdGlhbCB2ZXJcbiAqL1xuSWRlbnRpdHkucHJvdG90eXBlLl9zc2hwa0FwaVZlcnNpb24gPSBbMSwgMF07XG5cbklkZW50aXR5Ll9vbGRWZXJzaW9uRGV0ZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuXHRyZXR1cm4gKFsxLCAwXSk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBLZXkgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIEZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9maW5nZXJwcmludCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vcHJpdmF0ZS1rZXknKTtcbnZhciBDZXJ0aWZpY2F0ZSA9IHJlcXVpcmUoJy4vY2VydGlmaWNhdGUnKTtcbnZhciBJZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcbnZhciBlcnJzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8qIHRvcC1sZXZlbCBjbGFzc2VzICovXG5cdEtleTogS2V5LFxuXHRwYXJzZUtleTogS2V5LnBhcnNlLFxuXHRGaW5nZXJwcmludDogRmluZ2VycHJpbnQsXG5cdHBhcnNlRmluZ2VycHJpbnQ6IEZpbmdlcnByaW50LnBhcnNlLFxuXHRTaWduYXR1cmU6IFNpZ25hdHVyZSxcblx0cGFyc2VTaWduYXR1cmU6IFNpZ25hdHVyZS5wYXJzZSxcblx0UHJpdmF0ZUtleTogUHJpdmF0ZUtleSxcblx0cGFyc2VQcml2YXRlS2V5OiBQcml2YXRlS2V5LnBhcnNlLFxuXHRnZW5lcmF0ZVByaXZhdGVLZXk6IFByaXZhdGVLZXkuZ2VuZXJhdGUsXG5cdENlcnRpZmljYXRlOiBDZXJ0aWZpY2F0ZSxcblx0cGFyc2VDZXJ0aWZpY2F0ZTogQ2VydGlmaWNhdGUucGFyc2UsXG5cdGNyZWF0ZVNlbGZTaWduZWRDZXJ0aWZpY2F0ZTogQ2VydGlmaWNhdGUuY3JlYXRlU2VsZlNpZ25lZCxcblx0Y3JlYXRlQ2VydGlmaWNhdGU6IENlcnRpZmljYXRlLmNyZWF0ZSxcblx0SWRlbnRpdHk6IElkZW50aXR5LFxuXHRpZGVudGl0eUZyb21ETjogSWRlbnRpdHkucGFyc2VETixcblx0aWRlbnRpdHlGb3JIb3N0OiBJZGVudGl0eS5mb3JIb3N0LFxuXHRpZGVudGl0eUZvclVzZXI6IElkZW50aXR5LmZvclVzZXIsXG5cdGlkZW50aXR5Rm9yRW1haWw6IElkZW50aXR5LmZvckVtYWlsLFxuXHRpZGVudGl0eUZyb21BcnJheTogSWRlbnRpdHkuZnJvbUFycmF5LFxuXG5cdC8qIGVycm9ycyAqL1xuXHRGaW5nZXJwcmludEZvcm1hdEVycm9yOiBlcnJzLkZpbmdlcnByaW50Rm9ybWF0RXJyb3IsXG5cdEludmFsaWRBbGdvcml0aG1FcnJvcjogZXJycy5JbnZhbGlkQWxnb3JpdGhtRXJyb3IsXG5cdEtleVBhcnNlRXJyb3I6IGVycnMuS2V5UGFyc2VFcnJvcixcblx0U2lnbmF0dXJlUGFyc2VFcnJvcjogZXJycy5TaWduYXR1cmVQYXJzZUVycm9yLFxuXHRLZXlFbmNyeXB0ZWRFcnJvcjogZXJycy5LZXlFbmNyeXB0ZWRFcnJvcixcblx0Q2VydGlmaWNhdGVQYXJzZUVycm9yOiBlcnJzLkNlcnRpZmljYXRlUGFyc2VFcnJvclxufTtcbiIsIi8vIENvcHlyaWdodCAyMDE4IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgYWxncyA9IHJlcXVpcmUoJy4vYWxncycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIEZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9maW5nZXJwcmludCcpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgRGlmZmllSGVsbG1hbiA9IHJlcXVpcmUoJy4vZGhlJykuRGlmZmllSGVsbG1hbjtcbnZhciBlcnJzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBQcml2YXRlS2V5ID0gcmVxdWlyZSgnLi9wcml2YXRlLWtleScpO1xudmFyIGVkQ29tcGF0O1xuXG50cnkge1xuXHRlZENvbXBhdCA9IHJlcXVpcmUoJy4vZWQtY29tcGF0Jyk7XG59IGNhdGNoIChlKSB7XG5cdC8qIEp1c3QgY29udGludWUgdGhyb3VnaCwgYW5kIGJhaWwgb3V0IGlmIHdlIHRyeSB0byB1c2UgaXQuICovXG59XG5cbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSBlcnJzLkludmFsaWRBbGdvcml0aG1FcnJvcjtcbnZhciBLZXlQYXJzZUVycm9yID0gZXJycy5LZXlQYXJzZUVycm9yO1xuXG52YXIgZm9ybWF0cyA9IHt9O1xuZm9ybWF0c1snYXV0byddID0gcmVxdWlyZSgnLi9mb3JtYXRzL2F1dG8nKTtcbmZvcm1hdHNbJ3BlbSddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3BlbScpO1xuZm9ybWF0c1sncGtjczEnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wa2NzMScpO1xuZm9ybWF0c1sncGtjczgnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wa2NzOCcpO1xuZm9ybWF0c1sncmZjNDI1MyddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3JmYzQyNTMnKTtcbmZvcm1hdHNbJ3NzaCddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3NzaCcpO1xuZm9ybWF0c1snc3NoLXByaXZhdGUnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9zc2gtcHJpdmF0ZScpO1xuZm9ybWF0c1snb3BlbnNzaCddID0gZm9ybWF0c1snc3NoLXByaXZhdGUnXTtcbmZvcm1hdHNbJ2Ruc3NlYyddID0gcmVxdWlyZSgnLi9mb3JtYXRzL2Ruc3NlYycpO1xuZm9ybWF0c1sncHV0dHknXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wdXR0eScpO1xuZm9ybWF0c1sncHBrJ10gPSBmb3JtYXRzWydwdXR0eSddO1xuXG5mdW5jdGlvbiBLZXkob3B0cykge1xuXHRhc3NlcnQub2JqZWN0KG9wdHMsICdvcHRpb25zJyk7XG5cdGFzc2VydC5hcnJheU9mT2JqZWN0KG9wdHMucGFydHMsICdvcHRpb25zLnBhcnRzJyk7XG5cdGFzc2VydC5zdHJpbmcob3B0cy50eXBlLCAnb3B0aW9ucy50eXBlJyk7XG5cdGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRzLmNvbW1lbnQsICdvcHRpb25zLmNvbW1lbnQnKTtcblxuXHR2YXIgYWxnSW5mbyA9IGFsZ3MuaW5mb1tvcHRzLnR5cGVdO1xuXHRpZiAodHlwZW9mIChhbGdJbmZvKSAhPT0gJ29iamVjdCcpXG5cdFx0dGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3Iob3B0cy50eXBlKSk7XG5cblx0dmFyIHBhcnRMb29rdXAgPSB7fTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvcHRzLnBhcnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIHBhcnQgPSBvcHRzLnBhcnRzW2ldO1xuXHRcdHBhcnRMb29rdXBbcGFydC5uYW1lXSA9IHBhcnQ7XG5cdH1cblxuXHR0aGlzLnR5cGUgPSBvcHRzLnR5cGU7XG5cdHRoaXMucGFydHMgPSBvcHRzLnBhcnRzO1xuXHR0aGlzLnBhcnQgPSBwYXJ0TG9va3VwO1xuXHR0aGlzLmNvbW1lbnQgPSB1bmRlZmluZWQ7XG5cdHRoaXMuc291cmNlID0gb3B0cy5zb3VyY2U7XG5cblx0LyogZm9yIHNwZWVkaW5nIHVwIGhhc2hpbmcvZmluZ2VycHJpbnQgb3BlcmF0aW9ucyAqL1xuXHR0aGlzLl9yZmM0MjUzQ2FjaGUgPSBvcHRzLl9yZmM0MjUzQ2FjaGU7XG5cdHRoaXMuX2hhc2hDYWNoZSA9IHt9O1xuXG5cdHZhciBzejtcblx0dGhpcy5jdXJ2ZSA9IHVuZGVmaW5lZDtcblx0aWYgKHRoaXMudHlwZSA9PT0gJ2VjZHNhJykge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMucGFydC5jdXJ2ZS5kYXRhLnRvU3RyaW5nKCk7XG5cdFx0dGhpcy5jdXJ2ZSA9IGN1cnZlO1xuXHRcdHN6ID0gYWxncy5jdXJ2ZXNbY3VydmVdLnNpemU7XG5cdH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAnZWQyNTUxOScgfHwgdGhpcy50eXBlID09PSAnY3VydmUyNTUxOScpIHtcblx0XHRzeiA9IDI1Njtcblx0XHR0aGlzLmN1cnZlID0gJ2N1cnZlMjU1MTknO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBzelBhcnQgPSB0aGlzLnBhcnRbYWxnSW5mby5zaXplUGFydF07XG5cdFx0c3ogPSBzelBhcnQuZGF0YS5sZW5ndGg7XG5cdFx0c3ogPSBzeiAqIDggLSB1dGlscy5jb3VudFplcm9zKHN6UGFydC5kYXRhKTtcblx0fVxuXHR0aGlzLnNpemUgPSBzejtcbn1cblxuS2V5LmZvcm1hdHMgPSBmb3JtYXRzO1xuXG5LZXkucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKGZvcm1hdCwgb3B0aW9ucykge1xuXHRpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpXG5cdFx0Zm9ybWF0ID0gJ3NzaCc7XG5cdGFzc2VydC5zdHJpbmcoZm9ybWF0LCAnZm9ybWF0Jyk7XG5cdGFzc2VydC5vYmplY3QoZm9ybWF0c1tmb3JtYXRdLCAnZm9ybWF0c1tmb3JtYXRdJyk7XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuXG5cdGlmIChmb3JtYXQgPT09ICdyZmM0MjUzJykge1xuXHRcdGlmICh0aGlzLl9yZmM0MjUzQ2FjaGUgPT09IHVuZGVmaW5lZClcblx0XHRcdHRoaXMuX3JmYzQyNTNDYWNoZSA9IGZvcm1hdHNbJ3JmYzQyNTMnXS53cml0ZSh0aGlzKTtcblx0XHRyZXR1cm4gKHRoaXMuX3JmYzQyNTNDYWNoZSk7XG5cdH1cblxuXHRyZXR1cm4gKGZvcm1hdHNbZm9ybWF0XS53cml0ZSh0aGlzLCBvcHRpb25zKSk7XG59O1xuXG5LZXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGZvcm1hdCwgb3B0aW9ucykge1xuXHRyZXR1cm4gKHRoaXMudG9CdWZmZXIoZm9ybWF0LCBvcHRpb25zKS50b1N0cmluZygpKTtcbn07XG5cbktleS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uIChhbGdvLCB0eXBlKSB7XG5cdGFzc2VydC5zdHJpbmcoYWxnbywgJ2FsZ29yaXRobScpO1xuXHRhc3NlcnQub3B0aW9uYWxTdHJpbmcodHlwZSwgJ3R5cGUnKTtcblx0aWYgKHR5cGUgPT09IHVuZGVmaW5lZClcblx0XHR0eXBlID0gJ3NzaCc7XG5cdGFsZ28gPSBhbGdvLnRvTG93ZXJDYXNlKCk7XG5cdGlmIChhbGdzLmhhc2hBbGdzW2FsZ29dID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3IoYWxnbykpO1xuXG5cdHZhciBjYWNoZUtleSA9IGFsZ28gKyAnfHwnICsgdHlwZTtcblx0aWYgKHRoaXMuX2hhc2hDYWNoZVtjYWNoZUtleV0pXG5cdFx0cmV0dXJuICh0aGlzLl9oYXNoQ2FjaGVbY2FjaGVLZXldKTtcblxuXHR2YXIgYnVmO1xuXHRpZiAodHlwZSA9PT0gJ3NzaCcpIHtcblx0XHRidWYgPSB0aGlzLnRvQnVmZmVyKCdyZmM0MjUzJyk7XG5cdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3Nwa2knKSB7XG5cdFx0YnVmID0gZm9ybWF0cy5wa2NzOC5wa2NzOFRvQnVmZmVyKHRoaXMpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IChuZXcgRXJyb3IoJ0hhc2ggdHlwZSAnICsgdHlwZSArICcgbm90IHN1cHBvcnRlZCcpKTtcblx0fVxuXHR2YXIgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ28pLnVwZGF0ZShidWYpLmRpZ2VzdCgpO1xuXHR0aGlzLl9oYXNoQ2FjaGVbY2FjaGVLZXldID0gaGFzaDtcblx0cmV0dXJuIChoYXNoKTtcbn07XG5cbktleS5wcm90b3R5cGUuZmluZ2VycHJpbnQgPSBmdW5jdGlvbiAoYWxnbywgdHlwZSkge1xuXHRpZiAoYWxnbyA9PT0gdW5kZWZpbmVkKVxuXHRcdGFsZ28gPSAnc2hhMjU2Jztcblx0aWYgKHR5cGUgPT09IHVuZGVmaW5lZClcblx0XHR0eXBlID0gJ3NzaCc7XG5cdGFzc2VydC5zdHJpbmcoYWxnbywgJ2FsZ29yaXRobScpO1xuXHRhc3NlcnQuc3RyaW5nKHR5cGUsICd0eXBlJyk7XG5cdHZhciBvcHRzID0ge1xuXHRcdHR5cGU6ICdrZXknLFxuXHRcdGhhc2g6IHRoaXMuaGFzaChhbGdvLCB0eXBlKSxcblx0XHRhbGdvcml0aG06IGFsZ28sXG5cdFx0aGFzaFR5cGU6IHR5cGVcblx0fTtcblx0cmV0dXJuIChuZXcgRmluZ2VycHJpbnQob3B0cykpO1xufTtcblxuS2V5LnByb3RvdHlwZS5kZWZhdWx0SGFzaEFsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGhhc2hBbGdvID0gJ3NoYTEnO1xuXHRpZiAodGhpcy50eXBlID09PSAncnNhJylcblx0XHRoYXNoQWxnbyA9ICdzaGEyNTYnO1xuXHRpZiAodGhpcy50eXBlID09PSAnZHNhJyAmJiB0aGlzLnNpemUgPiAxMDI0KVxuXHRcdGhhc2hBbGdvID0gJ3NoYTI1Nic7XG5cdGlmICh0aGlzLnR5cGUgPT09ICdlZDI1NTE5Jylcblx0XHRoYXNoQWxnbyA9ICdzaGE1MTInO1xuXHRpZiAodGhpcy50eXBlID09PSAnZWNkc2EnKSB7XG5cdFx0aWYgKHRoaXMuc2l6ZSA8PSAyNTYpXG5cdFx0XHRoYXNoQWxnbyA9ICdzaGEyNTYnO1xuXHRcdGVsc2UgaWYgKHRoaXMuc2l6ZSA8PSAzODQpXG5cdFx0XHRoYXNoQWxnbyA9ICdzaGEzODQnO1xuXHRcdGVsc2Vcblx0XHRcdGhhc2hBbGdvID0gJ3NoYTUxMic7XG5cdH1cblx0cmV0dXJuIChoYXNoQWxnbyk7XG59O1xuXG5LZXkucHJvdG90eXBlLmNyZWF0ZVZlcmlmeSA9IGZ1bmN0aW9uIChoYXNoQWxnbykge1xuXHRpZiAoaGFzaEFsZ28gPT09IHVuZGVmaW5lZClcblx0XHRoYXNoQWxnbyA9IHRoaXMuZGVmYXVsdEhhc2hBbGdvcml0aG0oKTtcblx0YXNzZXJ0LnN0cmluZyhoYXNoQWxnbywgJ2hhc2ggYWxnb3JpdGhtJyk7XG5cblx0LyogRUQyNTUxOSBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wZW5TU0wsIHVzZSBhIGphdmFzY3JpcHQgaW1wbC4gKi9cblx0aWYgKHRoaXMudHlwZSA9PT0gJ2VkMjU1MTknICYmIGVkQ29tcGF0ICE9PSB1bmRlZmluZWQpXG5cdFx0cmV0dXJuIChuZXcgZWRDb21wYXQuVmVyaWZpZXIodGhpcywgaGFzaEFsZ28pKTtcblx0aWYgKHRoaXMudHlwZSA9PT0gJ2N1cnZlMjU1MTknKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0N1cnZlMjU1MTkga2V5cyBhcmUgbm90IHN1aXRhYmxlIGZvciAnICtcblx0XHQgICAgJ3NpZ25pbmcgb3IgdmVyaWZpY2F0aW9uJykpO1xuXG5cdHZhciB2LCBubSwgZXJyO1xuXHR0cnkge1xuXHRcdG5tID0gaGFzaEFsZ28udG9VcHBlckNhc2UoKTtcblx0XHR2ID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShubSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRlcnIgPSBlO1xuXHR9XG5cdGlmICh2ID09PSB1bmRlZmluZWQgfHwgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmXG5cdCAgICBlcnIubWVzc2FnZS5tYXRjaCgvVW5rbm93biBtZXNzYWdlIGRpZ2VzdC8pKSkge1xuXHRcdG5tID0gJ1JTQS0nO1xuXHRcdG5tICs9IGhhc2hBbGdvLnRvVXBwZXJDYXNlKCk7XG5cdFx0diA9IGNyeXB0by5jcmVhdGVWZXJpZnkobm0pO1xuXHR9XG5cdGFzc2VydC5vayh2LCAnZmFpbGVkIHRvIGNyZWF0ZSB2ZXJpZmllcicpO1xuXHR2YXIgb2xkVmVyaWZ5ID0gdi52ZXJpZnkuYmluZCh2KTtcblx0dmFyIGtleSA9IHRoaXMudG9CdWZmZXIoJ3BrY3M4Jyk7XG5cdHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG5cdHZhciBzZWxmID0gdGhpcztcblx0di52ZXJpZnkgPSBmdW5jdGlvbiAoc2lnbmF0dXJlLCBmbXQpIHtcblx0XHRpZiAoU2lnbmF0dXJlLmlzU2lnbmF0dXJlKHNpZ25hdHVyZSwgWzIsIDBdKSkge1xuXHRcdFx0aWYgKHNpZ25hdHVyZS50eXBlICE9PSBzZWxmLnR5cGUpXG5cdFx0XHRcdHJldHVybiAoZmFsc2UpO1xuXHRcdFx0aWYgKHNpZ25hdHVyZS5oYXNoQWxnb3JpdGhtICYmXG5cdFx0XHQgICAgc2lnbmF0dXJlLmhhc2hBbGdvcml0aG0gIT09IGhhc2hBbGdvKVxuXHRcdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0XHRcdGlmIChzaWduYXR1cmUuY3VydmUgJiYgc2VsZi50eXBlID09PSAnZWNkc2EnICYmXG5cdFx0XHQgICAgc2lnbmF0dXJlLmN1cnZlICE9PSBjdXJ2ZSlcblx0XHRcdFx0cmV0dXJuIChmYWxzZSk7XG5cdFx0XHRyZXR1cm4gKG9sZFZlcmlmeShrZXksIHNpZ25hdHVyZS50b0J1ZmZlcignYXNuMScpKSk7XG5cblx0XHR9IGVsc2UgaWYgKHR5cGVvZiAoc2lnbmF0dXJlKSA9PT0gJ3N0cmluZycgfHxcblx0XHQgICAgQnVmZmVyLmlzQnVmZmVyKHNpZ25hdHVyZSkpIHtcblx0XHRcdHJldHVybiAob2xkVmVyaWZ5KGtleSwgc2lnbmF0dXJlLCBmbXQpKTtcblxuXHRcdC8qXG5cdFx0ICogQXZvaWQgZG9pbmcgdGhpcyBvbiB2YWxpZCBhcmd1bWVudHMsIHdhbGtpbmcgdGhlIHByb3RvdHlwZVxuXHRcdCAqIGNoYWluIGNhbiBiZSBxdWl0ZSBzbG93LlxuXHRcdCAqL1xuXHRcdH0gZWxzZSBpZiAoU2lnbmF0dXJlLmlzU2lnbmF0dXJlKHNpZ25hdHVyZSwgWzEsIDBdKSkge1xuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignc2lnbmF0dXJlIHdhcyBjcmVhdGVkIGJ5IHRvbyBvbGQgJyArXG5cdFx0XHQgICAgJ2EgdmVyc2lvbiBvZiBzc2hwayBhbmQgY2Fubm90IGJlIHZlcmlmaWVkJykpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IChuZXcgVHlwZUVycm9yKCdzaWduYXR1cmUgbXVzdCBiZSBhIHN0cmluZywgJyArXG5cdFx0XHQgICAgJ0J1ZmZlciwgb3IgU2lnbmF0dXJlIG9iamVjdCcpKTtcblx0XHR9XG5cdH07XG5cdHJldHVybiAodik7XG59O1xuXG5LZXkucHJvdG90eXBlLmNyZWF0ZURpZmZpZUhlbGxtYW4gPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzLnR5cGUgPT09ICdyc2EnKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1JTQSBrZXlzIGRvIG5vdCBzdXBwb3J0IERpZmZpZS1IZWxsbWFuJykpO1xuXG5cdHJldHVybiAobmV3IERpZmZpZUhlbGxtYW4odGhpcykpO1xufTtcbktleS5wcm90b3R5cGUuY3JlYXRlREggPSBLZXkucHJvdG90eXBlLmNyZWF0ZURpZmZpZUhlbGxtYW47XG5cbktleS5wYXJzZSA9IGZ1bmN0aW9uIChkYXRhLCBmb3JtYXQsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiAoZGF0YSkgIT09ICdzdHJpbmcnKVxuXHRcdGFzc2VydC5idWZmZXIoZGF0YSwgJ2RhdGEnKTtcblx0aWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKVxuXHRcdGZvcm1hdCA9ICdhdXRvJztcblx0YXNzZXJ0LnN0cmluZyhmb3JtYXQsICdmb3JtYXQnKTtcblx0aWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdzdHJpbmcnKVxuXHRcdG9wdGlvbnMgPSB7IGZpbGVuYW1lOiBvcHRpb25zIH07XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuXHRpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKVxuXHRcdG9wdGlvbnMgPSB7fTtcblx0YXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKG9wdGlvbnMuZmlsZW5hbWUsICdvcHRpb25zLmZpbGVuYW1lJyk7XG5cdGlmIChvcHRpb25zLmZpbGVuYW1lID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucy5maWxlbmFtZSA9ICcodW5uYW1lZCknO1xuXG5cdGFzc2VydC5vYmplY3QoZm9ybWF0c1tmb3JtYXRdLCAnZm9ybWF0c1tmb3JtYXRdJyk7XG5cblx0dHJ5IHtcblx0XHR2YXIgayA9IGZvcm1hdHNbZm9ybWF0XS5yZWFkKGRhdGEsIG9wdGlvbnMpO1xuXHRcdGlmIChrIGluc3RhbmNlb2YgUHJpdmF0ZUtleSlcblx0XHRcdGsgPSBrLnRvUHVibGljKCk7XG5cdFx0aWYgKCFrLmNvbW1lbnQpXG5cdFx0XHRrLmNvbW1lbnQgPSBvcHRpb25zLmZpbGVuYW1lO1xuXHRcdHJldHVybiAoayk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoZS5uYW1lID09PSAnS2V5RW5jcnlwdGVkRXJyb3InKVxuXHRcdFx0dGhyb3cgKGUpO1xuXHRcdHRocm93IChuZXcgS2V5UGFyc2VFcnJvcihvcHRpb25zLmZpbGVuYW1lLCBmb3JtYXQsIGUpKTtcblx0fVxufTtcblxuS2V5LmlzS2V5ID0gZnVuY3Rpb24gKG9iaiwgdmVyKSB7XG5cdHJldHVybiAodXRpbHMuaXNDb21wYXRpYmxlKG9iaiwgS2V5LCB2ZXIpKTtcbn07XG5cbi8qXG4gKiBBUEkgdmVyc2lvbnMgZm9yIEtleTpcbiAqIFsxLDBdIC0tIGluaXRpYWwgdmVyLCBtYXkgdGFrZSBTaWduYXR1cmUgZm9yIGNyZWF0ZVZlcmlmeSBvciBtYXkgbm90XG4gKiBbMSwxXSAtLSBhZGRlZCBwa2NzMSwgcGtjczggZm9ybWF0c1xuICogWzEsMl0gLS0gYWRkZWQgYXV0bywgc3NoLXByaXZhdGUsIG9wZW5zc2ggZm9ybWF0c1xuICogWzEsM10gLS0gYWRkZWQgZGVmYXVsdEhhc2hBbGdvcml0aG1cbiAqIFsxLDRdIC0tIGFkZGVkIGVkIHN1cHBvcnQsIGNyZWF0ZURIXG4gKiBbMSw1XSAtLSBmaXJzdCBleHBsaWNpdGx5IHRhZ2dlZCB2ZXJzaW9uXG4gKiBbMSw2XSAtLSBjaGFuZ2VkIGVkMjU1MTkgcGFydCBuYW1lc1xuICogWzEsN10gLS0gc3BraSBoYXNoIHR5cGVzXG4gKi9cbktleS5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbiA9IFsxLCA3XTtcblxuS2V5Ll9vbGRWZXJzaW9uRGV0ZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuXHRhc3NlcnQuZnVuYyhvYmoudG9CdWZmZXIpO1xuXHRhc3NlcnQuZnVuYyhvYmouZmluZ2VycHJpbnQpO1xuXHRpZiAob2JqLmNyZWF0ZURIKVxuXHRcdHJldHVybiAoWzEsIDRdKTtcblx0aWYgKG9iai5kZWZhdWx0SGFzaEFsZ29yaXRobSlcblx0XHRyZXR1cm4gKFsxLCAzXSk7XG5cdGlmIChvYmouZm9ybWF0c1snYXV0byddKVxuXHRcdHJldHVybiAoWzEsIDJdKTtcblx0aWYgKG9iai5mb3JtYXRzWydwa2NzMSddKVxuXHRcdHJldHVybiAoWzEsIDFdKTtcblx0cmV0dXJuIChbMSwgMF0pO1xufTtcbiIsIi8vIENvcHlyaWdodCAyMDE3IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFByaXZhdGVLZXk7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmVyLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBhbGdzID0gcmVxdWlyZSgnLi9hbGdzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgRmluZ2VycHJpbnQgPSByZXF1aXJlKCcuL2ZpbmdlcnByaW50Jyk7XG52YXIgU2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbnZhciBlcnJzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGRoZSA9IHJlcXVpcmUoJy4vZGhlJyk7XG52YXIgZ2VuZXJhdGVFQ0RTQSA9IGRoZS5nZW5lcmF0ZUVDRFNBO1xudmFyIGdlbmVyYXRlRUQyNTUxOSA9IGRoZS5nZW5lcmF0ZUVEMjU1MTk7XG52YXIgZWRDb21wYXQgPSByZXF1aXJlKCcuL2VkLWNvbXBhdCcpO1xudmFyIG5hY2wgPSByZXF1aXJlKCd0d2VldG5hY2wnKTtcblxudmFyIEtleSA9IHJlcXVpcmUoJy4va2V5Jyk7XG5cbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSBlcnJzLkludmFsaWRBbGdvcml0aG1FcnJvcjtcbnZhciBLZXlQYXJzZUVycm9yID0gZXJycy5LZXlQYXJzZUVycm9yO1xudmFyIEtleUVuY3J5cHRlZEVycm9yID0gZXJycy5LZXlFbmNyeXB0ZWRFcnJvcjtcblxudmFyIGZvcm1hdHMgPSB7fTtcbmZvcm1hdHNbJ2F1dG8nXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9hdXRvJyk7XG5mb3JtYXRzWydwZW0nXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9wZW0nKTtcbmZvcm1hdHNbJ3BrY3MxJ10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvcGtjczEnKTtcbmZvcm1hdHNbJ3BrY3M4J10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvcGtjczgnKTtcbmZvcm1hdHNbJ3JmYzQyNTMnXSA9IHJlcXVpcmUoJy4vZm9ybWF0cy9yZmM0MjUzJyk7XG5mb3JtYXRzWydzc2gtcHJpdmF0ZSddID0gcmVxdWlyZSgnLi9mb3JtYXRzL3NzaC1wcml2YXRlJyk7XG5mb3JtYXRzWydvcGVuc3NoJ10gPSBmb3JtYXRzWydzc2gtcHJpdmF0ZSddO1xuZm9ybWF0c1snc3NoJ10gPSBmb3JtYXRzWydzc2gtcHJpdmF0ZSddO1xuZm9ybWF0c1snZG5zc2VjJ10gPSByZXF1aXJlKCcuL2Zvcm1hdHMvZG5zc2VjJyk7XG5cbmZ1bmN0aW9uIFByaXZhdGVLZXkob3B0cykge1xuXHRhc3NlcnQub2JqZWN0KG9wdHMsICdvcHRpb25zJyk7XG5cdEtleS5jYWxsKHRoaXMsIG9wdHMpO1xuXG5cdHRoaXMuX3B1YkNhY2hlID0gdW5kZWZpbmVkO1xufVxudXRpbC5pbmhlcml0cyhQcml2YXRlS2V5LCBLZXkpO1xuXG5Qcml2YXRlS2V5LmZvcm1hdHMgPSBmb3JtYXRzO1xuXG5Qcml2YXRlS2V5LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIChmb3JtYXQsIG9wdGlvbnMpIHtcblx0aWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKVxuXHRcdGZvcm1hdCA9ICdwa2NzMSc7XG5cdGFzc2VydC5zdHJpbmcoZm9ybWF0LCAnZm9ybWF0Jyk7XG5cdGFzc2VydC5vYmplY3QoZm9ybWF0c1tmb3JtYXRdLCAnZm9ybWF0c1tmb3JtYXRdJyk7XG5cdGFzc2VydC5vcHRpb25hbE9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuXG5cdHJldHVybiAoZm9ybWF0c1tmb3JtYXRdLndyaXRlKHRoaXMsIG9wdGlvbnMpKTtcbn07XG5cblByaXZhdGVLZXkucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoYWxnbywgdHlwZSkge1xuXHRyZXR1cm4gKHRoaXMudG9QdWJsaWMoKS5oYXNoKGFsZ28sIHR5cGUpKTtcbn07XG5cblByaXZhdGVLZXkucHJvdG90eXBlLmZpbmdlcnByaW50ID0gZnVuY3Rpb24gKGFsZ28sIHR5cGUpIHtcblx0cmV0dXJuICh0aGlzLnRvUHVibGljKCkuZmluZ2VycHJpbnQoYWxnbywgdHlwZSkpO1xufTtcblxuUHJpdmF0ZUtleS5wcm90b3R5cGUudG9QdWJsaWMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzLl9wdWJDYWNoZSlcblx0XHRyZXR1cm4gKHRoaXMuX3B1YkNhY2hlKTtcblxuXHR2YXIgYWxnSW5mbyA9IGFsZ3MuaW5mb1t0aGlzLnR5cGVdO1xuXHR2YXIgcHViUGFydHMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbGdJbmZvLnBhcnRzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIHAgPSBhbGdJbmZvLnBhcnRzW2ldO1xuXHRcdHB1YlBhcnRzLnB1c2godGhpcy5wYXJ0W3BdKTtcblx0fVxuXG5cdHRoaXMuX3B1YkNhY2hlID0gbmV3IEtleSh7XG5cdFx0dHlwZTogdGhpcy50eXBlLFxuXHRcdHNvdXJjZTogdGhpcyxcblx0XHRwYXJ0czogcHViUGFydHNcblx0fSk7XG5cdGlmICh0aGlzLmNvbW1lbnQpXG5cdFx0dGhpcy5fcHViQ2FjaGUuY29tbWVudCA9IHRoaXMuY29tbWVudDtcblx0cmV0dXJuICh0aGlzLl9wdWJDYWNoZSk7XG59O1xuXG5Qcml2YXRlS2V5LnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiAobmV3VHlwZSkge1xuXHRhc3NlcnQuc3RyaW5nKG5ld1R5cGUsICd0eXBlJyk7XG5cdHZhciBwcml2LCBwdWIsIHBhaXI7XG5cblx0aWYgKHRoaXMudHlwZSA9PT0gJ2VkMjU1MTknICYmIG5ld1R5cGUgPT09ICdjdXJ2ZTI1NTE5Jykge1xuXHRcdHByaXYgPSB0aGlzLnBhcnQuay5kYXRhO1xuXHRcdGlmIChwcml2WzBdID09PSAweDAwKVxuXHRcdFx0cHJpdiA9IHByaXYuc2xpY2UoMSk7XG5cblx0XHRwYWlyID0gbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5KG5ldyBVaW50OEFycmF5KHByaXYpKTtcblx0XHRwdWIgPSBCdWZmZXIuZnJvbShwYWlyLnB1YmxpY0tleSk7XG5cblx0XHRyZXR1cm4gKG5ldyBQcml2YXRlS2V5KHtcblx0XHRcdHR5cGU6ICdjdXJ2ZTI1NTE5Jyxcblx0XHRcdHBhcnRzOiBbXG5cdFx0XHRcdHsgbmFtZTogJ0EnLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShwdWIpIH0sXG5cdFx0XHRcdHsgbmFtZTogJ2snLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShwcml2KSB9XG5cdFx0XHRdXG5cdFx0fSkpO1xuXHR9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ2N1cnZlMjU1MTknICYmIG5ld1R5cGUgPT09ICdlZDI1NTE5Jykge1xuXHRcdHByaXYgPSB0aGlzLnBhcnQuay5kYXRhO1xuXHRcdGlmIChwcml2WzBdID09PSAweDAwKVxuXHRcdFx0cHJpdiA9IHByaXYuc2xpY2UoMSk7XG5cblx0XHRwYWlyID0gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQobmV3IFVpbnQ4QXJyYXkocHJpdikpO1xuXHRcdHB1YiA9IEJ1ZmZlci5mcm9tKHBhaXIucHVibGljS2V5KTtcblxuXHRcdHJldHVybiAobmV3IFByaXZhdGVLZXkoe1xuXHRcdFx0dHlwZTogJ2VkMjU1MTknLFxuXHRcdFx0cGFydHM6IFtcblx0XHRcdFx0eyBuYW1lOiAnQScsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHB1YikgfSxcblx0XHRcdFx0eyBuYW1lOiAnaycsIGRhdGE6IHV0aWxzLm1wTm9ybWFsaXplKHByaXYpIH1cblx0XHRcdF1cblx0XHR9KSk7XG5cdH1cblx0dGhyb3cgKG5ldyBFcnJvcignS2V5IGRlcml2YXRpb24gbm90IHN1cHBvcnRlZCBmcm9tICcgKyB0aGlzLnR5cGUgK1xuXHQgICAgJyB0byAnICsgbmV3VHlwZSkpO1xufTtcblxuUHJpdmF0ZUtleS5wcm90b3R5cGUuY3JlYXRlVmVyaWZ5ID0gZnVuY3Rpb24gKGhhc2hBbGdvKSB7XG5cdHJldHVybiAodGhpcy50b1B1YmxpYygpLmNyZWF0ZVZlcmlmeShoYXNoQWxnbykpO1xufTtcblxuUHJpdmF0ZUtleS5wcm90b3R5cGUuY3JlYXRlU2lnbiA9IGZ1bmN0aW9uIChoYXNoQWxnbykge1xuXHRpZiAoaGFzaEFsZ28gPT09IHVuZGVmaW5lZClcblx0XHRoYXNoQWxnbyA9IHRoaXMuZGVmYXVsdEhhc2hBbGdvcml0aG0oKTtcblx0YXNzZXJ0LnN0cmluZyhoYXNoQWxnbywgJ2hhc2ggYWxnb3JpdGhtJyk7XG5cblx0LyogRUQyNTUxOSBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wZW5TU0wsIHVzZSBhIGphdmFzY3JpcHQgaW1wbC4gKi9cblx0aWYgKHRoaXMudHlwZSA9PT0gJ2VkMjU1MTknICYmIGVkQ29tcGF0ICE9PSB1bmRlZmluZWQpXG5cdFx0cmV0dXJuIChuZXcgZWRDb21wYXQuU2lnbmVyKHRoaXMsIGhhc2hBbGdvKSk7XG5cdGlmICh0aGlzLnR5cGUgPT09ICdjdXJ2ZTI1NTE5Jylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdDdXJ2ZTI1NTE5IGtleXMgYXJlIG5vdCBzdWl0YWJsZSBmb3IgJyArXG5cdFx0ICAgICdzaWduaW5nIG9yIHZlcmlmaWNhdGlvbicpKTtcblxuXHR2YXIgdiwgbm0sIGVycjtcblx0dHJ5IHtcblx0XHRubSA9IGhhc2hBbGdvLnRvVXBwZXJDYXNlKCk7XG5cdFx0diA9IGNyeXB0by5jcmVhdGVTaWduKG5tKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGVyciA9IGU7XG5cdH1cblx0aWYgKHYgPT09IHVuZGVmaW5lZCB8fCAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiZcblx0ICAgIGVyci5tZXNzYWdlLm1hdGNoKC9Vbmtub3duIG1lc3NhZ2UgZGlnZXN0LykpKSB7XG5cdFx0bm0gPSAnUlNBLSc7XG5cdFx0bm0gKz0gaGFzaEFsZ28udG9VcHBlckNhc2UoKTtcblx0XHR2ID0gY3J5cHRvLmNyZWF0ZVNpZ24obm0pO1xuXHR9XG5cdGFzc2VydC5vayh2LCAnZmFpbGVkIHRvIGNyZWF0ZSB2ZXJpZmllcicpO1xuXHR2YXIgb2xkU2lnbiA9IHYuc2lnbi5iaW5kKHYpO1xuXHR2YXIga2V5ID0gdGhpcy50b0J1ZmZlcigncGtjczEnKTtcblx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cdHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG5cdHYuc2lnbiA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2lnID0gb2xkU2lnbihrZXkpO1xuXHRcdGlmICh0eXBlb2YgKHNpZykgPT09ICdzdHJpbmcnKVxuXHRcdFx0c2lnID0gQnVmZmVyLmZyb20oc2lnLCAnYmluYXJ5Jyk7XG5cdFx0c2lnID0gU2lnbmF0dXJlLnBhcnNlKHNpZywgdHlwZSwgJ2FzbjEnKTtcblx0XHRzaWcuaGFzaEFsZ29yaXRobSA9IGhhc2hBbGdvO1xuXHRcdHNpZy5jdXJ2ZSA9IGN1cnZlO1xuXHRcdHJldHVybiAoc2lnKTtcblx0fTtcblx0cmV0dXJuICh2KTtcbn07XG5cblByaXZhdGVLZXkucGFyc2UgPSBmdW5jdGlvbiAoZGF0YSwgZm9ybWF0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgKGRhdGEpICE9PSAnc3RyaW5nJylcblx0XHRhc3NlcnQuYnVmZmVyKGRhdGEsICdkYXRhJyk7XG5cdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZClcblx0XHRmb3JtYXQgPSAnYXV0byc7XG5cdGFzc2VydC5zdHJpbmcoZm9ybWF0LCAnZm9ybWF0Jyk7XG5cdGlmICh0eXBlb2YgKG9wdGlvbnMpID09PSAnc3RyaW5nJylcblx0XHRvcHRpb25zID0geyBmaWxlbmFtZTogb3B0aW9ucyB9O1xuXHRhc3NlcnQub3B0aW9uYWxPYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcblx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZClcblx0XHRvcHRpb25zID0ge307XG5cdGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRpb25zLmZpbGVuYW1lLCAnb3B0aW9ucy5maWxlbmFtZScpO1xuXHRpZiAob3B0aW9ucy5maWxlbmFtZSA9PT0gdW5kZWZpbmVkKVxuXHRcdG9wdGlvbnMuZmlsZW5hbWUgPSAnKHVubmFtZWQpJztcblxuXHRhc3NlcnQub2JqZWN0KGZvcm1hdHNbZm9ybWF0XSwgJ2Zvcm1hdHNbZm9ybWF0XScpO1xuXG5cdHRyeSB7XG5cdFx0dmFyIGsgPSBmb3JtYXRzW2Zvcm1hdF0ucmVhZChkYXRhLCBvcHRpb25zKTtcblx0XHRhc3NlcnQub2soayBpbnN0YW5jZW9mIFByaXZhdGVLZXksICdrZXkgaXMgbm90IGEgcHJpdmF0ZSBrZXknKTtcblx0XHRpZiAoIWsuY29tbWVudClcblx0XHRcdGsuY29tbWVudCA9IG9wdGlvbnMuZmlsZW5hbWU7XG5cdFx0cmV0dXJuIChrKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmIChlLm5hbWUgPT09ICdLZXlFbmNyeXB0ZWRFcnJvcicpXG5cdFx0XHR0aHJvdyAoZSk7XG5cdFx0dGhyb3cgKG5ldyBLZXlQYXJzZUVycm9yKG9wdGlvbnMuZmlsZW5hbWUsIGZvcm1hdCwgZSkpO1xuXHR9XG59O1xuXG5Qcml2YXRlS2V5LmlzUHJpdmF0ZUtleSA9IGZ1bmN0aW9uIChvYmosIHZlcikge1xuXHRyZXR1cm4gKHV0aWxzLmlzQ29tcGF0aWJsZShvYmosIFByaXZhdGVLZXksIHZlcikpO1xufTtcblxuUHJpdmF0ZUtleS5nZW5lcmF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBvcHRpb25zKSB7XG5cdGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXG5cdFx0b3B0aW9ucyA9IHt9O1xuXHRhc3NlcnQub2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cblx0c3dpdGNoICh0eXBlKSB7XG5cdGNhc2UgJ2VjZHNhJzpcblx0XHRpZiAob3B0aW9ucy5jdXJ2ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0b3B0aW9ucy5jdXJ2ZSA9ICduaXN0cDI1Nic7XG5cdFx0YXNzZXJ0LnN0cmluZyhvcHRpb25zLmN1cnZlLCAnb3B0aW9ucy5jdXJ2ZScpO1xuXHRcdHJldHVybiAoZ2VuZXJhdGVFQ0RTQShvcHRpb25zLmN1cnZlKSk7XG5cdGNhc2UgJ2VkMjU1MTknOlxuXHRcdHJldHVybiAoZ2VuZXJhdGVFRDI1NTE5KCkpO1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0tleSBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQgd2l0aCBrZXkgJyArXG5cdFx0ICAgICd0eXBlIFwiJyArIHR5cGUgKyAnXCInKSk7XG5cdH1cbn07XG5cbi8qXG4gKiBBUEkgdmVyc2lvbnMgZm9yIFByaXZhdGVLZXk6XG4gKiBbMSwwXSAtLSBpbml0aWFsIHZlclxuICogWzEsMV0gLS0gYWRkZWQgYXV0bywgcGtjc1sxOF0sIG9wZW5zc2gvc3NoLXByaXZhdGUgZm9ybWF0c1xuICogWzEsMl0gLS0gYWRkZWQgZGVmYXVsdEhhc2hBbGdvcml0aG1cbiAqIFsxLDNdIC0tIGFkZGVkIGRlcml2ZSwgZWQsIGNyZWF0ZURIXG4gKiBbMSw0XSAtLSBmaXJzdCB0YWdnZWQgdmVyc2lvblxuICogWzEsNV0gLS0gY2hhbmdlZCBlZDI1NTE5IHBhcnQgbmFtZXMgYW5kIGZvcm1hdFxuICogWzEsNl0gLS0gdHlwZSBhcmd1bWVudHMgZm9yIGhhc2goKSBhbmQgZmluZ2VycHJpbnQoKVxuICovXG5Qcml2YXRlS2V5LnByb3RvdHlwZS5fc3NocGtBcGlWZXJzaW9uID0gWzEsIDZdO1xuXG5Qcml2YXRlS2V5Ll9vbGRWZXJzaW9uRGV0ZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuXHRhc3NlcnQuZnVuYyhvYmoudG9QdWJsaWMpO1xuXHRhc3NlcnQuZnVuYyhvYmouY3JlYXRlU2lnbik7XG5cdGlmIChvYmouZGVyaXZlKVxuXHRcdHJldHVybiAoWzEsIDNdKTtcblx0aWYgKG9iai5kZWZhdWx0SGFzaEFsZ29yaXRobSlcblx0XHRyZXR1cm4gKFsxLCAyXSk7XG5cdGlmIChvYmouZm9ybWF0c1snYXV0byddKVxuXHRcdHJldHVybiAoWzEsIDFdKTtcblx0cmV0dXJuIChbMSwgMF0pO1xufTtcbiIsIi8vIENvcHlyaWdodCAyMDE1IEpveWVudCwgSW5jLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hdHVyZTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZXItYnVmZmVyJykuQnVmZmVyO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuL2FsZ3MnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBlcnJzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xudmFyIFNTSEJ1ZmZlciA9IHJlcXVpcmUoJy4vc3NoLWJ1ZmZlcicpO1xuXG52YXIgSW52YWxpZEFsZ29yaXRobUVycm9yID0gZXJycy5JbnZhbGlkQWxnb3JpdGhtRXJyb3I7XG52YXIgU2lnbmF0dXJlUGFyc2VFcnJvciA9IGVycnMuU2lnbmF0dXJlUGFyc2VFcnJvcjtcblxuZnVuY3Rpb24gU2lnbmF0dXJlKG9wdHMpIHtcblx0YXNzZXJ0Lm9iamVjdChvcHRzLCAnb3B0aW9ucycpO1xuXHRhc3NlcnQuYXJyYXlPZk9iamVjdChvcHRzLnBhcnRzLCAnb3B0aW9ucy5wYXJ0cycpO1xuXHRhc3NlcnQuc3RyaW5nKG9wdHMudHlwZSwgJ29wdGlvbnMudHlwZScpO1xuXG5cdHZhciBwYXJ0TG9va3VwID0ge307XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5wYXJ0cy5sZW5ndGg7ICsraSkge1xuXHRcdHZhciBwYXJ0ID0gb3B0cy5wYXJ0c1tpXTtcblx0XHRwYXJ0TG9va3VwW3BhcnQubmFtZV0gPSBwYXJ0O1xuXHR9XG5cblx0dGhpcy50eXBlID0gb3B0cy50eXBlO1xuXHR0aGlzLmhhc2hBbGdvcml0aG0gPSBvcHRzLmhhc2hBbGdvO1xuXHR0aGlzLmN1cnZlID0gb3B0cy5jdXJ2ZTtcblx0dGhpcy5wYXJ0cyA9IG9wdHMucGFydHM7XG5cdHRoaXMucGFydCA9IHBhcnRMb29rdXA7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZClcblx0XHRmb3JtYXQgPSAnYXNuMSc7XG5cdGFzc2VydC5zdHJpbmcoZm9ybWF0LCAnZm9ybWF0Jyk7XG5cblx0dmFyIGJ1Zjtcblx0dmFyIHN0eXBlID0gJ3NzaC0nICsgdGhpcy50eXBlO1xuXG5cdHN3aXRjaCAodGhpcy50eXBlKSB7XG5cdGNhc2UgJ3JzYSc6XG5cdFx0c3dpdGNoICh0aGlzLmhhc2hBbGdvcml0aG0pIHtcblx0XHRjYXNlICdzaGEyNTYnOlxuXHRcdFx0c3R5cGUgPSAncnNhLXNoYTItMjU2Jztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3NoYTUxMic6XG5cdFx0XHRzdHlwZSA9ICdyc2Etc2hhMi01MTInO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnc2hhMSc6XG5cdFx0Y2FzZSB1bmRlZmluZWQ6XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignU1NIIHNpZ25hdHVyZSAnICtcblx0XHRcdCAgICAnZm9ybWF0IGRvZXMgbm90IHN1cHBvcnQgaGFzaCAnICtcblx0XHRcdCAgICAnYWxnb3JpdGhtICcgKyB0aGlzLmhhc2hBbGdvcml0aG0pKTtcblx0XHR9XG5cdFx0aWYgKGZvcm1hdCA9PT0gJ3NzaCcpIHtcblx0XHRcdGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXHRcdFx0YnVmLndyaXRlU3RyaW5nKHN0eXBlKTtcblx0XHRcdGJ1Zi53cml0ZVBhcnQodGhpcy5wYXJ0LnNpZyk7XG5cdFx0XHRyZXR1cm4gKGJ1Zi50b0J1ZmZlcigpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICh0aGlzLnBhcnQuc2lnLmRhdGEpO1xuXHRcdH1cblx0XHRicmVhaztcblxuXHRjYXNlICdlZDI1NTE5Jzpcblx0XHRpZiAoZm9ybWF0ID09PSAnc3NoJykge1xuXHRcdFx0YnVmID0gbmV3IFNTSEJ1ZmZlcih7fSk7XG5cdFx0XHRidWYud3JpdGVTdHJpbmcoc3R5cGUpO1xuXHRcdFx0YnVmLndyaXRlUGFydCh0aGlzLnBhcnQuc2lnKTtcblx0XHRcdHJldHVybiAoYnVmLnRvQnVmZmVyKCkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKHRoaXMucGFydC5zaWcuZGF0YSk7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXG5cdGNhc2UgJ2RzYSc6XG5cdGNhc2UgJ2VjZHNhJzpcblx0XHR2YXIgciwgcztcblx0XHRpZiAoZm9ybWF0ID09PSAnYXNuMScpIHtcblx0XHRcdHZhciBkZXIgPSBuZXcgYXNuMS5CZXJXcml0ZXIoKTtcblx0XHRcdGRlci5zdGFydFNlcXVlbmNlKCk7XG5cdFx0XHRyID0gdXRpbHMubXBOb3JtYWxpemUodGhpcy5wYXJ0LnIuZGF0YSk7XG5cdFx0XHRzID0gdXRpbHMubXBOb3JtYWxpemUodGhpcy5wYXJ0LnMuZGF0YSk7XG5cdFx0XHRkZXIud3JpdGVCdWZmZXIociwgYXNuMS5CZXIuSW50ZWdlcik7XG5cdFx0XHRkZXIud3JpdGVCdWZmZXIocywgYXNuMS5CZXIuSW50ZWdlcik7XG5cdFx0XHRkZXIuZW5kU2VxdWVuY2UoKTtcblx0XHRcdHJldHVybiAoZGVyLmJ1ZmZlcik7XG5cdFx0fSBlbHNlIGlmIChmb3JtYXQgPT09ICdzc2gnICYmIHRoaXMudHlwZSA9PT0gJ2RzYScpIHtcblx0XHRcdGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe30pO1xuXHRcdFx0YnVmLndyaXRlU3RyaW5nKCdzc2gtZHNzJyk7XG5cdFx0XHRyID0gdGhpcy5wYXJ0LnIuZGF0YTtcblx0XHRcdGlmIChyLmxlbmd0aCA+IDIwICYmIHJbMF0gPT09IDB4MDApXG5cdFx0XHRcdHIgPSByLnNsaWNlKDEpO1xuXHRcdFx0cyA9IHRoaXMucGFydC5zLmRhdGE7XG5cdFx0XHRpZiAocy5sZW5ndGggPiAyMCAmJiBzWzBdID09PSAweDAwKVxuXHRcdFx0XHRzID0gcy5zbGljZSgxKTtcblx0XHRcdGlmICgodGhpcy5oYXNoQWxnb3JpdGhtICYmXG5cdFx0XHQgICAgdGhpcy5oYXNoQWxnb3JpdGhtICE9PSAnc2hhMScpIHx8XG5cdFx0XHQgICAgci5sZW5ndGggKyBzLmxlbmd0aCAhPT0gNDApIHtcblx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignT3BlblNTSCBvbmx5IHN1cHBvcnRzICcgK1xuXHRcdFx0XHQgICAgJ0RTQSBzaWduYXR1cmVzIHdpdGggU0hBMSBoYXNoJykpO1xuXHRcdFx0fVxuXHRcdFx0YnVmLndyaXRlQnVmZmVyKEJ1ZmZlci5jb25jYXQoW3IsIHNdKSk7XG5cdFx0XHRyZXR1cm4gKGJ1Zi50b0J1ZmZlcigpKTtcblx0XHR9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ3NzaCcgJiYgdGhpcy50eXBlID09PSAnZWNkc2EnKSB7XG5cdFx0XHR2YXIgaW5uZXIgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0XHRcdHIgPSB0aGlzLnBhcnQuci5kYXRhO1xuXHRcdFx0aW5uZXIud3JpdGVCdWZmZXIocik7XG5cdFx0XHRpbm5lci53cml0ZVBhcnQodGhpcy5wYXJ0LnMpO1xuXG5cdFx0XHRidWYgPSBuZXcgU1NIQnVmZmVyKHt9KTtcblx0XHRcdC8qIFhYWDogZmluZCBhIG1vcmUgcHJvcGVyIHdheSB0byBkbyB0aGlzPyAqL1xuXHRcdFx0dmFyIGN1cnZlO1xuXHRcdFx0aWYgKHJbMF0gPT09IDB4MDApXG5cdFx0XHRcdHIgPSByLnNsaWNlKDEpO1xuXHRcdFx0dmFyIHN6ID0gci5sZW5ndGggKiA4O1xuXHRcdFx0aWYgKHN6ID09PSAyNTYpXG5cdFx0XHRcdGN1cnZlID0gJ25pc3RwMjU2Jztcblx0XHRcdGVsc2UgaWYgKHN6ID09PSAzODQpXG5cdFx0XHRcdGN1cnZlID0gJ25pc3RwMzg0Jztcblx0XHRcdGVsc2UgaWYgKHN6ID09PSA1MjgpXG5cdFx0XHRcdGN1cnZlID0gJ25pc3RwNTIxJztcblx0XHRcdGJ1Zi53cml0ZVN0cmluZygnZWNkc2Etc2hhMi0nICsgY3VydmUpO1xuXHRcdFx0YnVmLndyaXRlQnVmZmVyKGlubmVyLnRvQnVmZmVyKCkpO1xuXHRcdFx0cmV0dXJuIChidWYudG9CdWZmZXIoKSk7XG5cdFx0fVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGZvcm1hdCcpKTtcblx0ZGVmYXVsdDpcblx0XHR0aHJvdyAobmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBkYXRhJykpO1xuXHR9XG59O1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHRhc3NlcnQub3B0aW9uYWxTdHJpbmcoZm9ybWF0LCAnZm9ybWF0Jyk7XG5cdHJldHVybiAodGhpcy50b0J1ZmZlcihmb3JtYXQpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG59O1xuXG5TaWduYXR1cmUucGFyc2UgPSBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgZm9ybWF0KSB7XG5cdGlmICh0eXBlb2YgKGRhdGEpID09PSAnc3RyaW5nJylcblx0XHRkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpO1xuXHRhc3NlcnQuYnVmZmVyKGRhdGEsICdkYXRhJyk7XG5cdGFzc2VydC5zdHJpbmcoZm9ybWF0LCAnZm9ybWF0Jyk7XG5cdGFzc2VydC5zdHJpbmcodHlwZSwgJ3R5cGUnKTtcblxuXHR2YXIgb3B0cyA9IHt9O1xuXHRvcHRzLnR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cdG9wdHMucGFydHMgPSBbXTtcblxuXHR0cnkge1xuXHRcdGFzc2VydC5vayhkYXRhLmxlbmd0aCA+IDAsICdzaWduYXR1cmUgbXVzdCBub3QgYmUgZW1wdHknKTtcblx0XHRzd2l0Y2ggKG9wdHMudHlwZSkge1xuXHRcdGNhc2UgJ3JzYSc6XG5cdFx0XHRyZXR1cm4gKHBhcnNlT25lTnVtKGRhdGEsIHR5cGUsIGZvcm1hdCwgb3B0cykpO1xuXHRcdGNhc2UgJ2VkMjU1MTknOlxuXHRcdFx0cmV0dXJuIChwYXJzZU9uZU51bShkYXRhLCB0eXBlLCBmb3JtYXQsIG9wdHMpKTtcblxuXHRcdGNhc2UgJ2RzYSc6XG5cdFx0Y2FzZSAnZWNkc2EnOlxuXHRcdFx0aWYgKGZvcm1hdCA9PT0gJ2FzbjEnKVxuXHRcdFx0XHRyZXR1cm4gKHBhcnNlRFNBYXNuMShkYXRhLCB0eXBlLCBmb3JtYXQsIG9wdHMpKTtcblx0XHRcdGVsc2UgaWYgKG9wdHMudHlwZSA9PT0gJ2RzYScpXG5cdFx0XHRcdHJldHVybiAocGFyc2VEU0EoZGF0YSwgdHlwZSwgZm9ybWF0LCBvcHRzKSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJldHVybiAocGFyc2VFQ0RTQShkYXRhLCB0eXBlLCBmb3JtYXQsIG9wdHMpKTtcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyAobmV3IEludmFsaWRBbGdvcml0aG1FcnJvcih0eXBlKSk7XG5cdFx0fVxuXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoZSBpbnN0YW5jZW9mIEludmFsaWRBbGdvcml0aG1FcnJvcilcblx0XHRcdHRocm93IChlKTtcblx0XHR0aHJvdyAobmV3IFNpZ25hdHVyZVBhcnNlRXJyb3IodHlwZSwgZm9ybWF0LCBlKSk7XG5cdH1cbn07XG5cbmZ1bmN0aW9uIHBhcnNlT25lTnVtKGRhdGEsIHR5cGUsIGZvcm1hdCwgb3B0cykge1xuXHRpZiAoZm9ybWF0ID09PSAnc3NoJykge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgYnVmID0gbmV3IFNTSEJ1ZmZlcih7YnVmZmVyOiBkYXRhfSk7XG5cdFx0XHR2YXIgaGVhZCA9IGJ1Zi5yZWFkU3RyaW5nKCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0LyogZmFsbCB0aHJvdWdoICovXG5cdFx0fVxuXHRcdGlmIChidWYgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyIG1zZyA9ICdTU0ggc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkICcgK1xuXHRcdFx0ICAgICd0eXBlIChleHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgaGVhZCArICcpJztcblx0XHRcdHN3aXRjaCAoaGVhZCkge1xuXHRcdFx0Y2FzZSAnc3NoLXJzYSc6XG5cdFx0XHRcdGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlLCAncnNhJywgbXNnKTtcblx0XHRcdFx0b3B0cy5oYXNoQWxnbyA9ICdzaGExJztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyc2Etc2hhMi0yNTYnOlxuXHRcdFx0XHRhc3NlcnQuc3RyaWN0RXF1YWwodHlwZSwgJ3JzYScsIG1zZyk7XG5cdFx0XHRcdG9wdHMuaGFzaEFsZ28gPSAnc2hhMjU2Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyc2Etc2hhMi01MTInOlxuXHRcdFx0XHRhc3NlcnQuc3RyaWN0RXF1YWwodHlwZSwgJ3JzYScsIG1zZyk7XG5cdFx0XHRcdG9wdHMuaGFzaEFsZ28gPSAnc2hhNTEyJztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzc2gtZWQyNTUxOSc6XG5cdFx0XHRcdGFzc2VydC5zdHJpY3RFcXVhbCh0eXBlLCAnZWQyNTUxOScsIG1zZyk7XG5cdFx0XHRcdG9wdHMuaGFzaEFsZ28gPSAnc2hhNTEyJztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyAobmV3IEVycm9yKCdVbmtub3duIFNTSCBzaWduYXR1cmUgJyArXG5cdFx0XHRcdCAgICAndHlwZTogJyArIGhlYWQpKTtcblx0XHRcdH1cblx0XHRcdHZhciBzaWcgPSBidWYucmVhZFBhcnQoKTtcblx0XHRcdGFzc2VydC5vayhidWYuYXRFbmQoKSwgJ2V4dHJhIHRyYWlsaW5nIGJ5dGVzJyk7XG5cdFx0XHRzaWcubmFtZSA9ICdzaWcnO1xuXHRcdFx0b3B0cy5wYXJ0cy5wdXNoKHNpZyk7XG5cdFx0XHRyZXR1cm4gKG5ldyBTaWduYXR1cmUob3B0cykpO1xuXHRcdH1cblx0fVxuXHRvcHRzLnBhcnRzLnB1c2goe25hbWU6ICdzaWcnLCBkYXRhOiBkYXRhfSk7XG5cdHJldHVybiAobmV3IFNpZ25hdHVyZShvcHRzKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRFNBYXNuMShkYXRhLCB0eXBlLCBmb3JtYXQsIG9wdHMpIHtcblx0dmFyIGRlciA9IG5ldyBhc24xLkJlclJlYWRlcihkYXRhKTtcblx0ZGVyLnJlYWRTZXF1ZW5jZSgpO1xuXHR2YXIgciA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpO1xuXHR2YXIgcyA9IGRlci5yZWFkU3RyaW5nKGFzbjEuQmVyLkludGVnZXIsIHRydWUpO1xuXG5cdG9wdHMucGFydHMucHVzaCh7bmFtZTogJ3InLCBkYXRhOiB1dGlscy5tcE5vcm1hbGl6ZShyKX0pO1xuXHRvcHRzLnBhcnRzLnB1c2goe25hbWU6ICdzJywgZGF0YTogdXRpbHMubXBOb3JtYWxpemUocyl9KTtcblxuXHRyZXR1cm4gKG5ldyBTaWduYXR1cmUob3B0cykpO1xufVxuXG5mdW5jdGlvbiBwYXJzZURTQShkYXRhLCB0eXBlLCBmb3JtYXQsIG9wdHMpIHtcblx0aWYgKGRhdGEubGVuZ3RoICE9IDQwKSB7XG5cdFx0dmFyIGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe2J1ZmZlcjogZGF0YX0pO1xuXHRcdHZhciBkID0gYnVmLnJlYWRCdWZmZXIoKTtcblx0XHRpZiAoZC50b1N0cmluZygnYXNjaWknKSA9PT0gJ3NzaC1kc3MnKVxuXHRcdFx0ZCA9IGJ1Zi5yZWFkQnVmZmVyKCk7XG5cdFx0YXNzZXJ0Lm9rKGJ1Zi5hdEVuZCgpLCAnZXh0cmEgdHJhaWxpbmcgYnl0ZXMnKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwoZC5sZW5ndGgsIDQwLCAnaW52YWxpZCBpbm5lciBsZW5ndGgnKTtcblx0XHRkYXRhID0gZDtcblx0fVxuXHRvcHRzLnBhcnRzLnB1c2goe25hbWU6ICdyJywgZGF0YTogZGF0YS5zbGljZSgwLCAyMCl9KTtcblx0b3B0cy5wYXJ0cy5wdXNoKHtuYW1lOiAncycsIGRhdGE6IGRhdGEuc2xpY2UoMjAsIDQwKX0pO1xuXHRyZXR1cm4gKG5ldyBTaWduYXR1cmUob3B0cykpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUVDRFNBKGRhdGEsIHR5cGUsIGZvcm1hdCwgb3B0cykge1xuXHR2YXIgYnVmID0gbmV3IFNTSEJ1ZmZlcih7YnVmZmVyOiBkYXRhfSk7XG5cblx0dmFyIHIsIHM7XG5cdHZhciBpbm5lciA9IGJ1Zi5yZWFkQnVmZmVyKCk7XG5cdHZhciBzdHlwZSA9IGlubmVyLnRvU3RyaW5nKCdhc2NpaScpO1xuXHRpZiAoc3R5cGUuc2xpY2UoMCwgNikgPT09ICdlY2RzYS0nKSB7XG5cdFx0dmFyIHBhcnRzID0gc3R5cGUuc3BsaXQoJy0nKTtcblx0XHRhc3NlcnQuc3RyaWN0RXF1YWwocGFydHNbMF0sICdlY2RzYScpO1xuXHRcdGFzc2VydC5zdHJpY3RFcXVhbChwYXJ0c1sxXSwgJ3NoYTInKTtcblx0XHRvcHRzLmN1cnZlID0gcGFydHNbMl07XG5cdFx0c3dpdGNoIChvcHRzLmN1cnZlKSB7XG5cdFx0Y2FzZSAnbmlzdHAyNTYnOlxuXHRcdFx0b3B0cy5oYXNoQWxnbyA9ICdzaGEyNTYnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbmlzdHAzODQnOlxuXHRcdFx0b3B0cy5oYXNoQWxnbyA9ICdzaGEzODQnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbmlzdHA1MjEnOlxuXHRcdFx0b3B0cy5oYXNoQWxnbyA9ICdzaGE1MTInO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEVDRFNBIGN1cnZlOiAnICtcblx0XHRcdCAgICBvcHRzLmN1cnZlKSk7XG5cdFx0fVxuXHRcdGlubmVyID0gYnVmLnJlYWRCdWZmZXIoKTtcblx0XHRhc3NlcnQub2soYnVmLmF0RW5kKCksICdleHRyYSB0cmFpbGluZyBieXRlcyBvbiBvdXRlcicpO1xuXHRcdGJ1ZiA9IG5ldyBTU0hCdWZmZXIoe2J1ZmZlcjogaW5uZXJ9KTtcblx0XHRyID0gYnVmLnJlYWRQYXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0ciA9IHtkYXRhOiBpbm5lcn07XG5cdH1cblxuXHRzID0gYnVmLnJlYWRQYXJ0KCk7XG5cdGFzc2VydC5vayhidWYuYXRFbmQoKSwgJ2V4dHJhIHRyYWlsaW5nIGJ5dGVzJyk7XG5cblx0ci5uYW1lID0gJ3InO1xuXHRzLm5hbWUgPSAncyc7XG5cblx0b3B0cy5wYXJ0cy5wdXNoKHIpO1xuXHRvcHRzLnBhcnRzLnB1c2gocyk7XG5cdHJldHVybiAobmV3IFNpZ25hdHVyZShvcHRzKSk7XG59XG5cblNpZ25hdHVyZS5pc1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChvYmosIHZlcikge1xuXHRyZXR1cm4gKHV0aWxzLmlzQ29tcGF0aWJsZShvYmosIFNpZ25hdHVyZSwgdmVyKSk7XG59O1xuXG4vKlxuICogQVBJIHZlcnNpb25zIGZvciBTaWduYXR1cmU6XG4gKiBbMSwwXSAtLSBpbml0aWFsIHZlclxuICogWzIsMF0gLS0gc3VwcG9ydCBmb3IgcnNhIGluIGZ1bGwgc3NoIGZvcm1hdCwgY29tcGF0IHdpdGggc3NocGstYWdlbnRcbiAqICAgICAgICAgIGhhc2hBbGdvcml0aG0gcHJvcGVydHlcbiAqIFsyLDFdIC0tIGZpcnN0IHRhZ2dlZCB2ZXJzaW9uXG4gKi9cblNpZ25hdHVyZS5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbiA9IFsyLCAxXTtcblxuU2lnbmF0dXJlLl9vbGRWZXJzaW9uRGV0ZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuXHRhc3NlcnQuZnVuYyhvYmoudG9CdWZmZXIpO1xuXHRpZiAob2JqLmhhc093blByb3BlcnR5KCdoYXNoQWxnb3JpdGhtJykpXG5cdFx0cmV0dXJuIChbMiwgMF0pO1xuXHRyZXR1cm4gKFsxLCAwXSk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbm1vZHVsZS5leHBvcnRzID0gU1NIQnVmZmVyO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG5cbmZ1bmN0aW9uIFNTSEJ1ZmZlcihvcHRzKSB7XG5cdGFzc2VydC5vYmplY3Qob3B0cywgJ29wdGlvbnMnKTtcblx0aWYgKG9wdHMuYnVmZmVyICE9PSB1bmRlZmluZWQpXG5cdFx0YXNzZXJ0LmJ1ZmZlcihvcHRzLmJ1ZmZlciwgJ29wdGlvbnMuYnVmZmVyJyk7XG5cblx0dGhpcy5fc2l6ZSA9IG9wdHMuYnVmZmVyID8gb3B0cy5idWZmZXIubGVuZ3RoIDogMTAyNDtcblx0dGhpcy5fYnVmZmVyID0gb3B0cy5idWZmZXIgfHwgQnVmZmVyLmFsbG9jKHRoaXMuX3NpemUpO1xuXHR0aGlzLl9vZmZzZXQgPSAwO1xufVxuXG5TU0hCdWZmZXIucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gKHRoaXMuX2J1ZmZlci5zbGljZSgwLCB0aGlzLl9vZmZzZXQpKTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUuYXRFbmQgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAodGhpcy5fb2Zmc2V0ID49IHRoaXMuX2J1ZmZlci5sZW5ndGgpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAodGhpcy5fYnVmZmVyLnNsaWNlKHRoaXMuX29mZnNldCkpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKG4pIHtcblx0dGhpcy5fb2Zmc2V0ICs9IG47XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5fc2l6ZSAqPSAyO1xuXHR2YXIgYnVmID0gQnVmZmVyLmFsbG9jKHRoaXMuX3NpemUpO1xuXHR0aGlzLl9idWZmZXIuY29weShidWYsIDApO1xuXHR0aGlzLl9idWZmZXIgPSBidWY7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLnJlYWRQYXJ0ID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gKHtkYXRhOiB0aGlzLnJlYWRCdWZmZXIoKX0pO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5yZWFkQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbGVuID0gdGhpcy5fYnVmZmVyLnJlYWRVSW50MzJCRSh0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gNDtcblx0YXNzZXJ0Lm9rKHRoaXMuX29mZnNldCArIGxlbiA8PSB0aGlzLl9idWZmZXIubGVuZ3RoLFxuXHQgICAgJ2xlbmd0aCBvdXQgb2YgYm91bmRzIGF0ICsweCcgKyB0aGlzLl9vZmZzZXQudG9TdHJpbmcoMTYpICtcblx0ICAgICcgKGRhdGEgdHJ1bmNhdGVkPyknKTtcblx0dmFyIGJ1ZiA9IHRoaXMuX2J1ZmZlci5zbGljZSh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIGxlbik7XG5cdHRoaXMuX29mZnNldCArPSBsZW47XG5cdHJldHVybiAoYnVmKTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUucmVhZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICh0aGlzLnJlYWRCdWZmZXIoKS50b1N0cmluZygpKTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUucmVhZENTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG5cdHdoaWxlIChvZmZzZXQgPCB0aGlzLl9idWZmZXIubGVuZ3RoICYmXG5cdCAgICB0aGlzLl9idWZmZXJbb2Zmc2V0XSAhPT0gMHgwMClcblx0XHRvZmZzZXQrKztcblx0YXNzZXJ0Lm9rKG9mZnNldCA8IHRoaXMuX2J1ZmZlci5sZW5ndGgsICdjIHN0cmluZyBkb2VzIG5vdCB0ZXJtaW5hdGUnKTtcblx0dmFyIHN0ciA9IHRoaXMuX2J1ZmZlci5zbGljZSh0aGlzLl9vZmZzZXQsIG9mZnNldCkudG9TdHJpbmcoKTtcblx0dGhpcy5fb2Zmc2V0ID0gb2Zmc2V0ICsgMTtcblx0cmV0dXJuIChzdHIpO1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgdiA9IHRoaXMuX2J1ZmZlci5yZWFkVUludDMyQkUodGhpcy5fb2Zmc2V0KTtcblx0dGhpcy5fb2Zmc2V0ICs9IDQ7XG5cdHJldHVybiAodik7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ2NCA9IGZ1bmN0aW9uICgpIHtcblx0YXNzZXJ0Lm9rKHRoaXMuX29mZnNldCArIDggPCB0aGlzLl9idWZmZXIubGVuZ3RoLFxuXHQgICAgJ2J1ZmZlciBub3QgbG9uZyBlbm91Z2ggdG8gcmVhZCBJbnQ2NCcpO1xuXHR2YXIgdiA9IHRoaXMuX2J1ZmZlci5zbGljZSh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIDgpO1xuXHR0aGlzLl9vZmZzZXQgKz0gODtcblx0cmV0dXJuICh2KTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUucmVhZENoYXIgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB2ID0gdGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXTtcblx0cmV0dXJuICh2KTtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbiAoYnVmKSB7XG5cdHdoaWxlICh0aGlzLl9vZmZzZXQgKyA0ICsgYnVmLmxlbmd0aCA+IHRoaXMuX3NpemUpXG5cdFx0dGhpcy5leHBhbmQoKTtcblx0dGhpcy5fYnVmZmVyLndyaXRlVUludDMyQkUoYnVmLmxlbmd0aCwgdGhpcy5fb2Zmc2V0KTtcblx0dGhpcy5fb2Zmc2V0ICs9IDQ7XG5cdGJ1Zi5jb3B5KHRoaXMuX2J1ZmZlciwgdGhpcy5fb2Zmc2V0KTtcblx0dGhpcy5fb2Zmc2V0ICs9IGJ1Zi5sZW5ndGg7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuXHR0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKSk7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLndyaXRlQ1N0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0d2hpbGUgKHRoaXMuX29mZnNldCArIDEgKyBzdHIubGVuZ3RoID4gdGhpcy5fc2l6ZSlcblx0XHR0aGlzLmV4cGFuZCgpO1xuXHR0aGlzLl9idWZmZXIud3JpdGUoc3RyLCB0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gc3RyLmxlbmd0aDtcblx0dGhpcy5fYnVmZmVyW3RoaXMuX29mZnNldCsrXSA9IDA7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLndyaXRlSW50ID0gZnVuY3Rpb24gKHYpIHtcblx0d2hpbGUgKHRoaXMuX29mZnNldCArIDQgPiB0aGlzLl9zaXplKVxuXHRcdHRoaXMuZXhwYW5kKCk7XG5cdHRoaXMuX2J1ZmZlci53cml0ZVVJbnQzMkJFKHYsIHRoaXMuX29mZnNldCk7XG5cdHRoaXMuX29mZnNldCArPSA0O1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24gKHYpIHtcblx0YXNzZXJ0LmJ1ZmZlcih2LCAndmFsdWUnKTtcblx0aWYgKHYubGVuZ3RoID4gOCkge1xuXHRcdHZhciBsZWFkID0gdi5zbGljZSgwLCB2Lmxlbmd0aCAtIDgpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVhZC5sZW5ndGg7ICsraSkge1xuXHRcdFx0YXNzZXJ0LnN0cmljdEVxdWFsKGxlYWRbaV0sIDAsXG5cdFx0XHQgICAgJ211c3QgZml0IGluIDY0IGJpdHMgb2YgcHJlY2lzaW9uJyk7XG5cdFx0fVxuXHRcdHYgPSB2LnNsaWNlKHYubGVuZ3RoIC0gOCwgdi5sZW5ndGgpO1xuXHR9XG5cdHdoaWxlICh0aGlzLl9vZmZzZXQgKyA4ID4gdGhpcy5fc2l6ZSlcblx0XHR0aGlzLmV4cGFuZCgpO1xuXHR2LmNvcHkodGhpcy5fYnVmZmVyLCB0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gODtcbn07XG5cblNTSEJ1ZmZlci5wcm90b3R5cGUud3JpdGVDaGFyID0gZnVuY3Rpb24gKHYpIHtcblx0d2hpbGUgKHRoaXMuX29mZnNldCArIDEgPiB0aGlzLl9zaXplKVxuXHRcdHRoaXMuZXhwYW5kKCk7XG5cdHRoaXMuX2J1ZmZlclt0aGlzLl9vZmZzZXQrK10gPSB2O1xufTtcblxuU1NIQnVmZmVyLnByb3RvdHlwZS53cml0ZVBhcnQgPSBmdW5jdGlvbiAocCkge1xuXHR0aGlzLndyaXRlQnVmZmVyKHAuZGF0YSk7XG59O1xuXG5TU0hCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuXHR3aGlsZSAodGhpcy5fb2Zmc2V0ICsgYnVmLmxlbmd0aCA+IHRoaXMuX3NpemUpXG5cdFx0dGhpcy5leHBhbmQoKTtcblx0YnVmLmNvcHkodGhpcy5fYnVmZmVyLCB0aGlzLl9vZmZzZXQpO1xuXHR0aGlzLl9vZmZzZXQgKz0gYnVmLmxlbmd0aDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAxNSBKb3llbnQsIEluYy5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGJ1ZmZlclNwbGl0OiBidWZmZXJTcGxpdCxcblx0YWRkUlNBTWlzc2luZzogYWRkUlNBTWlzc2luZyxcblx0Y2FsY3VsYXRlRFNBUHVibGljOiBjYWxjdWxhdGVEU0FQdWJsaWMsXG5cdGNhbGN1bGF0ZUVEMjU1MTlQdWJsaWM6IGNhbGN1bGF0ZUVEMjU1MTlQdWJsaWMsXG5cdGNhbGN1bGF0ZVgyNTUxOVB1YmxpYzogY2FsY3VsYXRlWDI1NTE5UHVibGljLFxuXHRtcE5vcm1hbGl6ZTogbXBOb3JtYWxpemUsXG5cdG1wRGVub3JtYWxpemU6IG1wRGVub3JtYWxpemUsXG5cdGVjTm9ybWFsaXplOiBlY05vcm1hbGl6ZSxcblx0Y291bnRaZXJvczogY291bnRaZXJvcyxcblx0YXNzZXJ0Q29tcGF0aWJsZTogYXNzZXJ0Q29tcGF0aWJsZSxcblx0aXNDb21wYXRpYmxlOiBpc0NvbXBhdGlibGUsXG5cdG9wZW5zc2xLZXlEZXJpdjogb3BlbnNzbEtleURlcml2LFxuXHRvcGVuc3NoQ2lwaGVySW5mbzogb3BlbnNzaENpcGhlckluZm8sXG5cdHB1YmxpY0Zyb21Qcml2YXRlRUNEU0E6IHB1YmxpY0Zyb21Qcml2YXRlRUNEU0EsXG5cdHplcm9QYWRUb0xlbmd0aDogemVyb1BhZFRvTGVuZ3RoLFxuXHR3cml0ZUJpdFN0cmluZzogd3JpdGVCaXRTdHJpbmcsXG5cdHJlYWRCaXRTdHJpbmc6IHJlYWRCaXRTdHJpbmcsXG5cdHBia2RmMjogcGJrZGYyXG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlci1idWZmZXInKS5CdWZmZXI7XG52YXIgUHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vcHJpdmF0ZS1rZXknKTtcbnZhciBLZXkgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIGFsZ3MgPSByZXF1aXJlKCcuL2FsZ3MnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMScpO1xuXG52YXIgZWMgPSByZXF1aXJlKCdlY2MtanNibi9saWIvZWMnKTtcbnZhciBqc2JuID0gcmVxdWlyZSgnanNibicpLkJpZ0ludGVnZXI7XG52YXIgbmFjbCA9IHJlcXVpcmUoJ3R3ZWV0bmFjbCcpO1xuXG52YXIgTUFYX0NMQVNTX0RFUFRIID0gMztcblxuZnVuY3Rpb24gaXNDb21wYXRpYmxlKG9iaiwga2xhc3MsIG5lZWRWZXIpIHtcblx0aWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2YgKG9iaikgIT09ICdvYmplY3QnKVxuXHRcdHJldHVybiAoZmFsc2UpO1xuXHRpZiAobmVlZFZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdG5lZWRWZXIgPSBrbGFzcy5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbjtcblx0aWYgKG9iaiBpbnN0YW5jZW9mIGtsYXNzICYmXG5cdCAgICBrbGFzcy5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvblswXSA9PSBuZWVkVmVyWzBdKVxuXHRcdHJldHVybiAodHJ1ZSk7XG5cdHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuXHR2YXIgZGVwdGggPSAwO1xuXHR3aGlsZSAocHJvdG8uY29uc3RydWN0b3IubmFtZSAhPT0ga2xhc3MubmFtZSkge1xuXHRcdHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRpZiAoIXByb3RvIHx8ICsrZGVwdGggPiBNQVhfQ0xBU1NfREVQVEgpXG5cdFx0XHRyZXR1cm4gKGZhbHNlKTtcblx0fVxuXHRpZiAocHJvdG8uY29uc3RydWN0b3IubmFtZSAhPT0ga2xhc3MubmFtZSlcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0dmFyIHZlciA9IHByb3RvLl9zc2hwa0FwaVZlcnNpb247XG5cdGlmICh2ZXIgPT09IHVuZGVmaW5lZClcblx0XHR2ZXIgPSBrbGFzcy5fb2xkVmVyc2lvbkRldGVjdChvYmopO1xuXHRpZiAodmVyWzBdICE9IG5lZWRWZXJbMF0gfHwgdmVyWzFdIDwgbmVlZFZlclsxXSlcblx0XHRyZXR1cm4gKGZhbHNlKTtcblx0cmV0dXJuICh0cnVlKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29tcGF0aWJsZShvYmosIGtsYXNzLCBuZWVkVmVyLCBuYW1lKSB7XG5cdGlmIChuYW1lID09PSB1bmRlZmluZWQpXG5cdFx0bmFtZSA9ICdvYmplY3QnO1xuXHRhc3NlcnQub2sob2JqLCBuYW1lICsgJyBtdXN0IG5vdCBiZSBudWxsJyk7XG5cdGFzc2VydC5vYmplY3Qob2JqLCBuYW1lICsgJyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXHRpZiAobmVlZFZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdG5lZWRWZXIgPSBrbGFzcy5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvbjtcblx0aWYgKG9iaiBpbnN0YW5jZW9mIGtsYXNzICYmXG5cdCAgICBrbGFzcy5wcm90b3R5cGUuX3NzaHBrQXBpVmVyc2lvblswXSA9PSBuZWVkVmVyWzBdKVxuXHRcdHJldHVybjtcblx0dmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG5cdHZhciBkZXB0aCA9IDA7XG5cdHdoaWxlIChwcm90by5jb25zdHJ1Y3Rvci5uYW1lICE9PSBrbGFzcy5uYW1lKSB7XG5cdFx0cHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdGFzc2VydC5vayhwcm90byAmJiArK2RlcHRoIDw9IE1BWF9DTEFTU19ERVBUSCxcblx0XHQgICAgbmFtZSArICcgbXVzdCBiZSBhICcgKyBrbGFzcy5uYW1lICsgJyBpbnN0YW5jZScpO1xuXHR9XG5cdGFzc2VydC5zdHJpY3RFcXVhbChwcm90by5jb25zdHJ1Y3Rvci5uYW1lLCBrbGFzcy5uYW1lLFxuXHQgICAgbmFtZSArICcgbXVzdCBiZSBhICcgKyBrbGFzcy5uYW1lICsgJyBpbnN0YW5jZScpO1xuXHR2YXIgdmVyID0gcHJvdG8uX3NzaHBrQXBpVmVyc2lvbjtcblx0aWYgKHZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHZlciA9IGtsYXNzLl9vbGRWZXJzaW9uRGV0ZWN0KG9iaik7XG5cdGFzc2VydC5vayh2ZXJbMF0gPT0gbmVlZFZlclswXSAmJiB2ZXJbMV0gPj0gbmVlZFZlclsxXSxcblx0ICAgIG5hbWUgKyAnIG11c3QgYmUgY29tcGF0aWJsZSB3aXRoICcgKyBrbGFzcy5uYW1lICsgJyBrbGFzcyAnICtcblx0ICAgICd2ZXJzaW9uICcgKyBuZWVkVmVyWzBdICsgJy4nICsgbmVlZFZlclsxXSk7XG59XG5cbnZhciBDSVBIRVJfTEVOID0ge1xuXHQnZGVzLWVkZTMtY2JjJzogeyBrZXk6IDI0LCBpdjogOCB9LFxuXHQnYWVzLTEyOC1jYmMnOiB7IGtleTogMTYsIGl2OiAxNiB9LFxuXHQnYWVzLTI1Ni1jYmMnOiB7IGtleTogMzIsIGl2OiAxNiB9XG59O1xudmFyIFBLQ1M1X1NBTFRfTEVOID0gODtcblxuZnVuY3Rpb24gb3BlbnNzbEtleURlcml2KGNpcGhlciwgc2FsdCwgcGFzc3BocmFzZSwgY291bnQpIHtcblx0YXNzZXJ0LmJ1ZmZlcihzYWx0LCAnc2FsdCcpO1xuXHRhc3NlcnQuYnVmZmVyKHBhc3NwaHJhc2UsICdwYXNzcGhyYXNlJyk7XG5cdGFzc2VydC5udW1iZXIoY291bnQsICdpdGVyYXRpb24gY291bnQnKTtcblxuXHR2YXIgY2xlbiA9IENJUEhFUl9MRU5bY2lwaGVyXTtcblx0YXNzZXJ0Lm9iamVjdChjbGVuLCAnc3VwcG9ydGVkIGNpcGhlcicpO1xuXG5cdHNhbHQgPSBzYWx0LnNsaWNlKDAsIFBLQ1M1X1NBTFRfTEVOKTtcblxuXHR2YXIgRCwgRF9wcmV2LCBidWZzO1xuXHR2YXIgbWF0ZXJpYWwgPSBCdWZmZXIuYWxsb2MoMCk7XG5cdHdoaWxlIChtYXRlcmlhbC5sZW5ndGggPCBjbGVuLmtleSArIGNsZW4uaXYpIHtcblx0XHRidWZzID0gW107XG5cdFx0aWYgKERfcHJldilcblx0XHRcdGJ1ZnMucHVzaChEX3ByZXYpO1xuXHRcdGJ1ZnMucHVzaChwYXNzcGhyYXNlKTtcblx0XHRidWZzLnB1c2goc2FsdCk7XG5cdFx0RCA9IEJ1ZmZlci5jb25jYXQoYnVmcyk7XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgKytqKVxuXHRcdFx0RCA9IGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoRCkuZGlnZXN0KCk7XG5cdFx0bWF0ZXJpYWwgPSBCdWZmZXIuY29uY2F0KFttYXRlcmlhbCwgRF0pO1xuXHRcdERfcHJldiA9IEQ7XG5cdH1cblxuXHRyZXR1cm4gKHtcblx0ICAgIGtleTogbWF0ZXJpYWwuc2xpY2UoMCwgY2xlbi5rZXkpLFxuXHQgICAgaXY6IG1hdGVyaWFsLnNsaWNlKGNsZW4ua2V5LCBjbGVuLmtleSArIGNsZW4uaXYpXG5cdH0pO1xufVxuXG4vKiBTZWU6IFJGQzI4OTggKi9cbmZ1bmN0aW9uIHBia2RmMihoYXNoQWxnLCBzYWx0LCBpdGVyYXRpb25zLCBzaXplLCBwYXNzcGhyYXNlKSB7XG5cdHZhciBoa2V5ID0gQnVmZmVyLmFsbG9jKHNhbHQubGVuZ3RoICsgNCk7XG5cdHNhbHQuY29weShoa2V5KTtcblxuXHR2YXIgZ2VuID0gMCwgdHMgPSBbXTtcblx0dmFyIGkgPSAxO1xuXHR3aGlsZSAoZ2VuIDwgc2l6ZSkge1xuXHRcdHZhciB0ID0gVChpKyspO1xuXHRcdGdlbiArPSB0Lmxlbmd0aDtcblx0XHR0cy5wdXNoKHQpO1xuXHR9XG5cdHJldHVybiAoQnVmZmVyLmNvbmNhdCh0cykuc2xpY2UoMCwgc2l6ZSkpO1xuXG5cdGZ1bmN0aW9uIFQoSSkge1xuXHRcdGhrZXkud3JpdGVVSW50MzJCRShJLCBoa2V5Lmxlbmd0aCAtIDQpO1xuXG5cdFx0dmFyIGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYyhoYXNoQWxnLCBwYXNzcGhyYXNlKTtcblx0XHRobWFjLnVwZGF0ZShoa2V5KTtcblxuXHRcdHZhciBUaSA9IGhtYWMuZGlnZXN0KCk7XG5cdFx0dmFyIFVjID0gVGk7XG5cdFx0dmFyIGMgPSAxO1xuXHRcdHdoaWxlIChjKysgPCBpdGVyYXRpb25zKSB7XG5cdFx0XHRobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaEFsZywgcGFzc3BocmFzZSk7XG5cdFx0XHRobWFjLnVwZGF0ZShVYyk7XG5cdFx0XHRVYyA9IGhtYWMuZGlnZXN0KCk7XG5cdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IFRpLmxlbmd0aDsgKyt4KVxuXHRcdFx0XHRUaVt4XSBePSBVY1t4XTtcblx0XHR9XG5cdFx0cmV0dXJuIChUaSk7XG5cdH1cbn1cblxuLyogQ291bnQgbGVhZGluZyB6ZXJvIGJpdHMgb24gYSBidWZmZXIgKi9cbmZ1bmN0aW9uIGNvdW50WmVyb3MoYnVmKSB7XG5cdHZhciBvID0gMCwgb2JpdCA9IDg7XG5cdHdoaWxlIChvIDwgYnVmLmxlbmd0aCkge1xuXHRcdHZhciBtYXNrID0gKDEgPDwgb2JpdCk7XG5cdFx0aWYgKChidWZbb10gJiBtYXNrKSA9PT0gbWFzaylcblx0XHRcdGJyZWFrO1xuXHRcdG9iaXQtLTtcblx0XHRpZiAob2JpdCA8IDApIHtcblx0XHRcdG8rKztcblx0XHRcdG9iaXQgPSA4O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gKG8qOCArICg4IC0gb2JpdCkgLSAxKTtcbn1cblxuZnVuY3Rpb24gYnVmZmVyU3BsaXQoYnVmLCBjaHIpIHtcblx0YXNzZXJ0LmJ1ZmZlcihidWYpO1xuXHRhc3NlcnQuc3RyaW5nKGNocik7XG5cblx0dmFyIHBhcnRzID0gW107XG5cdHZhciBsYXN0UGFydCA9IDA7XG5cdHZhciBtYXRjaGVzID0gMDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyArK2kpIHtcblx0XHRpZiAoYnVmW2ldID09PSBjaHIuY2hhckNvZGVBdChtYXRjaGVzKSlcblx0XHRcdCsrbWF0Y2hlcztcblx0XHRlbHNlIGlmIChidWZbaV0gPT09IGNoci5jaGFyQ29kZUF0KDApKVxuXHRcdFx0bWF0Y2hlcyA9IDE7XG5cdFx0ZWxzZVxuXHRcdFx0bWF0Y2hlcyA9IDA7XG5cblx0XHRpZiAobWF0Y2hlcyA+PSBjaHIubGVuZ3RoKSB7XG5cdFx0XHR2YXIgbmV3UGFydCA9IGkgKyAxO1xuXHRcdFx0cGFydHMucHVzaChidWYuc2xpY2UobGFzdFBhcnQsIG5ld1BhcnQgLSBtYXRjaGVzKSk7XG5cdFx0XHRsYXN0UGFydCA9IG5ld1BhcnQ7XG5cdFx0XHRtYXRjaGVzID0gMDtcblx0XHR9XG5cdH1cblx0aWYgKGxhc3RQYXJ0IDw9IGJ1Zi5sZW5ndGgpXG5cdFx0cGFydHMucHVzaChidWYuc2xpY2UobGFzdFBhcnQsIGJ1Zi5sZW5ndGgpKTtcblxuXHRyZXR1cm4gKHBhcnRzKTtcbn1cblxuZnVuY3Rpb24gZWNOb3JtYWxpemUoYnVmLCBhZGRaZXJvKSB7XG5cdGFzc2VydC5idWZmZXIoYnVmKTtcblx0aWYgKGJ1ZlswXSA9PT0gMHgwMCAmJiBidWZbMV0gPT09IDB4MDQpIHtcblx0XHRpZiAoYWRkWmVybylcblx0XHRcdHJldHVybiAoYnVmKTtcblx0XHRyZXR1cm4gKGJ1Zi5zbGljZSgxKSk7XG5cdH0gZWxzZSBpZiAoYnVmWzBdID09PSAweDA0KSB7XG5cdFx0aWYgKCFhZGRaZXJvKVxuXHRcdFx0cmV0dXJuIChidWYpO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlIChidWZbMF0gPT09IDB4MDApXG5cdFx0XHRidWYgPSBidWYuc2xpY2UoMSk7XG5cdFx0aWYgKGJ1ZlswXSA9PT0gMHgwMiB8fCBidWZbMF0gPT09IDB4MDMpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdDb21wcmVzc2VkIGVsbGlwdGljIGN1cnZlIHBvaW50cyAnICtcblx0XHRcdCAgICAnYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XG5cdFx0aWYgKGJ1ZlswXSAhPT0gMHgwNClcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGVsbGlwdGljIGN1cnZlIHBvaW50JykpO1xuXHRcdGlmICghYWRkWmVybylcblx0XHRcdHJldHVybiAoYnVmKTtcblx0fVxuXHR2YXIgYiA9IEJ1ZmZlci5hbGxvYyhidWYubGVuZ3RoICsgMSk7XG5cdGJbMF0gPSAweDA7XG5cdGJ1Zi5jb3B5KGIsIDEpO1xuXHRyZXR1cm4gKGIpO1xufVxuXG5mdW5jdGlvbiByZWFkQml0U3RyaW5nKGRlciwgdGFnKSB7XG5cdGlmICh0YWcgPT09IHVuZGVmaW5lZClcblx0XHR0YWcgPSBhc24xLkJlci5CaXRTdHJpbmc7XG5cdHZhciBidWYgPSBkZXIucmVhZFN0cmluZyh0YWcsIHRydWUpO1xuXHRhc3NlcnQuc3RyaWN0RXF1YWwoYnVmWzBdLCAweDAwLCAnYml0IHN0cmluZ3Mgd2l0aCB1bnVzZWQgYml0cyBhcmUgJyArXG5cdCAgICAnbm90IHN1cHBvcnRlZCAoMHgnICsgYnVmWzBdLnRvU3RyaW5nKDE2KSArICcpJyk7XG5cdHJldHVybiAoYnVmLnNsaWNlKDEpKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVCaXRTdHJpbmcoZGVyLCBidWYsIHRhZykge1xuXHRpZiAodGFnID09PSB1bmRlZmluZWQpXG5cdFx0dGFnID0gYXNuMS5CZXIuQml0U3RyaW5nO1xuXHR2YXIgYiA9IEJ1ZmZlci5hbGxvYyhidWYubGVuZ3RoICsgMSk7XG5cdGJbMF0gPSAweDAwO1xuXHRidWYuY29weShiLCAxKTtcblx0ZGVyLndyaXRlQnVmZmVyKGIsIHRhZyk7XG59XG5cbmZ1bmN0aW9uIG1wTm9ybWFsaXplKGJ1Zikge1xuXHRhc3NlcnQuYnVmZmVyKGJ1Zik7XG5cdHdoaWxlIChidWYubGVuZ3RoID4gMSAmJiBidWZbMF0gPT09IDB4MDAgJiYgKGJ1ZlsxXSAmIDB4ODApID09PSAweDAwKVxuXHRcdGJ1ZiA9IGJ1Zi5zbGljZSgxKTtcblx0aWYgKChidWZbMF0gJiAweDgwKSA9PT0gMHg4MCkge1xuXHRcdHZhciBiID0gQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGggKyAxKTtcblx0XHRiWzBdID0gMHgwMDtcblx0XHRidWYuY29weShiLCAxKTtcblx0XHRidWYgPSBiO1xuXHR9XG5cdHJldHVybiAoYnVmKTtcbn1cblxuZnVuY3Rpb24gbXBEZW5vcm1hbGl6ZShidWYpIHtcblx0YXNzZXJ0LmJ1ZmZlcihidWYpO1xuXHR3aGlsZSAoYnVmLmxlbmd0aCA+IDEgJiYgYnVmWzBdID09PSAweDAwKVxuXHRcdGJ1ZiA9IGJ1Zi5zbGljZSgxKTtcblx0cmV0dXJuIChidWYpO1xufVxuXG5mdW5jdGlvbiB6ZXJvUGFkVG9MZW5ndGgoYnVmLCBsZW4pIHtcblx0YXNzZXJ0LmJ1ZmZlcihidWYpO1xuXHRhc3NlcnQubnVtYmVyKGxlbik7XG5cdHdoaWxlIChidWYubGVuZ3RoID4gbGVuKSB7XG5cdFx0YXNzZXJ0LmVxdWFsKGJ1ZlswXSwgMHgwMCk7XG5cdFx0YnVmID0gYnVmLnNsaWNlKDEpO1xuXHR9XG5cdHdoaWxlIChidWYubGVuZ3RoIDwgbGVuKSB7XG5cdFx0dmFyIGIgPSBCdWZmZXIuYWxsb2MoYnVmLmxlbmd0aCArIDEpO1xuXHRcdGJbMF0gPSAweDAwO1xuXHRcdGJ1Zi5jb3B5KGIsIDEpO1xuXHRcdGJ1ZiA9IGI7XG5cdH1cblx0cmV0dXJuIChidWYpO1xufVxuXG5mdW5jdGlvbiBiaWdpbnRUb01wQnVmKGJpZ2ludCkge1xuXHR2YXIgYnVmID0gQnVmZmVyLmZyb20oYmlnaW50LnRvQnl0ZUFycmF5KCkpO1xuXHRidWYgPSBtcE5vcm1hbGl6ZShidWYpO1xuXHRyZXR1cm4gKGJ1Zik7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURTQVB1YmxpYyhnLCBwLCB4KSB7XG5cdGFzc2VydC5idWZmZXIoZyk7XG5cdGFzc2VydC5idWZmZXIocCk7XG5cdGFzc2VydC5idWZmZXIoeCk7XG5cdGcgPSBuZXcganNibihnKTtcblx0cCA9IG5ldyBqc2JuKHApO1xuXHR4ID0gbmV3IGpzYm4oeCk7XG5cdHZhciB5ID0gZy5tb2RQb3coeCwgcCk7XG5cdHZhciB5YnVmID0gYmlnaW50VG9NcEJ1Zih5KTtcblx0cmV0dXJuICh5YnVmKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRUQyNTUxOVB1YmxpYyhrKSB7XG5cdGFzc2VydC5idWZmZXIoayk7XG5cblx0dmFyIGtwID0gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQobmV3IFVpbnQ4QXJyYXkoaykpO1xuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKGtwLnB1YmxpY0tleSkpO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVYMjU1MTlQdWJsaWMoaykge1xuXHRhc3NlcnQuYnVmZmVyKGspO1xuXG5cdHZhciBrcCA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlZWQobmV3IFVpbnQ4QXJyYXkoaykpO1xuXHRyZXR1cm4gKEJ1ZmZlci5mcm9tKGtwLnB1YmxpY0tleSkpO1xufVxuXG5mdW5jdGlvbiBhZGRSU0FNaXNzaW5nKGtleSkge1xuXHRhc3NlcnQub2JqZWN0KGtleSk7XG5cdGFzc2VydENvbXBhdGlibGUoa2V5LCBQcml2YXRlS2V5LCBbMSwgMV0pO1xuXG5cdHZhciBkID0gbmV3IGpzYm4oa2V5LnBhcnQuZC5kYXRhKTtcblx0dmFyIGJ1ZjtcblxuXHRpZiAoIWtleS5wYXJ0LmRtb2RwKSB7XG5cdFx0dmFyIHAgPSBuZXcganNibihrZXkucGFydC5wLmRhdGEpO1xuXHRcdHZhciBkbW9kcCA9IGQubW9kKHAuc3VidHJhY3QoMSkpO1xuXG5cdFx0YnVmID0gYmlnaW50VG9NcEJ1ZihkbW9kcCk7XG5cdFx0a2V5LnBhcnQuZG1vZHAgPSB7bmFtZTogJ2Rtb2RwJywgZGF0YTogYnVmfTtcblx0XHRrZXkucGFydHMucHVzaChrZXkucGFydC5kbW9kcCk7XG5cdH1cblx0aWYgKCFrZXkucGFydC5kbW9kcSkge1xuXHRcdHZhciBxID0gbmV3IGpzYm4oa2V5LnBhcnQucS5kYXRhKTtcblx0XHR2YXIgZG1vZHEgPSBkLm1vZChxLnN1YnRyYWN0KDEpKTtcblxuXHRcdGJ1ZiA9IGJpZ2ludFRvTXBCdWYoZG1vZHEpO1xuXHRcdGtleS5wYXJ0LmRtb2RxID0ge25hbWU6ICdkbW9kcScsIGRhdGE6IGJ1Zn07XG5cdFx0a2V5LnBhcnRzLnB1c2goa2V5LnBhcnQuZG1vZHEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHB1YmxpY0Zyb21Qcml2YXRlRUNEU0EoY3VydmVOYW1lLCBwcml2KSB7XG5cdGFzc2VydC5zdHJpbmcoY3VydmVOYW1lLCAnY3VydmVOYW1lJyk7XG5cdGFzc2VydC5idWZmZXIocHJpdik7XG5cdHZhciBwYXJhbXMgPSBhbGdzLmN1cnZlc1tjdXJ2ZU5hbWVdO1xuXHR2YXIgcCA9IG5ldyBqc2JuKHBhcmFtcy5wKTtcblx0dmFyIGEgPSBuZXcganNibihwYXJhbXMuYSk7XG5cdHZhciBiID0gbmV3IGpzYm4ocGFyYW1zLmIpO1xuXHR2YXIgY3VydmUgPSBuZXcgZWMuRUNDdXJ2ZUZwKHAsIGEsIGIpO1xuXHR2YXIgRyA9IGN1cnZlLmRlY29kZVBvaW50SGV4KHBhcmFtcy5HLnRvU3RyaW5nKCdoZXgnKSk7XG5cblx0dmFyIGQgPSBuZXcganNibihtcE5vcm1hbGl6ZShwcml2KSk7XG5cdHZhciBwdWIgPSBHLm11bHRpcGx5KGQpO1xuXHRwdWIgPSBCdWZmZXIuZnJvbShjdXJ2ZS5lbmNvZGVQb2ludEhleChwdWIpLCAnaGV4Jyk7XG5cblx0dmFyIHBhcnRzID0gW107XG5cdHBhcnRzLnB1c2goe25hbWU6ICdjdXJ2ZScsIGRhdGE6IEJ1ZmZlci5mcm9tKGN1cnZlTmFtZSl9KTtcblx0cGFydHMucHVzaCh7bmFtZTogJ1EnLCBkYXRhOiBwdWJ9KTtcblxuXHR2YXIga2V5ID0gbmV3IEtleSh7dHlwZTogJ2VjZHNhJywgY3VydmU6IGN1cnZlLCBwYXJ0czogcGFydHN9KTtcblx0cmV0dXJuIChrZXkpO1xufVxuXG5mdW5jdGlvbiBvcGVuc3NoQ2lwaGVySW5mbyhjaXBoZXIpIHtcblx0dmFyIGluZiA9IHt9O1xuXHRzd2l0Y2ggKGNpcGhlcikge1xuXHRjYXNlICczZGVzLWNiYyc6XG5cdFx0aW5mLmtleVNpemUgPSAyNDtcblx0XHRpbmYuYmxvY2tTaXplID0gODtcblx0XHRpbmYub3BlbnNzbE5hbWUgPSAnZGVzLWVkZTMtY2JjJztcblx0XHRicmVhaztcblx0Y2FzZSAnYmxvd2Zpc2gtY2JjJzpcblx0XHRpbmYua2V5U2l6ZSA9IDE2O1xuXHRcdGluZi5ibG9ja1NpemUgPSA4O1xuXHRcdGluZi5vcGVuc3NsTmFtZSA9ICdiZi1jYmMnO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdhZXMxMjgtY2JjJzpcblx0Y2FzZSAnYWVzMTI4LWN0cic6XG5cdGNhc2UgJ2FlczEyOC1nY21Ab3BlbnNzaC5jb20nOlxuXHRcdGluZi5rZXlTaXplID0gMTY7XG5cdFx0aW5mLmJsb2NrU2l6ZSA9IDE2O1xuXHRcdGluZi5vcGVuc3NsTmFtZSA9ICdhZXMtMTI4LScgKyBjaXBoZXIuc2xpY2UoNywgMTApO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdhZXMxOTItY2JjJzpcblx0Y2FzZSAnYWVzMTkyLWN0cic6XG5cdGNhc2UgJ2FlczE5Mi1nY21Ab3BlbnNzaC5jb20nOlxuXHRcdGluZi5rZXlTaXplID0gMjQ7XG5cdFx0aW5mLmJsb2NrU2l6ZSA9IDE2O1xuXHRcdGluZi5vcGVuc3NsTmFtZSA9ICdhZXMtMTkyLScgKyBjaXBoZXIuc2xpY2UoNywgMTApO1xuXHRcdGJyZWFrO1xuXHRjYXNlICdhZXMyNTYtY2JjJzpcblx0Y2FzZSAnYWVzMjU2LWN0cic6XG5cdGNhc2UgJ2FlczI1Ni1nY21Ab3BlbnNzaC5jb20nOlxuXHRcdGluZi5rZXlTaXplID0gMzI7XG5cdFx0aW5mLmJsb2NrU2l6ZSA9IDE2O1xuXHRcdGluZi5vcGVuc3NsTmFtZSA9ICdhZXMtMjU2LScgKyBjaXBoZXIuc2xpY2UoNywgMTApO1xuXHRcdGJyZWFrO1xuXHRkZWZhdWx0OlxuXHRcdHRocm93IChuZXcgRXJyb3IoXG5cdFx0ICAgICdVbnN1cHBvcnRlZCBvcGVuc3NsIGNpcGhlciBcIicgKyBjaXBoZXIgKyAnXCInKSk7XG5cdH1cblx0cmV0dXJuIChpbmYpO1xufVxuIiwiLyohXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIFNhbGVzZm9yY2UuY29tLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIFNhbGVzZm9yY2UuY29tIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXlcbiAqIGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXRcbiAqIHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAqIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG52YXIgdXJsUGFyc2UgPSByZXF1aXJlKCd1cmwnKS5wYXJzZTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHB1YnN1ZmZpeCA9IHJlcXVpcmUoJy4vcHVic3VmZml4LXBzbCcpO1xudmFyIFN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZScpLlN0b3JlO1xudmFyIE1lbW9yeUNvb2tpZVN0b3JlID0gcmVxdWlyZSgnLi9tZW1zdG9yZScpLk1lbW9yeUNvb2tpZVN0b3JlO1xudmFyIHBhdGhNYXRjaCA9IHJlcXVpcmUoJy4vcGF0aE1hdGNoJykucGF0aE1hdGNoO1xudmFyIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuXG52YXIgcHVueWNvZGU7XG50cnkge1xuICBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG59IGNhdGNoKGUpIHtcbiAgY29uc29sZS53YXJuKFwidG91Z2gtY29va2llOiBjYW4ndCBsb2FkIHB1bnljb2RlOyB3b24ndCB1c2UgcHVueWNvZGUgZm9yIGRvbWFpbiBub3JtYWxpemF0aW9uXCIpO1xufVxuXG4vLyBGcm9tIFJGQzYyNjUgUzQuMS4xXG4vLyBub3RlIHRoYXQgaXQgZXhjbHVkZXMgXFx4M0IgXCI7XCJcbnZhciBDT09LSUVfT0NURVRTID0gL15bXFx4MjFcXHgyMy1cXHgyQlxceDJELVxceDNBXFx4M0MtXFx4NUJcXHg1RC1cXHg3RV0rJC87XG5cbnZhciBDT05UUk9MX0NIQVJTID0gL1tcXHgwMC1cXHgxRl0vO1xuXG4vLyBGcm9tIENocm9taXVtIC8vICdcXHInLCAnXFxuJyBhbmQgJ1xcMCcgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB0ZXJtaW5hdG9yIGluXG4vLyB0aGUgXCJyZWxheGVkXCIgbW9kZSwgc2VlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0Nocm9taXVtV2ViQXBwcy9jaHJvbWl1bS9ibG9iL2IzZDNiNGRhOGJiOTRjMWIyZTA2MTYwMGRmMTA2ZDU5MGZkYTM2MjAvbmV0L2Nvb2tpZXMvcGFyc2VkX2Nvb2tpZS5jYyNMNjBcbnZhciBURVJNSU5BVE9SUyA9IFsnXFxuJywgJ1xccicsICdcXDAnXTtcblxuLy8gUkZDNjI2NSBTNC4xLjEgZGVmaW5lcyBwYXRoIHZhbHVlIGFzICdhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBcIjtcIidcbi8vIE5vdGUgJzsnIGlzIFxceDNCXG52YXIgUEFUSF9WQUxVRSA9IC9bXFx4MjAtXFx4M0FcXHgzQy1cXHg3RV0rLztcblxuLy8gZGF0ZS10aW1lIHBhcnNpbmcgY29uc3RhbnRzIChSRkM2MjY1IFM1LjEuMSlcblxudmFyIERBVEVfREVMSU0gPSAvW1xceDA5XFx4MjAtXFx4MkZcXHgzQi1cXHg0MFxceDVCLVxceDYwXFx4N0ItXFx4N0VdLztcblxudmFyIE1PTlRIX1RPX05VTSA9IHtcbiAgamFuOjAsIGZlYjoxLCBtYXI6MiwgYXByOjMsIG1heTo0LCBqdW46NSxcbiAganVsOjYsIGF1Zzo3LCBzZXA6OCwgb2N0OjksIG5vdjoxMCwgZGVjOjExXG59O1xudmFyIE5VTV9UT19NT05USCA9IFtcbiAgJ0phbicsJ0ZlYicsJ01hcicsJ0FwcicsJ01heScsJ0p1bicsJ0p1bCcsJ0F1ZycsJ1NlcCcsJ09jdCcsJ05vdicsJ0RlYydcbl07XG52YXIgTlVNX1RPX0RBWSA9IFtcbiAgJ1N1bicsJ01vbicsJ1R1ZScsJ1dlZCcsJ1RodScsJ0ZyaScsJ1NhdCdcbl07XG5cbnZhciBNQVhfVElNRSA9IDIxNDc0ODM2NDcwMDA7IC8vIDMxLWJpdCBtYXhcbnZhciBNSU5fVElNRSA9IDA7IC8vIDMxLWJpdCBtaW5cblxuLypcbiAqIFBhcnNlcyBhIE5hdHVyYWwgbnVtYmVyIChpLmUuLCBub24tbmVnYXRpdmUgaW50ZWdlcikgd2l0aCBlaXRoZXIgdGhlXG4gKiAgICA8bWluPio8bWF4PkRJR0lUICggbm9uLWRpZ2l0ICpPQ1RFVCApXG4gKiBvclxuICogICAgPG1pbj4qPG1heD5ESUdJVFxuICogZ3JhbW1hciAoUkZDNjI2NSBTNS4xLjEpLlxuICpcbiAqIFRoZSBcInRyYWlsaW5nT0tcIiBib29sZWFuIGNvbnRyb2xzIGlmIHRoZSBncmFtbWFyIGFjY2VwdHMgYVxuICogXCIoIG5vbi1kaWdpdCAqT0NURVQgKVwiIHRyYWlsZXIuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGlnaXRzKHRva2VuLCBtaW5EaWdpdHMsIG1heERpZ2l0cywgdHJhaWxpbmdPSykge1xuICB2YXIgY291bnQgPSAwO1xuICB3aGlsZSAoY291bnQgPCB0b2tlbi5sZW5ndGgpIHtcbiAgICB2YXIgYyA9IHRva2VuLmNoYXJDb2RlQXQoY291bnQpO1xuICAgIC8vIFwibm9uLWRpZ2l0ID0gJXgwMC0yRiAvICV4M0EtRkZcIlxuICAgIGlmIChjIDw9IDB4MkYgfHwgYyA+PSAweDNBKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY291bnQrKztcbiAgfVxuXG4gIC8vIGNvbnN0cmFpbiB0byBhIG1pbmltdW0gYW5kIG1heGltdW0gbnVtYmVyIG9mIGRpZ2l0cy5cbiAgaWYgKGNvdW50IDwgbWluRGlnaXRzIHx8IGNvdW50ID4gbWF4RGlnaXRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIXRyYWlsaW5nT0sgJiYgY291bnQgIT0gdG9rZW4ubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodG9rZW4uc3Vic3RyKDAsY291bnQpLCAxMCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZSh0b2tlbikge1xuICB2YXIgcGFydHMgPSB0b2tlbi5zcGxpdCgnOicpO1xuICB2YXIgcmVzdWx0ID0gWzAsMCwwXTtcblxuICAvKiBSRjYyNTYgUzUuMS4xOlxuICAgKiAgICAgIHRpbWUgICAgICAgICAgICA9IGhtcy10aW1lICggbm9uLWRpZ2l0ICpPQ1RFVCApXG4gICAqICAgICAgaG1zLXRpbWUgICAgICAgID0gdGltZS1maWVsZCBcIjpcIiB0aW1lLWZpZWxkIFwiOlwiIHRpbWUtZmllbGRcbiAgICogICAgICB0aW1lLWZpZWxkICAgICAgPSAxKjJESUdJVFxuICAgKi9cblxuICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIC8vIFwidGltZS1maWVsZFwiIG11c3QgYmUgc3RyaWN0bHkgXCIxKjJESUdJVFwiLCBIT1dFVkVSLCBcImhtcy10aW1lXCIgY2FuIGJlXG4gICAgLy8gZm9sbG93ZWQgYnkgXCIoIG5vbi1kaWdpdCAqT0NURVQgKVwiIHNvIHRoZXJlZm9yZSB0aGUgbGFzdCB0aW1lLWZpZWxkIGNhblxuICAgIC8vIGhhdmUgYSB0cmFpbGVyXG4gICAgdmFyIHRyYWlsaW5nT0sgPSAoaSA9PSAyKTtcbiAgICB2YXIgbnVtID0gcGFyc2VEaWdpdHMocGFydHNbaV0sIDEsIDIsIHRyYWlsaW5nT0spO1xuICAgIGlmIChudW0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXN1bHRbaV0gPSBudW07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZU1vbnRoKHRva2VuKSB7XG4gIHRva2VuID0gU3RyaW5nKHRva2VuKS5zdWJzdHIoMCwzKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgbnVtID0gTU9OVEhfVE9fTlVNW3Rva2VuXTtcbiAgcmV0dXJuIG51bSA+PSAwID8gbnVtIDogbnVsbDtcbn1cblxuLypcbiAqIFJGQzYyNjUgUzUuMS4xIGRhdGUgcGFyc2VyIChzZWUgUkZDIGZvciBmdWxsIGdyYW1tYXIpXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0ZShzdHIpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiBSRkM2MjY1IFM1LjEuMTpcbiAgICogMi4gUHJvY2VzcyBlYWNoIGRhdGUtdG9rZW4gc2VxdWVudGlhbGx5IGluIHRoZSBvcmRlciB0aGUgZGF0ZS10b2tlbnNcbiAgICogYXBwZWFyIGluIHRoZSBjb29raWUtZGF0ZVxuICAgKi9cbiAgdmFyIHRva2VucyA9IHN0ci5zcGxpdChEQVRFX0RFTElNKTtcbiAgaWYgKCF0b2tlbnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaG91ciA9IG51bGw7XG4gIHZhciBtaW51dGUgPSBudWxsO1xuICB2YXIgc2Vjb25kID0gbnVsbDtcbiAgdmFyIGRheU9mTW9udGggPSBudWxsO1xuICB2YXIgbW9udGggPSBudWxsO1xuICB2YXIgeWVhciA9IG51bGw7XG5cbiAgZm9yICh2YXIgaT0wOyBpPHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXS50cmltKCk7XG4gICAgaWYgKCF0b2tlbi5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvKiAyLjEuIElmIHRoZSBmb3VuZC10aW1lIGZsYWcgaXMgbm90IHNldCBhbmQgdGhlIHRva2VuIG1hdGNoZXMgdGhlIHRpbWVcbiAgICAgKiBwcm9kdWN0aW9uLCBzZXQgdGhlIGZvdW5kLXRpbWUgZmxhZyBhbmQgc2V0IHRoZSBob3VyLSB2YWx1ZSxcbiAgICAgKiBtaW51dGUtdmFsdWUsIGFuZCBzZWNvbmQtdmFsdWUgdG8gdGhlIG51bWJlcnMgZGVub3RlZCBieSB0aGUgZGlnaXRzIGluXG4gICAgICogdGhlIGRhdGUtdG9rZW4sIHJlc3BlY3RpdmVseS4gIFNraXAgdGhlIHJlbWFpbmluZyBzdWItc3RlcHMgYW5kIGNvbnRpbnVlXG4gICAgICogdG8gdGhlIG5leHQgZGF0ZS10b2tlbi5cbiAgICAgKi9cbiAgICBpZiAoc2Vjb25kID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBwYXJzZVRpbWUodG9rZW4pO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBob3VyID0gcmVzdWx0WzBdO1xuICAgICAgICBtaW51dGUgPSByZXN1bHRbMV07XG4gICAgICAgIHNlY29uZCA9IHJlc3VsdFsyXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogMi4yLiBJZiB0aGUgZm91bmQtZGF5LW9mLW1vbnRoIGZsYWcgaXMgbm90IHNldCBhbmQgdGhlIGRhdGUtdG9rZW4gbWF0Y2hlc1xuICAgICAqIHRoZSBkYXktb2YtbW9udGggcHJvZHVjdGlvbiwgc2V0IHRoZSBmb3VuZC1kYXktb2YtIG1vbnRoIGZsYWcgYW5kIHNldFxuICAgICAqIHRoZSBkYXktb2YtbW9udGgtdmFsdWUgdG8gdGhlIG51bWJlciBkZW5vdGVkIGJ5IHRoZSBkYXRlLXRva2VuLiAgU2tpcFxuICAgICAqIHRoZSByZW1haW5pbmcgc3ViLXN0ZXBzIGFuZCBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICAgICAqL1xuICAgIGlmIChkYXlPZk1vbnRoID09PSBudWxsKSB7XG4gICAgICAvLyBcImRheS1vZi1tb250aCA9IDEqMkRJR0lUICggbm9uLWRpZ2l0ICpPQ1RFVCApXCJcbiAgICAgIHJlc3VsdCA9IHBhcnNlRGlnaXRzKHRva2VuLCAxLCAyLCB0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgZGF5T2ZNb250aCA9IHJlc3VsdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogMi4zLiBJZiB0aGUgZm91bmQtbW9udGggZmxhZyBpcyBub3Qgc2V0IGFuZCB0aGUgZGF0ZS10b2tlbiBtYXRjaGVzIHRoZVxuICAgICAqIG1vbnRoIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQtbW9udGggZmxhZyBhbmQgc2V0IHRoZSBtb250aC12YWx1ZSB0b1xuICAgICAqIHRoZSBtb250aCBkZW5vdGVkIGJ5IHRoZSBkYXRlLXRva2VuLiAgU2tpcCB0aGUgcmVtYWluaW5nIHN1Yi1zdGVwcyBhbmRcbiAgICAgKiBjb250aW51ZSB0byB0aGUgbmV4dCBkYXRlLXRva2VuLlxuICAgICAqL1xuICAgIGlmIChtb250aCA9PT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcGFyc2VNb250aCh0b2tlbik7XG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIG1vbnRoID0gcmVzdWx0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiAyLjQuIElmIHRoZSBmb3VuZC15ZWFyIGZsYWcgaXMgbm90IHNldCBhbmQgdGhlIGRhdGUtdG9rZW4gbWF0Y2hlcyB0aGVcbiAgICAgKiB5ZWFyIHByb2R1Y3Rpb24sIHNldCB0aGUgZm91bmQteWVhciBmbGFnIGFuZCBzZXQgdGhlIHllYXItdmFsdWUgdG8gdGhlXG4gICAgICogbnVtYmVyIGRlbm90ZWQgYnkgdGhlIGRhdGUtdG9rZW4uICBTa2lwIHRoZSByZW1haW5pbmcgc3ViLXN0ZXBzIGFuZFxuICAgICAqIGNvbnRpbnVlIHRvIHRoZSBuZXh0IGRhdGUtdG9rZW4uXG4gICAgICovXG4gICAgaWYgKHllYXIgPT09IG51bGwpIHtcbiAgICAgIC8vIFwieWVhciA9IDIqNERJR0lUICggbm9uLWRpZ2l0ICpPQ1RFVCApXCJcbiAgICAgIHJlc3VsdCA9IHBhcnNlRGlnaXRzKHRva2VuLCAyLCA0LCB0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgeWVhciA9IHJlc3VsdDtcbiAgICAgICAgLyogRnJvbSBTNS4xLjE6XG4gICAgICAgICAqIDMuICBJZiB0aGUgeWVhci12YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gNzAgYW5kIGxlc3NcbiAgICAgICAgICogdGhhbiBvciBlcXVhbCB0byA5OSwgaW5jcmVtZW50IHRoZSB5ZWFyLXZhbHVlIGJ5IDE5MDAuXG4gICAgICAgICAqIDQuICBJZiB0aGUgeWVhci12YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBhbmQgbGVzc1xuICAgICAgICAgKiB0aGFuIG9yIGVxdWFsIHRvIDY5LCBpbmNyZW1lbnQgdGhlIHllYXItdmFsdWUgYnkgMjAwMC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh5ZWFyID49IDcwICYmIHllYXIgPD0gOTkpIHtcbiAgICAgICAgICB5ZWFyICs9IDE5MDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA+PSAwICYmIHllYXIgPD0gNjkpIHtcbiAgICAgICAgICB5ZWFyICs9IDIwMDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiBSRkMgNjI2NSBTNS4xLjFcbiAgICogXCI1LiBBYm9ydCB0aGVzZSBzdGVwcyBhbmQgZmFpbCB0byBwYXJzZSB0aGUgY29va2llLWRhdGUgaWY6XG4gICAqICAgICAqICBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvdW5kLWRheS1vZi1tb250aCwgZm91bmQtbW9udGgsIGZvdW5kLVxuICAgKiAgICAgICAgeWVhciwgb3IgZm91bmQtdGltZSBmbGFncyBpcyBub3Qgc2V0LFxuICAgKiAgICAgKiAgdGhlIGRheS1vZi1tb250aC12YWx1ZSBpcyBsZXNzIHRoYW4gMSBvciBncmVhdGVyIHRoYW4gMzEsXG4gICAqICAgICAqICB0aGUgeWVhci12YWx1ZSBpcyBsZXNzIHRoYW4gMTYwMSxcbiAgICogICAgICogIHRoZSBob3VyLXZhbHVlIGlzIGdyZWF0ZXIgdGhhbiAyMyxcbiAgICogICAgICogIHRoZSBtaW51dGUtdmFsdWUgaXMgZ3JlYXRlciB0aGFuIDU5LCBvclxuICAgKiAgICAgKiAgdGhlIHNlY29uZC12YWx1ZSBpcyBncmVhdGVyIHRoYW4gNTkuXG4gICAqICAgICAoTm90ZSB0aGF0IGxlYXAgc2Vjb25kcyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gdGhpcyBzeW50YXguKVwiXG4gICAqXG4gICAqIFNvLCBpbiBvcmRlciBhcyBhYm92ZTpcbiAgICovXG4gIGlmIChcbiAgICBkYXlPZk1vbnRoID09PSBudWxsIHx8IG1vbnRoID09PSBudWxsIHx8IHllYXIgPT09IG51bGwgfHwgc2Vjb25kID09PSBudWxsIHx8XG4gICAgZGF5T2ZNb250aCA8IDEgfHwgZGF5T2ZNb250aCA+IDMxIHx8XG4gICAgeWVhciA8IDE2MDEgfHxcbiAgICBob3VyID4gMjMgfHxcbiAgICBtaW51dGUgPiA1OSB8fFxuICAgIHNlY29uZCA+IDU5XG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5T2ZNb250aCwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIHZhciBkID0gZGF0ZS5nZXRVVENEYXRlKCk7IGQgPSBkID49IDEwID8gZCA6ICcwJytkO1xuICB2YXIgaCA9IGRhdGUuZ2V0VVRDSG91cnMoKTsgaCA9IGggPj0gMTAgPyBoIDogJzAnK2g7XG4gIHZhciBtID0gZGF0ZS5nZXRVVENNaW51dGVzKCk7IG0gPSBtID49IDEwID8gbSA6ICcwJyttO1xuICB2YXIgcyA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpOyBzID0gcyA+PSAxMCA/IHMgOiAnMCcrcztcbiAgcmV0dXJuIE5VTV9UT19EQVlbZGF0ZS5nZXRVVENEYXkoKV0gKyAnLCAnICtcbiAgICBkKycgJysgTlVNX1RPX01PTlRIW2RhdGUuZ2V0VVRDTW9udGgoKV0gKycgJysgZGF0ZS5nZXRVVENGdWxsWWVhcigpICsnICcrXG4gICAgaCsnOicrbSsnOicrcysnIEdNVCc7XG59XG5cbi8vIFM1LjEuMiBDYW5vbmljYWxpemVkIEhvc3QgTmFtZXNcbmZ1bmN0aW9uIGNhbm9uaWNhbERvbWFpbihzdHIpIHtcbiAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKC9eXFwuLywnJyk7IC8vIFM0LjEuMi4zICYgUzUuMi4zOiBpZ25vcmUgbGVhZGluZyAuXG5cbiAgLy8gY29udmVydCB0byBJRE4gaWYgYW55IG5vbi1BU0NJSSBjaGFyYWN0ZXJzXG4gIGlmIChwdW55Y29kZSAmJiAvW15cXHUwMDAxLVxcdTAwN2ZdLy50ZXN0KHN0cikpIHtcbiAgICBzdHIgPSBwdW55Y29kZS50b0FTQ0lJKHN0cik7XG4gIH1cblxuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8vIFM1LjEuMyBEb21haW4gTWF0Y2hpbmdcbmZ1bmN0aW9uIGRvbWFpbk1hdGNoKHN0ciwgZG9tU3RyLCBjYW5vbmljYWxpemUpIHtcbiAgaWYgKHN0ciA9PSBudWxsIHx8IGRvbVN0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNhbm9uaWNhbGl6ZSAhPT0gZmFsc2UpIHtcbiAgICBzdHIgPSBjYW5vbmljYWxEb21haW4oc3RyKTtcbiAgICBkb21TdHIgPSBjYW5vbmljYWxEb21haW4oZG9tU3RyKTtcbiAgfVxuXG4gIC8qXG4gICAqIFwiVGhlIGRvbWFpbiBzdHJpbmcgYW5kIHRoZSBzdHJpbmcgYXJlIGlkZW50aWNhbC4gKE5vdGUgdGhhdCBib3RoIHRoZVxuICAgKiBkb21haW4gc3RyaW5nIGFuZCB0aGUgc3RyaW5nIHdpbGwgaGF2ZSBiZWVuIGNhbm9uaWNhbGl6ZWQgdG8gbG93ZXIgY2FzZSBhdFxuICAgKiB0aGlzIHBvaW50KVwiXG4gICAqL1xuICBpZiAoc3RyID09IGRvbVN0cikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyogXCJBbGwgb2YgdGhlIGZvbGxvd2luZyBbdGhyZWVdIGNvbmRpdGlvbnMgaG9sZDpcIiAob3JkZXIgYWRqdXN0ZWQgZnJvbSB0aGUgUkZDKSAqL1xuXG4gIC8qIFwiKiBUaGUgc3RyaW5nIGlzIGEgaG9zdCBuYW1lIChpLmUuLCBub3QgYW4gSVAgYWRkcmVzcykuXCIgKi9cbiAgaWYgKG5ldC5pc0lQKHN0cikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiBcIiogVGhlIGRvbWFpbiBzdHJpbmcgaXMgYSBzdWZmaXggb2YgdGhlIHN0cmluZ1wiICovXG4gIHZhciBpZHggPSBzdHIuaW5kZXhPZihkb21TdHIpO1xuICBpZiAoaWR4IDw9IDApIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIGl0J3MgYSBub24tbWF0Y2ggKC0xKSBvciBwcmVmaXggKDApXG4gIH1cblxuICAvLyBlLmcgXCJhLmIuY1wiLmluZGV4T2YoXCJiLmNcIikgPT09IDJcbiAgLy8gNSA9PT0gMysyXG4gIGlmIChzdHIubGVuZ3RoICE9PSBkb21TdHIubGVuZ3RoICsgaWR4KSB7IC8vIGl0J3Mgbm90IGEgc3VmZml4XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyogXCIqIFRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nIHRoYXQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBkb21haW5cbiAgKiBzdHJpbmcgaXMgYSAleDJFIChcIi5cIikgY2hhcmFjdGVyLlwiICovXG4gIGlmIChzdHIuc3Vic3RyKGlkeC0xLDEpICE9PSAnLicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vLyBSRkM2MjY1IFM1LjEuNCBQYXRocyBhbmQgUGF0aC1NYXRjaFxuXG4vKlxuICogXCJUaGUgdXNlciBhZ2VudCBNVVNUIHVzZSBhbiBhbGdvcml0aG0gZXF1aXZhbGVudCB0byB0aGUgZm9sbG93aW5nIGFsZ29yaXRobVxuICogdG8gY29tcHV0ZSB0aGUgZGVmYXVsdC1wYXRoIG9mIGEgY29va2llOlwiXG4gKlxuICogQXNzdW1wdGlvbjogdGhlIHBhdGggKGFuZCBub3QgcXVlcnkgcGFydCBvciBhYnNvbHV0ZSB1cmkpIGlzIHBhc3NlZCBpbi5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFBhdGgocGF0aCkge1xuICAvLyBcIjIuIElmIHRoZSB1cmktcGF0aCBpcyBlbXB0eSBvciBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSB1cmktcGF0aCBpcyBub3RcbiAgLy8gYSAleDJGIChcIi9cIikgY2hhcmFjdGVyLCBvdXRwdXQgJXgyRiAoXCIvXCIpIGFuZCBza2lwIHRoZSByZW1haW5pbmcgc3RlcHMuXG4gIGlmICghcGF0aCB8fCBwYXRoLnN1YnN0cigwLDEpICE9PSBcIi9cIikge1xuICAgIHJldHVybiBcIi9cIjtcbiAgfVxuXG4gIC8vIFwiMy4gSWYgdGhlIHVyaS1wYXRoIGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBvbmUgJXgyRiAoXCIvXCIpIGNoYXJhY3Rlciwgb3V0cHV0XG4gIC8vICV4MkYgKFwiL1wiKSBhbmQgc2tpcCB0aGUgcmVtYWluaW5nIHN0ZXAuXCJcbiAgaWYgKHBhdGggPT09IFwiL1wiKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICB2YXIgcmlnaHRTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoXCIvXCIpO1xuICBpZiAocmlnaHRTbGFzaCA9PT0gMCkge1xuICAgIHJldHVybiBcIi9cIjtcbiAgfVxuXG4gIC8vIFwiNC4gT3V0cHV0IHRoZSBjaGFyYWN0ZXJzIG9mIHRoZSB1cmktcGF0aCBmcm9tIHRoZSBmaXJzdCBjaGFyYWN0ZXIgdXAgdG8sXG4gIC8vIGJ1dCBub3QgaW5jbHVkaW5nLCB0aGUgcmlnaHQtbW9zdCAleDJGIChcIi9cIikuXCJcbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgcmlnaHRTbGFzaCk7XG59XG5cbmZ1bmN0aW9uIHRyaW1UZXJtaW5hdG9yKHN0cikge1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IFRFUk1JTkFUT1JTLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIHRlcm1pbmF0b3JJZHggPSBzdHIuaW5kZXhPZihURVJNSU5BVE9SU1t0XSk7XG4gICAgaWYgKHRlcm1pbmF0b3JJZHggIT09IC0xKSB7XG4gICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsdGVybWluYXRvcklkeCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcGFyc2VDb29raWVQYWlyKGNvb2tpZVBhaXIsIGxvb3NlTW9kZSkge1xuICBjb29raWVQYWlyID0gdHJpbVRlcm1pbmF0b3IoY29va2llUGFpcik7XG5cbiAgdmFyIGZpcnN0RXEgPSBjb29raWVQYWlyLmluZGV4T2YoJz0nKTtcbiAgaWYgKGxvb3NlTW9kZSkge1xuICAgIGlmIChmaXJzdEVxID09PSAwKSB7IC8vICc9JyBpcyBpbW1lZGlhdGVseSBhdCBzdGFydFxuICAgICAgY29va2llUGFpciA9IGNvb2tpZVBhaXIuc3Vic3RyKDEpO1xuICAgICAgZmlyc3RFcSA9IGNvb2tpZVBhaXIuaW5kZXhPZignPScpOyAvLyBtaWdodCBzdGlsbCBuZWVkIHRvIHNwbGl0IG9uICc9J1xuICAgIH1cbiAgfSBlbHNlIHsgLy8gbm9uLWxvb3NlIG1vZGVcbiAgICBpZiAoZmlyc3RFcSA8PSAwKSB7IC8vIG5vICc9JyBvciBpcyBhdCBzdGFydFxuICAgICAgcmV0dXJuOyAvLyBuZWVkcyB0byBoYXZlIG5vbi1lbXB0eSBcImNvb2tpZS1uYW1lXCJcbiAgICB9XG4gIH1cblxuICB2YXIgY29va2llTmFtZSwgY29va2llVmFsdWU7XG4gIGlmIChmaXJzdEVxIDw9IDApIHtcbiAgICBjb29raWVOYW1lID0gXCJcIjtcbiAgICBjb29raWVWYWx1ZSA9IGNvb2tpZVBhaXIudHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIGNvb2tpZU5hbWUgPSBjb29raWVQYWlyLnN1YnN0cigwLCBmaXJzdEVxKS50cmltKCk7XG4gICAgY29va2llVmFsdWUgPSBjb29raWVQYWlyLnN1YnN0cihmaXJzdEVxKzEpLnRyaW0oKTtcbiAgfVxuXG4gIGlmIChDT05UUk9MX0NIQVJTLnRlc3QoY29va2llTmFtZSkgfHwgQ09OVFJPTF9DSEFSUy50ZXN0KGNvb2tpZVZhbHVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjID0gbmV3IENvb2tpZSgpO1xuICBjLmtleSA9IGNvb2tpZU5hbWU7XG4gIGMudmFsdWUgPSBjb29raWVWYWx1ZTtcbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHN0ciwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHN0ciA9IHN0ci50cmltKCk7XG5cbiAgLy8gV2UgdXNlIGEgcmVnZXggdG8gcGFyc2UgdGhlIFwibmFtZS12YWx1ZS1wYWlyXCIgcGFydCBvZiBTNS4yXG4gIHZhciBmaXJzdFNlbWkgPSBzdHIuaW5kZXhPZignOycpOyAvLyBTNS4yIHN0ZXAgMVxuICB2YXIgY29va2llUGFpciA9IChmaXJzdFNlbWkgPT09IC0xKSA/IHN0ciA6IHN0ci5zdWJzdHIoMCwgZmlyc3RTZW1pKTtcbiAgdmFyIGMgPSBwYXJzZUNvb2tpZVBhaXIoY29va2llUGFpciwgISFvcHRpb25zLmxvb3NlKTtcbiAgaWYgKCFjKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGZpcnN0U2VtaSA9PT0gLTEpIHtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8vIFM1LjIuMyBcInVucGFyc2VkLWF0dHJpYnV0ZXMgY29uc2lzdCBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBzZXQtY29va2llLXN0cmluZ1xuICAvLyAoaW5jbHVkaW5nIHRoZSAleDNCIChcIjtcIikgaW4gcXVlc3Rpb24pLlwiIHBsdXMgbGF0ZXIgb24gaW4gdGhlIHNhbWUgc2VjdGlvblxuICAvLyBcImRpc2NhcmQgdGhlIGZpcnN0IFwiO1wiIGFuZCB0cmltXCIuXG4gIHZhciB1bnBhcnNlZCA9IHN0ci5zbGljZShmaXJzdFNlbWkgKyAxKS50cmltKCk7XG5cbiAgLy8gXCJJZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyBzdHJpbmcgaXMgZW1wdHksIHNraXAgdGhlIHJlc3Qgb2YgdGhlc2VcbiAgLy8gc3RlcHMuXCJcbiAgaWYgKHVucGFyc2VkLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgLypcbiAgICogUzUuMiBzYXlzIHRoYXQgd2hlbiBsb29waW5nIG92ZXIgdGhlIGl0ZW1zIFwiW3Bdcm9jZXNzIHRoZSBhdHRyaWJ1dGUtbmFtZVxuICAgKiBhbmQgYXR0cmlidXRlLXZhbHVlIGFjY29yZGluZyB0byB0aGUgcmVxdWlyZW1lbnRzIGluIHRoZSBmb2xsb3dpbmdcbiAgICogc3Vic2VjdGlvbnNcIiBmb3IgZXZlcnkgaXRlbS4gIFBsdXMsIGZvciBtYW55IG9mIHRoZSBpbmRpdmlkdWFsIGF0dHJpYnV0ZXNcbiAgICogaW4gUzUuMyBpdCBzYXlzIHRvIHVzZSB0aGUgXCJhdHRyaWJ1dGUtdmFsdWUgb2YgdGhlIGxhc3QgYXR0cmlidXRlIGluIHRoZVxuICAgKiBjb29raWUtYXR0cmlidXRlLWxpc3RcIi4gIFRoZXJlZm9yZSwgaW4gdGhpcyBpbXBsZW1lbnRhdGlvbiwgd2Ugb3ZlcndyaXRlXG4gICAqIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICovXG4gIHZhciBjb29raWVfYXZzID0gdW5wYXJzZWQuc3BsaXQoJzsnKTtcbiAgd2hpbGUgKGNvb2tpZV9hdnMubGVuZ3RoKSB7XG4gICAgdmFyIGF2ID0gY29va2llX2F2cy5zaGlmdCgpLnRyaW0oKTtcbiAgICBpZiAoYXYubGVuZ3RoID09PSAwKSB7IC8vIGhhcHBlbnMgaWYgXCI7O1wiIGFwcGVhcnNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgYXZfc2VwID0gYXYuaW5kZXhPZignPScpO1xuICAgIHZhciBhdl9rZXksIGF2X3ZhbHVlO1xuXG4gICAgaWYgKGF2X3NlcCA9PT0gLTEpIHtcbiAgICAgIGF2X2tleSA9IGF2O1xuICAgICAgYXZfdmFsdWUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdl9rZXkgPSBhdi5zdWJzdHIoMCxhdl9zZXApO1xuICAgICAgYXZfdmFsdWUgPSBhdi5zdWJzdHIoYXZfc2VwKzEpO1xuICAgIH1cblxuICAgIGF2X2tleSA9IGF2X2tleS50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChhdl92YWx1ZSkge1xuICAgICAgYXZfdmFsdWUgPSBhdl92YWx1ZS50cmltKCk7XG4gICAgfVxuXG4gICAgc3dpdGNoKGF2X2tleSkge1xuICAgIGNhc2UgJ2V4cGlyZXMnOiAvLyBTNS4yLjFcbiAgICAgIGlmIChhdl92YWx1ZSkge1xuICAgICAgICB2YXIgZXhwID0gcGFyc2VEYXRlKGF2X3ZhbHVlKTtcbiAgICAgICAgLy8gXCJJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGZhaWxlZCB0byBwYXJzZSBhcyBhIGNvb2tpZSBkYXRlLCBpZ25vcmUgdGhlXG4gICAgICAgIC8vIGNvb2tpZS1hdi5cIlxuICAgICAgICBpZiAoZXhwKSB7XG4gICAgICAgICAgLy8gb3ZlciBhbmQgdW5kZXJmbG93IG5vdCByZWFsaXN0aWNhbGx5IGEgY29uY2VybjogVjgncyBnZXRUaW1lKCkgc2VlbXMgdG9cbiAgICAgICAgICAvLyBzdG9yZSBzb21ldGhpbmcgbGFyZ2VyIHRoYW4gYSAzMi1iaXQgdGltZV90IChldmVuIHdpdGggMzItYml0IG5vZGUpXG4gICAgICAgICAgYy5leHBpcmVzID0gZXhwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ21heC1hZ2UnOiAvLyBTNS4yLjJcbiAgICAgIGlmIChhdl92YWx1ZSkge1xuICAgICAgICAvLyBcIklmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBub3QgYSBESUdJVCBvciBhIFwiLVwiXG4gICAgICAgIC8vIGNoYXJhY3RlciAuLi5bb3JdLi4uIElmIHRoZSByZW1haW5kZXIgb2YgYXR0cmlidXRlLXZhbHVlIGNvbnRhaW5zIGFcbiAgICAgICAgLy8gbm9uLURJR0lUIGNoYXJhY3RlciwgaWdub3JlIHRoZSBjb29raWUtYXYuXCJcbiAgICAgICAgaWYgKC9eLT9bMC05XSskLy50ZXN0KGF2X3ZhbHVlKSkge1xuICAgICAgICAgIHZhciBkZWx0YSA9IHBhcnNlSW50KGF2X3ZhbHVlLCAxMCk7XG4gICAgICAgICAgLy8gXCJJZiBkZWx0YS1zZWNvbmRzIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB6ZXJvICgwKSwgbGV0IGV4cGlyeS10aW1lXG4gICAgICAgICAgLy8gYmUgdGhlIGVhcmxpZXN0IHJlcHJlc2VudGFibGUgZGF0ZSBhbmQgdGltZS5cIlxuICAgICAgICAgIGMuc2V0TWF4QWdlKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkb21haW4nOiAvLyBTNS4yLjNcbiAgICAgIC8vIFwiSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBlbXB0eSwgdGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZC4gIEhvd2V2ZXIsXG4gICAgICAvLyB0aGUgdXNlciBhZ2VudCBTSE9VTEQgaWdub3JlIHRoZSBjb29raWUtYXYgZW50aXJlbHkuXCJcbiAgICAgIGlmIChhdl92YWx1ZSkge1xuICAgICAgICAvLyBTNS4yLjMgXCJMZXQgY29va2llLWRvbWFpbiBiZSB0aGUgYXR0cmlidXRlLXZhbHVlIHdpdGhvdXQgdGhlIGxlYWRpbmcgJXgyRVxuICAgICAgICAvLyAoXCIuXCIpIGNoYXJhY3Rlci5cIlxuICAgICAgICB2YXIgZG9tYWluID0gYXZfdmFsdWUudHJpbSgpLnJlcGxhY2UoL15cXC4vLCAnJyk7XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAvLyBcIkNvbnZlcnQgdGhlIGNvb2tpZS1kb21haW4gdG8gbG93ZXIgY2FzZS5cIlxuICAgICAgICAgIGMuZG9tYWluID0gZG9tYWluLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0aCc6IC8vIFM1LjIuNFxuICAgICAgLypcbiAgICAgICAqIFwiSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBlbXB0eSBvciBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZVxuICAgICAgICogYXR0cmlidXRlLXZhbHVlIGlzIG5vdCAleDJGIChcIi9cIik6XG4gICAgICAgKiAgIExldCBjb29raWUtcGF0aCBiZSB0aGUgZGVmYXVsdC1wYXRoLlxuICAgICAgICogT3RoZXJ3aXNlOlxuICAgICAgICogICBMZXQgY29va2llLXBhdGggYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZS5cIlxuICAgICAgICpcbiAgICAgICAqIFdlJ2xsIHJlcHJlc2VudCB0aGUgZGVmYXVsdC1wYXRoIGFzIG51bGwgc2luY2UgaXQgZGVwZW5kcyBvbiB0aGVcbiAgICAgICAqIGNvbnRleHQgb2YgdGhlIHBhcnNpbmcuXG4gICAgICAgKi9cbiAgICAgIGMucGF0aCA9IGF2X3ZhbHVlICYmIGF2X3ZhbHVlWzBdID09PSBcIi9cIiA/IGF2X3ZhbHVlIDogbnVsbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VjdXJlJzogLy8gUzUuMi41XG4gICAgICAvKlxuICAgICAgICogXCJJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIlNlY3VyZVwiLFxuICAgICAgICogdGhlIHVzZXIgYWdlbnQgTVVTVCBhcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3RcbiAgICAgICAqIHdpdGggYW4gYXR0cmlidXRlLW5hbWUgb2YgU2VjdXJlIGFuZCBhbiBlbXB0eSBhdHRyaWJ1dGUtdmFsdWUuXCJcbiAgICAgICAqL1xuICAgICAgYy5zZWN1cmUgPSB0cnVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdodHRwb25seSc6IC8vIFM1LjIuNiAtLSBlZmZlY3RpdmVseSB0aGUgc2FtZSBhcyAnc2VjdXJlJ1xuICAgICAgYy5odHRwT25seSA9IHRydWU7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBjLmV4dGVuc2lvbnMgPSBjLmV4dGVuc2lvbnMgfHwgW107XG4gICAgICBjLmV4dGVuc2lvbnMucHVzaChhdik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYztcbn1cblxuLy8gYXZvaWQgdGhlIFY4IGRlb3B0aW1pemF0aW9uIG1vbnN0ZXIhXG5mdW5jdGlvbiBqc29uUGFyc2Uoc3RyKSB7XG4gIHZhciBvYmo7XG4gIHRyeSB7XG4gICAgb2JqID0gSlNPTi5wYXJzZShzdHIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gZnJvbUpTT04oc3RyKSB7XG4gIGlmICghc3RyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgb2JqO1xuICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICBvYmogPSBqc29uUGFyc2Uoc3RyKTtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBhc3N1bWUgaXQncyBhbiBPYmplY3RcbiAgICBvYmogPSBzdHI7XG4gIH1cblxuICB2YXIgYyA9IG5ldyBDb29raWUoKTtcbiAgZm9yICh2YXIgaT0wOyBpPENvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBDb29raWUuc2VyaWFsaXphYmxlUHJvcGVydGllc1tpXTtcbiAgICBpZiAob2JqW3Byb3BdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgb2JqW3Byb3BdID09PSBDb29raWUucHJvdG90eXBlW3Byb3BdKVxuICAgIHtcbiAgICAgIGNvbnRpbnVlOyAvLyBsZWF2ZSBhcyBwcm90b3R5cGUgZGVmYXVsdFxuICAgIH1cblxuICAgIGlmIChwcm9wID09PSAnZXhwaXJlcycgfHxcbiAgICAgICAgcHJvcCA9PT0gJ2NyZWF0aW9uJyB8fFxuICAgICAgICBwcm9wID09PSAnbGFzdEFjY2Vzc2VkJylcbiAgICB7XG4gICAgICBpZiAob2JqW3Byb3BdID09PSBudWxsKSB7XG4gICAgICAgIGNbcHJvcF0gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY1twcm9wXSA9IG9ialtwcm9wXSA9PSBcIkluZmluaXR5XCIgP1xuICAgICAgICAgIFwiSW5maW5pdHlcIiA6IG5ldyBEYXRlKG9ialtwcm9wXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGM7XG59XG5cbi8qIFNlY3Rpb24gNS40IHBhcnQgMjpcbiAqIFwiKiAgQ29va2llcyB3aXRoIGxvbmdlciBwYXRocyBhcmUgbGlzdGVkIGJlZm9yZSBjb29raWVzIHdpdGhcbiAqICAgICBzaG9ydGVyIHBhdGhzLlxuICpcbiAqICAqICBBbW9uZyBjb29raWVzIHRoYXQgaGF2ZSBlcXVhbC1sZW5ndGggcGF0aCBmaWVsZHMsIGNvb2tpZXMgd2l0aFxuICogICAgIGVhcmxpZXIgY3JlYXRpb24tdGltZXMgYXJlIGxpc3RlZCBiZWZvcmUgY29va2llcyB3aXRoIGxhdGVyXG4gKiAgICAgY3JlYXRpb24tdGltZXMuXCJcbiAqL1xuXG5mdW5jdGlvbiBjb29raWVDb21wYXJlKGEsYikge1xuICB2YXIgY21wID0gMDtcblxuICAvLyBkZXNjZW5kaW5nIGZvciBsZW5ndGg6IGIgQ01QIGFcbiAgdmFyIGFQYXRoTGVuID0gYS5wYXRoID8gYS5wYXRoLmxlbmd0aCA6IDA7XG4gIHZhciBiUGF0aExlbiA9IGIucGF0aCA/IGIucGF0aC5sZW5ndGggOiAwO1xuICBjbXAgPSBiUGF0aExlbiAtIGFQYXRoTGVuO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIC8vIGFzY2VuZGluZyBmb3IgdGltZTogYSBDTVAgYlxuICB2YXIgYVRpbWUgPSBhLmNyZWF0aW9uID8gYS5jcmVhdGlvbi5nZXRUaW1lKCkgOiBNQVhfVElNRTtcbiAgdmFyIGJUaW1lID0gYi5jcmVhdGlvbiA/IGIuY3JlYXRpb24uZ2V0VGltZSgpIDogTUFYX1RJTUU7XG4gIGNtcCA9IGFUaW1lIC0gYlRpbWU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgLy8gYnJlYWsgdGllcyBmb3IgdGhlIHNhbWUgbWlsbGlzZWNvbmQgKHByZWNpc2lvbiBvZiBKYXZhU2NyaXB0J3MgY2xvY2spXG4gIGNtcCA9IGEuY3JlYXRpb25JbmRleCAtIGIuY3JlYXRpb25JbmRleDtcblxuICByZXR1cm4gY21wO1xufVxuXG4vLyBHaXZlcyB0aGUgcGVybXV0YXRpb24gb2YgYWxsIHBvc3NpYmxlIHBhdGhNYXRjaCgpZXMgb2YgYSBnaXZlbiBwYXRoLiBUaGVcbi8vIGFycmF5IGlzIGluIGxvbmdlc3QtdG8tc2hvcnRlc3Qgb3JkZXIuICBIYW5keSBmb3IgaW5kZXhpbmcuXG5mdW5jdGlvbiBwZXJtdXRlUGF0aChwYXRoKSB7XG4gIGlmIChwYXRoID09PSAnLycpIHtcbiAgICByZXR1cm4gWycvJ107XG4gIH1cbiAgaWYgKHBhdGgubGFzdEluZGV4T2YoJy8nKSA9PT0gcGF0aC5sZW5ndGgtMSkge1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLHBhdGgubGVuZ3RoLTEpO1xuICB9XG4gIHZhciBwZXJtdXRhdGlvbnMgPSBbcGF0aF07XG4gIHdoaWxlIChwYXRoLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgbGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIGlmIChsaW5kZXggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCxsaW5kZXgpO1xuICAgIHBlcm11dGF0aW9ucy5wdXNoKHBhdGgpO1xuICB9XG4gIHBlcm11dGF0aW9ucy5wdXNoKCcvJyk7XG4gIHJldHVybiBwZXJtdXRhdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGdldENvb2tpZUNvbnRleHQodXJsKSB7XG4gIGlmICh1cmwgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIC8vIE5PVEU6IGRlY29kZVVSSSB3aWxsIHRocm93IG9uIG1hbGZvcm1lZCBVUklzIChzZWUgR0gtMzIpLlxuICAvLyBUaGVyZWZvcmUsIHdlIHdpbGwganVzdCBza2lwIGRlY29kaW5nIGZvciBzdWNoIFVSSXMuXG4gIHRyeSB7XG4gICAgdXJsID0gZGVjb2RlVVJJKHVybCk7XG4gIH1cbiAgY2F0Y2goZXJyKSB7XG4gICAgLy8gU2lsZW50bHkgc3dhbGxvdyBlcnJvclxuICB9XG5cbiAgcmV0dXJuIHVybFBhcnNlKHVybCk7XG59XG5cbmZ1bmN0aW9uIENvb2tpZShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgIGlmIChDb29raWUucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApICYmXG4gICAgICAgIENvb2tpZS5wcm90b3R5cGVbcHJvcF0gIT09IG9wdGlvbnNbcHJvcF0gJiZcbiAgICAgICAgcHJvcC5zdWJzdHIoMCwxKSAhPT0gJ18nKVxuICAgIHtcbiAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgdGhpcy5jcmVhdGlvbiA9IHRoaXMuY3JlYXRpb24gfHwgbmV3IERhdGUoKTtcblxuICAvLyB1c2VkIHRvIGJyZWFrIGNyZWF0aW9uIHRpZXMgaW4gY29va2llQ29tcGFyZSgpOlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NyZWF0aW9uSW5kZXgnLCB7XG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSwgLy8gaW1wb3J0YW50IGZvciBhc3NlcnQuZGVlcEVxdWFsIGNoZWNrc1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiArK0Nvb2tpZS5jb29raWVzQ3JlYXRlZFxuICB9KTtcbn1cblxuQ29va2llLmNvb2tpZXNDcmVhdGVkID0gMDsgLy8gaW5jcmVtZW50ZWQgZWFjaCB0aW1lIGEgY29va2llIGlzIGNyZWF0ZWRcblxuQ29va2llLnBhcnNlID0gcGFyc2U7XG5Db29raWUuZnJvbUpTT04gPSBmcm9tSlNPTjtcblxuQ29va2llLnByb3RvdHlwZS5rZXkgPSBcIlwiO1xuQ29va2llLnByb3RvdHlwZS52YWx1ZSA9IFwiXCI7XG5cbi8vIHRoZSBvcmRlciBpbiB3aGljaCB0aGUgUkZDIGhhcyB0aGVtOlxuQ29va2llLnByb3RvdHlwZS5leHBpcmVzID0gXCJJbmZpbml0eVwiOyAvLyBjb2VyY2VzIHRvIGxpdGVyYWwgSW5maW5pdHlcbkNvb2tpZS5wcm90b3R5cGUubWF4QWdlID0gbnVsbDsgLy8gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGV4cGlyZXMgZm9yIFRUTFxuQ29va2llLnByb3RvdHlwZS5kb21haW4gPSBudWxsO1xuQ29va2llLnByb3RvdHlwZS5wYXRoID0gbnVsbDtcbkNvb2tpZS5wcm90b3R5cGUuc2VjdXJlID0gZmFsc2U7XG5Db29raWUucHJvdG90eXBlLmh0dHBPbmx5ID0gZmFsc2U7XG5Db29raWUucHJvdG90eXBlLmV4dGVuc2lvbnMgPSBudWxsO1xuXG4vLyBzZXQgYnkgdGhlIENvb2tpZUphcjpcbkNvb2tpZS5wcm90b3R5cGUuaG9zdE9ubHkgPSBudWxsOyAvLyBib29sZWFuIHdoZW4gc2V0XG5Db29raWUucHJvdG90eXBlLnBhdGhJc0RlZmF1bHQgPSBudWxsOyAvLyBib29sZWFuIHdoZW4gc2V0XG5Db29raWUucHJvdG90eXBlLmNyZWF0aW9uID0gbnVsbDsgLy8gRGF0ZSB3aGVuIHNldDsgZGVmYXVsdGVkIGJ5IENvb2tpZS5wYXJzZVxuQ29va2llLnByb3RvdHlwZS5sYXN0QWNjZXNzZWQgPSBudWxsOyAvLyBEYXRlIHdoZW4gc2V0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29va2llLnByb3RvdHlwZSwgJ2NyZWF0aW9uSW5kZXgnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZTogMFxufSk7XG5cbkNvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoQ29va2llLnByb3RvdHlwZSlcbiAgLmZpbHRlcihmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuICEoXG4gICAgICBDb29raWUucHJvdG90eXBlW3Byb3BdIGluc3RhbmNlb2YgRnVuY3Rpb24gfHxcbiAgICAgIHByb3AgPT09ICdjcmVhdGlvbkluZGV4JyB8fFxuICAgICAgcHJvcC5zdWJzdHIoMCwxKSA9PT0gJ18nXG4gICAgKTtcbiAgfSk7XG5cbkNvb2tpZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICByZXR1cm4gJ0Nvb2tpZT1cIicrdGhpcy50b1N0cmluZygpICtcbiAgICAnOyBob3N0T25seT0nKyh0aGlzLmhvc3RPbmx5ICE9IG51bGwgPyB0aGlzLmhvc3RPbmx5IDogJz8nKSArXG4gICAgJzsgYUFnZT0nKyh0aGlzLmxhc3RBY2Nlc3NlZCA/IChub3ctdGhpcy5sYXN0QWNjZXNzZWQuZ2V0VGltZSgpKSsnbXMnIDogJz8nKSArXG4gICAgJzsgY0FnZT0nKyh0aGlzLmNyZWF0aW9uID8gKG5vdy10aGlzLmNyZWF0aW9uLmdldFRpbWUoKSkrJ21zJyA6ICc/JykgK1xuICAgICdcIic7XG59O1xuXG4vLyBVc2UgdGhlIG5ldyBjdXN0b20gaW5zcGVjdGlvbiBzeW1ib2wgdG8gYWRkIHRoZSBjdXN0b20gaW5zcGVjdCBmdW5jdGlvbiBpZlxuLy8gYXZhaWxhYmxlLlxuaWYgKHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgQ29va2llLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IENvb2tpZS5wcm90b3R5cGUuaW5zcGVjdDtcbn1cblxuQ29va2llLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIHZhciBwcm9wcyA9IENvb2tpZS5zZXJpYWxpemFibGVQcm9wZXJ0aWVzO1xuICBmb3IgKHZhciBpPTA7IGk8cHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIGlmICh0aGlzW3Byb3BdID09PSBDb29raWUucHJvdG90eXBlW3Byb3BdKSB7XG4gICAgICBjb250aW51ZTsgLy8gbGVhdmUgYXMgcHJvdG90eXBlIGRlZmF1bHRcbiAgICB9XG5cbiAgICBpZiAocHJvcCA9PT0gJ2V4cGlyZXMnIHx8XG4gICAgICAgIHByb3AgPT09ICdjcmVhdGlvbicgfHxcbiAgICAgICAgcHJvcCA9PT0gJ2xhc3RBY2Nlc3NlZCcpXG4gICAge1xuICAgICAgaWYgKHRoaXNbcHJvcF0gPT09IG51bGwpIHtcbiAgICAgICAgb2JqW3Byb3BdID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtwcm9wXSA9IHRoaXNbcHJvcF0gPT0gXCJJbmZpbml0eVwiID8gLy8gaW50ZW50aW9uYWxseSBub3QgPT09XG4gICAgICAgICAgXCJJbmZpbml0eVwiIDogdGhpc1twcm9wXS50b0lTT1N0cmluZygpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ21heEFnZScpIHtcbiAgICAgIGlmICh0aGlzW3Byb3BdICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGFnYWluLCBpbnRlbnRpb25hbGx5IG5vdCA9PT1cbiAgICAgICAgb2JqW3Byb3BdID0gKHRoaXNbcHJvcF0gPT0gSW5maW5pdHkgfHwgdGhpc1twcm9wXSA9PSAtSW5maW5pdHkpID9cbiAgICAgICAgICB0aGlzW3Byb3BdLnRvU3RyaW5nKCkgOiB0aGlzW3Byb3BdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpc1twcm9wXSAhPT0gQ29va2llLnByb3RvdHlwZVtwcm9wXSkge1xuICAgICAgICBvYmpbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5Db29raWUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmcm9tSlNPTih0aGlzLnRvSlNPTigpKTtcbn07XG5cbkNvb2tpZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgaWYgKCFDT09LSUVfT0NURVRTLnRlc3QodGhpcy52YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMuZXhwaXJlcyAhPSBJbmZpbml0eSAmJiAhKHRoaXMuZXhwaXJlcyBpbnN0YW5jZW9mIERhdGUpICYmICFwYXJzZURhdGUodGhpcy5leHBpcmVzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCAmJiB0aGlzLm1heEFnZSA8PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBcIk1heC1BZ2U9XCIgbm9uLXplcm8tZGlnaXQgKkRJR0lUXG4gIH1cbiAgaWYgKHRoaXMucGF0aCAhPSBudWxsICYmICFQQVRIX1ZBTFVFLnRlc3QodGhpcy5wYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjZG9tYWluID0gdGhpcy5jZG9tYWluKCk7XG4gIGlmIChjZG9tYWluKSB7XG4gICAgaWYgKGNkb21haW4ubWF0Y2goL1xcLiQvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTNC4xLjIuMyBzdWdnZXN0cyB0aGF0IHRoaXMgaXMgYmFkLiBkb21haW5NYXRjaCgpIHRlc3RzIGNvbmZpcm0gdGhpc1xuICAgIH1cbiAgICB2YXIgc3VmZml4ID0gcHVic3VmZml4LmdldFB1YmxpY1N1ZmZpeChjZG9tYWluKTtcbiAgICBpZiAoc3VmZml4ID09IG51bGwpIHsgLy8gaXQncyBhIHB1YmxpYyBzdWZmaXhcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5Db29raWUucHJvdG90eXBlLnNldEV4cGlyZXMgPSBmdW5jdGlvbiBzZXRFeHBpcmVzKGV4cCkge1xuICBpZiAoZXhwIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHRoaXMuZXhwaXJlcyA9IGV4cDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmV4cGlyZXMgPSBwYXJzZURhdGUoZXhwKSB8fCBcIkluZmluaXR5XCI7XG4gIH1cbn07XG5cbkNvb2tpZS5wcm90b3R5cGUuc2V0TWF4QWdlID0gZnVuY3Rpb24gc2V0TWF4QWdlKGFnZSkge1xuICBpZiAoYWdlID09PSBJbmZpbml0eSB8fCBhZ2UgPT09IC1JbmZpbml0eSkge1xuICAgIHRoaXMubWF4QWdlID0gYWdlLnRvU3RyaW5nKCk7IC8vIHNvIEpTT04uc3RyaW5naWZ5KCkgd29ya3NcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1heEFnZSA9IGFnZTtcbiAgfVxufTtcblxuLy8gZ2l2ZXMgQ29va2llIGhlYWRlciBmb3JtYXRcbkNvb2tpZS5wcm90b3R5cGUuY29va2llU3RyaW5nID0gZnVuY3Rpb24gY29va2llU3RyaW5nKCkge1xuICB2YXIgdmFsID0gdGhpcy52YWx1ZTtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgdmFsID0gJyc7XG4gIH1cbiAgaWYgKHRoaXMua2V5ID09PSAnJykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgcmV0dXJuIHRoaXMua2V5Kyc9Jyt2YWw7XG59O1xuXG4vLyBnaXZlcyBTZXQtQ29va2llIGhlYWRlciBmb3JtYXRcbkNvb2tpZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IHRoaXMuY29va2llU3RyaW5nKCk7XG5cbiAgaWYgKHRoaXMuZXhwaXJlcyAhPSBJbmZpbml0eSkge1xuICAgIGlmICh0aGlzLmV4cGlyZXMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBzdHIgKz0gJzsgRXhwaXJlcz0nK2Zvcm1hdERhdGUodGhpcy5leHBpcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICc7IEV4cGlyZXM9Jyt0aGlzLmV4cGlyZXM7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMubWF4QWdlICE9IG51bGwgJiYgdGhpcy5tYXhBZ2UgIT0gSW5maW5pdHkpIHtcbiAgICBzdHIgKz0gJzsgTWF4LUFnZT0nK3RoaXMubWF4QWdlO1xuICB9XG5cbiAgaWYgKHRoaXMuZG9tYWluICYmICF0aGlzLmhvc3RPbmx5KSB7XG4gICAgc3RyICs9ICc7IERvbWFpbj0nK3RoaXMuZG9tYWluO1xuICB9XG4gIGlmICh0aGlzLnBhdGgpIHtcbiAgICBzdHIgKz0gJzsgUGF0aD0nK3RoaXMucGF0aDtcbiAgfVxuXG4gIGlmICh0aGlzLnNlY3VyZSkge1xuICAgIHN0ciArPSAnOyBTZWN1cmUnO1xuICB9XG4gIGlmICh0aGlzLmh0dHBPbmx5KSB7XG4gICAgc3RyICs9ICc7IEh0dHBPbmx5JztcbiAgfVxuICBpZiAodGhpcy5leHRlbnNpb25zKSB7XG4gICAgdGhpcy5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24oZXh0KSB7XG4gICAgICBzdHIgKz0gJzsgJytleHQ7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLy8gVFRMKCkgcGFydGlhbGx5IHJlcGxhY2VzIHRoZSBcImV4cGlyeS10aW1lXCIgcGFydHMgb2YgUzUuMyBzdGVwIDMgKHNldENvb2tpZSgpXG4vLyBlbHNld2hlcmUpXG4vLyBTNS4zIHNheXMgdG8gZ2l2ZSB0aGUgXCJsYXRlc3QgcmVwcmVzZW50YWJsZSBkYXRlXCIgZm9yIHdoaWNoIHdlIHVzZSBJbmZpbml0eVxuLy8gRm9yIFwiZXhwaXJlZFwiIHdlIHVzZSAwXG5Db29raWUucHJvdG90eXBlLlRUTCA9IGZ1bmN0aW9uIFRUTChub3cpIHtcbiAgLyogUkZDNjI2NSBTNC4xLjIuMiBJZiBhIGNvb2tpZSBoYXMgYm90aCB0aGUgTWF4LUFnZSBhbmQgdGhlIEV4cGlyZXNcbiAgICogYXR0cmlidXRlLCB0aGUgTWF4LUFnZSBhdHRyaWJ1dGUgaGFzIHByZWNlZGVuY2UgYW5kIGNvbnRyb2xzIHRoZVxuICAgKiBleHBpcmF0aW9uIGRhdGUgb2YgdGhlIGNvb2tpZS5cbiAgICogKENvbmN1cnMgd2l0aCBTNS4zIHN0ZXAgMylcbiAgICovXG4gIGlmICh0aGlzLm1heEFnZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4QWdlPD0wID8gMCA6IHRoaXMubWF4QWdlKjEwMDA7XG4gIH1cblxuICB2YXIgZXhwaXJlcyA9IHRoaXMuZXhwaXJlcztcbiAgaWYgKGV4cGlyZXMgIT0gSW5maW5pdHkpIHtcbiAgICBpZiAoIShleHBpcmVzIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIGV4cGlyZXMgPSBwYXJzZURhdGUoZXhwaXJlcykgfHwgSW5maW5pdHk7XG4gICAgfVxuXG4gICAgaWYgKGV4cGlyZXMgPT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwaXJlcy5nZXRUaW1lKCkgLSAobm93IHx8IERhdGUubm93KCkpO1xuICB9XG5cbiAgcmV0dXJuIEluZmluaXR5O1xufTtcblxuLy8gZXhwaXJ5VGltZSgpIHJlcGxhY2VzIHRoZSBcImV4cGlyeS10aW1lXCIgcGFydHMgb2YgUzUuMyBzdGVwIDMgKHNldENvb2tpZSgpXG4vLyBlbHNld2hlcmUpXG5Db29raWUucHJvdG90eXBlLmV4cGlyeVRpbWUgPSBmdW5jdGlvbiBleHBpcnlUaW1lKG5vdykge1xuICBpZiAodGhpcy5tYXhBZ2UgIT0gbnVsbCkge1xuICAgIHZhciByZWxhdGl2ZVRvID0gbm93IHx8IHRoaXMuY3JlYXRpb24gfHwgbmV3IERhdGUoKTtcbiAgICB2YXIgYWdlID0gKHRoaXMubWF4QWdlIDw9IDApID8gLUluZmluaXR5IDogdGhpcy5tYXhBZ2UqMTAwMDtcbiAgICByZXR1cm4gcmVsYXRpdmVUby5nZXRUaW1lKCkgKyBhZ2U7XG4gIH1cblxuICBpZiAodGhpcy5leHBpcmVzID09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIHJldHVybiB0aGlzLmV4cGlyZXMuZ2V0VGltZSgpO1xufTtcblxuLy8gZXhwaXJ5RGF0ZSgpIHJlcGxhY2VzIHRoZSBcImV4cGlyeS10aW1lXCIgcGFydHMgb2YgUzUuMyBzdGVwIDMgKHNldENvb2tpZSgpXG4vLyBlbHNld2hlcmUpLCBleGNlcHQgaXQgcmV0dXJucyBhIERhdGVcbkNvb2tpZS5wcm90b3R5cGUuZXhwaXJ5RGF0ZSA9IGZ1bmN0aW9uIGV4cGlyeURhdGUobm93KSB7XG4gIHZhciBtaWxsaXNlYyA9IHRoaXMuZXhwaXJ5VGltZShub3cpO1xuICBpZiAobWlsbGlzZWMgPT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTUFYX1RJTUUpO1xuICB9IGVsc2UgaWYgKG1pbGxpc2VjID09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShNSU5fVElNRSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKG1pbGxpc2VjKTtcbiAgfVxufTtcblxuLy8gVGhpcyByZXBsYWNlcyB0aGUgXCJwZXJzaXN0ZW50LWZsYWdcIiBwYXJ0cyBvZiBTNS4zIHN0ZXAgM1xuQ29va2llLnByb3RvdHlwZS5pc1BlcnNpc3RlbnQgPSBmdW5jdGlvbiBpc1BlcnNpc3RlbnQoKSB7XG4gIHJldHVybiAodGhpcy5tYXhBZ2UgIT0gbnVsbCB8fCB0aGlzLmV4cGlyZXMgIT0gSW5maW5pdHkpO1xufTtcblxuLy8gTW9zdGx5IFM1LjEuMiBhbmQgUzUuMi4zOlxuQ29va2llLnByb3RvdHlwZS5jZG9tYWluID1cbkNvb2tpZS5wcm90b3R5cGUuY2Fub25pY2FsaXplZERvbWFpbiA9IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZWREb21haW4oKSB7XG4gIGlmICh0aGlzLmRvbWFpbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNhbm9uaWNhbERvbWFpbih0aGlzLmRvbWFpbik7XG59O1xuXG5mdW5jdGlvbiBDb29raWVKYXIoc3RvcmUsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIikge1xuICAgIG9wdGlvbnMgPSB7cmVqZWN0UHVibGljU3VmZml4ZXM6IG9wdGlvbnN9O1xuICB9IGVsc2UgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZWplY3RQdWJsaWNTdWZmaXhlcyAhPSBudWxsKSB7XG4gICAgdGhpcy5yZWplY3RQdWJsaWNTdWZmaXhlcyA9IG9wdGlvbnMucmVqZWN0UHVibGljU3VmZml4ZXM7XG4gIH1cbiAgaWYgKG9wdGlvbnMubG9vc2VNb2RlICE9IG51bGwpIHtcbiAgICB0aGlzLmVuYWJsZUxvb3NlTW9kZSA9IG9wdGlvbnMubG9vc2VNb2RlO1xuICB9XG5cbiAgaWYgKCFzdG9yZSkge1xuICAgIHN0b3JlID0gbmV3IE1lbW9yeUNvb2tpZVN0b3JlKCk7XG4gIH1cbiAgdGhpcy5zdG9yZSA9IHN0b3JlO1xufVxuQ29va2llSmFyLnByb3RvdHlwZS5zdG9yZSA9IG51bGw7XG5Db29raWVKYXIucHJvdG90eXBlLnJlamVjdFB1YmxpY1N1ZmZpeGVzID0gdHJ1ZTtcbkNvb2tpZUphci5wcm90b3R5cGUuZW5hYmxlTG9vc2VNb2RlID0gZmFsc2U7XG52YXIgQ0FOX0JFX1NZTkMgPSBbXTtcblxuQ0FOX0JFX1NZTkMucHVzaCgnc2V0Q29va2llJyk7XG5Db29raWVKYXIucHJvdG90eXBlLnNldENvb2tpZSA9IGZ1bmN0aW9uKGNvb2tpZSwgdXJsLCBvcHRpb25zLCBjYikge1xuICB2YXIgZXJyO1xuICB2YXIgY29udGV4dCA9IGdldENvb2tpZUNvbnRleHQodXJsKTtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIGNiID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgaG9zdCA9IGNhbm9uaWNhbERvbWFpbihjb250ZXh0Lmhvc3RuYW1lKTtcbiAgdmFyIGxvb3NlID0gdGhpcy5lbmFibGVMb29zZU1vZGU7XG4gIGlmIChvcHRpb25zLmxvb3NlICE9IG51bGwpIHtcbiAgICBsb29zZSA9IG9wdGlvbnMubG9vc2U7XG4gIH1cblxuICAvLyBTNS4zIHN0ZXAgMVxuICBpZiAoIShjb29raWUgaW5zdGFuY2VvZiBDb29raWUpKSB7XG4gICAgY29va2llID0gQ29va2llLnBhcnNlKGNvb2tpZSwgeyBsb29zZTogbG9vc2UgfSk7XG4gIH1cbiAgaWYgKCFjb29raWUpIHtcbiAgICBlcnIgPSBuZXcgRXJyb3IoXCJDb29raWUgZmFpbGVkIHRvIHBhcnNlXCIpO1xuICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gIH1cblxuICAvLyBTNS4zIHN0ZXAgMlxuICB2YXIgbm93ID0gb3B0aW9ucy5ub3cgfHwgbmV3IERhdGUoKTsgLy8gd2lsbCBhc3NpZ24gbGF0ZXIgdG8gc2F2ZSBlZmZvcnQgaW4gdGhlIGZhY2Ugb2YgZXJyb3JzXG5cbiAgLy8gUzUuMyBzdGVwIDM6IE5PT1A7IHBlcnNpc3RlbnQtZmxhZyBhbmQgZXhwaXJ5LXRpbWUgaXMgaGFuZGxlZCBieSBnZXRDb29raWUoKVxuXG4gIC8vIFM1LjMgc3RlcCA0OiBOT09QOyBkb21haW4gaXMgbnVsbCBieSBkZWZhdWx0XG5cbiAgLy8gUzUuMyBzdGVwIDU6IHB1YmxpYyBzdWZmaXhlc1xuICBpZiAodGhpcy5yZWplY3RQdWJsaWNTdWZmaXhlcyAmJiBjb29raWUuZG9tYWluKSB7XG4gICAgdmFyIHN1ZmZpeCA9IHB1YnN1ZmZpeC5nZXRQdWJsaWNTdWZmaXgoY29va2llLmNkb21haW4oKSk7XG4gICAgaWYgKHN1ZmZpeCA9PSBudWxsKSB7IC8vIGUuZy4gXCJjb21cIlxuICAgICAgZXJyID0gbmV3IEVycm9yKFwiQ29va2llIGhhcyBkb21haW4gc2V0IHRvIGEgcHVibGljIHN1ZmZpeFwiKTtcbiAgICAgIHJldHVybiBjYihvcHRpb25zLmlnbm9yZUVycm9yID8gbnVsbCA6IGVycik7XG4gICAgfVxuICB9XG5cbiAgLy8gUzUuMyBzdGVwIDY6XG4gIGlmIChjb29raWUuZG9tYWluKSB7XG4gICAgaWYgKCFkb21haW5NYXRjaChob3N0LCBjb29raWUuY2RvbWFpbigpLCBmYWxzZSkpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcihcIkNvb2tpZSBub3QgaW4gdGhpcyBob3N0J3MgZG9tYWluLiBDb29raWU6XCIrY29va2llLmNkb21haW4oKStcIiBSZXF1ZXN0OlwiK2hvc3QpO1xuICAgICAgcmV0dXJuIGNiKG9wdGlvbnMuaWdub3JlRXJyb3IgPyBudWxsIDogZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoY29va2llLmhvc3RPbmx5ID09IG51bGwpIHsgLy8gZG9uJ3QgcmVzZXQgaWYgYWxyZWFkeSBzZXRcbiAgICAgIGNvb2tpZS5ob3N0T25seSA9IGZhbHNlO1xuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIGNvb2tpZS5ob3N0T25seSA9IHRydWU7XG4gICAgY29va2llLmRvbWFpbiA9IGhvc3Q7XG4gIH1cblxuICAvL1M1LjIuNCBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGVtcHR5IG9yIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gIC8vYXR0cmlidXRlLXZhbHVlIGlzIG5vdCAleDJGIChcIi9cIik6XG4gIC8vTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBkZWZhdWx0LXBhdGguXG4gIGlmICghY29va2llLnBhdGggfHwgY29va2llLnBhdGhbMF0gIT09ICcvJykge1xuICAgIGNvb2tpZS5wYXRoID0gZGVmYXVsdFBhdGgoY29udGV4dC5wYXRobmFtZSk7XG4gICAgY29va2llLnBhdGhJc0RlZmF1bHQgPSB0cnVlO1xuICB9XG5cbiAgLy8gUzUuMyBzdGVwIDg6IE5PT1A7IHNlY3VyZSBhdHRyaWJ1dGVcbiAgLy8gUzUuMyBzdGVwIDk6IE5PT1A7IGh0dHBPbmx5IGF0dHJpYnV0ZVxuXG4gIC8vIFM1LjMgc3RlcCAxMFxuICBpZiAob3B0aW9ucy5odHRwID09PSBmYWxzZSAmJiBjb29raWUuaHR0cE9ubHkpIHtcbiAgICBlcnIgPSBuZXcgRXJyb3IoXCJDb29raWUgaXMgSHR0cE9ubHkgYW5kIHRoaXMgaXNuJ3QgYW4gSFRUUCBBUElcIik7XG4gICAgcmV0dXJuIGNiKG9wdGlvbnMuaWdub3JlRXJyb3IgPyBudWxsIDogZXJyKTtcbiAgfVxuXG4gIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG5cbiAgaWYgKCFzdG9yZS51cGRhdGVDb29raWUpIHtcbiAgICBzdG9yZS51cGRhdGVDb29raWUgPSBmdW5jdGlvbihvbGRDb29raWUsIG5ld0Nvb2tpZSwgY2IpIHtcbiAgICAgIHRoaXMucHV0Q29va2llKG5ld0Nvb2tpZSwgY2IpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoQ29va2llKGVyciwgb2xkQ29va2llKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihudWxsLCBjb29raWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob2xkQ29va2llKSB7XG4gICAgICAvLyBTNS4zIHN0ZXAgMTEgLSBcIklmIHRoZSBjb29raWUgc3RvcmUgY29udGFpbnMgYSBjb29raWUgd2l0aCB0aGUgc2FtZSBuYW1lLFxuICAgICAgLy8gZG9tYWluLCBhbmQgcGF0aCBhcyB0aGUgbmV3bHkgY3JlYXRlZCBjb29raWU6XCJcbiAgICAgIGlmIChvcHRpb25zLmh0dHAgPT09IGZhbHNlICYmIG9sZENvb2tpZS5odHRwT25seSkgeyAvLyBzdGVwIDExLjJcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKFwib2xkIENvb2tpZSBpcyBIdHRwT25seSBhbmQgdGhpcyBpc24ndCBhbiBIVFRQIEFQSVwiKTtcbiAgICAgICAgcmV0dXJuIGNiKG9wdGlvbnMuaWdub3JlRXJyb3IgPyBudWxsIDogZXJyKTtcbiAgICAgIH1cbiAgICAgIGNvb2tpZS5jcmVhdGlvbiA9IG9sZENvb2tpZS5jcmVhdGlvbjsgLy8gc3RlcCAxMS4zXG4gICAgICBjb29raWUuY3JlYXRpb25JbmRleCA9IG9sZENvb2tpZS5jcmVhdGlvbkluZGV4OyAvLyBwcmVzZXJ2ZSB0aWUtYnJlYWtlclxuICAgICAgY29va2llLmxhc3RBY2Nlc3NlZCA9IG5vdztcbiAgICAgIC8vIFN0ZXAgMTEuNCAoZGVsZXRlIGNvb2tpZSkgaXMgaW1wbGllZCBieSBqdXN0IHNldHRpbmcgdGhlIG5ldyBvbmU6XG4gICAgICBzdG9yZS51cGRhdGVDb29raWUob2xkQ29va2llLCBjb29raWUsIG5leHQpOyAvLyBzdGVwIDEyXG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29va2llLmNyZWF0aW9uID0gY29va2llLmxhc3RBY2Nlc3NlZCA9IG5vdztcbiAgICAgIHN0b3JlLnB1dENvb2tpZShjb29raWUsIG5leHQpOyAvLyBzdGVwIDEyXG4gICAgfVxuICB9XG5cbiAgc3RvcmUuZmluZENvb2tpZShjb29raWUuZG9tYWluLCBjb29raWUucGF0aCwgY29va2llLmtleSwgd2l0aENvb2tpZSk7XG59O1xuXG4vLyBSRkM2MzY1IFM1LjRcbkNBTl9CRV9TWU5DLnB1c2goJ2dldENvb2tpZXMnKTtcbkNvb2tpZUphci5wcm90b3R5cGUuZ2V0Q29va2llcyA9IGZ1bmN0aW9uKHVybCwgb3B0aW9ucywgY2IpIHtcbiAgdmFyIGNvbnRleHQgPSBnZXRDb29raWVDb250ZXh0KHVybCk7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICBjYiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIGhvc3QgPSBjYW5vbmljYWxEb21haW4oY29udGV4dC5ob3N0bmFtZSk7XG4gIHZhciBwYXRoID0gY29udGV4dC5wYXRobmFtZSB8fCAnLyc7XG5cbiAgdmFyIHNlY3VyZSA9IG9wdGlvbnMuc2VjdXJlO1xuICBpZiAoc2VjdXJlID09IG51bGwgJiYgY29udGV4dC5wcm90b2NvbCAmJlxuICAgICAgKGNvbnRleHQucHJvdG9jb2wgPT0gJ2h0dHBzOicgfHwgY29udGV4dC5wcm90b2NvbCA9PSAnd3NzOicpKVxuICB7XG4gICAgc2VjdXJlID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBodHRwID0gb3B0aW9ucy5odHRwO1xuICBpZiAoaHR0cCA9PSBudWxsKSB7XG4gICAgaHR0cCA9IHRydWU7XG4gIH1cblxuICB2YXIgbm93ID0gb3B0aW9ucy5ub3cgfHwgRGF0ZS5ub3coKTtcbiAgdmFyIGV4cGlyZUNoZWNrID0gb3B0aW9ucy5leHBpcmUgIT09IGZhbHNlO1xuICB2YXIgYWxsUGF0aHMgPSAhIW9wdGlvbnMuYWxsUGF0aHM7XG4gIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG5cbiAgZnVuY3Rpb24gbWF0Y2hpbmdDb29raWUoYykge1xuICAgIC8vIFwiRWl0aGVyOlxuICAgIC8vICAgVGhlIGNvb2tpZSdzIGhvc3Qtb25seS1mbGFnIGlzIHRydWUgYW5kIHRoZSBjYW5vbmljYWxpemVkXG4gICAgLy8gICByZXF1ZXN0LWhvc3QgaXMgaWRlbnRpY2FsIHRvIHRoZSBjb29raWUncyBkb21haW4uXG4gICAgLy8gT3I6XG4gICAgLy8gICBUaGUgY29va2llJ3MgaG9zdC1vbmx5LWZsYWcgaXMgZmFsc2UgYW5kIHRoZSBjYW5vbmljYWxpemVkXG4gICAgLy8gICByZXF1ZXN0LWhvc3QgZG9tYWluLW1hdGNoZXMgdGhlIGNvb2tpZSdzIGRvbWFpbi5cIlxuICAgIGlmIChjLmhvc3RPbmx5KSB7XG4gICAgICBpZiAoYy5kb21haW4gIT0gaG9zdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZG9tYWluTWF0Y2goaG9zdCwgYy5kb21haW4sIGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gXCJUaGUgcmVxdWVzdC11cmkncyBwYXRoIHBhdGgtbWF0Y2hlcyB0aGUgY29va2llJ3MgcGF0aC5cIlxuICAgIGlmICghYWxsUGF0aHMgJiYgIXBhdGhNYXRjaChwYXRoLCBjLnBhdGgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gXCJJZiB0aGUgY29va2llJ3Mgc2VjdXJlLW9ubHktZmxhZyBpcyB0cnVlLCB0aGVuIHRoZSByZXF1ZXN0LXVyaSdzXG4gICAgLy8gc2NoZW1lIG11c3QgZGVub3RlIGEgXCJzZWN1cmVcIiBwcm90b2NvbFwiXG4gICAgaWYgKGMuc2VjdXJlICYmICFzZWN1cmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBcIklmIHRoZSBjb29raWUncyBodHRwLW9ubHktZmxhZyBpcyB0cnVlLCB0aGVuIGV4Y2x1ZGUgdGhlIGNvb2tpZSBpZiB0aGVcbiAgICAvLyBjb29raWUtc3RyaW5nIGlzIGJlaW5nIGdlbmVyYXRlZCBmb3IgYSBcIm5vbi1IVFRQXCIgQVBJXCJcbiAgICBpZiAoYy5odHRwT25seSAmJiAhaHR0cCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGRlZmVycmVkIGZyb20gUzUuM1xuICAgIC8vIG5vbi1SRkM6IGFsbG93IHJldGVudGlvbiBvZiBleHBpcmVkIGNvb2tpZXMgYnkgY2hvaWNlXG4gICAgaWYgKGV4cGlyZUNoZWNrICYmIGMuZXhwaXJ5VGltZSgpIDw9IG5vdykge1xuICAgICAgc3RvcmUucmVtb3ZlQ29va2llKGMuZG9tYWluLCBjLnBhdGgsIGMua2V5LCBmdW5jdGlvbigpe30pOyAvLyByZXN1bHQgaWdub3JlZFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RvcmUuZmluZENvb2tpZXMoaG9zdCwgYWxsUGF0aHMgPyBudWxsIDogcGF0aCwgZnVuY3Rpb24oZXJyLGNvb2tpZXMpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG5cbiAgICBjb29raWVzID0gY29va2llcy5maWx0ZXIobWF0Y2hpbmdDb29raWUpO1xuXG4gICAgLy8gc29ydGluZyBvZiBTNS40IHBhcnQgMlxuICAgIGlmIChvcHRpb25zLnNvcnQgIT09IGZhbHNlKSB7XG4gICAgICBjb29raWVzID0gY29va2llcy5zb3J0KGNvb2tpZUNvbXBhcmUpO1xuICAgIH1cblxuICAgIC8vIFM1LjQgcGFydCAzXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgY29va2llcy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgIGMubGFzdEFjY2Vzc2VkID0gbm93O1xuICAgIH0pO1xuICAgIC8vIFRPRE8gcGVyc2lzdCBsYXN0QWNjZXNzZWRcblxuICAgIGNiKG51bGwsY29va2llcyk7XG4gIH0pO1xufTtcblxuQ0FOX0JFX1NZTkMucHVzaCgnZ2V0Q29va2llU3RyaW5nJyk7XG5Db29raWVKYXIucHJvdG90eXBlLmdldENvb2tpZVN0cmluZyA9IGZ1bmN0aW9uKC8qLi4uLCBjYiovKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApO1xuICB2YXIgY2IgPSBhcmdzLnBvcCgpO1xuICB2YXIgbmV4dCA9IGZ1bmN0aW9uKGVycixjb29raWVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IobnVsbCwgY29va2llc1xuICAgICAgICAuc29ydChjb29raWVDb21wYXJlKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKGMpe1xuICAgICAgICAgIHJldHVybiBjLmNvb2tpZVN0cmluZygpO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignOyAnKSk7XG4gICAgfVxuICB9O1xuICBhcmdzLnB1c2gobmV4dCk7XG4gIHRoaXMuZ2V0Q29va2llcy5hcHBseSh0aGlzLGFyZ3MpO1xufTtcblxuQ0FOX0JFX1NZTkMucHVzaCgnZ2V0U2V0Q29va2llU3RyaW5ncycpO1xuQ29va2llSmFyLnByb3RvdHlwZS5nZXRTZXRDb29raWVTdHJpbmdzID0gZnVuY3Rpb24oLyouLi4sIGNiKi8pIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7XG4gIHZhciBjYiA9IGFyZ3MucG9wKCk7XG4gIHZhciBuZXh0ID0gZnVuY3Rpb24oZXJyLGNvb2tpZXMpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYihudWxsLCBjb29raWVzLm1hcChmdW5jdGlvbihjKXtcbiAgICAgICAgcmV0dXJuIGMudG9TdHJpbmcoKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG4gIGFyZ3MucHVzaChuZXh0KTtcbiAgdGhpcy5nZXRDb29raWVzLmFwcGx5KHRoaXMsYXJncyk7XG59O1xuXG5DQU5fQkVfU1lOQy5wdXNoKCdzZXJpYWxpemUnKTtcbkNvb2tpZUphci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24oY2IpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLnN0b3JlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmICh0eXBlID09PSAnT2JqZWN0Jykge1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG5cbiAgLy8gdXBkYXRlIFJFQURNRS5tZCBcIlNlcmlhbGl6YXRpb24gRm9ybWF0XCIgaWYgeW91IGNoYW5nZSB0aGlzLCBwbGVhc2UhXG4gIHZhciBzZXJpYWxpemVkID0ge1xuICAgIC8vIFRoZSB2ZXJzaW9uIG9mIHRvdWdoLWNvb2tpZSB0aGF0IHNlcmlhbGl6ZWQgdGhpcyBqYXIuIEdlbmVyYWxseSBhIGdvb2RcbiAgICAvLyBwcmFjdGljZSBzaW5jZSBmdXR1cmUgdmVyc2lvbnMgY2FuIG1ha2UgZGF0YSBpbXBvcnQgZGVjaXNpb25zIGJhc2VkIG9uXG4gICAgLy8ga25vd24gcGFzdCBiZWhhdmlvci4gV2hlbi9pZiB0aGlzIG1hdHRlcnMsIHVzZSBgc2VtdmVyYC5cbiAgICB2ZXJzaW9uOiAndG91Z2gtY29va2llQCcrVkVSU0lPTixcblxuICAgIC8vIGFkZCB0aGUgc3RvcmUgdHlwZSwgdG8gbWFrZSBodW1hbnMgaGFwcHk6XG4gICAgc3RvcmVUeXBlOiB0eXBlLFxuXG4gICAgLy8gQ29va2llSmFyIGNvbmZpZ3VyYXRpb246XG4gICAgcmVqZWN0UHVibGljU3VmZml4ZXM6ICEhdGhpcy5yZWplY3RQdWJsaWNTdWZmaXhlcyxcblxuICAgIC8vIHRoaXMgZ2V0cyBmaWxsZWQgZnJvbSBnZXRBbGxDb29raWVzOlxuICAgIGNvb2tpZXM6IFtdXG4gIH07XG5cbiAgaWYgKCEodGhpcy5zdG9yZS5nZXRBbGxDb29raWVzICYmXG4gICAgICAgIHR5cGVvZiB0aGlzLnN0b3JlLmdldEFsbENvb2tpZXMgPT09ICdmdW5jdGlvbicpKVxuICB7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcignc3RvcmUgZG9lcyBub3Qgc3VwcG9ydCBnZXRBbGxDb29raWVzIGFuZCBjYW5ub3QgYmUgc2VyaWFsaXplZCcpKTtcbiAgfVxuXG4gIHRoaXMuc3RvcmUuZ2V0QWxsQ29va2llcyhmdW5jdGlvbihlcnIsY29va2llcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpO1xuICAgIH1cblxuICAgIHNlcmlhbGl6ZWQuY29va2llcyA9IGNvb2tpZXMubWFwKGZ1bmN0aW9uKGNvb2tpZSkge1xuICAgICAgLy8gY29udmVydCB0byBzZXJpYWxpemVkICdyYXcnIGNvb2tpZXNcbiAgICAgIGNvb2tpZSA9IChjb29raWUgaW5zdGFuY2VvZiBDb29raWUpID8gY29va2llLnRvSlNPTigpIDogY29va2llO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIGluZGV4IHNvIG5ldyBvbmVzIGdldCBhc3NpZ25lZCBkdXJpbmcgZGVzZXJpYWxpemF0aW9uXG4gICAgICBkZWxldGUgY29va2llLmNyZWF0aW9uSW5kZXg7XG5cbiAgICAgIHJldHVybiBjb29raWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2IobnVsbCwgc2VyaWFsaXplZCk7XG4gIH0pO1xufTtcblxuLy8gd2VsbC1rbm93biBuYW1lIHRoYXQgSlNPTi5zdHJpbmdpZnkgY2FsbHNcbkNvb2tpZUphci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNlcmlhbGl6ZVN5bmMoKTtcbn07XG5cbi8vIHVzZSB0aGUgY2xhc3MgbWV0aG9kIENvb2tpZUphci5kZXNlcmlhbGl6ZSBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBkaXJlY3RseVxuQ0FOX0JFX1NZTkMucHVzaCgnX2ltcG9ydENvb2tpZXMnKTtcbkNvb2tpZUphci5wcm90b3R5cGUuX2ltcG9ydENvb2tpZXMgPSBmdW5jdGlvbihzZXJpYWxpemVkLCBjYikge1xuICB2YXIgamFyID0gdGhpcztcbiAgdmFyIGNvb2tpZXMgPSBzZXJpYWxpemVkLmNvb2tpZXM7XG4gIGlmICghY29va2llcyB8fCAhQXJyYXkuaXNBcnJheShjb29raWVzKSkge1xuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ3NlcmlhbGl6ZWQgamFyIGhhcyBubyBjb29raWVzIGFycmF5JykpO1xuICB9XG4gIGNvb2tpZXMgPSBjb29raWVzLnNsaWNlKCk7IC8vIGRvIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsXG5cbiAgZnVuY3Rpb24gcHV0TmV4dChlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvb2tpZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY2IoZXJyLCBqYXIpO1xuICAgIH1cblxuICAgIHZhciBjb29raWU7XG4gICAgdHJ5IHtcbiAgICAgIGNvb2tpZSA9IGZyb21KU09OKGNvb2tpZXMuc2hpZnQoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNiKGUpO1xuICAgIH1cblxuICAgIGlmIChjb29raWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBwdXROZXh0KG51bGwpOyAvLyBza2lwIHRoaXMgY29va2llXG4gICAgfVxuXG4gICAgamFyLnN0b3JlLnB1dENvb2tpZShjb29raWUsIHB1dE5leHQpO1xuICB9XG5cbiAgcHV0TmV4dCgpO1xufTtcblxuQ29va2llSmFyLmRlc2VyaWFsaXplID0gZnVuY3Rpb24oc3RyT3JPYmosIHN0b3JlLCBjYikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMykge1xuICAgIC8vIHN0b3JlIGlzIG9wdGlvbmFsXG4gICAgY2IgPSBzdG9yZTtcbiAgICBzdG9yZSA9IG51bGw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZDtcbiAgaWYgKHR5cGVvZiBzdHJPck9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICBzZXJpYWxpemVkID0ganNvblBhcnNlKHN0ck9yT2JqKTtcbiAgICBpZiAoc2VyaWFsaXplZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gY2Ioc2VyaWFsaXplZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWQgPSBzdHJPck9iajtcbiAgfVxuXG4gIHZhciBqYXIgPSBuZXcgQ29va2llSmFyKHN0b3JlLCBzZXJpYWxpemVkLnJlamVjdFB1YmxpY1N1ZmZpeGVzKTtcbiAgamFyLl9pbXBvcnRDb29raWVzKHNlcmlhbGl6ZWQsIGZ1bmN0aW9uKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYihlcnIpO1xuICAgIH1cbiAgICBjYihudWxsLCBqYXIpO1xuICB9KTtcbn07XG5cbkNvb2tpZUphci5kZXNlcmlhbGl6ZVN5bmMgPSBmdW5jdGlvbihzdHJPck9iaiwgc3RvcmUpIHtcbiAgdmFyIHNlcmlhbGl6ZWQgPSB0eXBlb2Ygc3RyT3JPYmogPT09ICdzdHJpbmcnID9cbiAgICBKU09OLnBhcnNlKHN0ck9yT2JqKSA6IHN0ck9yT2JqO1xuICB2YXIgamFyID0gbmV3IENvb2tpZUphcihzdG9yZSwgc2VyaWFsaXplZC5yZWplY3RQdWJsaWNTdWZmaXhlcyk7XG5cbiAgLy8gY2F0Y2ggdGhpcyBtaXN0YWtlIGVhcmx5OlxuICBpZiAoIWphci5zdG9yZS5zeW5jaHJvbm91cykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29va2llSmFyIHN0b3JlIGlzIG5vdCBzeW5jaHJvbm91czsgdXNlIGFzeW5jIEFQSSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgamFyLl9pbXBvcnRDb29raWVzU3luYyhzZXJpYWxpemVkKTtcbiAgcmV0dXJuIGphcjtcbn07XG5Db29raWVKYXIuZnJvbUpTT04gPSBDb29raWVKYXIuZGVzZXJpYWxpemVTeW5jO1xuXG5DQU5fQkVfU1lOQy5wdXNoKCdjbG9uZScpO1xuQ29va2llSmFyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKG5ld1N0b3JlLCBjYikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNiID0gbmV3U3RvcmU7XG4gICAgbmV3U3RvcmUgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5zZXJpYWxpemUoZnVuY3Rpb24oZXJyLHNlcmlhbGl6ZWQpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICB9XG4gICAgQ29va2llSmFyLmRlc2VyaWFsaXplKG5ld1N0b3JlLCBzZXJpYWxpemVkLCBjYik7XG4gIH0pO1xufTtcblxuLy8gVXNlIGEgY2xvc3VyZSB0byBwcm92aWRlIGEgdHJ1ZSBpbXBlcmF0aXZlIEFQSSBmb3Igc3luY2hyb25vdXMgc3RvcmVzLlxuZnVuY3Rpb24gc3luY1dyYXAobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuc3RvcmUuc3luY2hyb25vdXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29va2llSmFyIHN0b3JlIGlzIG5vdCBzeW5jaHJvbm91czsgdXNlIGFzeW5jIEFQSSBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgc3luY0Vyciwgc3luY1Jlc3VsdDtcbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gc3luY0NiKGVyciwgcmVzdWx0KSB7XG4gICAgICBzeW5jRXJyID0gZXJyO1xuICAgICAgc3luY1Jlc3VsdCA9IHJlc3VsdDtcbiAgICB9KTtcbiAgICB0aGlzW21ldGhvZF0uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICBpZiAoc3luY0Vycikge1xuICAgICAgdGhyb3cgc3luY0VycjtcbiAgICB9XG4gICAgcmV0dXJuIHN5bmNSZXN1bHQ7XG4gIH07XG59XG5cbi8vIHdyYXAgYWxsIGRlY2xhcmVkIENBTl9CRV9TWU5DIG1ldGhvZHMgaW4gdGhlIHN5bmMgd3JhcHBlclxuQ0FOX0JFX1NZTkMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgQ29va2llSmFyLnByb3RvdHlwZVttZXRob2QrJ1N5bmMnXSA9IHN5bmNXcmFwKG1ldGhvZCk7XG59KTtcblxuZXhwb3J0cy5Db29raWVKYXIgPSBDb29raWVKYXI7XG5leHBvcnRzLkNvb2tpZSA9IENvb2tpZTtcbmV4cG9ydHMuU3RvcmUgPSBTdG9yZTtcbmV4cG9ydHMuTWVtb3J5Q29va2llU3RvcmUgPSBNZW1vcnlDb29raWVTdG9yZTtcbmV4cG9ydHMucGFyc2VEYXRlID0gcGFyc2VEYXRlO1xuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMuZnJvbUpTT04gPSBmcm9tSlNPTjtcbmV4cG9ydHMuZG9tYWluTWF0Y2ggPSBkb21haW5NYXRjaDtcbmV4cG9ydHMuZGVmYXVsdFBhdGggPSBkZWZhdWx0UGF0aDtcbmV4cG9ydHMucGF0aE1hdGNoID0gcGF0aE1hdGNoO1xuZXhwb3J0cy5nZXRQdWJsaWNTdWZmaXggPSBwdWJzdWZmaXguZ2V0UHVibGljU3VmZml4O1xuZXhwb3J0cy5jb29raWVDb21wYXJlID0gY29va2llQ29tcGFyZTtcbmV4cG9ydHMucGVybXV0ZURvbWFpbiA9IHJlcXVpcmUoJy4vcGVybXV0ZURvbWFpbicpLnBlcm11dGVEb21haW47XG5leHBvcnRzLnBlcm11dGVQYXRoID0gcGVybXV0ZVBhdGg7XG5leHBvcnRzLmNhbm9uaWNhbERvbWFpbiA9IGNhbm9uaWNhbERvbWFpbjtcbiIsIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIFN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZScpLlN0b3JlO1xudmFyIHBlcm11dGVEb21haW4gPSByZXF1aXJlKCcuL3Blcm11dGVEb21haW4nKS5wZXJtdXRlRG9tYWluO1xudmFyIHBhdGhNYXRjaCA9IHJlcXVpcmUoJy4vcGF0aE1hdGNoJykucGF0aE1hdGNoO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIE1lbW9yeUNvb2tpZVN0b3JlKCkge1xuICBTdG9yZS5jYWxsKHRoaXMpO1xuICB0aGlzLmlkeCA9IHt9O1xufVxudXRpbC5pbmhlcml0cyhNZW1vcnlDb29raWVTdG9yZSwgU3RvcmUpO1xuZXhwb3J0cy5NZW1vcnlDb29raWVTdG9yZSA9IE1lbW9yeUNvb2tpZVN0b3JlO1xuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLmlkeCA9IG51bGw7XG5cbi8vIFNpbmNlIGl0J3MganVzdCBhIHN0cnVjdCBpbiBSQU0sIHRoaXMgU3RvcmUgaXMgc3luY2hyb25vdXNcbk1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZS5zeW5jaHJvbm91cyA9IHRydWU7XG5cbi8vIGZvcmNlIGEgZGVmYXVsdCBkZXB0aDpcbk1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBcInsgaWR4OiBcIit1dGlsLmluc3BlY3QodGhpcy5pZHgsIGZhbHNlLCAyKSsnIH0nO1xufTtcblxuLy8gVXNlIHRoZSBuZXcgY3VzdG9tIGluc3BlY3Rpb24gc3ltYm9sIHRvIGFkZCB0aGUgY3VzdG9tIGluc3BlY3QgZnVuY3Rpb24gaWZcbi8vIGF2YWlsYWJsZS5cbmlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIE1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IE1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZS5pbnNwZWN0O1xufVxuXG5NZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGUuZmluZENvb2tpZSA9IGZ1bmN0aW9uKGRvbWFpbiwgcGF0aCwga2V5LCBjYikge1xuICBpZiAoIXRoaXMuaWR4W2RvbWFpbl0pIHtcbiAgICByZXR1cm4gY2IobnVsbCx1bmRlZmluZWQpO1xuICB9XG4gIGlmICghdGhpcy5pZHhbZG9tYWluXVtwYXRoXSkge1xuICAgIHJldHVybiBjYihudWxsLHVuZGVmaW5lZCk7XG4gIH1cbiAgcmV0dXJuIGNiKG51bGwsdGhpcy5pZHhbZG9tYWluXVtwYXRoXVtrZXldfHxudWxsKTtcbn07XG5cbk1lbW9yeUNvb2tpZVN0b3JlLnByb3RvdHlwZS5maW5kQ29va2llcyA9IGZ1bmN0aW9uKGRvbWFpbiwgcGF0aCwgY2IpIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgaWYgKCFkb21haW4pIHtcbiAgICByZXR1cm4gY2IobnVsbCxbXSk7XG4gIH1cblxuICB2YXIgcGF0aE1hdGNoZXI7XG4gIGlmICghcGF0aCkge1xuICAgIC8vIG51bGwgbWVhbnMgXCJhbGwgcGF0aHNcIlxuICAgIHBhdGhNYXRjaGVyID0gZnVuY3Rpb24gbWF0Y2hBbGwoZG9tYWluSW5kZXgpIHtcbiAgICAgIGZvciAodmFyIGN1clBhdGggaW4gZG9tYWluSW5kZXgpIHtcbiAgICAgICAgdmFyIHBhdGhJbmRleCA9IGRvbWFpbkluZGV4W2N1clBhdGhdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGF0aEluZGV4KSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHBhdGhJbmRleFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgfSBlbHNlIHtcbiAgICBwYXRoTWF0Y2hlciA9IGZ1bmN0aW9uIG1hdGNoUkZDKGRvbWFpbkluZGV4KSB7XG4gICAgICAgLy9OT1RFOiB3ZSBzaG91bGQgdXNlIHBhdGgtbWF0Y2ggYWxnb3JpdGhtIGZyb20gUzUuMS40IGhlcmVcbiAgICAgICAvLyhzZWUgOiBodHRwczovL2dpdGh1Yi5jb20vQ2hyb21pdW1XZWJBcHBzL2Nocm9taXVtL2Jsb2IvYjNkM2I0ZGE4YmI5NGMxYjJlMDYxNjAwZGYxMDZkNTkwZmRhMzYyMC9uZXQvY29va2llcy9jYW5vbmljYWxfY29va2llLmNjI0wyOTkpXG4gICAgICAgT2JqZWN0LmtleXMoZG9tYWluSW5kZXgpLmZvckVhY2goZnVuY3Rpb24gKGNvb2tpZVBhdGgpIHtcbiAgICAgICAgIGlmIChwYXRoTWF0Y2gocGF0aCwgY29va2llUGF0aCkpIHtcbiAgICAgICAgICAgdmFyIHBhdGhJbmRleCA9IGRvbWFpbkluZGV4W2Nvb2tpZVBhdGhdO1xuXG4gICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwYXRoSW5kZXgpIHtcbiAgICAgICAgICAgICByZXN1bHRzLnB1c2gocGF0aEluZGV4W2tleV0pO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgfSk7XG4gICAgIH07XG4gIH1cblxuICB2YXIgZG9tYWlucyA9IHBlcm11dGVEb21haW4oZG9tYWluKSB8fCBbZG9tYWluXTtcbiAgdmFyIGlkeCA9IHRoaXMuaWR4O1xuICBkb21haW5zLmZvckVhY2goZnVuY3Rpb24oY3VyRG9tYWluKSB7XG4gICAgdmFyIGRvbWFpbkluZGV4ID0gaWR4W2N1ckRvbWFpbl07XG4gICAgaWYgKCFkb21haW5JbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXRoTWF0Y2hlcihkb21haW5JbmRleCk7XG4gIH0pO1xuXG4gIGNiKG51bGwscmVzdWx0cyk7XG59O1xuXG5NZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGUucHV0Q29va2llID0gZnVuY3Rpb24oY29va2llLCBjYikge1xuICBpZiAoIXRoaXMuaWR4W2Nvb2tpZS5kb21haW5dKSB7XG4gICAgdGhpcy5pZHhbY29va2llLmRvbWFpbl0gPSB7fTtcbiAgfVxuICBpZiAoIXRoaXMuaWR4W2Nvb2tpZS5kb21haW5dW2Nvb2tpZS5wYXRoXSkge1xuICAgIHRoaXMuaWR4W2Nvb2tpZS5kb21haW5dW2Nvb2tpZS5wYXRoXSA9IHt9O1xuICB9XG4gIHRoaXMuaWR4W2Nvb2tpZS5kb21haW5dW2Nvb2tpZS5wYXRoXVtjb29raWUua2V5XSA9IGNvb2tpZTtcbiAgY2IobnVsbCk7XG59O1xuXG5NZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGUudXBkYXRlQ29va2llID0gZnVuY3Rpb24ob2xkQ29va2llLCBuZXdDb29raWUsIGNiKSB7XG4gIC8vIHVwZGF0ZUNvb2tpZSgpIG1heSBhdm9pZCB1cGRhdGluZyBjb29raWVzIHRoYXQgYXJlIGlkZW50aWNhbC4gIEZvciBleGFtcGxlLFxuICAvLyBsYXN0QWNjZXNzZWQgbWF5IG5vdCBiZSBpbXBvcnRhbnQgdG8gc29tZSBzdG9yZXMgYW5kIGFuIGVxdWFsaXR5XG4gIC8vIGNvbXBhcmlzb24gY291bGQgZXhjbHVkZSB0aGF0IGZpZWxkLlxuICB0aGlzLnB1dENvb2tpZShuZXdDb29raWUsY2IpO1xufTtcblxuTWVtb3J5Q29va2llU3RvcmUucHJvdG90eXBlLnJlbW92ZUNvb2tpZSA9IGZ1bmN0aW9uKGRvbWFpbiwgcGF0aCwga2V5LCBjYikge1xuICBpZiAodGhpcy5pZHhbZG9tYWluXSAmJiB0aGlzLmlkeFtkb21haW5dW3BhdGhdICYmIHRoaXMuaWR4W2RvbWFpbl1bcGF0aF1ba2V5XSkge1xuICAgIGRlbGV0ZSB0aGlzLmlkeFtkb21haW5dW3BhdGhdW2tleV07XG4gIH1cbiAgY2IobnVsbCk7XG59O1xuXG5NZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGUucmVtb3ZlQ29va2llcyA9IGZ1bmN0aW9uKGRvbWFpbiwgcGF0aCwgY2IpIHtcbiAgaWYgKHRoaXMuaWR4W2RvbWFpbl0pIHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuaWR4W2RvbWFpbl1bcGF0aF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmlkeFtkb21haW5dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2IobnVsbCk7XG59O1xuXG5NZW1vcnlDb29raWVTdG9yZS5wcm90b3R5cGUuZ2V0QWxsQ29va2llcyA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBjb29raWVzID0gW107XG4gIHZhciBpZHggPSB0aGlzLmlkeDtcblxuICB2YXIgZG9tYWlucyA9IE9iamVjdC5rZXlzKGlkeCk7XG4gIGRvbWFpbnMuZm9yRWFjaChmdW5jdGlvbihkb21haW4pIHtcbiAgICB2YXIgcGF0aHMgPSBPYmplY3Qua2V5cyhpZHhbZG9tYWluXSk7XG4gICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbihwYXRoKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGlkeFtkb21haW5dW3BhdGhdKTtcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvb2tpZXMucHVzaChpZHhbZG9tYWluXVtwYXRoXVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFNvcnQgYnkgY3JlYXRpb25JbmRleCBzbyBkZXNlcmlhbGl6aW5nIHJldGFpbnMgdGhlIGNyZWF0aW9uIG9yZGVyLlxuICAvLyBXaGVuIGltcGxlbWVudGluZyB5b3VyIG93biBzdG9yZSwgdGhpcyBTSE9VTEQgcmV0YWluIHRoZSBvcmRlciB0b29cbiAgY29va2llcy5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgIHJldHVybiAoYS5jcmVhdGlvbkluZGV4fHwwKSAtIChiLmNyZWF0aW9uSW5kZXh8fDApO1xuICB9KTtcblxuICBjYihudWxsLCBjb29raWVzKTtcbn07XG4iLCIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNSwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuLypcbiAqIFwiQSByZXF1ZXN0LXBhdGggcGF0aC1tYXRjaGVzIGEgZ2l2ZW4gY29va2llLXBhdGggaWYgYXQgbGVhc3Qgb25lIG9mIHRoZVxuICogZm9sbG93aW5nIGNvbmRpdGlvbnMgaG9sZHM6XCJcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoIChyZXFQYXRoLCBjb29raWVQYXRoKSB7XG4gIC8vIFwibyAgVGhlIGNvb2tpZS1wYXRoIGFuZCB0aGUgcmVxdWVzdC1wYXRoIGFyZSBpZGVudGljYWwuXCJcbiAgaWYgKGNvb2tpZVBhdGggPT09IHJlcVBhdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpZHggPSByZXFQYXRoLmluZGV4T2YoY29va2llUGF0aCk7XG4gIGlmIChpZHggPT09IDApIHtcbiAgICAvLyBcIm8gIFRoZSBjb29raWUtcGF0aCBpcyBhIHByZWZpeCBvZiB0aGUgcmVxdWVzdC1wYXRoLCBhbmQgdGhlIGxhc3RcbiAgICAvLyBjaGFyYWN0ZXIgb2YgdGhlIGNvb2tpZS1wYXRoIGlzICV4MkYgKFwiL1wiKS5cIlxuICAgIGlmIChjb29raWVQYXRoLnN1YnN0cigtMSkgPT09IFwiL1wiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBcIiBvICBUaGUgY29va2llLXBhdGggaXMgYSBwcmVmaXggb2YgdGhlIHJlcXVlc3QtcGF0aCwgYW5kIHRoZSBmaXJzdFxuICAgIC8vIGNoYXJhY3RlciBvZiB0aGUgcmVxdWVzdC1wYXRoIHRoYXQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSBjb29raWUtIHBhdGhcbiAgICAvLyBpcyBhICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIuXCJcbiAgICBpZiAocmVxUGF0aC5zdWJzdHIoY29va2llUGF0aC5sZW5ndGgsIDEpID09PSBcIi9cIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnRzLnBhdGhNYXRjaCA9IHBhdGhNYXRjaDtcbiIsIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHVic3VmZml4ID0gcmVxdWlyZSgnLi9wdWJzdWZmaXgtcHNsJyk7XG5cbi8vIEdpdmVzIHRoZSBwZXJtdXRhdGlvbiBvZiBhbGwgcG9zc2libGUgZG9tYWluTWF0Y2goKWVzIG9mIGEgZ2l2ZW4gZG9tYWluLiBUaGVcbi8vIGFycmF5IGlzIGluIHNob3J0ZXN0LXRvLWxvbmdlc3Qgb3JkZXIuICBIYW5keSBmb3IgaW5kZXhpbmcuXG5mdW5jdGlvbiBwZXJtdXRlRG9tYWluIChkb21haW4pIHtcbiAgdmFyIHB1YlN1ZiA9IHB1YnN1ZmZpeC5nZXRQdWJsaWNTdWZmaXgoZG9tYWluKTtcbiAgaWYgKCFwdWJTdWYpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocHViU3VmID09IGRvbWFpbikge1xuICAgIHJldHVybiBbZG9tYWluXTtcbiAgfVxuXG4gIHZhciBwcmVmaXggPSBkb21haW4uc2xpY2UoMCwgLShwdWJTdWYubGVuZ3RoICsgMSkpOyAvLyBcIi5leGFtcGxlLmNvbVwiXG4gIHZhciBwYXJ0cyA9IHByZWZpeC5zcGxpdCgnLicpLnJldmVyc2UoKTtcbiAgdmFyIGN1ciA9IHB1YlN1ZjtcbiAgdmFyIHBlcm11dGF0aW9ucyA9IFtjdXJdO1xuICB3aGlsZSAocGFydHMubGVuZ3RoKSB7XG4gICAgY3VyID0gcGFydHMuc2hpZnQoKSArICcuJyArIGN1cjtcbiAgICBwZXJtdXRhdGlvbnMucHVzaChjdXIpO1xuICB9XG4gIHJldHVybiBwZXJtdXRhdGlvbnM7XG59XG5cbmV4cG9ydHMucGVybXV0ZURvbWFpbiA9IHBlcm11dGVEb21haW47XG4iLCIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxOCwgU2FsZXNmb3JjZS5jb20sIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIDMuIE5laXRoZXIgdGhlIG5hbWUgb2YgU2FsZXNmb3JjZS5jb20gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heVxuICogYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dFxuICogc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuICogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiAqIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuICogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBwc2wgPSByZXF1aXJlKCdwc2wnKTtcblxuZnVuY3Rpb24gZ2V0UHVibGljU3VmZml4KGRvbWFpbikge1xuICByZXR1cm4gcHNsLmdldChkb21haW4pO1xufVxuXG5leHBvcnRzLmdldFB1YmxpY1N1ZmZpeCA9IGdldFB1YmxpY1N1ZmZpeDtcbiIsIi8qIVxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBTYWxlc2ZvcmNlLmNvbSwgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiBTYWxlc2ZvcmNlLmNvbSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5XG4gKiBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuLypqc2hpbnQgdW51c2VkOmZhbHNlICovXG5cbmZ1bmN0aW9uIFN0b3JlKCkge1xufVxuZXhwb3J0cy5TdG9yZSA9IFN0b3JlO1xuXG4vLyBTdG9yZXMgbWF5IGJlIHN5bmNocm9ub3VzLCBidXQgYXJlIHN0aWxsIHJlcXVpcmVkIHRvIHVzZSBhXG4vLyBDb250aW51YXRpb24tUGFzc2luZyBTdHlsZSBBUEkuICBUaGUgQ29va2llSmFyIGl0c2VsZiB3aWxsIGV4cG9zZSBhIFwiKlN5bmNcIlxuLy8gQVBJIHRoYXQgY29udmVydHMgZnJvbSBzeW5jaHJvbm91cy1jYWxsYmFja3MgdG8gaW1wZXJhdGl2ZSBzdHlsZS5cblN0b3JlLnByb3RvdHlwZS5zeW5jaHJvbm91cyA9IGZhbHNlO1xuXG5TdG9yZS5wcm90b3R5cGUuZmluZENvb2tpZSA9IGZ1bmN0aW9uKGRvbWFpbiwgcGF0aCwga2V5LCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbmRDb29raWUgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZmluZENvb2tpZXMgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignZmluZENvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucHV0Q29va2llID0gZnVuY3Rpb24oY29va2llLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3B1dENvb2tpZSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS51cGRhdGVDb29raWUgPSBmdW5jdGlvbihvbGRDb29raWUsIG5ld0Nvb2tpZSwgY2IpIHtcbiAgLy8gcmVjb21tZW5kZWQgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbjpcbiAgLy8gcmV0dXJuIHRoaXMucHV0Q29va2llKG5ld0Nvb2tpZSwgY2IpO1xuICB0aHJvdyBuZXcgRXJyb3IoJ3VwZGF0ZUNvb2tpZSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZW1vdmVDb29raWUgPSBmdW5jdGlvbihkb21haW4sIHBhdGgsIGtleSwgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVDb29raWUgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVtb3ZlQ29va2llcyA9IGZ1bmN0aW9uKGRvbWFpbiwgcGF0aCwgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVDb29raWVzIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmdldEFsbENvb2tpZXMgPSBmdW5jdGlvbihjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2dldEFsbENvb2tpZXMgaXMgbm90IGltcGxlbWVudGVkICh0aGVyZWZvcmUgamFyIGNhbm5vdCBiZSBzZXJpYWxpemVkKScpO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0JylcbiAgLCB0bHMgPSByZXF1aXJlKCd0bHMnKVxuICAsIGh0dHAgPSByZXF1aXJlKCdodHRwJylcbiAgLCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJylcbiAgLCBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxuICAsIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuICAsIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG4gIDtcblxuZXhwb3J0cy5odHRwT3Zlckh0dHAgPSBodHRwT3Zlckh0dHBcbmV4cG9ydHMuaHR0cHNPdmVySHR0cCA9IGh0dHBzT3Zlckh0dHBcbmV4cG9ydHMuaHR0cE92ZXJIdHRwcyA9IGh0dHBPdmVySHR0cHNcbmV4cG9ydHMuaHR0cHNPdmVySHR0cHMgPSBodHRwc092ZXJIdHRwc1xuXG5cbmZ1bmN0aW9uIGh0dHBPdmVySHR0cChvcHRpb25zKSB7XG4gIHZhciBhZ2VudCA9IG5ldyBUdW5uZWxpbmdBZ2VudChvcHRpb25zKVxuICBhZ2VudC5yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0XG4gIHJldHVybiBhZ2VudFxufVxuXG5mdW5jdGlvbiBodHRwc092ZXJIdHRwKG9wdGlvbnMpIHtcbiAgdmFyIGFnZW50ID0gbmV3IFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpXG4gIGFnZW50LnJlcXVlc3QgPSBodHRwLnJlcXVlc3RcbiAgYWdlbnQuY3JlYXRlU29ja2V0ID0gY3JlYXRlU2VjdXJlU29ja2V0XG4gIGFnZW50LmRlZmF1bHRQb3J0ID0gNDQzXG4gIHJldHVybiBhZ2VudFxufVxuXG5mdW5jdGlvbiBodHRwT3Zlckh0dHBzKG9wdGlvbnMpIHtcbiAgdmFyIGFnZW50ID0gbmV3IFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpXG4gIGFnZW50LnJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0XG4gIHJldHVybiBhZ2VudFxufVxuXG5mdW5jdGlvbiBodHRwc092ZXJIdHRwcyhvcHRpb25zKSB7XG4gIHZhciBhZ2VudCA9IG5ldyBUdW5uZWxpbmdBZ2VudChvcHRpb25zKVxuICBhZ2VudC5yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdFxuICBhZ2VudC5jcmVhdGVTb2NrZXQgPSBjcmVhdGVTZWN1cmVTb2NrZXRcbiAgYWdlbnQuZGVmYXVsdFBvcnQgPSA0NDNcbiAgcmV0dXJuIGFnZW50XG59XG5cblxuZnVuY3Rpb24gVHVubmVsaW5nQWdlbnQob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBzZWxmLnByb3h5T3B0aW9ucyA9IHNlbGYub3B0aW9ucy5wcm94eSB8fCB7fVxuICBzZWxmLm1heFNvY2tldHMgPSBzZWxmLm9wdGlvbnMubWF4U29ja2V0cyB8fCBodHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzXG4gIHNlbGYucmVxdWVzdHMgPSBbXVxuICBzZWxmLnNvY2tldHMgPSBbXVxuXG4gIHNlbGYub24oJ2ZyZWUnLCBmdW5jdGlvbiBvbkZyZWUoc29ja2V0LCBob3N0LCBwb3J0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYucmVxdWVzdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHZhciBwZW5kaW5nID0gc2VsZi5yZXF1ZXN0c1tpXVxuICAgICAgaWYgKHBlbmRpbmcuaG9zdCA9PT0gaG9zdCAmJiBwZW5kaW5nLnBvcnQgPT09IHBvcnQpIHtcbiAgICAgICAgLy8gRGV0ZWN0IHRoZSByZXF1ZXN0IHRvIGNvbm5lY3Qgc2FtZSBvcmlnaW4gc2VydmVyLFxuICAgICAgICAvLyByZXVzZSB0aGUgY29ubmVjdGlvbi5cbiAgICAgICAgc2VsZi5yZXF1ZXN0cy5zcGxpY2UoaSwgMSlcbiAgICAgICAgcGVuZGluZy5yZXF1ZXN0Lm9uU29ja2V0KHNvY2tldClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIHNvY2tldC5kZXN0cm95KClcbiAgICBzZWxmLnJlbW92ZVNvY2tldChzb2NrZXQpXG4gIH0pXG59XG51dGlsLmluaGVyaXRzKFR1bm5lbGluZ0FnZW50LCBldmVudHMuRXZlbnRFbWl0dGVyKVxuXG5UdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUuYWRkUmVxdWVzdCA9IGZ1bmN0aW9uIGFkZFJlcXVlc3QocmVxLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gICAvLyBMZWdhY3kgQVBJOiBhZGRSZXF1ZXN0KHJlcSwgaG9zdCwgcG9ydCwgcGF0aClcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBob3N0OiBvcHRpb25zLFxuICAgICAgcG9ydDogYXJndW1lbnRzWzJdLFxuICAgICAgcGF0aDogYXJndW1lbnRzWzNdXG4gICAgfTtcbiAgfVxuXG4gIGlmIChzZWxmLnNvY2tldHMubGVuZ3RoID49IHRoaXMubWF4U29ja2V0cykge1xuICAgIC8vIFdlIGFyZSBvdmVyIGxpbWl0IHNvIHdlJ2xsIGFkZCBpdCB0byB0aGUgcXVldWUuXG4gICAgc2VsZi5yZXF1ZXN0cy5wdXNoKHtob3N0OiBvcHRpb25zLmhvc3QsIHBvcnQ6IG9wdGlvbnMucG9ydCwgcmVxdWVzdDogcmVxfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIElmIHdlIGFyZSB1bmRlciBtYXhTb2NrZXRzIGNyZWF0ZSBhIG5ldyBvbmUuXG4gIHNlbGYuY3JlYXRlQ29ubmVjdGlvbih7aG9zdDogb3B0aW9ucy5ob3N0LCBwb3J0OiBvcHRpb25zLnBvcnQsIHJlcXVlc3Q6IHJlcX0pXG59XG5cblR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvbihwZW5kaW5nKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHNlbGYuY3JlYXRlU29ja2V0KHBlbmRpbmcsIGZ1bmN0aW9uKHNvY2tldCkge1xuICAgIHNvY2tldC5vbignZnJlZScsIG9uRnJlZSlcbiAgICBzb2NrZXQub24oJ2Nsb3NlJywgb25DbG9zZU9yUmVtb3ZlKVxuICAgIHNvY2tldC5vbignYWdlbnRSZW1vdmUnLCBvbkNsb3NlT3JSZW1vdmUpXG4gICAgcGVuZGluZy5yZXF1ZXN0Lm9uU29ja2V0KHNvY2tldClcblxuICAgIGZ1bmN0aW9uIG9uRnJlZSgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZnJlZScsIHNvY2tldCwgcGVuZGluZy5ob3N0LCBwZW5kaW5nLnBvcnQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbG9zZU9yUmVtb3ZlKGVycikge1xuICAgICAgc2VsZi5yZW1vdmVTb2NrZXQoc29ja2V0KVxuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdmcmVlJywgb25GcmVlKVxuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2VPclJlbW92ZSlcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignYWdlbnRSZW1vdmUnLCBvbkNsb3NlT3JSZW1vdmUpXG4gICAgfVxuICB9KVxufVxuXG5UdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUuY3JlYXRlU29ja2V0ID0gZnVuY3Rpb24gY3JlYXRlU29ja2V0KG9wdGlvbnMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcGxhY2Vob2xkZXIgPSB7fVxuICBzZWxmLnNvY2tldHMucHVzaChwbGFjZWhvbGRlcilcblxuICB2YXIgY29ubmVjdE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoe30sIHNlbGYucHJveHlPcHRpb25zLFxuICAgIHsgbWV0aG9kOiAnQ09OTkVDVCdcbiAgICAsIHBhdGg6IG9wdGlvbnMuaG9zdCArICc6JyArIG9wdGlvbnMucG9ydFxuICAgICwgYWdlbnQ6IGZhbHNlXG4gICAgfVxuICApXG4gIGlmIChjb25uZWN0T3B0aW9ucy5wcm94eUF1dGgpIHtcbiAgICBjb25uZWN0T3B0aW9ucy5oZWFkZXJzID0gY29ubmVjdE9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIGNvbm5lY3RPcHRpb25zLmhlYWRlcnNbJ1Byb3h5LUF1dGhvcml6YXRpb24nXSA9ICdCYXNpYyAnICtcbiAgICAgICAgQnVmZmVyLmZyb20oY29ubmVjdE9wdGlvbnMucHJveHlBdXRoKS50b1N0cmluZygnYmFzZTY0JylcbiAgfVxuXG4gIGRlYnVnKCdtYWtpbmcgQ09OTkVDVCByZXF1ZXN0JylcbiAgdmFyIGNvbm5lY3RSZXEgPSBzZWxmLnJlcXVlc3QoY29ubmVjdE9wdGlvbnMpXG4gIGNvbm5lY3RSZXEudXNlQ2h1bmtlZEVuY29kaW5nQnlEZWZhdWx0ID0gZmFsc2UgLy8gZm9yIHYwLjZcbiAgY29ubmVjdFJlcS5vbmNlKCdyZXNwb25zZScsIG9uUmVzcG9uc2UpIC8vIGZvciB2MC42XG4gIGNvbm5lY3RSZXEub25jZSgndXBncmFkZScsIG9uVXBncmFkZSkgICAvLyBmb3IgdjAuNlxuICBjb25uZWN0UmVxLm9uY2UoJ2Nvbm5lY3QnLCBvbkNvbm5lY3QpICAgLy8gZm9yIHYwLjcgb3IgbGF0ZXJcbiAgY29ubmVjdFJlcS5vbmNlKCdlcnJvcicsIG9uRXJyb3IpXG4gIGNvbm5lY3RSZXEuZW5kKClcblxuICBmdW5jdGlvbiBvblJlc3BvbnNlKHJlcykge1xuICAgIC8vIFZlcnkgaGFja3kuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGF2b2lkIGh0dHAtcGFyc2VyIGxlYWtzLlxuICAgIHJlcy51cGdyYWRlID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gb25VcGdyYWRlKHJlcywgc29ja2V0LCBoZWFkKSB7XG4gICAgLy8gSGFja3kuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG9uQ29ubmVjdChyZXMsIHNvY2tldCwgaGVhZClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0KHJlcywgc29ja2V0LCBoZWFkKSB7XG4gICAgY29ubmVjdFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuXG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIGFzc2VydC5lcXVhbChoZWFkLmxlbmd0aCwgMClcbiAgICAgIGRlYnVnKCd0dW5uZWxpbmcgY29ubmVjdGlvbiBoYXMgZXN0YWJsaXNoZWQnKVxuICAgICAgc2VsZi5zb2NrZXRzW3NlbGYuc29ja2V0cy5pbmRleE9mKHBsYWNlaG9sZGVyKV0gPSBzb2NrZXRcbiAgICAgIGNiKHNvY2tldClcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCBzdGF0dXNDb2RlPSVkJywgcmVzLnN0YXR1c0NvZGUpXG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCAnICsgJ3N0YXR1c0NvZGU9JyArIHJlcy5zdGF0dXNDb2RlKVxuICAgICAgZXJyb3IuY29kZSA9ICdFQ09OTlJFU0VUJ1xuICAgICAgb3B0aW9ucy5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgICBzZWxmLnJlbW92ZVNvY2tldChwbGFjZWhvbGRlcilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGNhdXNlKSB7XG4gICAgY29ubmVjdFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuXG4gICAgZGVidWcoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCBjYXVzZT0lc1xcbicsIGNhdXNlLm1lc3NhZ2UsIGNhdXNlLnN0YWNrKVxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigndHVubmVsaW5nIHNvY2tldCBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQsICcgKyAnY2F1c2U9JyArIGNhdXNlLm1lc3NhZ2UpXG4gICAgZXJyb3IuY29kZSA9ICdFQ09OTlJFU0VUJ1xuICAgIG9wdGlvbnMucmVxdWVzdC5lbWl0KCdlcnJvcicsIGVycm9yKVxuICAgIHNlbGYucmVtb3ZlU29ja2V0KHBsYWNlaG9sZGVyKVxuICB9XG59XG5cblR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5yZW1vdmVTb2NrZXQgPSBmdW5jdGlvbiByZW1vdmVTb2NrZXQoc29ja2V0KSB7XG4gIHZhciBwb3MgPSB0aGlzLnNvY2tldHMuaW5kZXhPZihzb2NrZXQpXG4gIGlmIChwb3MgPT09IC0xKSByZXR1cm5cblxuICB0aGlzLnNvY2tldHMuc3BsaWNlKHBvcywgMSlcblxuICB2YXIgcGVuZGluZyA9IHRoaXMucmVxdWVzdHMuc2hpZnQoKVxuICBpZiAocGVuZGluZykge1xuICAgIC8vIElmIHdlIGhhdmUgcGVuZGluZyByZXF1ZXN0cyBhbmQgYSBzb2NrZXQgZ2V0cyBjbG9zZWQgYSBuZXcgb25lXG4gICAgLy8gbmVlZHMgdG8gYmUgY3JlYXRlZCB0byB0YWtlIG92ZXIgaW4gdGhlIHBvb2wgZm9yIHRoZSBvbmUgdGhhdCBjbG9zZWQuXG4gICAgdGhpcy5jcmVhdGVDb25uZWN0aW9uKHBlbmRpbmcpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VjdXJlU29ja2V0KG9wdGlvbnMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBUdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUuY3JlYXRlU29ja2V0LmNhbGwoc2VsZiwgb3B0aW9ucywgZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgLy8gMCBpcyBkdW1teSBwb3J0IGZvciB2MC42XG4gICAgdmFyIHNlY3VyZVNvY2tldCA9IHRscy5jb25uZWN0KDAsIG1lcmdlT3B0aW9ucyh7fSwgc2VsZi5vcHRpb25zLFxuICAgICAgeyBzZXJ2ZXJuYW1lOiBvcHRpb25zLmhvc3RcbiAgICAgICwgc29ja2V0OiBzb2NrZXRcbiAgICAgIH1cbiAgICApKVxuICAgIHNlbGYuc29ja2V0c1tzZWxmLnNvY2tldHMuaW5kZXhPZihzb2NrZXQpXSA9IHNlY3VyZVNvY2tldFxuICAgIGNiKHNlY3VyZVNvY2tldClcbiAgfSlcbn1cblxuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgb3ZlcnJpZGVzID0gYXJndW1lbnRzW2ldXG4gICAgaWYgKHR5cGVvZiBvdmVycmlkZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcylcbiAgICAgIGZvciAodmFyIGogPSAwLCBrZXlMZW4gPSBrZXlzLmxlbmd0aDsgaiA8IGtleUxlbjsgKytqKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1tqXVxuICAgICAgICBpZiAob3ZlcnJpZGVzW2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXRba10gPSBvdmVycmlkZXNba11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0XG59XG5cblxudmFyIGRlYnVnXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJiAvXFxidHVubmVsXFxiLy50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpKSB7XG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgYXJnc1swXSA9ICdUVU5ORUw6ICcgKyBhcmdzWzBdXG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MudW5zaGlmdCgnVFVOTkVMOicpXG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJncylcbiAgfVxufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbigpIHt9XG59XG5leHBvcnRzLmRlYnVnID0gZGVidWcgLy8gZm9yIHRlc3RcbiIsIihmdW5jdGlvbihuYWNsKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFBvcnRlZCBpbiAyMDE0IGJ5IERtaXRyeSBDaGVzdG55a2ggYW5kIERldmkgTWFuZGlyaS5cbi8vIFB1YmxpYyBkb21haW4uXG4vL1xuLy8gSW1wbGVtZW50YXRpb24gZGVyaXZlZCBmcm9tIFR3ZWV0TmFDbCB2ZXJzaW9uIDIwMTQwNDI3LlxuLy8gU2VlIGZvciBkZXRhaWxzOiBodHRwOi8vdHdlZXRuYWNsLmNyLnlwLnRvL1xuXG52YXIgZ2YgPSBmdW5jdGlvbihpbml0KSB7XG4gIHZhciBpLCByID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gIGlmIChpbml0KSBmb3IgKGkgPSAwOyBpIDwgaW5pdC5sZW5ndGg7IGkrKykgcltpXSA9IGluaXRbaV07XG4gIHJldHVybiByO1xufTtcblxuLy8gIFBsdWdnYWJsZSwgaW5pdGlhbGl6ZWQgaW4gaGlnaC1sZXZlbCBBUEkgYmVsb3cuXG52YXIgcmFuZG9tYnl0ZXMgPSBmdW5jdGlvbigvKiB4LCBuICovKSB7IHRocm93IG5ldyBFcnJvcignbm8gUFJORycpOyB9O1xuXG52YXIgXzAgPSBuZXcgVWludDhBcnJheSgxNik7XG52YXIgXzkgPSBuZXcgVWludDhBcnJheSgzMik7IF85WzBdID0gOTtcblxudmFyIGdmMCA9IGdmKCksXG4gICAgZ2YxID0gZ2YoWzFdKSxcbiAgICBfMTIxNjY1ID0gZ2YoWzB4ZGI0MSwgMV0pLFxuICAgIEQgPSBnZihbMHg3OGEzLCAweDEzNTksIDB4NGRjYSwgMHg3NWViLCAweGQ4YWIsIDB4NDE0MSwgMHgwYTRkLCAweDAwNzAsIDB4ZTg5OCwgMHg3Nzc5LCAweDQwNzksIDB4OGNjNywgMHhmZTczLCAweDJiNmYsIDB4NmNlZSwgMHg1MjAzXSksXG4gICAgRDIgPSBnZihbMHhmMTU5LCAweDI2YjIsIDB4OWI5NCwgMHhlYmQ2LCAweGIxNTYsIDB4ODI4MywgMHgxNDlhLCAweDAwZTAsIDB4ZDEzMCwgMHhlZWYzLCAweDgwZjIsIDB4MTk4ZSwgMHhmY2U3LCAweDU2ZGYsIDB4ZDlkYywgMHgyNDA2XSksXG4gICAgWCA9IGdmKFsweGQ1MWEsIDB4OGYyNSwgMHgyZDYwLCAweGM5NTYsIDB4YTdiMiwgMHg5NTI1LCAweGM3NjAsIDB4NjkyYywgMHhkYzVjLCAweGZkZDYsIDB4ZTIzMSwgMHhjMGE0LCAweDUzZmUsIDB4Y2Q2ZSwgMHgzNmQzLCAweDIxNjldKSxcbiAgICBZID0gZ2YoWzB4NjY1OCwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2Nl0pLFxuICAgIEkgPSBnZihbMHhhMGIwLCAweDRhMGUsIDB4MWIyNywgMHhjNGVlLCAweGU0NzgsIDB4YWQyZiwgMHgxODA2LCAweDJmNDMsIDB4ZDdhNywgMHgzZGZiLCAweDAwOTksIDB4MmI0ZCwgMHhkZjBiLCAweDRmYzEsIDB4MjQ4MCwgMHgyYjgzXSk7XG5cbmZ1bmN0aW9uIHRzNjQoeCwgaSwgaCwgbCkge1xuICB4W2ldICAgPSAoaCA+PiAyNCkgJiAweGZmO1xuICB4W2krMV0gPSAoaCA+PiAxNikgJiAweGZmO1xuICB4W2krMl0gPSAoaCA+PiAgOCkgJiAweGZmO1xuICB4W2krM10gPSBoICYgMHhmZjtcbiAgeFtpKzRdID0gKGwgPj4gMjQpICAmIDB4ZmY7XG4gIHhbaSs1XSA9IChsID4+IDE2KSAgJiAweGZmO1xuICB4W2krNl0gPSAobCA+PiAgOCkgICYgMHhmZjtcbiAgeFtpKzddID0gbCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIHZuKHgsIHhpLCB5LCB5aSwgbikge1xuICB2YXIgaSxkID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZCB8PSB4W3hpK2ldXnlbeWkraV07XG4gIHJldHVybiAoMSAmICgoZCAtIDEpID4+PiA4KSkgLSAxO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzE2KHgsIHhpLCB5LCB5aSkge1xuICByZXR1cm4gdm4oeCx4aSx5LHlpLDE2KTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3ZlcmlmeV8zMih4LCB4aSwgeSwgeWkpIHtcbiAgcmV0dXJuIHZuKHgseGkseSx5aSwzMik7XG59XG5cbmZ1bmN0aW9uIGNvcmVfc2Fsc2EyMChvLCBwLCBrLCBjKSB7XG4gIHZhciBqMCAgPSBjWyAwXSAmIDB4ZmYgfCAoY1sgMV0gJiAweGZmKTw8OCB8IChjWyAyXSAmIDB4ZmYpPDwxNiB8IChjWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxICA9IGtbIDBdICYgMHhmZiB8IChrWyAxXSAmIDB4ZmYpPDw4IHwgKGtbIDJdICYgMHhmZik8PDE2IHwgKGtbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajIgID0ga1sgNF0gJiAweGZmIHwgKGtbIDVdICYgMHhmZik8PDggfCAoa1sgNl0gJiAweGZmKTw8MTYgfCAoa1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqMyAgPSBrWyA4XSAmIDB4ZmYgfCAoa1sgOV0gJiAweGZmKTw8OCB8IChrWzEwXSAmIDB4ZmYpPDwxNiB8IChrWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo0ICA9IGtbMTJdICYgMHhmZiB8IChrWzEzXSAmIDB4ZmYpPDw4IHwgKGtbMTRdICYgMHhmZik8PDE2IHwgKGtbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajUgID0gY1sgNF0gJiAweGZmIHwgKGNbIDVdICYgMHhmZik8PDggfCAoY1sgNl0gJiAweGZmKTw8MTYgfCAoY1sgN10gJiAweGZmKTw8MjQsXG4gICAgICBqNiAgPSBwWyAwXSAmIDB4ZmYgfCAocFsgMV0gJiAweGZmKTw8OCB8IChwWyAyXSAmIDB4ZmYpPDwxNiB8IChwWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo3ICA9IHBbIDRdICYgMHhmZiB8IChwWyA1XSAmIDB4ZmYpPDw4IHwgKHBbIDZdICYgMHhmZik8PDE2IHwgKHBbIDddICYgMHhmZik8PDI0LFxuICAgICAgajggID0gcFsgOF0gJiAweGZmIHwgKHBbIDldICYgMHhmZik8PDggfCAocFsxMF0gJiAweGZmKTw8MTYgfCAocFsxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqOSAgPSBwWzEyXSAmIDB4ZmYgfCAocFsxM10gJiAweGZmKTw8OCB8IChwWzE0XSAmIDB4ZmYpPDwxNiB8IChwWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMCA9IGNbIDhdICYgMHhmZiB8IChjWyA5XSAmIDB4ZmYpPDw4IHwgKGNbMTBdICYgMHhmZik8PDE2IHwgKGNbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajExID0ga1sxNl0gJiAweGZmIHwgKGtbMTddICYgMHhmZik8PDggfCAoa1sxOF0gJiAweGZmKTw8MTYgfCAoa1sxOV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTIgPSBrWzIwXSAmIDB4ZmYgfCAoa1syMV0gJiAweGZmKTw8OCB8IChrWzIyXSAmIDB4ZmYpPDwxNiB8IChrWzIzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMyA9IGtbMjRdICYgMHhmZiB8IChrWzI1XSAmIDB4ZmYpPDw4IHwgKGtbMjZdICYgMHhmZik8PDE2IHwgKGtbMjddICYgMHhmZik8PDI0LFxuICAgICAgajE0ID0ga1syOF0gJiAweGZmIHwgKGtbMjldICYgMHhmZik8PDggfCAoa1szMF0gJiAweGZmKTw8MTYgfCAoa1szMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTUgPSBjWzEyXSAmIDB4ZmYgfCAoY1sxM10gJiAweGZmKTw8OCB8IChjWzE0XSAmIDB4ZmYpPDwxNiB8IChjWzE1XSAmIDB4ZmYpPDwyNDtcblxuICB2YXIgeDAgPSBqMCwgeDEgPSBqMSwgeDIgPSBqMiwgeDMgPSBqMywgeDQgPSBqNCwgeDUgPSBqNSwgeDYgPSBqNiwgeDcgPSBqNyxcbiAgICAgIHg4ID0gajgsIHg5ID0gajksIHgxMCA9IGoxMCwgeDExID0gajExLCB4MTIgPSBqMTIsIHgxMyA9IGoxMywgeDE0ID0gajE0LFxuICAgICAgeDE1ID0gajE1LCB1O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkgKz0gMikge1xuICAgIHUgPSB4MCArIHgxMiB8IDA7XG4gICAgeDQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg0ICsgeDAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHg0IHwgMDtcbiAgICB4MTIgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEyICsgeDggfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4MSB8IDA7XG4gICAgeDkgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg5ICsgeDUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDkgfCAwO1xuICAgIHgxIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxICsgeDEzIHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg2IHwgMDtcbiAgICB4MTQgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxNCArIHgxMCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDE0IHwgMDtcbiAgICB4NiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NiArIHgyIHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTEgfCAwO1xuICAgIHgzIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MyArIHgxNSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDMgfCAwO1xuICAgIHgxMSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTEgKyB4NyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDAgKyB4MyB8IDA7XG4gICAgeDEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxICsgeDAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxIHwgMDtcbiAgICB4MyBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MyArIHgyIHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDQgfCAwO1xuICAgIHg2IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NiArIHg1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4NiB8IDA7XG4gICAgeDQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDQgKyB4NyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4OSB8IDA7XG4gICAgeDExIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTEgKyB4MTAgfCAwO1xuICAgIHg4IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4OCArIHgxMSB8IDA7XG4gICAgeDkgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDkgKyB4OCB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDE0IHwgMDtcbiAgICB4MTIgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMiArIHgxNSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4MTIgfCAwO1xuICAgIHgxNCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTQgKyB4MTMgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuICB9XG4gICB4MCA9ICB4MCArICBqMCB8IDA7XG4gICB4MSA9ICB4MSArICBqMSB8IDA7XG4gICB4MiA9ICB4MiArICBqMiB8IDA7XG4gICB4MyA9ICB4MyArICBqMyB8IDA7XG4gICB4NCA9ICB4NCArICBqNCB8IDA7XG4gICB4NSA9ICB4NSArICBqNSB8IDA7XG4gICB4NiA9ICB4NiArICBqNiB8IDA7XG4gICB4NyA9ICB4NyArICBqNyB8IDA7XG4gICB4OCA9ICB4OCArICBqOCB8IDA7XG4gICB4OSA9ICB4OSArICBqOSB8IDA7XG4gIHgxMCA9IHgxMCArIGoxMCB8IDA7XG4gIHgxMSA9IHgxMSArIGoxMSB8IDA7XG4gIHgxMiA9IHgxMiArIGoxMiB8IDA7XG4gIHgxMyA9IHgxMyArIGoxMyB8IDA7XG4gIHgxNCA9IHgxNCArIGoxNCB8IDA7XG4gIHgxNSA9IHgxNSArIGoxNSB8IDA7XG5cbiAgb1sgMF0gPSB4MCA+Pj4gIDAgJiAweGZmO1xuICBvWyAxXSA9IHgwID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDJdID0geDAgPj4+IDE2ICYgMHhmZjtcbiAgb1sgM10gPSB4MCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDRdID0geDEgPj4+ICAwICYgMHhmZjtcbiAgb1sgNV0gPSB4MSA+Pj4gIDggJiAweGZmO1xuICBvWyA2XSA9IHgxID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDddID0geDEgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA4XSA9IHgyID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDldID0geDIgPj4+ICA4ICYgMHhmZjtcbiAgb1sxMF0gPSB4MiA+Pj4gMTYgJiAweGZmO1xuICBvWzExXSA9IHgyID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxMl0gPSB4MyA+Pj4gIDAgJiAweGZmO1xuICBvWzEzXSA9IHgzID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTRdID0geDMgPj4+IDE2ICYgMHhmZjtcbiAgb1sxNV0gPSB4MyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTZdID0geDQgPj4+ICAwICYgMHhmZjtcbiAgb1sxN10gPSB4NCA+Pj4gIDggJiAweGZmO1xuICBvWzE4XSA9IHg0ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTldID0geDQgPj4+IDI0ICYgMHhmZjtcblxuICBvWzIwXSA9IHg1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjFdID0geDUgPj4+ICA4ICYgMHhmZjtcbiAgb1syMl0gPSB4NSA+Pj4gMTYgJiAweGZmO1xuICBvWzIzXSA9IHg1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syNF0gPSB4NiA+Pj4gIDAgJiAweGZmO1xuICBvWzI1XSA9IHg2ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjZdID0geDYgPj4+IDE2ICYgMHhmZjtcbiAgb1syN10gPSB4NiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjhdID0geDcgPj4+ICAwICYgMHhmZjtcbiAgb1syOV0gPSB4NyA+Pj4gIDggJiAweGZmO1xuICBvWzMwXSA9IHg3ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzFdID0geDcgPj4+IDI0ICYgMHhmZjtcblxuICBvWzMyXSA9IHg4ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMzNdID0geDggPj4+ICA4ICYgMHhmZjtcbiAgb1szNF0gPSB4OCA+Pj4gMTYgJiAweGZmO1xuICBvWzM1XSA9IHg4ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1szNl0gPSB4OSA+Pj4gIDAgJiAweGZmO1xuICBvWzM3XSA9IHg5ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzhdID0geDkgPj4+IDE2ICYgMHhmZjtcbiAgb1szOV0gPSB4OSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDBdID0geDEwID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDFdID0geDEwID4+PiAgOCAmIDB4ZmY7XG4gIG9bNDJdID0geDEwID4+PiAxNiAmIDB4ZmY7XG4gIG9bNDNdID0geDEwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0NF0gPSB4MTEgPj4+ICAwICYgMHhmZjtcbiAgb1s0NV0gPSB4MTEgPj4+ICA4ICYgMHhmZjtcbiAgb1s0Nl0gPSB4MTEgPj4+IDE2ICYgMHhmZjtcbiAgb1s0N10gPSB4MTEgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQ4XSA9IHgxMiA+Pj4gIDAgJiAweGZmO1xuICBvWzQ5XSA9IHgxMiA+Pj4gIDggJiAweGZmO1xuICBvWzUwXSA9IHgxMiA+Pj4gMTYgJiAweGZmO1xuICBvWzUxXSA9IHgxMiA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNTJdID0geDEzID4+PiAgMCAmIDB4ZmY7XG4gIG9bNTNdID0geDEzID4+PiAgOCAmIDB4ZmY7XG4gIG9bNTRdID0geDEzID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTVdID0geDEzID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s1Nl0gPSB4MTQgPj4+ICAwICYgMHhmZjtcbiAgb1s1N10gPSB4MTQgPj4+ICA4ICYgMHhmZjtcbiAgb1s1OF0gPSB4MTQgPj4+IDE2ICYgMHhmZjtcbiAgb1s1OV0gPSB4MTQgPj4+IDI0ICYgMHhmZjtcblxuICBvWzYwXSA9IHgxNSA+Pj4gIDAgJiAweGZmO1xuICBvWzYxXSA9IHgxNSA+Pj4gIDggJiAweGZmO1xuICBvWzYyXSA9IHgxNSA+Pj4gMTYgJiAweGZmO1xuICBvWzYzXSA9IHgxNSA+Pj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiBjb3JlX2hzYWxzYTIwKG8scCxrLGMpIHtcbiAgdmFyIGowICA9IGNbIDBdICYgMHhmZiB8IChjWyAxXSAmIDB4ZmYpPDw4IHwgKGNbIDJdICYgMHhmZik8PDE2IHwgKGNbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajEgID0ga1sgMF0gJiAweGZmIHwgKGtbIDFdICYgMHhmZik8PDggfCAoa1sgMl0gJiAweGZmKTw8MTYgfCAoa1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMiAgPSBrWyA0XSAmIDB4ZmYgfCAoa1sgNV0gJiAweGZmKTw8OCB8IChrWyA2XSAmIDB4ZmYpPDwxNiB8IChrWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGozICA9IGtbIDhdICYgMHhmZiB8IChrWyA5XSAmIDB4ZmYpPDw4IHwgKGtbMTBdICYgMHhmZik8PDE2IHwgKGtbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajQgID0ga1sxMl0gJiAweGZmIHwgKGtbMTNdICYgMHhmZik8PDggfCAoa1sxNF0gJiAweGZmKTw8MTYgfCAoa1sxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqNSAgPSBjWyA0XSAmIDB4ZmYgfCAoY1sgNV0gJiAweGZmKTw8OCB8IChjWyA2XSAmIDB4ZmYpPDwxNiB8IChjWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo2ICA9IHBbIDBdICYgMHhmZiB8IChwWyAxXSAmIDB4ZmYpPDw4IHwgKHBbIDJdICYgMHhmZik8PDE2IHwgKHBbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajcgID0gcFsgNF0gJiAweGZmIHwgKHBbIDVdICYgMHhmZik8PDggfCAocFsgNl0gJiAweGZmKTw8MTYgfCAocFsgN10gJiAweGZmKTw8MjQsXG4gICAgICBqOCAgPSBwWyA4XSAmIDB4ZmYgfCAocFsgOV0gJiAweGZmKTw8OCB8IChwWzEwXSAmIDB4ZmYpPDwxNiB8IChwWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo5ICA9IHBbMTJdICYgMHhmZiB8IChwWzEzXSAmIDB4ZmYpPDw4IHwgKHBbMTRdICYgMHhmZik8PDE2IHwgKHBbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajEwID0gY1sgOF0gJiAweGZmIHwgKGNbIDldICYgMHhmZik8PDggfCAoY1sxMF0gJiAweGZmKTw8MTYgfCAoY1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTEgPSBrWzE2XSAmIDB4ZmYgfCAoa1sxN10gJiAweGZmKTw8OCB8IChrWzE4XSAmIDB4ZmYpPDwxNiB8IChrWzE5XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMiA9IGtbMjBdICYgMHhmZiB8IChrWzIxXSAmIDB4ZmYpPDw4IHwgKGtbMjJdICYgMHhmZik8PDE2IHwgKGtbMjNdICYgMHhmZik8PDI0LFxuICAgICAgajEzID0ga1syNF0gJiAweGZmIHwgKGtbMjVdICYgMHhmZik8PDggfCAoa1syNl0gJiAweGZmKTw8MTYgfCAoa1syN10gJiAweGZmKTw8MjQsXG4gICAgICBqMTQgPSBrWzI4XSAmIDB4ZmYgfCAoa1syOV0gJiAweGZmKTw8OCB8IChrWzMwXSAmIDB4ZmYpPDwxNiB8IChrWzMxXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNSA9IGNbMTJdICYgMHhmZiB8IChjWzEzXSAmIDB4ZmYpPDw4IHwgKGNbMTRdICYgMHhmZik8PDE2IHwgKGNbMTVdICYgMHhmZik8PDI0O1xuXG4gIHZhciB4MCA9IGowLCB4MSA9IGoxLCB4MiA9IGoyLCB4MyA9IGozLCB4NCA9IGo0LCB4NSA9IGo1LCB4NiA9IGo2LCB4NyA9IGo3LFxuICAgICAgeDggPSBqOCwgeDkgPSBqOSwgeDEwID0gajEwLCB4MTEgPSBqMTEsIHgxMiA9IGoxMiwgeDEzID0gajEzLCB4MTQgPSBqMTQsXG4gICAgICB4MTUgPSBqMTUsIHU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSArPSAyKSB7XG4gICAgdSA9IHgwICsgeDEyIHwgMDtcbiAgICB4NCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDQgKyB4MCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDQgfCAwO1xuICAgIHgxMiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTIgKyB4OCB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHgxIHwgMDtcbiAgICB4OSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDkgKyB4NSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4OSB8IDA7XG4gICAgeDEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEgKyB4MTMgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDYgfCAwO1xuICAgIHgxNCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDE0ICsgeDEwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MTQgfCAwO1xuICAgIHg2IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg2ICsgeDIgfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxMSB8IDA7XG4gICAgeDMgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgzICsgeDE1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4MyB8IDA7XG4gICAgeDExIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMSArIHg3IHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MCArIHgzIHwgMDtcbiAgICB4MSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEgKyB4MCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDEgfCAwO1xuICAgIHgzIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgzICsgeDIgfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4NCB8IDA7XG4gICAgeDYgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg2ICsgeDUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHg2IHwgMDtcbiAgICB4NCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NCArIHg3IHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg5IHwgMDtcbiAgICB4MTEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMSArIHgxMCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDExIHwgMDtcbiAgICB4OSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4OSArIHg4IHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTQgfCAwO1xuICAgIHgxMiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEyICsgeDE1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHgxMiB8IDA7XG4gICAgeDE0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxNCArIHgxMyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG4gIH1cblxuICBvWyAwXSA9IHgwID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDFdID0geDAgPj4+ICA4ICYgMHhmZjtcbiAgb1sgMl0gPSB4MCA+Pj4gMTYgJiAweGZmO1xuICBvWyAzXSA9IHgwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgNF0gPSB4NSA+Pj4gIDAgJiAweGZmO1xuICBvWyA1XSA9IHg1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDZdID0geDUgPj4+IDE2ICYgMHhmZjtcbiAgb1sgN10gPSB4NSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDhdID0geDEwID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDldID0geDEwID4+PiAgOCAmIDB4ZmY7XG4gIG9bMTBdID0geDEwID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTFdID0geDEwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxMl0gPSB4MTUgPj4+ICAwICYgMHhmZjtcbiAgb1sxM10gPSB4MTUgPj4+ICA4ICYgMHhmZjtcbiAgb1sxNF0gPSB4MTUgPj4+IDE2ICYgMHhmZjtcbiAgb1sxNV0gPSB4MTUgPj4+IDI0ICYgMHhmZjtcblxuICBvWzE2XSA9IHg2ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTddID0geDYgPj4+ICA4ICYgMHhmZjtcbiAgb1sxOF0gPSB4NiA+Pj4gMTYgJiAweGZmO1xuICBvWzE5XSA9IHg2ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syMF0gPSB4NyA+Pj4gIDAgJiAweGZmO1xuICBvWzIxXSA9IHg3ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjJdID0geDcgPj4+IDE2ICYgMHhmZjtcbiAgb1syM10gPSB4NyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjRdID0geDggPj4+ICAwICYgMHhmZjtcbiAgb1syNV0gPSB4OCA+Pj4gIDggJiAweGZmO1xuICBvWzI2XSA9IHg4ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjddID0geDggPj4+IDI0ICYgMHhmZjtcblxuICBvWzI4XSA9IHg5ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjldID0geDkgPj4+ICA4ICYgMHhmZjtcbiAgb1szMF0gPSB4OSA+Pj4gMTYgJiAweGZmO1xuICBvWzMxXSA9IHg5ID4+PiAyNCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19jb3JlX3NhbHNhMjAob3V0LGlucCxrLGMpIHtcbiAgY29yZV9zYWxzYTIwKG91dCxpbnAsayxjKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2NvcmVfaHNhbHNhMjAob3V0LGlucCxrLGMpIHtcbiAgY29yZV9oc2Fsc2EyMChvdXQsaW5wLGssYyk7XG59XG5cbnZhciBzaWdtYSA9IG5ldyBVaW50OEFycmF5KFsxMDEsIDEyMCwgMTEyLCA5NywgMTEwLCAxMDAsIDMyLCA1MSwgNTAsIDQ1LCA5OCwgMTIxLCAxMTYsIDEwMSwgMzIsIDEwN10pO1xuICAgICAgICAgICAgLy8gXCJleHBhbmQgMzItYnl0ZSBrXCJcblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcihjLGNwb3MsbSxtcG9zLGIsbixrKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCB4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgdSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHpbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB6W2ldID0gbltpXTtcbiAgd2hpbGUgKGIgPj0gNjQpIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgY1tjcG9zK2ldID0gbVttcG9zK2ldIF4geFtpXTtcbiAgICB1ID0gMTtcbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrKykge1xuICAgICAgdSA9IHUgKyAoeltpXSAmIDB4ZmYpIHwgMDtcbiAgICAgIHpbaV0gPSB1ICYgMHhmZjtcbiAgICAgIHUgPj4+PSA4O1xuICAgIH1cbiAgICBiIC09IDY0O1xuICAgIGNwb3MgKz0gNjQ7XG4gICAgbXBvcyArPSA2NDtcbiAgfVxuICBpZiAoYiA+IDApIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYjsgaSsrKSBjW2Nwb3MraV0gPSBtW21wb3MraV0gXiB4W2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAoYyxjcG9zLGIsbixrKSB7XG4gIHZhciB6ID0gbmV3IFVpbnQ4QXJyYXkoMTYpLCB4ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgdSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHpbaV0gPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB6W2ldID0gbltpXTtcbiAgd2hpbGUgKGIgPj0gNjQpIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgY1tjcG9zK2ldID0geFtpXTtcbiAgICB1ID0gMTtcbiAgICBmb3IgKGkgPSA4OyBpIDwgMTY7IGkrKykge1xuICAgICAgdSA9IHUgKyAoeltpXSAmIDB4ZmYpIHwgMDtcbiAgICAgIHpbaV0gPSB1ICYgMHhmZjtcbiAgICAgIHUgPj4+PSA4O1xuICAgIH1cbiAgICBiIC09IDY0O1xuICAgIGNwb3MgKz0gNjQ7XG4gIH1cbiAgaWYgKGIgPiAwKSB7XG4gICAgY3J5cHRvX2NvcmVfc2Fsc2EyMCh4LHosayxzaWdtYSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGI7IGkrKykgY1tjcG9zK2ldID0geFtpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbShjLGNwb3MsZCxuLGspIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsbixrLHNpZ21hKTtcbiAgdmFyIHNuID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBzbltpXSA9IG5baSsxNl07XG4gIHJldHVybiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAoYyxjcG9zLGQsc24scyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1feG9yKGMsY3BvcyxtLG1wb3MsZCxuLGspIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19jb3JlX2hzYWxzYTIwKHMsbixrLHNpZ21hKTtcbiAgdmFyIHNuID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSBzbltpXSA9IG5baSsxNl07XG4gIHJldHVybiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yKGMsY3BvcyxtLG1wb3MsZCxzbixzKTtcbn1cblxuLypcbiogUG9ydCBvZiBBbmRyZXcgTW9vbidzIFBvbHkxMzA1LWRvbm5hLTE2LiBQdWJsaWMgZG9tYWluLlxuKiBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmFcbiovXG5cbnZhciBwb2x5MTMwNSA9IGZ1bmN0aW9uKGtleSkge1xuICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgdGhpcy5yID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdGhpcy5oID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgdGhpcy5wYWQgPSBuZXcgVWludDE2QXJyYXkoOCk7XG4gIHRoaXMubGVmdG92ZXIgPSAwO1xuICB0aGlzLmZpbiA9IDA7XG5cbiAgdmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDUsIHQ2LCB0NztcblxuICB0MCA9IGtleVsgMF0gJiAweGZmIHwgKGtleVsgMV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbMF0gPSAoIHQwICAgICAgICAgICAgICAgICAgICAgKSAmIDB4MWZmZjtcbiAgdDEgPSBrZXlbIDJdICYgMHhmZiB8IChrZXlbIDNdICYgMHhmZikgPDwgODsgdGhpcy5yWzFdID0gKCh0MCA+Pj4gMTMpIHwgKHQxIDw8ICAzKSkgJiAweDFmZmY7XG4gIHQyID0ga2V5WyA0XSAmIDB4ZmYgfCAoa2V5WyA1XSAmIDB4ZmYpIDw8IDg7IHRoaXMuclsyXSA9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCAgNikpICYgMHgxZjAzO1xuICB0MyA9IGtleVsgNl0gJiAweGZmIHwgKGtleVsgN10gJiAweGZmKSA8PCA4OyB0aGlzLnJbM10gPSAoKHQyID4+PiAgNykgfCAodDMgPDwgIDkpKSAmIDB4MWZmZjtcbiAgdDQgPSBrZXlbIDhdICYgMHhmZiB8IChrZXlbIDldICYgMHhmZikgPDwgODsgdGhpcy5yWzRdID0gKCh0MyA+Pj4gIDQpIHwgKHQ0IDw8IDEyKSkgJiAweDAwZmY7XG4gIHRoaXMucls1XSA9ICgodDQgPj4+ICAxKSkgJiAweDFmZmU7XG4gIHQ1ID0ga2V5WzEwXSAmIDB4ZmYgfCAoa2V5WzExXSAmIDB4ZmYpIDw8IDg7IHRoaXMucls2XSA9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAgMikpICYgMHgxZmZmO1xuICB0NiA9IGtleVsxMl0gJiAweGZmIHwgKGtleVsxM10gJiAweGZmKSA8PCA4OyB0aGlzLnJbN10gPSAoKHQ1ID4+PiAxMSkgfCAodDYgPDwgIDUpKSAmIDB4MWY4MTtcbiAgdDcgPSBrZXlbMTRdICYgMHhmZiB8IChrZXlbMTVdICYgMHhmZikgPDwgODsgdGhpcy5yWzhdID0gKCh0NiA+Pj4gIDgpIHwgKHQ3IDw8ICA4KSkgJiAweDFmZmY7XG4gIHRoaXMucls5XSA9ICgodDcgPj4+ICA1KSkgJiAweDAwN2Y7XG5cbiAgdGhpcy5wYWRbMF0gPSBrZXlbMTZdICYgMHhmZiB8IChrZXlbMTddICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbMV0gPSBrZXlbMThdICYgMHhmZiB8IChrZXlbMTldICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbMl0gPSBrZXlbMjBdICYgMHhmZiB8IChrZXlbMjFdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbM10gPSBrZXlbMjJdICYgMHhmZiB8IChrZXlbMjNdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNF0gPSBrZXlbMjRdICYgMHhmZiB8IChrZXlbMjVdICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNV0gPSBrZXlbMjZdICYgMHhmZiB8IChrZXlbMjddICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbNl0gPSBrZXlbMjhdICYgMHhmZiB8IChrZXlbMjldICYgMHhmZikgPDwgODtcbiAgdGhpcy5wYWRbN10gPSBrZXlbMzBdICYgMHhmZiB8IChrZXlbMzFdICYgMHhmZikgPDwgODtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS5ibG9ja3MgPSBmdW5jdGlvbihtLCBtcG9zLCBieXRlcykge1xuICB2YXIgaGliaXQgPSB0aGlzLmZpbiA/IDAgOiAoMSA8PCAxMSk7XG4gIHZhciB0MCwgdDEsIHQyLCB0MywgdDQsIHQ1LCB0NiwgdDcsIGM7XG4gIHZhciBkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOTtcblxuICB2YXIgaDAgPSB0aGlzLmhbMF0sXG4gICAgICBoMSA9IHRoaXMuaFsxXSxcbiAgICAgIGgyID0gdGhpcy5oWzJdLFxuICAgICAgaDMgPSB0aGlzLmhbM10sXG4gICAgICBoNCA9IHRoaXMuaFs0XSxcbiAgICAgIGg1ID0gdGhpcy5oWzVdLFxuICAgICAgaDYgPSB0aGlzLmhbNl0sXG4gICAgICBoNyA9IHRoaXMuaFs3XSxcbiAgICAgIGg4ID0gdGhpcy5oWzhdLFxuICAgICAgaDkgPSB0aGlzLmhbOV07XG5cbiAgdmFyIHIwID0gdGhpcy5yWzBdLFxuICAgICAgcjEgPSB0aGlzLnJbMV0sXG4gICAgICByMiA9IHRoaXMuclsyXSxcbiAgICAgIHIzID0gdGhpcy5yWzNdLFxuICAgICAgcjQgPSB0aGlzLnJbNF0sXG4gICAgICByNSA9IHRoaXMucls1XSxcbiAgICAgIHI2ID0gdGhpcy5yWzZdLFxuICAgICAgcjcgPSB0aGlzLnJbN10sXG4gICAgICByOCA9IHRoaXMucls4XSxcbiAgICAgIHI5ID0gdGhpcy5yWzldO1xuXG4gIHdoaWxlIChieXRlcyA+PSAxNikge1xuICAgIHQwID0gbVttcG9zKyAwXSAmIDB4ZmYgfCAobVttcG9zKyAxXSAmIDB4ZmYpIDw8IDg7IGgwICs9ICggdDAgICAgICAgICAgICAgICAgICAgICApICYgMHgxZmZmO1xuICAgIHQxID0gbVttcG9zKyAyXSAmIDB4ZmYgfCAobVttcG9zKyAzXSAmIDB4ZmYpIDw8IDg7IGgxICs9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAgMykpICYgMHgxZmZmO1xuICAgIHQyID0gbVttcG9zKyA0XSAmIDB4ZmYgfCAobVttcG9zKyA1XSAmIDB4ZmYpIDw8IDg7IGgyICs9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCAgNikpICYgMHgxZmZmO1xuICAgIHQzID0gbVttcG9zKyA2XSAmIDB4ZmYgfCAobVttcG9zKyA3XSAmIDB4ZmYpIDw8IDg7IGgzICs9ICgodDIgPj4+ICA3KSB8ICh0MyA8PCAgOSkpICYgMHgxZmZmO1xuICAgIHQ0ID0gbVttcG9zKyA4XSAmIDB4ZmYgfCAobVttcG9zKyA5XSAmIDB4ZmYpIDw8IDg7IGg0ICs9ICgodDMgPj4+ICA0KSB8ICh0NCA8PCAxMikpICYgMHgxZmZmO1xuICAgIGg1ICs9ICgodDQgPj4+ICAxKSkgJiAweDFmZmY7XG4gICAgdDUgPSBtW21wb3MrMTBdICYgMHhmZiB8IChtW21wb3MrMTFdICYgMHhmZikgPDwgODsgaDYgKz0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8ICAyKSkgJiAweDFmZmY7XG4gICAgdDYgPSBtW21wb3MrMTJdICYgMHhmZiB8IChtW21wb3MrMTNdICYgMHhmZikgPDwgODsgaDcgKz0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8ICA1KSkgJiAweDFmZmY7XG4gICAgdDcgPSBtW21wb3MrMTRdICYgMHhmZiB8IChtW21wb3MrMTVdICYgMHhmZikgPDwgODsgaDggKz0gKCh0NiA+Pj4gIDgpIHwgKHQ3IDw8ICA4KSkgJiAweDFmZmY7XG4gICAgaDkgKz0gKCh0NyA+Pj4gNSkpIHwgaGliaXQ7XG5cbiAgICBjID0gMDtcblxuICAgIGQwID0gYztcbiAgICBkMCArPSBoMCAqIHIwO1xuICAgIGQwICs9IGgxICogKDUgKiByOSk7XG4gICAgZDAgKz0gaDIgKiAoNSAqIHI4KTtcbiAgICBkMCArPSBoMyAqICg1ICogcjcpO1xuICAgIGQwICs9IGg0ICogKDUgKiByNik7XG4gICAgYyA9IChkMCA+Pj4gMTMpOyBkMCAmPSAweDFmZmY7XG4gICAgZDAgKz0gaDUgKiAoNSAqIHI1KTtcbiAgICBkMCArPSBoNiAqICg1ICogcjQpO1xuICAgIGQwICs9IGg3ICogKDUgKiByMyk7XG4gICAgZDAgKz0gaDggKiAoNSAqIHIyKTtcbiAgICBkMCArPSBoOSAqICg1ICogcjEpO1xuICAgIGMgKz0gKGQwID4+PiAxMyk7IGQwICY9IDB4MWZmZjtcblxuICAgIGQxID0gYztcbiAgICBkMSArPSBoMCAqIHIxO1xuICAgIGQxICs9IGgxICogcjA7XG4gICAgZDEgKz0gaDIgKiAoNSAqIHI5KTtcbiAgICBkMSArPSBoMyAqICg1ICogcjgpO1xuICAgIGQxICs9IGg0ICogKDUgKiByNyk7XG4gICAgYyA9IChkMSA+Pj4gMTMpOyBkMSAmPSAweDFmZmY7XG4gICAgZDEgKz0gaDUgKiAoNSAqIHI2KTtcbiAgICBkMSArPSBoNiAqICg1ICogcjUpO1xuICAgIGQxICs9IGg3ICogKDUgKiByNCk7XG4gICAgZDEgKz0gaDggKiAoNSAqIHIzKTtcbiAgICBkMSArPSBoOSAqICg1ICogcjIpO1xuICAgIGMgKz0gKGQxID4+PiAxMyk7IGQxICY9IDB4MWZmZjtcblxuICAgIGQyID0gYztcbiAgICBkMiArPSBoMCAqIHIyO1xuICAgIGQyICs9IGgxICogcjE7XG4gICAgZDIgKz0gaDIgKiByMDtcbiAgICBkMiArPSBoMyAqICg1ICogcjkpO1xuICAgIGQyICs9IGg0ICogKDUgKiByOCk7XG4gICAgYyA9IChkMiA+Pj4gMTMpOyBkMiAmPSAweDFmZmY7XG4gICAgZDIgKz0gaDUgKiAoNSAqIHI3KTtcbiAgICBkMiArPSBoNiAqICg1ICogcjYpO1xuICAgIGQyICs9IGg3ICogKDUgKiByNSk7XG4gICAgZDIgKz0gaDggKiAoNSAqIHI0KTtcbiAgICBkMiArPSBoOSAqICg1ICogcjMpO1xuICAgIGMgKz0gKGQyID4+PiAxMyk7IGQyICY9IDB4MWZmZjtcblxuICAgIGQzID0gYztcbiAgICBkMyArPSBoMCAqIHIzO1xuICAgIGQzICs9IGgxICogcjI7XG4gICAgZDMgKz0gaDIgKiByMTtcbiAgICBkMyArPSBoMyAqIHIwO1xuICAgIGQzICs9IGg0ICogKDUgKiByOSk7XG4gICAgYyA9IChkMyA+Pj4gMTMpOyBkMyAmPSAweDFmZmY7XG4gICAgZDMgKz0gaDUgKiAoNSAqIHI4KTtcbiAgICBkMyArPSBoNiAqICg1ICogcjcpO1xuICAgIGQzICs9IGg3ICogKDUgKiByNik7XG4gICAgZDMgKz0gaDggKiAoNSAqIHI1KTtcbiAgICBkMyArPSBoOSAqICg1ICogcjQpO1xuICAgIGMgKz0gKGQzID4+PiAxMyk7IGQzICY9IDB4MWZmZjtcblxuICAgIGQ0ID0gYztcbiAgICBkNCArPSBoMCAqIHI0O1xuICAgIGQ0ICs9IGgxICogcjM7XG4gICAgZDQgKz0gaDIgKiByMjtcbiAgICBkNCArPSBoMyAqIHIxO1xuICAgIGQ0ICs9IGg0ICogcjA7XG4gICAgYyA9IChkNCA+Pj4gMTMpOyBkNCAmPSAweDFmZmY7XG4gICAgZDQgKz0gaDUgKiAoNSAqIHI5KTtcbiAgICBkNCArPSBoNiAqICg1ICogcjgpO1xuICAgIGQ0ICs9IGg3ICogKDUgKiByNyk7XG4gICAgZDQgKz0gaDggKiAoNSAqIHI2KTtcbiAgICBkNCArPSBoOSAqICg1ICogcjUpO1xuICAgIGMgKz0gKGQ0ID4+PiAxMyk7IGQ0ICY9IDB4MWZmZjtcblxuICAgIGQ1ID0gYztcbiAgICBkNSArPSBoMCAqIHI1O1xuICAgIGQ1ICs9IGgxICogcjQ7XG4gICAgZDUgKz0gaDIgKiByMztcbiAgICBkNSArPSBoMyAqIHIyO1xuICAgIGQ1ICs9IGg0ICogcjE7XG4gICAgYyA9IChkNSA+Pj4gMTMpOyBkNSAmPSAweDFmZmY7XG4gICAgZDUgKz0gaDUgKiByMDtcbiAgICBkNSArPSBoNiAqICg1ICogcjkpO1xuICAgIGQ1ICs9IGg3ICogKDUgKiByOCk7XG4gICAgZDUgKz0gaDggKiAoNSAqIHI3KTtcbiAgICBkNSArPSBoOSAqICg1ICogcjYpO1xuICAgIGMgKz0gKGQ1ID4+PiAxMyk7IGQ1ICY9IDB4MWZmZjtcblxuICAgIGQ2ID0gYztcbiAgICBkNiArPSBoMCAqIHI2O1xuICAgIGQ2ICs9IGgxICogcjU7XG4gICAgZDYgKz0gaDIgKiByNDtcbiAgICBkNiArPSBoMyAqIHIzO1xuICAgIGQ2ICs9IGg0ICogcjI7XG4gICAgYyA9IChkNiA+Pj4gMTMpOyBkNiAmPSAweDFmZmY7XG4gICAgZDYgKz0gaDUgKiByMTtcbiAgICBkNiArPSBoNiAqIHIwO1xuICAgIGQ2ICs9IGg3ICogKDUgKiByOSk7XG4gICAgZDYgKz0gaDggKiAoNSAqIHI4KTtcbiAgICBkNiArPSBoOSAqICg1ICogcjcpO1xuICAgIGMgKz0gKGQ2ID4+PiAxMyk7IGQ2ICY9IDB4MWZmZjtcblxuICAgIGQ3ID0gYztcbiAgICBkNyArPSBoMCAqIHI3O1xuICAgIGQ3ICs9IGgxICogcjY7XG4gICAgZDcgKz0gaDIgKiByNTtcbiAgICBkNyArPSBoMyAqIHI0O1xuICAgIGQ3ICs9IGg0ICogcjM7XG4gICAgYyA9IChkNyA+Pj4gMTMpOyBkNyAmPSAweDFmZmY7XG4gICAgZDcgKz0gaDUgKiByMjtcbiAgICBkNyArPSBoNiAqIHIxO1xuICAgIGQ3ICs9IGg3ICogcjA7XG4gICAgZDcgKz0gaDggKiAoNSAqIHI5KTtcbiAgICBkNyArPSBoOSAqICg1ICogcjgpO1xuICAgIGMgKz0gKGQ3ID4+PiAxMyk7IGQ3ICY9IDB4MWZmZjtcblxuICAgIGQ4ID0gYztcbiAgICBkOCArPSBoMCAqIHI4O1xuICAgIGQ4ICs9IGgxICogcjc7XG4gICAgZDggKz0gaDIgKiByNjtcbiAgICBkOCArPSBoMyAqIHI1O1xuICAgIGQ4ICs9IGg0ICogcjQ7XG4gICAgYyA9IChkOCA+Pj4gMTMpOyBkOCAmPSAweDFmZmY7XG4gICAgZDggKz0gaDUgKiByMztcbiAgICBkOCArPSBoNiAqIHIyO1xuICAgIGQ4ICs9IGg3ICogcjE7XG4gICAgZDggKz0gaDggKiByMDtcbiAgICBkOCArPSBoOSAqICg1ICogcjkpO1xuICAgIGMgKz0gKGQ4ID4+PiAxMyk7IGQ4ICY9IDB4MWZmZjtcblxuICAgIGQ5ID0gYztcbiAgICBkOSArPSBoMCAqIHI5O1xuICAgIGQ5ICs9IGgxICogcjg7XG4gICAgZDkgKz0gaDIgKiByNztcbiAgICBkOSArPSBoMyAqIHI2O1xuICAgIGQ5ICs9IGg0ICogcjU7XG4gICAgYyA9IChkOSA+Pj4gMTMpOyBkOSAmPSAweDFmZmY7XG4gICAgZDkgKz0gaDUgKiByNDtcbiAgICBkOSArPSBoNiAqIHIzO1xuICAgIGQ5ICs9IGg3ICogcjI7XG4gICAgZDkgKz0gaDggKiByMTtcbiAgICBkOSArPSBoOSAqIHIwO1xuICAgIGMgKz0gKGQ5ID4+PiAxMyk7IGQ5ICY9IDB4MWZmZjtcblxuICAgIGMgPSAoKChjIDw8IDIpICsgYykpIHwgMDtcbiAgICBjID0gKGMgKyBkMCkgfCAwO1xuICAgIGQwID0gYyAmIDB4MWZmZjtcbiAgICBjID0gKGMgPj4+IDEzKTtcbiAgICBkMSArPSBjO1xuXG4gICAgaDAgPSBkMDtcbiAgICBoMSA9IGQxO1xuICAgIGgyID0gZDI7XG4gICAgaDMgPSBkMztcbiAgICBoNCA9IGQ0O1xuICAgIGg1ID0gZDU7XG4gICAgaDYgPSBkNjtcbiAgICBoNyA9IGQ3O1xuICAgIGg4ID0gZDg7XG4gICAgaDkgPSBkOTtcblxuICAgIG1wb3MgKz0gMTY7XG4gICAgYnl0ZXMgLT0gMTY7XG4gIH1cbiAgdGhpcy5oWzBdID0gaDA7XG4gIHRoaXMuaFsxXSA9IGgxO1xuICB0aGlzLmhbMl0gPSBoMjtcbiAgdGhpcy5oWzNdID0gaDM7XG4gIHRoaXMuaFs0XSA9IGg0O1xuICB0aGlzLmhbNV0gPSBoNTtcbiAgdGhpcy5oWzZdID0gaDY7XG4gIHRoaXMuaFs3XSA9IGg3O1xuICB0aGlzLmhbOF0gPSBoODtcbiAgdGhpcy5oWzldID0gaDk7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24obWFjLCBtYWNwb3MpIHtcbiAgdmFyIGcgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB2YXIgYywgbWFzaywgZiwgaTtcblxuICBpZiAodGhpcy5sZWZ0b3Zlcikge1xuICAgIGkgPSB0aGlzLmxlZnRvdmVyO1xuICAgIHRoaXMuYnVmZmVyW2krK10gPSAxO1xuICAgIGZvciAoOyBpIDwgMTY7IGkrKykgdGhpcy5idWZmZXJbaV0gPSAwO1xuICAgIHRoaXMuZmluID0gMTtcbiAgICB0aGlzLmJsb2Nrcyh0aGlzLmJ1ZmZlciwgMCwgMTYpO1xuICB9XG5cbiAgYyA9IHRoaXMuaFsxXSA+Pj4gMTM7XG4gIHRoaXMuaFsxXSAmPSAweDFmZmY7XG4gIGZvciAoaSA9IDI7IGkgPCAxMDsgaSsrKSB7XG4gICAgdGhpcy5oW2ldICs9IGM7XG4gICAgYyA9IHRoaXMuaFtpXSA+Pj4gMTM7XG4gICAgdGhpcy5oW2ldICY9IDB4MWZmZjtcbiAgfVxuICB0aGlzLmhbMF0gKz0gKGMgKiA1KTtcbiAgYyA9IHRoaXMuaFswXSA+Pj4gMTM7XG4gIHRoaXMuaFswXSAmPSAweDFmZmY7XG4gIHRoaXMuaFsxXSArPSBjO1xuICBjID0gdGhpcy5oWzFdID4+PiAxMztcbiAgdGhpcy5oWzFdICY9IDB4MWZmZjtcbiAgdGhpcy5oWzJdICs9IGM7XG5cbiAgZ1swXSA9IHRoaXMuaFswXSArIDU7XG4gIGMgPSBnWzBdID4+PiAxMztcbiAgZ1swXSAmPSAweDFmZmY7XG4gIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgZ1tpXSA9IHRoaXMuaFtpXSArIGM7XG4gICAgYyA9IGdbaV0gPj4+IDEzO1xuICAgIGdbaV0gJj0gMHgxZmZmO1xuICB9XG4gIGdbOV0gLT0gKDEgPDwgMTMpO1xuXG4gIG1hc2sgPSAoYyBeIDEpIC0gMTtcbiAgZm9yIChpID0gMDsgaSA8IDEwOyBpKyspIGdbaV0gJj0gbWFzaztcbiAgbWFzayA9IH5tYXNrO1xuICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykgdGhpcy5oW2ldID0gKHRoaXMuaFtpXSAmIG1hc2spIHwgZ1tpXTtcblxuICB0aGlzLmhbMF0gPSAoKHRoaXMuaFswXSAgICAgICApIHwgKHRoaXMuaFsxXSA8PCAxMykgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFsxXSA9ICgodGhpcy5oWzFdID4+PiAgMykgfCAodGhpcy5oWzJdIDw8IDEwKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzJdID0gKCh0aGlzLmhbMl0gPj4+ICA2KSB8ICh0aGlzLmhbM10gPDwgIDcpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbM10gPSAoKHRoaXMuaFszXSA+Pj4gIDkpIHwgKHRoaXMuaFs0XSA8PCAgNCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs0XSA9ICgodGhpcy5oWzRdID4+PiAxMikgfCAodGhpcy5oWzVdIDw8ICAxKSB8ICh0aGlzLmhbNl0gPDwgMTQpKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzVdID0gKCh0aGlzLmhbNl0gPj4+ICAyKSB8ICh0aGlzLmhbN10gPDwgMTEpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbNl0gPSAoKHRoaXMuaFs3XSA+Pj4gIDUpIHwgKHRoaXMuaFs4XSA8PCAgOCkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs3XSA9ICgodGhpcy5oWzhdID4+PiAgOCkgfCAodGhpcy5oWzldIDw8ICA1KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcblxuICBmID0gdGhpcy5oWzBdICsgdGhpcy5wYWRbMF07XG4gIHRoaXMuaFswXSA9IGYgJiAweGZmZmY7XG4gIGZvciAoaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICBmID0gKCgodGhpcy5oW2ldICsgdGhpcy5wYWRbaV0pIHwgMCkgKyAoZiA+Pj4gMTYpKSB8IDA7XG4gICAgdGhpcy5oW2ldID0gZiAmIDB4ZmZmZjtcbiAgfVxuXG4gIG1hY1ttYWNwb3MrIDBdID0gKHRoaXMuaFswXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAxXSA9ICh0aGlzLmhbMF0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgMl0gPSAodGhpcy5oWzFdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDNdID0gKHRoaXMuaFsxXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA0XSA9ICh0aGlzLmhbMl0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNV0gPSAodGhpcy5oWzJdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDZdID0gKHRoaXMuaFszXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA3XSA9ICh0aGlzLmhbM10gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgOF0gPSAodGhpcy5oWzRdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDldID0gKHRoaXMuaFs0XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEwXSA9ICh0aGlzLmhbNV0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMV0gPSAodGhpcy5oWzVdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTJdID0gKHRoaXMuaFs2XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzEzXSA9ICh0aGlzLmhbNl0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxNF0gPSAodGhpcy5oWzddID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTVdID0gKHRoaXMuaFs3XSA+Pj4gOCkgJiAweGZmO1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG0sIG1wb3MsIGJ5dGVzKSB7XG4gIHZhciBpLCB3YW50O1xuXG4gIGlmICh0aGlzLmxlZnRvdmVyKSB7XG4gICAgd2FudCA9ICgxNiAtIHRoaXMubGVmdG92ZXIpO1xuICAgIGlmICh3YW50ID4gYnl0ZXMpXG4gICAgICB3YW50ID0gYnl0ZXM7XG4gICAgZm9yIChpID0gMDsgaSA8IHdhbnQ7IGkrKylcbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMubGVmdG92ZXIgKyBpXSA9IG1bbXBvcytpXTtcbiAgICBieXRlcyAtPSB3YW50O1xuICAgIG1wb3MgKz0gd2FudDtcbiAgICB0aGlzLmxlZnRvdmVyICs9IHdhbnQ7XG4gICAgaWYgKHRoaXMubGVmdG92ZXIgPCAxNilcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJsb2Nrcyh0aGlzLmJ1ZmZlciwgMCwgMTYpO1xuICAgIHRoaXMubGVmdG92ZXIgPSAwO1xuICB9XG5cbiAgaWYgKGJ5dGVzID49IDE2KSB7XG4gICAgd2FudCA9IGJ5dGVzIC0gKGJ5dGVzICUgMTYpO1xuICAgIHRoaXMuYmxvY2tzKG0sIG1wb3MsIHdhbnQpO1xuICAgIG1wb3MgKz0gd2FudDtcbiAgICBieXRlcyAtPSB3YW50O1xuICB9XG5cbiAgaWYgKGJ5dGVzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGJ5dGVzOyBpKyspXG4gICAgICB0aGlzLmJ1ZmZlclt0aGlzLmxlZnRvdmVyICsgaV0gPSBtW21wb3MraV07XG4gICAgdGhpcy5sZWZ0b3ZlciArPSBieXRlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoKG91dCwgb3V0cG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gIHZhciBzID0gbmV3IHBvbHkxMzA1KGspO1xuICBzLnVwZGF0ZShtLCBtcG9zLCBuKTtcbiAgcy5maW5pc2gob3V0LCBvdXRwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX29uZXRpbWVhdXRoX3ZlcmlmeShoLCBocG9zLCBtLCBtcG9zLCBuLCBrKSB7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBjcnlwdG9fb25ldGltZWF1dGgoeCwwLG0sbXBvcyxuLGspO1xuICByZXR1cm4gY3J5cHRvX3ZlcmlmeV8xNihoLGhwb3MseCwwKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveChjLG0sZCxuLGspIHtcbiAgdmFyIGk7XG4gIGlmIChkIDwgMzIpIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbV94b3IoYywwLG0sMCxkLG4sayk7XG4gIGNyeXB0b19vbmV0aW1lYXV0aChjLCAxNiwgYywgMzIsIGQgLSAzMiwgYyk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSBjW2ldID0gMDtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zZWNyZXRib3hfb3BlbihtLGMsZCxuLGspIHtcbiAgdmFyIGk7XG4gIHZhciB4ID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBpZiAoZCA8IDMyKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW0oeCwwLDMyLG4sayk7XG4gIGlmIChjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5KGMsIDE2LGMsIDMyLGQgLSAzMix4KSAhPT0gMCkgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtX3hvcihtLDAsYywwLGQsbixrKTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIG1baV0gPSAwO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gc2V0MjU1MTkociwgYSkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHJbaV0gPSBhW2ldfDA7XG59XG5cbmZ1bmN0aW9uIGNhcjI1NTE5KG8pIHtcbiAgdmFyIGksIHYsIGMgPSAxO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHYgPSBvW2ldICsgYyArIDY1NTM1O1xuICAgIGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7XG4gICAgb1tpXSA9IHYgLSBjICogNjU1MzY7XG4gIH1cbiAgb1swXSArPSBjLTEgKyAzNyAqIChjLTEpO1xufVxuXG5mdW5jdGlvbiBzZWwyNTUxOShwLCBxLCBiKSB7XG4gIHZhciB0LCBjID0gfihiLTEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB0ID0gYyAmIChwW2ldIF4gcVtpXSk7XG4gICAgcFtpXSBePSB0O1xuICAgIHFbaV0gXj0gdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWNrMjU1MTkobywgbikge1xuICB2YXIgaSwgaiwgYjtcbiAgdmFyIG0gPSBnZigpLCB0ID0gZ2YoKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHRbaV0gPSBuW2ldO1xuICBjYXIyNTUxOSh0KTtcbiAgY2FyMjU1MTkodCk7XG4gIGNhcjI1NTE5KHQpO1xuICBmb3IgKGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgbVswXSA9IHRbMF0gLSAweGZmZWQ7XG4gICAgZm9yIChpID0gMTsgaSA8IDE1OyBpKyspIHtcbiAgICAgIG1baV0gPSB0W2ldIC0gMHhmZmZmIC0gKChtW2ktMV0+PjE2KSAmIDEpO1xuICAgICAgbVtpLTFdICY9IDB4ZmZmZjtcbiAgICB9XG4gICAgbVsxNV0gPSB0WzE1XSAtIDB4N2ZmZiAtICgobVsxNF0+PjE2KSAmIDEpO1xuICAgIGIgPSAobVsxNV0+PjE2KSAmIDE7XG4gICAgbVsxNF0gJj0gMHhmZmZmO1xuICAgIHNlbDI1NTE5KHQsIG0sIDEtYik7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICBvWzIqaV0gPSB0W2ldICYgMHhmZjtcbiAgICBvWzIqaSsxXSA9IHRbaV0+Pjg7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVxMjU1MTkoYSwgYikge1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KDMyKSwgZCA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgcGFjazI1NTE5KGMsIGEpO1xuICBwYWNrMjU1MTkoZCwgYik7XG4gIHJldHVybiBjcnlwdG9fdmVyaWZ5XzMyKGMsIDAsIGQsIDApO1xufVxuXG5mdW5jdGlvbiBwYXIyNTUxOShhKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBwYWNrMjU1MTkoZCwgYSk7XG4gIHJldHVybiBkWzBdICYgMTtcbn1cblxuZnVuY3Rpb24gdW5wYWNrMjU1MTkobywgbikge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBuWzIqaV0gKyAoblsyKmkrMV0gPDwgOCk7XG4gIG9bMTVdICY9IDB4N2ZmZjtcbn1cblxuZnVuY3Rpb24gQShvLCBhLCBiKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IGFbaV0gKyBiW2ldO1xufVxuXG5mdW5jdGlvbiBaKG8sIGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gYVtpXSAtIGJbaV07XG59XG5cbmZ1bmN0aW9uIE0obywgYSwgYikge1xuICB2YXIgdiwgYyxcbiAgICAgdDAgPSAwLCAgdDEgPSAwLCAgdDIgPSAwLCAgdDMgPSAwLCAgdDQgPSAwLCAgdDUgPSAwLCAgdDYgPSAwLCAgdDcgPSAwLFxuICAgICB0OCA9IDAsICB0OSA9IDAsIHQxMCA9IDAsIHQxMSA9IDAsIHQxMiA9IDAsIHQxMyA9IDAsIHQxNCA9IDAsIHQxNSA9IDAsXG4gICAgdDE2ID0gMCwgdDE3ID0gMCwgdDE4ID0gMCwgdDE5ID0gMCwgdDIwID0gMCwgdDIxID0gMCwgdDIyID0gMCwgdDIzID0gMCxcbiAgICB0MjQgPSAwLCB0MjUgPSAwLCB0MjYgPSAwLCB0MjcgPSAwLCB0MjggPSAwLCB0MjkgPSAwLCB0MzAgPSAwLFxuICAgIGIwID0gYlswXSxcbiAgICBiMSA9IGJbMV0sXG4gICAgYjIgPSBiWzJdLFxuICAgIGIzID0gYlszXSxcbiAgICBiNCA9IGJbNF0sXG4gICAgYjUgPSBiWzVdLFxuICAgIGI2ID0gYls2XSxcbiAgICBiNyA9IGJbN10sXG4gICAgYjggPSBiWzhdLFxuICAgIGI5ID0gYls5XSxcbiAgICBiMTAgPSBiWzEwXSxcbiAgICBiMTEgPSBiWzExXSxcbiAgICBiMTIgPSBiWzEyXSxcbiAgICBiMTMgPSBiWzEzXSxcbiAgICBiMTQgPSBiWzE0XSxcbiAgICBiMTUgPSBiWzE1XTtcblxuICB2ID0gYVswXTtcbiAgdDAgKz0gdiAqIGIwO1xuICB0MSArPSB2ICogYjE7XG4gIHQyICs9IHYgKiBiMjtcbiAgdDMgKz0gdiAqIGIzO1xuICB0NCArPSB2ICogYjQ7XG4gIHQ1ICs9IHYgKiBiNTtcbiAgdDYgKz0gdiAqIGI2O1xuICB0NyArPSB2ICogYjc7XG4gIHQ4ICs9IHYgKiBiODtcbiAgdDkgKz0gdiAqIGI5O1xuICB0MTAgKz0gdiAqIGIxMDtcbiAgdDExICs9IHYgKiBiMTE7XG4gIHQxMiArPSB2ICogYjEyO1xuICB0MTMgKz0gdiAqIGIxMztcbiAgdDE0ICs9IHYgKiBiMTQ7XG4gIHQxNSArPSB2ICogYjE1O1xuICB2ID0gYVsxXTtcbiAgdDEgKz0gdiAqIGIwO1xuICB0MiArPSB2ICogYjE7XG4gIHQzICs9IHYgKiBiMjtcbiAgdDQgKz0gdiAqIGIzO1xuICB0NSArPSB2ICogYjQ7XG4gIHQ2ICs9IHYgKiBiNTtcbiAgdDcgKz0gdiAqIGI2O1xuICB0OCArPSB2ICogYjc7XG4gIHQ5ICs9IHYgKiBiODtcbiAgdDEwICs9IHYgKiBiOTtcbiAgdDExICs9IHYgKiBiMTA7XG4gIHQxMiArPSB2ICogYjExO1xuICB0MTMgKz0gdiAqIGIxMjtcbiAgdDE0ICs9IHYgKiBiMTM7XG4gIHQxNSArPSB2ICogYjE0O1xuICB0MTYgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMl07XG4gIHQyICs9IHYgKiBiMDtcbiAgdDMgKz0gdiAqIGIxO1xuICB0NCArPSB2ICogYjI7XG4gIHQ1ICs9IHYgKiBiMztcbiAgdDYgKz0gdiAqIGI0O1xuICB0NyArPSB2ICogYjU7XG4gIHQ4ICs9IHYgKiBiNjtcbiAgdDkgKz0gdiAqIGI3O1xuICB0MTAgKz0gdiAqIGI4O1xuICB0MTEgKz0gdiAqIGI5O1xuICB0MTIgKz0gdiAqIGIxMDtcbiAgdDEzICs9IHYgKiBiMTE7XG4gIHQxNCArPSB2ICogYjEyO1xuICB0MTUgKz0gdiAqIGIxMztcbiAgdDE2ICs9IHYgKiBiMTQ7XG4gIHQxNyArPSB2ICogYjE1O1xuICB2ID0gYVszXTtcbiAgdDMgKz0gdiAqIGIwO1xuICB0NCArPSB2ICogYjE7XG4gIHQ1ICs9IHYgKiBiMjtcbiAgdDYgKz0gdiAqIGIzO1xuICB0NyArPSB2ICogYjQ7XG4gIHQ4ICs9IHYgKiBiNTtcbiAgdDkgKz0gdiAqIGI2O1xuICB0MTAgKz0gdiAqIGI3O1xuICB0MTEgKz0gdiAqIGI4O1xuICB0MTIgKz0gdiAqIGI5O1xuICB0MTMgKz0gdiAqIGIxMDtcbiAgdDE0ICs9IHYgKiBiMTE7XG4gIHQxNSArPSB2ICogYjEyO1xuICB0MTYgKz0gdiAqIGIxMztcbiAgdDE3ICs9IHYgKiBiMTQ7XG4gIHQxOCArPSB2ICogYjE1O1xuICB2ID0gYVs0XTtcbiAgdDQgKz0gdiAqIGIwO1xuICB0NSArPSB2ICogYjE7XG4gIHQ2ICs9IHYgKiBiMjtcbiAgdDcgKz0gdiAqIGIzO1xuICB0OCArPSB2ICogYjQ7XG4gIHQ5ICs9IHYgKiBiNTtcbiAgdDEwICs9IHYgKiBiNjtcbiAgdDExICs9IHYgKiBiNztcbiAgdDEyICs9IHYgKiBiODtcbiAgdDEzICs9IHYgKiBiOTtcbiAgdDE0ICs9IHYgKiBiMTA7XG4gIHQxNSArPSB2ICogYjExO1xuICB0MTYgKz0gdiAqIGIxMjtcbiAgdDE3ICs9IHYgKiBiMTM7XG4gIHQxOCArPSB2ICogYjE0O1xuICB0MTkgKz0gdiAqIGIxNTtcbiAgdiA9IGFbNV07XG4gIHQ1ICs9IHYgKiBiMDtcbiAgdDYgKz0gdiAqIGIxO1xuICB0NyArPSB2ICogYjI7XG4gIHQ4ICs9IHYgKiBiMztcbiAgdDkgKz0gdiAqIGI0O1xuICB0MTAgKz0gdiAqIGI1O1xuICB0MTEgKz0gdiAqIGI2O1xuICB0MTIgKz0gdiAqIGI3O1xuICB0MTMgKz0gdiAqIGI4O1xuICB0MTQgKz0gdiAqIGI5O1xuICB0MTUgKz0gdiAqIGIxMDtcbiAgdDE2ICs9IHYgKiBiMTE7XG4gIHQxNyArPSB2ICogYjEyO1xuICB0MTggKz0gdiAqIGIxMztcbiAgdDE5ICs9IHYgKiBiMTQ7XG4gIHQyMCArPSB2ICogYjE1O1xuICB2ID0gYVs2XTtcbiAgdDYgKz0gdiAqIGIwO1xuICB0NyArPSB2ICogYjE7XG4gIHQ4ICs9IHYgKiBiMjtcbiAgdDkgKz0gdiAqIGIzO1xuICB0MTAgKz0gdiAqIGI0O1xuICB0MTEgKz0gdiAqIGI1O1xuICB0MTIgKz0gdiAqIGI2O1xuICB0MTMgKz0gdiAqIGI3O1xuICB0MTQgKz0gdiAqIGI4O1xuICB0MTUgKz0gdiAqIGI5O1xuICB0MTYgKz0gdiAqIGIxMDtcbiAgdDE3ICs9IHYgKiBiMTE7XG4gIHQxOCArPSB2ICogYjEyO1xuICB0MTkgKz0gdiAqIGIxMztcbiAgdDIwICs9IHYgKiBiMTQ7XG4gIHQyMSArPSB2ICogYjE1O1xuICB2ID0gYVs3XTtcbiAgdDcgKz0gdiAqIGIwO1xuICB0OCArPSB2ICogYjE7XG4gIHQ5ICs9IHYgKiBiMjtcbiAgdDEwICs9IHYgKiBiMztcbiAgdDExICs9IHYgKiBiNDtcbiAgdDEyICs9IHYgKiBiNTtcbiAgdDEzICs9IHYgKiBiNjtcbiAgdDE0ICs9IHYgKiBiNztcbiAgdDE1ICs9IHYgKiBiODtcbiAgdDE2ICs9IHYgKiBiOTtcbiAgdDE3ICs9IHYgKiBiMTA7XG4gIHQxOCArPSB2ICogYjExO1xuICB0MTkgKz0gdiAqIGIxMjtcbiAgdDIwICs9IHYgKiBiMTM7XG4gIHQyMSArPSB2ICogYjE0O1xuICB0MjIgKz0gdiAqIGIxNTtcbiAgdiA9IGFbOF07XG4gIHQ4ICs9IHYgKiBiMDtcbiAgdDkgKz0gdiAqIGIxO1xuICB0MTAgKz0gdiAqIGIyO1xuICB0MTEgKz0gdiAqIGIzO1xuICB0MTIgKz0gdiAqIGI0O1xuICB0MTMgKz0gdiAqIGI1O1xuICB0MTQgKz0gdiAqIGI2O1xuICB0MTUgKz0gdiAqIGI3O1xuICB0MTYgKz0gdiAqIGI4O1xuICB0MTcgKz0gdiAqIGI5O1xuICB0MTggKz0gdiAqIGIxMDtcbiAgdDE5ICs9IHYgKiBiMTE7XG4gIHQyMCArPSB2ICogYjEyO1xuICB0MjEgKz0gdiAqIGIxMztcbiAgdDIyICs9IHYgKiBiMTQ7XG4gIHQyMyArPSB2ICogYjE1O1xuICB2ID0gYVs5XTtcbiAgdDkgKz0gdiAqIGIwO1xuICB0MTAgKz0gdiAqIGIxO1xuICB0MTEgKz0gdiAqIGIyO1xuICB0MTIgKz0gdiAqIGIzO1xuICB0MTMgKz0gdiAqIGI0O1xuICB0MTQgKz0gdiAqIGI1O1xuICB0MTUgKz0gdiAqIGI2O1xuICB0MTYgKz0gdiAqIGI3O1xuICB0MTcgKz0gdiAqIGI4O1xuICB0MTggKz0gdiAqIGI5O1xuICB0MTkgKz0gdiAqIGIxMDtcbiAgdDIwICs9IHYgKiBiMTE7XG4gIHQyMSArPSB2ICogYjEyO1xuICB0MjIgKz0gdiAqIGIxMztcbiAgdDIzICs9IHYgKiBiMTQ7XG4gIHQyNCArPSB2ICogYjE1O1xuICB2ID0gYVsxMF07XG4gIHQxMCArPSB2ICogYjA7XG4gIHQxMSArPSB2ICogYjE7XG4gIHQxMiArPSB2ICogYjI7XG4gIHQxMyArPSB2ICogYjM7XG4gIHQxNCArPSB2ICogYjQ7XG4gIHQxNSArPSB2ICogYjU7XG4gIHQxNiArPSB2ICogYjY7XG4gIHQxNyArPSB2ICogYjc7XG4gIHQxOCArPSB2ICogYjg7XG4gIHQxOSArPSB2ICogYjk7XG4gIHQyMCArPSB2ICogYjEwO1xuICB0MjEgKz0gdiAqIGIxMTtcbiAgdDIyICs9IHYgKiBiMTI7XG4gIHQyMyArPSB2ICogYjEzO1xuICB0MjQgKz0gdiAqIGIxNDtcbiAgdDI1ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzExXTtcbiAgdDExICs9IHYgKiBiMDtcbiAgdDEyICs9IHYgKiBiMTtcbiAgdDEzICs9IHYgKiBiMjtcbiAgdDE0ICs9IHYgKiBiMztcbiAgdDE1ICs9IHYgKiBiNDtcbiAgdDE2ICs9IHYgKiBiNTtcbiAgdDE3ICs9IHYgKiBiNjtcbiAgdDE4ICs9IHYgKiBiNztcbiAgdDE5ICs9IHYgKiBiODtcbiAgdDIwICs9IHYgKiBiOTtcbiAgdDIxICs9IHYgKiBiMTA7XG4gIHQyMiArPSB2ICogYjExO1xuICB0MjMgKz0gdiAqIGIxMjtcbiAgdDI0ICs9IHYgKiBiMTM7XG4gIHQyNSArPSB2ICogYjE0O1xuICB0MjYgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTJdO1xuICB0MTIgKz0gdiAqIGIwO1xuICB0MTMgKz0gdiAqIGIxO1xuICB0MTQgKz0gdiAqIGIyO1xuICB0MTUgKz0gdiAqIGIzO1xuICB0MTYgKz0gdiAqIGI0O1xuICB0MTcgKz0gdiAqIGI1O1xuICB0MTggKz0gdiAqIGI2O1xuICB0MTkgKz0gdiAqIGI3O1xuICB0MjAgKz0gdiAqIGI4O1xuICB0MjEgKz0gdiAqIGI5O1xuICB0MjIgKz0gdiAqIGIxMDtcbiAgdDIzICs9IHYgKiBiMTE7XG4gIHQyNCArPSB2ICogYjEyO1xuICB0MjUgKz0gdiAqIGIxMztcbiAgdDI2ICs9IHYgKiBiMTQ7XG4gIHQyNyArPSB2ICogYjE1O1xuICB2ID0gYVsxM107XG4gIHQxMyArPSB2ICogYjA7XG4gIHQxNCArPSB2ICogYjE7XG4gIHQxNSArPSB2ICogYjI7XG4gIHQxNiArPSB2ICogYjM7XG4gIHQxNyArPSB2ICogYjQ7XG4gIHQxOCArPSB2ICogYjU7XG4gIHQxOSArPSB2ICogYjY7XG4gIHQyMCArPSB2ICogYjc7XG4gIHQyMSArPSB2ICogYjg7XG4gIHQyMiArPSB2ICogYjk7XG4gIHQyMyArPSB2ICogYjEwO1xuICB0MjQgKz0gdiAqIGIxMTtcbiAgdDI1ICs9IHYgKiBiMTI7XG4gIHQyNiArPSB2ICogYjEzO1xuICB0MjcgKz0gdiAqIGIxNDtcbiAgdDI4ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzE0XTtcbiAgdDE0ICs9IHYgKiBiMDtcbiAgdDE1ICs9IHYgKiBiMTtcbiAgdDE2ICs9IHYgKiBiMjtcbiAgdDE3ICs9IHYgKiBiMztcbiAgdDE4ICs9IHYgKiBiNDtcbiAgdDE5ICs9IHYgKiBiNTtcbiAgdDIwICs9IHYgKiBiNjtcbiAgdDIxICs9IHYgKiBiNztcbiAgdDIyICs9IHYgKiBiODtcbiAgdDIzICs9IHYgKiBiOTtcbiAgdDI0ICs9IHYgKiBiMTA7XG4gIHQyNSArPSB2ICogYjExO1xuICB0MjYgKz0gdiAqIGIxMjtcbiAgdDI3ICs9IHYgKiBiMTM7XG4gIHQyOCArPSB2ICogYjE0O1xuICB0MjkgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTVdO1xuICB0MTUgKz0gdiAqIGIwO1xuICB0MTYgKz0gdiAqIGIxO1xuICB0MTcgKz0gdiAqIGIyO1xuICB0MTggKz0gdiAqIGIzO1xuICB0MTkgKz0gdiAqIGI0O1xuICB0MjAgKz0gdiAqIGI1O1xuICB0MjEgKz0gdiAqIGI2O1xuICB0MjIgKz0gdiAqIGI3O1xuICB0MjMgKz0gdiAqIGI4O1xuICB0MjQgKz0gdiAqIGI5O1xuICB0MjUgKz0gdiAqIGIxMDtcbiAgdDI2ICs9IHYgKiBiMTE7XG4gIHQyNyArPSB2ICogYjEyO1xuICB0MjggKz0gdiAqIGIxMztcbiAgdDI5ICs9IHYgKiBiMTQ7XG4gIHQzMCArPSB2ICogYjE1O1xuXG4gIHQwICArPSAzOCAqIHQxNjtcbiAgdDEgICs9IDM4ICogdDE3O1xuICB0MiAgKz0gMzggKiB0MTg7XG4gIHQzICArPSAzOCAqIHQxOTtcbiAgdDQgICs9IDM4ICogdDIwO1xuICB0NSAgKz0gMzggKiB0MjE7XG4gIHQ2ICArPSAzOCAqIHQyMjtcbiAgdDcgICs9IDM4ICogdDIzO1xuICB0OCAgKz0gMzggKiB0MjQ7XG4gIHQ5ICArPSAzOCAqIHQyNTtcbiAgdDEwICs9IDM4ICogdDI2O1xuICB0MTEgKz0gMzggKiB0Mjc7XG4gIHQxMiArPSAzOCAqIHQyODtcbiAgdDEzICs9IDM4ICogdDI5O1xuICB0MTQgKz0gMzggKiB0MzA7XG4gIC8vIHQxNSBsZWZ0IGFzIGlzXG5cbiAgLy8gZmlyc3QgY2FyXG4gIGMgPSAxO1xuICB2ID0gIHQwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQxICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDUgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ2ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDYgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ3ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDcgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ4ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDggPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gIHQ5ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyAgdDkgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEwICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTAgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDExICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTEgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEyICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTIgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDEzICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTMgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE0ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTQgPSB2IC0gYyAqIDY1NTM2O1xuICB2ID0gdDE1ICsgYyArIDY1NTM1OyBjID0gTWF0aC5mbG9vcih2IC8gNjU1MzYpOyB0MTUgPSB2IC0gYyAqIDY1NTM2O1xuICB0MCArPSBjLTEgKyAzNyAqIChjLTEpO1xuXG4gIC8vIHNlY29uZCBjYXJcbiAgYyA9IDE7XG4gIHYgPSAgdDAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDYgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDcgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDggKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDkgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNSA9IHYgLSBjICogNjU1MzY7XG4gIHQwICs9IGMtMSArIDM3ICogKGMtMSk7XG5cbiAgb1sgMF0gPSB0MDtcbiAgb1sgMV0gPSB0MTtcbiAgb1sgMl0gPSB0MjtcbiAgb1sgM10gPSB0MztcbiAgb1sgNF0gPSB0NDtcbiAgb1sgNV0gPSB0NTtcbiAgb1sgNl0gPSB0NjtcbiAgb1sgN10gPSB0NztcbiAgb1sgOF0gPSB0ODtcbiAgb1sgOV0gPSB0OTtcbiAgb1sxMF0gPSB0MTA7XG4gIG9bMTFdID0gdDExO1xuICBvWzEyXSA9IHQxMjtcbiAgb1sxM10gPSB0MTM7XG4gIG9bMTRdID0gdDE0O1xuICBvWzE1XSA9IHQxNTtcbn1cblxuZnVuY3Rpb24gUyhvLCBhKSB7XG4gIE0obywgYSwgYSk7XG59XG5cbmZ1bmN0aW9uIGludjI1NTE5KG8sIGkpIHtcbiAgdmFyIGMgPSBnZigpO1xuICB2YXIgYTtcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIGNbYV0gPSBpW2FdO1xuICBmb3IgKGEgPSAyNTM7IGEgPj0gMDsgYS0tKSB7XG4gICAgUyhjLCBjKTtcbiAgICBpZihhICE9PSAyICYmIGEgIT09IDQpIE0oYywgYywgaSk7XG4gIH1cbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIG9bYV0gPSBjW2FdO1xufVxuXG5mdW5jdGlvbiBwb3cyNTIzKG8sIGkpIHtcbiAgdmFyIGMgPSBnZigpO1xuICB2YXIgYTtcbiAgZm9yIChhID0gMDsgYSA8IDE2OyBhKyspIGNbYV0gPSBpW2FdO1xuICBmb3IgKGEgPSAyNTA7IGEgPj0gMDsgYS0tKSB7XG4gICAgICBTKGMsIGMpO1xuICAgICAgaWYoYSAhPT0gMSkgTShjLCBjLCBpKTtcbiAgfVxuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgb1thXSA9IGNbYV07XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIHApIHtcbiAgdmFyIHogPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg4MCksIHIsIGk7XG4gIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLFxuICAgICAgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKTtcbiAgZm9yIChpID0gMDsgaSA8IDMxOyBpKyspIHpbaV0gPSBuW2ldO1xuICB6WzMxXT0oblszMV0mMTI3KXw2NDtcbiAgelswXSY9MjQ4O1xuICB1bnBhY2syNTUxOSh4LHApO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGJbaV09eFtpXTtcbiAgICBkW2ldPWFbaV09Y1tpXT0wO1xuICB9XG4gIGFbMF09ZFswXT0xO1xuICBmb3IgKGk9MjU0OyBpPj0wOyAtLWkpIHtcbiAgICByPSh6W2k+Pj4zXT4+PihpJjcpKSYxO1xuICAgIHNlbDI1NTE5KGEsYixyKTtcbiAgICBzZWwyNTUxOShjLGQscik7XG4gICAgQShlLGEsYyk7XG4gICAgWihhLGEsYyk7XG4gICAgQShjLGIsZCk7XG4gICAgWihiLGIsZCk7XG4gICAgUyhkLGUpO1xuICAgIFMoZixhKTtcbiAgICBNKGEsYyxhKTtcbiAgICBNKGMsYixlKTtcbiAgICBBKGUsYSxjKTtcbiAgICBaKGEsYSxjKTtcbiAgICBTKGIsYSk7XG4gICAgWihjLGQsZik7XG4gICAgTShhLGMsXzEyMTY2NSk7XG4gICAgQShhLGEsZCk7XG4gICAgTShjLGMsYSk7XG4gICAgTShhLGQsZik7XG4gICAgTShkLGIseCk7XG4gICAgUyhiLGUpO1xuICAgIHNlbDI1NTE5KGEsYixyKTtcbiAgICBzZWwyNTUxOShjLGQscik7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB4W2krMTZdPWFbaV07XG4gICAgeFtpKzMyXT1jW2ldO1xuICAgIHhbaSs0OF09YltpXTtcbiAgICB4W2krNjRdPWRbaV07XG4gIH1cbiAgdmFyIHgzMiA9IHguc3ViYXJyYXkoMzIpO1xuICB2YXIgeDE2ID0geC5zdWJhcnJheSgxNik7XG4gIGludjI1NTE5KHgzMix4MzIpO1xuICBNKHgxNix4MTYseDMyKTtcbiAgcGFjazI1NTE5KHEseDE2KTtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UocSwgbikge1xuICByZXR1cm4gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgXzkpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fYm94X2tleXBhaXIoeSwgeCkge1xuICByYW5kb21ieXRlcyh4LCAzMik7XG4gIHJldHVybiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHksIHgpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpIHtcbiAgdmFyIHMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19zY2FsYXJtdWx0KHMsIHgsIHkpO1xuICByZXR1cm4gY3J5cHRvX2NvcmVfaHNhbHNhMjAoaywgXzAsIHMsIHNpZ21hKTtcbn1cblxudmFyIGNyeXB0b19ib3hfYWZ0ZXJubSA9IGNyeXB0b19zZWNyZXRib3g7XG52YXIgY3J5cHRvX2JveF9vcGVuX2FmdGVybm0gPSBjcnlwdG9fc2VjcmV0Ym94X29wZW47XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3goYywgbSwgZCwgbiwgeSwgeCkge1xuICB2YXIgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KTtcbiAgcmV0dXJuIGNyeXB0b19ib3hfYWZ0ZXJubShjLCBtLCBkLCBuLCBrKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2JveF9vcGVuKG0sIGMsIGQsIG4sIHksIHgpIHtcbiAgdmFyIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCk7XG4gIHJldHVybiBjcnlwdG9fYm94X29wZW5fYWZ0ZXJubShtLCBjLCBkLCBuLCBrKTtcbn1cblxudmFyIEsgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl07XG5cbmZ1bmN0aW9uIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbikge1xuICB2YXIgd2ggPSBuZXcgSW50MzJBcnJheSgxNiksIHdsID0gbmV3IEludDMyQXJyYXkoMTYpLFxuICAgICAgYmgwLCBiaDEsIGJoMiwgYmgzLCBiaDQsIGJoNSwgYmg2LCBiaDcsXG4gICAgICBibDAsIGJsMSwgYmwyLCBibDMsIGJsNCwgYmw1LCBibDYsIGJsNyxcbiAgICAgIHRoLCB0bCwgaSwgaiwgaCwgbCwgYSwgYiwgYywgZDtcblxuICB2YXIgYWgwID0gaGhbMF0sXG4gICAgICBhaDEgPSBoaFsxXSxcbiAgICAgIGFoMiA9IGhoWzJdLFxuICAgICAgYWgzID0gaGhbM10sXG4gICAgICBhaDQgPSBoaFs0XSxcbiAgICAgIGFoNSA9IGhoWzVdLFxuICAgICAgYWg2ID0gaGhbNl0sXG4gICAgICBhaDcgPSBoaFs3XSxcblxuICAgICAgYWwwID0gaGxbMF0sXG4gICAgICBhbDEgPSBobFsxXSxcbiAgICAgIGFsMiA9IGhsWzJdLFxuICAgICAgYWwzID0gaGxbM10sXG4gICAgICBhbDQgPSBobFs0XSxcbiAgICAgIGFsNSA9IGhsWzVdLFxuICAgICAgYWw2ID0gaGxbNl0sXG4gICAgICBhbDcgPSBobFs3XTtcblxuICB2YXIgcG9zID0gMDtcbiAgd2hpbGUgKG4gPj0gMTI4KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIGogPSA4ICogaSArIHBvcztcbiAgICAgIHdoW2ldID0gKG1baiswXSA8PCAyNCkgfCAobVtqKzFdIDw8IDE2KSB8IChtW2orMl0gPDwgOCkgfCBtW2orM107XG4gICAgICB3bFtpXSA9IChtW2orNF0gPDwgMjQpIHwgKG1bais1XSA8PCAxNikgfCAobVtqKzZdIDw8IDgpIHwgbVtqKzddO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgYmgwID0gYWgwO1xuICAgICAgYmgxID0gYWgxO1xuICAgICAgYmgyID0gYWgyO1xuICAgICAgYmgzID0gYWgzO1xuICAgICAgYmg0ID0gYWg0O1xuICAgICAgYmg1ID0gYWg1O1xuICAgICAgYmg2ID0gYWg2O1xuICAgICAgYmg3ID0gYWg3O1xuXG4gICAgICBibDAgPSBhbDA7XG4gICAgICBibDEgPSBhbDE7XG4gICAgICBibDIgPSBhbDI7XG4gICAgICBibDMgPSBhbDM7XG4gICAgICBibDQgPSBhbDQ7XG4gICAgICBibDUgPSBhbDU7XG4gICAgICBibDYgPSBhbDY7XG4gICAgICBibDcgPSBhbDc7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IGFoNztcbiAgICAgIGwgPSBhbDc7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAvLyBTaWdtYTFcbiAgICAgIGggPSAoKGFoNCA+Pj4gMTQpIHwgKGFsNCA8PCAoMzItMTQpKSkgXiAoKGFoNCA+Pj4gMTgpIHwgKGFsNCA8PCAoMzItMTgpKSkgXiAoKGFsNCA+Pj4gKDQxLTMyKSkgfCAoYWg0IDw8ICgzMi0oNDEtMzIpKSkpO1xuICAgICAgbCA9ICgoYWw0ID4+PiAxNCkgfCAoYWg0IDw8ICgzMi0xNCkpKSBeICgoYWw0ID4+PiAxOCkgfCAoYWg0IDw8ICgzMi0xOCkpKSBeICgoYWg0ID4+PiAoNDEtMzIpKSB8IChhbDQgPDwgKDMyLSg0MS0zMikpKSk7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gQ2hcbiAgICAgIGggPSAoYWg0ICYgYWg1KSBeICh+YWg0ICYgYWg2KTtcbiAgICAgIGwgPSAoYWw0ICYgYWw1KSBeICh+YWw0ICYgYWw2KTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBLXG4gICAgICBoID0gS1tpKjJdO1xuICAgICAgbCA9IEtbaSoyKzFdO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIHdcbiAgICAgIGggPSB3aFtpJTE2XTtcbiAgICAgIGwgPSB3bFtpJTE2XTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIHRoID0gYyAmIDB4ZmZmZiB8IGQgPDwgMTY7XG4gICAgICB0bCA9IGEgJiAweGZmZmYgfCBiIDw8IDE2O1xuXG4gICAgICAvLyBhZGRcbiAgICAgIGggPSB0aDtcbiAgICAgIGwgPSB0bDtcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIFNpZ21hMFxuICAgICAgaCA9ICgoYWgwID4+PiAyOCkgfCAoYWwwIDw8ICgzMi0yOCkpKSBeICgoYWwwID4+PiAoMzQtMzIpKSB8IChhaDAgPDwgKDMyLSgzNC0zMikpKSkgXiAoKGFsMCA+Pj4gKDM5LTMyKSkgfCAoYWgwIDw8ICgzMi0oMzktMzIpKSkpO1xuICAgICAgbCA9ICgoYWwwID4+PiAyOCkgfCAoYWgwIDw8ICgzMi0yOCkpKSBeICgoYWgwID4+PiAoMzQtMzIpKSB8IChhbDAgPDwgKDMyLSgzNC0zMikpKSkgXiAoKGFoMCA+Pj4gKDM5LTMyKSkgfCAoYWwwIDw8ICgzMi0oMzktMzIpKSkpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIE1halxuICAgICAgaCA9IChhaDAgJiBhaDEpIF4gKGFoMCAmIGFoMikgXiAoYWgxICYgYWgyKTtcbiAgICAgIGwgPSAoYWwwICYgYWwxKSBeIChhbDAgJiBhbDIpIF4gKGFsMSAmIGFsMik7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICBiaDcgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICBibDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IGJoMztcbiAgICAgIGwgPSBibDM7XG5cbiAgICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICBoID0gdGg7XG4gICAgICBsID0gdGw7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgIGMgKz0gYiA+Pj4gMTY7XG4gICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICBiaDMgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICBibDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICAgIGFoMSA9IGJoMDtcbiAgICAgIGFoMiA9IGJoMTtcbiAgICAgIGFoMyA9IGJoMjtcbiAgICAgIGFoNCA9IGJoMztcbiAgICAgIGFoNSA9IGJoNDtcbiAgICAgIGFoNiA9IGJoNTtcbiAgICAgIGFoNyA9IGJoNjtcbiAgICAgIGFoMCA9IGJoNztcblxuICAgICAgYWwxID0gYmwwO1xuICAgICAgYWwyID0gYmwxO1xuICAgICAgYWwzID0gYmwyO1xuICAgICAgYWw0ID0gYmwzO1xuICAgICAgYWw1ID0gYmw0O1xuICAgICAgYWw2ID0gYmw1O1xuICAgICAgYWw3ID0gYmw2O1xuICAgICAgYWwwID0gYmw3O1xuXG4gICAgICBpZiAoaSUxNiA9PT0gMTUpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAvLyBhZGRcbiAgICAgICAgICBoID0gd2hbal07XG4gICAgICAgICAgbCA9IHdsW2pdO1xuXG4gICAgICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgICAgICBjID0gaCAmIDB4ZmZmZjsgZCA9IGggPj4+IDE2O1xuXG4gICAgICAgICAgaCA9IHdoWyhqKzkpJTE2XTtcbiAgICAgICAgICBsID0gd2xbKGorOSklMTZdO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIC8vIHNpZ21hMFxuICAgICAgICAgIHRoID0gd2hbKGorMSklMTZdO1xuICAgICAgICAgIHRsID0gd2xbKGorMSklMTZdO1xuICAgICAgICAgIGggPSAoKHRoID4+PiAxKSB8ICh0bCA8PCAoMzItMSkpKSBeICgodGggPj4+IDgpIHwgKHRsIDw8ICgzMi04KSkpIF4gKHRoID4+PiA3KTtcbiAgICAgICAgICBsID0gKCh0bCA+Pj4gMSkgfCAodGggPDwgKDMyLTEpKSkgXiAoKHRsID4+PiA4KSB8ICh0aCA8PCAoMzItOCkpKSBeICgodGwgPj4+IDcpIHwgKHRoIDw8ICgzMi03KSkpO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIC8vIHNpZ21hMVxuICAgICAgICAgIHRoID0gd2hbKGorMTQpJTE2XTtcbiAgICAgICAgICB0bCA9IHdsWyhqKzE0KSUxNl07XG4gICAgICAgICAgaCA9ICgodGggPj4+IDE5KSB8ICh0bCA8PCAoMzItMTkpKSkgXiAoKHRsID4+PiAoNjEtMzIpKSB8ICh0aCA8PCAoMzItKDYxLTMyKSkpKSBeICh0aCA+Pj4gNik7XG4gICAgICAgICAgbCA9ICgodGwgPj4+IDE5KSB8ICh0aCA8PCAoMzItMTkpKSkgXiAoKHRoID4+PiAoNjEtMzIpKSB8ICh0bCA8PCAoMzItKDYxLTMyKSkpKSBeICgodGwgPj4+IDYpIHwgKHRoIDw8ICgzMi02KSkpO1xuXG4gICAgICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgICAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgICAgICAgd2hbal0gPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgICAgICAgd2xbal0gPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGRcbiAgICBoID0gYWgwO1xuICAgIGwgPSBhbDA7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMF07XG4gICAgbCA9IGhsWzBdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMF0gPSBhaDAgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMF0gPSBhbDAgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgxO1xuICAgIGwgPSBhbDE7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMV07XG4gICAgbCA9IGhsWzFdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMV0gPSBhaDEgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMV0gPSBhbDEgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgyO1xuICAgIGwgPSBhbDI7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbMl07XG4gICAgbCA9IGhsWzJdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbMl0gPSBhaDIgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbMl0gPSBhbDIgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWgzO1xuICAgIGwgPSBhbDM7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbM107XG4gICAgbCA9IGhsWzNdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbM10gPSBhaDMgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbM10gPSBhbDMgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg0O1xuICAgIGwgPSBhbDQ7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNF07XG4gICAgbCA9IGhsWzRdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNF0gPSBhaDQgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNF0gPSBhbDQgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg1O1xuICAgIGwgPSBhbDU7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNV07XG4gICAgbCA9IGhsWzVdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNV0gPSBhaDUgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNV0gPSBhbDUgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg2O1xuICAgIGwgPSBhbDY7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbNl07XG4gICAgbCA9IGhsWzZdO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbNl0gPSBhaDYgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbNl0gPSBhbDYgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBoID0gYWg3O1xuICAgIGwgPSBhbDc7XG5cbiAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICBoID0gaGhbN107XG4gICAgbCA9IGhsWzddO1xuXG4gICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgYyArPSBiID4+PiAxNjtcbiAgICBkICs9IGMgPj4+IDE2O1xuXG4gICAgaGhbN10gPSBhaDcgPSAoYyAmIDB4ZmZmZikgfCAoZCA8PCAxNik7XG4gICAgaGxbN10gPSBhbDcgPSAoYSAmIDB4ZmZmZikgfCAoYiA8PCAxNik7XG5cbiAgICBwb3MgKz0gMTI4O1xuICAgIG4gLT0gMTI4O1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19oYXNoKG91dCwgbSwgbikge1xuICB2YXIgaGggPSBuZXcgSW50MzJBcnJheSg4KSxcbiAgICAgIGhsID0gbmV3IEludDMyQXJyYXkoOCksXG4gICAgICB4ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KSxcbiAgICAgIGksIGIgPSBuO1xuXG4gIGhoWzBdID0gMHg2YTA5ZTY2NztcbiAgaGhbMV0gPSAweGJiNjdhZTg1O1xuICBoaFsyXSA9IDB4M2M2ZWYzNzI7XG4gIGhoWzNdID0gMHhhNTRmZjUzYTtcbiAgaGhbNF0gPSAweDUxMGU1MjdmO1xuICBoaFs1XSA9IDB4OWIwNTY4OGM7XG4gIGhoWzZdID0gMHgxZjgzZDlhYjtcbiAgaGhbN10gPSAweDViZTBjZDE5O1xuXG4gIGhsWzBdID0gMHhmM2JjYzkwODtcbiAgaGxbMV0gPSAweDg0Y2FhNzNiO1xuICBobFsyXSA9IDB4ZmU5NGY4MmI7XG4gIGhsWzNdID0gMHg1ZjFkMzZmMTtcbiAgaGxbNF0gPSAweGFkZTY4MmQxO1xuICBobFs1XSA9IDB4MmIzZTZjMWY7XG4gIGhsWzZdID0gMHhmYjQxYmQ2YjtcbiAgaGxbN10gPSAweDEzN2UyMTc5O1xuXG4gIGNyeXB0b19oYXNoYmxvY2tzX2hsKGhoLCBobCwgbSwgbik7XG4gIG4gJT0gMTI4O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSBtW2ItbitpXTtcbiAgeFtuXSA9IDEyODtcblxuICBuID0gMjU2LTEyOCoobjwxMTI/MTowKTtcbiAgeFtuLTldID0gMDtcbiAgdHM2NCh4LCBuLTgsICAoYiAvIDB4MjAwMDAwMDApIHwgMCwgYiA8PCAzKTtcbiAgY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCB4LCBuKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB0czY0KG91dCwgOCppLCBoaFtpXSwgaGxbaV0pO1xuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhZGQocCwgcSkge1xuICB2YXIgYSA9IGdmKCksIGIgPSBnZigpLCBjID0gZ2YoKSxcbiAgICAgIGQgPSBnZigpLCBlID0gZ2YoKSwgZiA9IGdmKCksXG4gICAgICBnID0gZ2YoKSwgaCA9IGdmKCksIHQgPSBnZigpO1xuXG4gIFooYSwgcFsxXSwgcFswXSk7XG4gIFoodCwgcVsxXSwgcVswXSk7XG4gIE0oYSwgYSwgdCk7XG4gIEEoYiwgcFswXSwgcFsxXSk7XG4gIEEodCwgcVswXSwgcVsxXSk7XG4gIE0oYiwgYiwgdCk7XG4gIE0oYywgcFszXSwgcVszXSk7XG4gIE0oYywgYywgRDIpO1xuICBNKGQsIHBbMl0sIHFbMl0pO1xuICBBKGQsIGQsIGQpO1xuICBaKGUsIGIsIGEpO1xuICBaKGYsIGQsIGMpO1xuICBBKGcsIGQsIGMpO1xuICBBKGgsIGIsIGEpO1xuXG4gIE0ocFswXSwgZSwgZik7XG4gIE0ocFsxXSwgaCwgZyk7XG4gIE0ocFsyXSwgZywgZik7XG4gIE0ocFszXSwgZSwgaCk7XG59XG5cbmZ1bmN0aW9uIGNzd2FwKHAsIHEsIGIpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBzZWwyNTUxOShwW2ldLCBxW2ldLCBiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYWNrKHIsIHApIHtcbiAgdmFyIHR4ID0gZ2YoKSwgdHkgPSBnZigpLCB6aSA9IGdmKCk7XG4gIGludjI1NTE5KHppLCBwWzJdKTtcbiAgTSh0eCwgcFswXSwgemkpO1xuICBNKHR5LCBwWzFdLCB6aSk7XG4gIHBhY2syNTUxOShyLCB0eSk7XG4gIHJbMzFdIF49IHBhcjI1NTE5KHR4KSA8PCA3O1xufVxuXG5mdW5jdGlvbiBzY2FsYXJtdWx0KHAsIHEsIHMpIHtcbiAgdmFyIGIsIGk7XG4gIHNldDI1NTE5KHBbMF0sIGdmMCk7XG4gIHNldDI1NTE5KHBbMV0sIGdmMSk7XG4gIHNldDI1NTE5KHBbMl0sIGdmMSk7XG4gIHNldDI1NTE5KHBbM10sIGdmMCk7XG4gIGZvciAoaSA9IDI1NTsgaSA+PSAwOyAtLWkpIHtcbiAgICBiID0gKHNbKGkvOCl8MF0gPj4gKGkmNykpICYgMTtcbiAgICBjc3dhcChwLCBxLCBiKTtcbiAgICBhZGQocSwgcCk7XG4gICAgYWRkKHAsIHApO1xuICAgIGNzd2FwKHAsIHEsIGIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjYWxhcmJhc2UocCwgcykge1xuICB2YXIgcSA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcbiAgc2V0MjU1MTkocVswXSwgWCk7XG4gIHNldDI1NTE5KHFbMV0sIFkpO1xuICBzZXQyNTUxOShxWzJdLCBnZjEpO1xuICBNKHFbM10sIFgsIFkpO1xuICBzY2FsYXJtdWx0KHAsIHEsIHMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzaywgc2VlZGVkKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcbiAgdmFyIGk7XG5cbiAgaWYgKCFzZWVkZWQpIHJhbmRvbWJ5dGVzKHNrLCAzMik7XG4gIGNyeXB0b19oYXNoKGQsIHNrLCAzMik7XG4gIGRbMF0gJj0gMjQ4O1xuICBkWzMxXSAmPSAxMjc7XG4gIGRbMzFdIHw9IDY0O1xuXG4gIHNjYWxhcmJhc2UocCwgZCk7XG4gIHBhY2socGssIHApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBza1tpKzMyXSA9IHBrW2ldO1xuICByZXR1cm4gMDtcbn1cblxudmFyIEwgPSBuZXcgRmxvYXQ2NEFycmF5KFsweGVkLCAweGQzLCAweGY1LCAweDVjLCAweDFhLCAweDYzLCAweDEyLCAweDU4LCAweGQ2LCAweDljLCAweGY3LCAweGEyLCAweGRlLCAweGY5LCAweGRlLCAweDE0LCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDEwXSk7XG5cbmZ1bmN0aW9uIG1vZEwociwgeCkge1xuICB2YXIgY2FycnksIGksIGosIGs7XG4gIGZvciAoaSA9IDYzOyBpID49IDMyOyAtLWkpIHtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChqID0gaSAtIDMyLCBrID0gaSAtIDEyOyBqIDwgazsgKytqKSB7XG4gICAgICB4W2pdICs9IGNhcnJ5IC0gMTYgKiB4W2ldICogTFtqIC0gKGkgLSAzMildO1xuICAgICAgY2FycnkgPSAoeFtqXSArIDEyOCkgPj4gODtcbiAgICAgIHhbal0gLT0gY2FycnkgKiAyNTY7XG4gICAgfVxuICAgIHhbal0gKz0gY2Fycnk7XG4gICAgeFtpXSA9IDA7XG4gIH1cbiAgY2FycnkgPSAwO1xuICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgIHhbal0gKz0gY2FycnkgLSAoeFszMV0gPj4gNCkgKiBMW2pdO1xuICAgIGNhcnJ5ID0geFtqXSA+PiA4O1xuICAgIHhbal0gJj0gMjU1O1xuICB9XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB4W2pdIC09IGNhcnJ5ICogTFtqXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICB4W2krMV0gKz0geFtpXSA+PiA4O1xuICAgIHJbaV0gPSB4W2ldICYgMjU1O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZShyKSB7XG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gcltpXTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHJbaV0gPSAwO1xuICBtb2RMKHIsIHgpO1xufVxuXG4vLyBOb3RlOiBkaWZmZXJlbmNlIGZyb20gQyAtIHNtbGVuIHJldHVybmVkLCBub3QgcGFzc2VkIGFzIGFyZ3VtZW50LlxuZnVuY3Rpb24gY3J5cHRvX3NpZ24oc20sIG0sIG4sIHNrKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCBoID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCByID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgaSwgaiwgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICB2YXIgc21sZW4gPSBuICsgNjQ7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHNtWzY0ICsgaV0gPSBtW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc21bMzIgKyBpXSA9IGRbMzIgKyBpXTtcblxuICBjcnlwdG9faGFzaChyLCBzbS5zdWJhcnJheSgzMiksIG4rMzIpO1xuICByZWR1Y2Uocik7XG4gIHNjYWxhcmJhc2UocCwgcik7XG4gIHBhY2soc20sIHApO1xuXG4gIGZvciAoaSA9IDMyOyBpIDwgNjQ7IGkrKykgc21baV0gPSBza1tpXTtcbiAgY3J5cHRvX2hhc2goaCwgc20sIG4gKyA2NCk7XG4gIHJlZHVjZShoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeFtpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB4W2ldID0gcltpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgICAgeFtpK2pdICs9IGhbaV0gKiBkW2pdO1xuICAgIH1cbiAgfVxuXG4gIG1vZEwoc20uc3ViYXJyYXkoMzIpLCB4KTtcbiAgcmV0dXJuIHNtbGVuO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tuZWcociwgcCkge1xuICB2YXIgdCA9IGdmKCksIGNoayA9IGdmKCksIG51bSA9IGdmKCksXG4gICAgICBkZW4gPSBnZigpLCBkZW4yID0gZ2YoKSwgZGVuNCA9IGdmKCksXG4gICAgICBkZW42ID0gZ2YoKTtcblxuICBzZXQyNTUxOShyWzJdLCBnZjEpO1xuICB1bnBhY2syNTUxOShyWzFdLCBwKTtcbiAgUyhudW0sIHJbMV0pO1xuICBNKGRlbiwgbnVtLCBEKTtcbiAgWihudW0sIG51bSwgclsyXSk7XG4gIEEoZGVuLCByWzJdLCBkZW4pO1xuXG4gIFMoZGVuMiwgZGVuKTtcbiAgUyhkZW40LCBkZW4yKTtcbiAgTShkZW42LCBkZW40LCBkZW4yKTtcbiAgTSh0LCBkZW42LCBudW0pO1xuICBNKHQsIHQsIGRlbik7XG5cbiAgcG93MjUyMyh0LCB0KTtcbiAgTSh0LCB0LCBudW0pO1xuICBNKHQsIHQsIGRlbik7XG4gIE0odCwgdCwgZGVuKTtcbiAgTShyWzBdLCB0LCBkZW4pO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgTShyWzBdLCByWzBdLCBJKTtcblxuICBTKGNoaywgclswXSk7XG4gIE0oY2hrLCBjaGssIGRlbik7XG4gIGlmIChuZXEyNTUxOShjaGssIG51bSkpIHJldHVybiAtMTtcblxuICBpZiAocGFyMjU1MTkoclswXSkgPT09IChwWzMxXT4+NykpIFooclswXSwgZ2YwLCByWzBdKTtcblxuICBNKHJbM10sIHJbMF0sIHJbMV0pO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgbiwgcGspIHtcbiAgdmFyIGksIG1sZW47XG4gIHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBoID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXSxcbiAgICAgIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgbWxlbiA9IC0xO1xuICBpZiAobiA8IDY0KSByZXR1cm4gLTE7XG5cbiAgaWYgKHVucGFja25lZyhxLCBwaykpIHJldHVybiAtMTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBtW2ldID0gc21baV07XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSBtW2krMzJdID0gcGtbaV07XG4gIGNyeXB0b19oYXNoKGgsIG0sIG4pO1xuICByZWR1Y2UoaCk7XG4gIHNjYWxhcm11bHQocCwgcSwgaCk7XG5cbiAgc2NhbGFyYmFzZShxLCBzbS5zdWJhcnJheSgzMikpO1xuICBhZGQocCwgcSk7XG4gIHBhY2sodCwgcCk7XG5cbiAgbiAtPSA2NDtcbiAgaWYgKGNyeXB0b192ZXJpZnlfMzIoc20sIDAsIHQsIDApKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2kgKyA2NF07XG4gIG1sZW4gPSBuO1xuICByZXR1cm4gbWxlbjtcbn1cblxudmFyIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMgPSAyNCxcbiAgICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTID0gMTYsXG4gICAgY3J5cHRvX3NjYWxhcm11bHRfQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9OT05DRUJZVEVTID0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICAgIGNyeXB0b19ib3hfWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gICAgY3J5cHRvX2JveF9CT1haRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgICBjcnlwdG9fc2lnbl9CWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMgPSA2NCxcbiAgICBjcnlwdG9fc2lnbl9TRUVEQllURVMgPSAzMixcbiAgICBjcnlwdG9faGFzaF9CWVRFUyA9IDY0O1xuXG5uYWNsLmxvd2xldmVsID0ge1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMDogY3J5cHRvX2NvcmVfaHNhbHNhMjAsXG4gIGNyeXB0b19zdHJlYW1feG9yOiBjcnlwdG9fc3RyZWFtX3hvcixcbiAgY3J5cHRvX3N0cmVhbTogY3J5cHRvX3N0cmVhbSxcbiAgY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcjogY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcixcbiAgY3J5cHRvX3N0cmVhbV9zYWxzYTIwOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAsXG4gIGNyeXB0b19vbmV0aW1lYXV0aDogY3J5cHRvX29uZXRpbWVhdXRoLFxuICBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5OiBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5LFxuICBjcnlwdG9fdmVyaWZ5XzE2OiBjcnlwdG9fdmVyaWZ5XzE2LFxuICBjcnlwdG9fdmVyaWZ5XzMyOiBjcnlwdG9fdmVyaWZ5XzMyLFxuICBjcnlwdG9fc2VjcmV0Ym94OiBjcnlwdG9fc2VjcmV0Ym94LFxuICBjcnlwdG9fc2VjcmV0Ym94X29wZW46IGNyeXB0b19zZWNyZXRib3hfb3BlbixcbiAgY3J5cHRvX3NjYWxhcm11bHQ6IGNyeXB0b19zY2FsYXJtdWx0LFxuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlOiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlLFxuICBjcnlwdG9fYm94X2JlZm9yZW5tOiBjcnlwdG9fYm94X2JlZm9yZW5tLFxuICBjcnlwdG9fYm94X2FmdGVybm06IGNyeXB0b19ib3hfYWZ0ZXJubSxcbiAgY3J5cHRvX2JveDogY3J5cHRvX2JveCxcbiAgY3J5cHRvX2JveF9vcGVuOiBjcnlwdG9fYm94X29wZW4sXG4gIGNyeXB0b19ib3hfa2V5cGFpcjogY3J5cHRvX2JveF9rZXlwYWlyLFxuICBjcnlwdG9faGFzaDogY3J5cHRvX2hhc2gsXG4gIGNyeXB0b19zaWduOiBjcnlwdG9fc2lnbixcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcjogY3J5cHRvX3NpZ25fa2V5cGFpcixcbiAgY3J5cHRvX3NpZ25fb3BlbjogY3J5cHRvX3NpZ25fb3BlbixcblxuICBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM6IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbiAgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVM6IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsXG4gIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTOiBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyxcbiAgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTLFxuICBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTLFxuICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTOiBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTLFxuICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM6IGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyxcbiAgY3J5cHRvX2JveF9OT05DRUJZVEVTOiBjcnlwdG9fYm94X05PTkNFQllURVMsXG4gIGNyeXB0b19ib3hfWkVST0JZVEVTOiBjcnlwdG9fYm94X1pFUk9CWVRFUyxcbiAgY3J5cHRvX2JveF9CT1haRVJPQllURVM6IGNyeXB0b19ib3hfQk9YWkVST0JZVEVTLFxuICBjcnlwdG9fc2lnbl9CWVRFUzogY3J5cHRvX3NpZ25fQllURVMsXG4gIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyxcbiAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM6IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTLFxuICBjcnlwdG9fc2lnbl9TRUVEQllURVM6IGNyeXB0b19zaWduX1NFRURCWVRFUyxcbiAgY3J5cHRvX2hhc2hfQllURVM6IGNyeXB0b19oYXNoX0JZVEVTXG59O1xuXG4vKiBIaWdoLWxldmVsIEFQSSAqL1xuXG5mdW5jdGlvbiBjaGVja0xlbmd0aHMoaywgbikge1xuICBpZiAoay5sZW5ndGggIT09IGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIGtleSBzaXplJyk7XG4gIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBub25jZSBzaXplJyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94TGVuZ3Rocyhwaywgc2spIHtcbiAgaWYgKHBrLmxlbmd0aCAhPT0gY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gIGlmIChzay5sZW5ndGggIT09IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xufVxuXG5mdW5jdGlvbiBjaGVja0FycmF5VHlwZXMoKSB7XG4gIHZhciB0LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgIGlmICgodCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHNbaV0pKSAhPT0gJ1tvYmplY3QgVWludDhBcnJheV0nKVxuICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuZXhwZWN0ZWQgdHlwZSAnICsgdCArICcsIHVzZSBVaW50OEFycmF5Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW51cChhcnIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycltpXSA9IDA7XG59XG5cbi8vIFRPRE86IENvbXBsZXRlbHkgcmVtb3ZlIHRoaXMgaW4gdjAuMTUuXG5pZiAoIW5hY2wudXRpbCkge1xuICBuYWNsLnV0aWwgPSB7fTtcbiAgbmFjbC51dGlsLmRlY29kZVVURjggPSBuYWNsLnV0aWwuZW5jb2RlVVRGOCA9IG5hY2wudXRpbC5lbmNvZGVCYXNlNjQgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCduYWNsLnV0aWwgbW92ZWQgaW50byBzZXBhcmF0ZSBwYWNrYWdlOiBodHRwczovL2dpdGh1Yi5jb20vZGNoZXN0L3R3ZWV0bmFjbC11dGlsLWpzJyk7XG4gIH07XG59XG5cbm5hY2wucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBiID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gIHJhbmRvbWJ5dGVzKGIsIG4pO1xuICByZXR1cm4gYjtcbn07XG5cbm5hY2wuc2VjcmV0Ym94ID0gZnVuY3Rpb24obXNnLCBub25jZSwga2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhtc2csIG5vbmNlLCBrZXkpO1xuICBjaGVja0xlbmd0aHMoa2V5LCBub25jZSk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIGMgPSBuZXcgVWludDhBcnJheShtLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBtW2krY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVNdID0gbXNnW2ldO1xuICBjcnlwdG9fc2VjcmV0Ym94KGMsIG0sIG0ubGVuZ3RoLCBub25jZSwga2V5KTtcbiAgcmV0dXJuIGMuc3ViYXJyYXkoY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMpO1xufTtcblxubmFjbC5zZWNyZXRib3gub3BlbiA9IGZ1bmN0aW9uKGJveCwgbm9uY2UsIGtleSkge1xuICBjaGVja0FycmF5VHlwZXMoYm94LCBub25jZSwga2V5KTtcbiAgY2hlY2tMZW5ndGhzKGtleSwgbm9uY2UpO1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTICsgYm94Lmxlbmd0aCk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoYy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJveC5sZW5ndGg7IGkrKykgY1tpK2NyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTXSA9IGJveFtpXTtcbiAgaWYgKGMubGVuZ3RoIDwgMzIpIHJldHVybiBmYWxzZTtcbiAgaWYgKGNyeXB0b19zZWNyZXRib3hfb3BlbihtLCBjLCBjLmxlbmd0aCwgbm9uY2UsIGtleSkgIT09IDApIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG0uc3ViYXJyYXkoY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMpO1xufTtcblxubmFjbC5zZWNyZXRib3gua2V5TGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUztcbm5hY2wuc2VjcmV0Ym94Lm5vbmNlTGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTO1xubmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUztcblxubmFjbC5zY2FsYXJNdWx0ID0gZnVuY3Rpb24obiwgcCkge1xuICBjaGVja0FycmF5VHlwZXMobiwgcCk7XG4gIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG4gc2l6ZScpO1xuICBpZiAocC5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwIHNpemUnKTtcbiAgdmFyIHEgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIHApO1xuICByZXR1cm4gcTtcbn07XG5cbm5hY2wuc2NhbGFyTXVsdC5iYXNlID0gZnVuY3Rpb24obikge1xuICBjaGVja0FycmF5VHlwZXMobik7XG4gIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG4gc2l6ZScpO1xuICB2YXIgcSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShxLCBuKTtcbiAgcmV0dXJuIHE7XG59O1xuXG5uYWNsLnNjYWxhck11bHQuc2NhbGFyTGVuZ3RoID0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVM7XG5uYWNsLnNjYWxhck11bHQuZ3JvdXBFbGVtZW50TGVuZ3RoID0gY3J5cHRvX3NjYWxhcm11bHRfQllURVM7XG5cbm5hY2wuYm94ID0gZnVuY3Rpb24obXNnLCBub25jZSwgcHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgdmFyIGsgPSBuYWNsLmJveC5iZWZvcmUocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICByZXR1cm4gbmFjbC5zZWNyZXRib3gobXNnLCBub25jZSwgayk7XG59O1xuXG5uYWNsLmJveC5iZWZvcmUgPSBmdW5jdGlvbihwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICBjaGVja0JveExlbmd0aHMocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICB2YXIgayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyk7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgcHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICByZXR1cm4gaztcbn07XG5cbm5hY2wuYm94LmFmdGVyID0gbmFjbC5zZWNyZXRib3g7XG5cbm5hY2wuYm94Lm9wZW4gPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBuYWNsLnNlY3JldGJveC5vcGVuKG1zZywgbm9uY2UsIGspO1xufTtcblxubmFjbC5ib3gub3Blbi5hZnRlciA9IG5hY2wuc2VjcmV0Ym94Lm9wZW47XG5cbm5hY2wuYm94LmtleVBhaXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpO1xuICBjcnlwdG9fYm94X2tleXBhaXIocGssIHNrKTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IHNrfTtcbn07XG5cbm5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHBrLCBzZWNyZXRLZXkpO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KX07XG59O1xuXG5uYWNsLmJveC5wdWJsaWNLZXlMZW5ndGggPSBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTO1xubmFjbC5ib3guc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUztcbm5hY2wuYm94LnNoYXJlZEtleUxlbmd0aCA9IGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUztcbm5hY2wuYm94Lm5vbmNlTGVuZ3RoID0gY3J5cHRvX2JveF9OT05DRUJZVEVTO1xubmFjbC5ib3gub3ZlcmhlYWRMZW5ndGggPSBuYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aDtcblxubmFjbC5zaWduID0gZnVuY3Rpb24obXNnLCBzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZywgc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgc2lnbmVkTXNnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMrbXNnLmxlbmd0aCk7XG4gIGNyeXB0b19zaWduKHNpZ25lZE1zZywgbXNnLCBtc2cubGVuZ3RoLCBzZWNyZXRLZXkpO1xuICByZXR1cm4gc2lnbmVkTXNnO1xufTtcblxubmFjbC5zaWduLm9wZW4gPSBmdW5jdGlvbihzaWduZWRNc2csIHB1YmxpY0tleSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25hY2wuc2lnbi5vcGVuIGFjY2VwdHMgMiBhcmd1bWVudHM7IGRpZCB5b3UgbWVhbiB0byB1c2UgbmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeT8nKTtcbiAgY2hlY2tBcnJheVR5cGVzKHNpZ25lZE1zZywgcHVibGljS2V5KTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoc2lnbmVkTXNnLmxlbmd0aCk7XG4gIHZhciBtbGVuID0gY3J5cHRvX3NpZ25fb3Blbih0bXAsIHNpZ25lZE1zZywgc2lnbmVkTXNnLmxlbmd0aCwgcHVibGljS2V5KTtcbiAgaWYgKG1sZW4gPCAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShtbGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBtW2ldID0gdG1wW2ldO1xuICByZXR1cm4gbTtcbn07XG5cbm5hY2wuc2lnbi5kZXRhY2hlZCA9IGZ1bmN0aW9uKG1zZywgc2VjcmV0S2V5KSB7XG4gIHZhciBzaWduZWRNc2cgPSBuYWNsLnNpZ24obXNnLCBzZWNyZXRLZXkpO1xuICB2YXIgc2lnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZy5sZW5ndGg7IGkrKykgc2lnW2ldID0gc2lnbmVkTXNnW2ldO1xuICByZXR1cm4gc2lnO1xufTtcblxubmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeSA9IGZ1bmN0aW9uKG1zZywgc2lnLCBwdWJsaWNLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZywgc2lnLCBwdWJsaWNLZXkpO1xuICBpZiAoc2lnLmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2lnbmF0dXJlIHNpemUnKTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHB1YmxpYyBrZXkgc2l6ZScpO1xuICB2YXIgc20gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgY3J5cHRvX3NpZ25fQllURVM7IGkrKykgc21baV0gPSBzaWdbaV07XG4gIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHNtW2krY3J5cHRvX3NpZ25fQllURVNdID0gbXNnW2ldO1xuICByZXR1cm4gKGNyeXB0b19zaWduX29wZW4obSwgc20sIHNtLmxlbmd0aCwgcHVibGljS2V5KSA+PSAwKTtcbn07XG5cbm5hY2wuc2lnbi5rZXlQYWlyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpO1xuICBjcnlwdG9fc2lnbl9rZXlwYWlyKHBrLCBzayk7XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBza307XG59O1xuXG5uYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VjcmV0S2V5ID0gZnVuY3Rpb24oc2VjcmV0S2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWNyZXRLZXkpO1xuICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBway5sZW5ndGg7IGkrKykgcGtbaV0gPSBzZWNyZXRLZXlbMzIraV07XG4gIHJldHVybiB7cHVibGljS2V5OiBwaywgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpfTtcbn07XG5cbm5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWVkID0gZnVuY3Rpb24oc2VlZCkge1xuICBjaGVja0FycmF5VHlwZXMoc2VlZCk7XG4gIGlmIChzZWVkLmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fU0VFREJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlZWQgc2l6ZScpO1xuICB2YXIgcGsgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSBza1tpXSA9IHNlZWRbaV07XG4gIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrLCB0cnVlKTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IHNrfTtcbn07XG5cbm5hY2wuc2lnbi5wdWJsaWNLZXlMZW5ndGggPSBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUztcbm5hY2wuc2lnbi5zZWNyZXRLZXlMZW5ndGggPSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUztcbm5hY2wuc2lnbi5zZWVkTGVuZ3RoID0gY3J5cHRvX3NpZ25fU0VFREJZVEVTO1xubmFjbC5zaWduLnNpZ25hdHVyZUxlbmd0aCA9IGNyeXB0b19zaWduX0JZVEVTO1xuXG5uYWNsLmhhc2ggPSBmdW5jdGlvbihtc2cpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZyk7XG4gIHZhciBoID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2hhc2hfQllURVMpO1xuICBjcnlwdG9faGFzaChoLCBtc2csIG1zZy5sZW5ndGgpO1xuICByZXR1cm4gaDtcbn07XG5cbm5hY2wuaGFzaC5oYXNoTGVuZ3RoID0gY3J5cHRvX2hhc2hfQllURVM7XG5cbm5hY2wudmVyaWZ5ID0gZnVuY3Rpb24oeCwgeSkge1xuICBjaGVja0FycmF5VHlwZXMoeCwgeSk7XG4gIC8vIFplcm8gbGVuZ3RoIGFyZ3VtZW50cyBhcmUgY29uc2lkZXJlZCBub3QgZXF1YWwuXG4gIGlmICh4Lmxlbmd0aCA9PT0gMCB8fCB5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAodm4oeCwgMCwgeSwgMCwgeC5sZW5ndGgpID09PSAwKSA/IHRydWUgOiBmYWxzZTtcbn07XG5cbm5hY2wuc2V0UFJORyA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJhbmRvbWJ5dGVzID0gZm47XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gIC8vIEluaXRpYWxpemUgUFJORyBpZiBlbnZpcm9ubWVudCBwcm92aWRlcyBDU1BSTkcuXG4gIC8vIElmIG5vdCwgbWV0aG9kcyBjYWxsaW5nIHJhbmRvbWJ5dGVzIHdpbGwgdGhyb3cuXG4gIHZhciBjcnlwdG8gPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyAoc2VsZi5jcnlwdG8gfHwgc2VsZi5tc0NyeXB0bykgOiBudWxsO1xuICBpZiAoY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBCcm93c2Vycy5cbiAgICB2YXIgUVVPVEEgPSA2NTUzNjtcbiAgICBuYWNsLnNldFBSTkcoZnVuY3Rpb24oeCwgbikge1xuICAgICAgdmFyIGksIHYgPSBuZXcgVWludDhBcnJheShuKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpICs9IFFVT1RBKSB7XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModi5zdWJhcnJheShpLCBpICsgTWF0aC5taW4obiAtIGksIFFVT1RBKSkpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IHZbaV07XG4gICAgICBjbGVhbnVwKHYpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vZGUuanMuXG4gICAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gICAgaWYgKGNyeXB0byAmJiBjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICAgIG5hY2wuc2V0UFJORyhmdW5jdGlvbih4LCBuKSB7XG4gICAgICAgIHZhciBpLCB2ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKG4pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gdltpXTtcbiAgICAgICAgY2xlYW51cCh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSkoKTtcblxufSkodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgPyBtb2R1bGUuZXhwb3J0cyA6IChzZWxmLm5hY2wgPSBzZWxmLm5hY2wgfHwge30pKTtcbiIsIi8qKiBAbGljZW5zZSBVUkkuanMgdjQuMi4xIChjKSAyMDExIEdhcnkgQ291cnQuIExpY2Vuc2U6IGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanMgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5VUkkgPSBnbG9iYWwuVVJJIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc2V0cyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB2YXIgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIHggPSAxOyB4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgc2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBzZXRzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZXRzWzBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YmV4cChzdHIpIHtcbiAgICByZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuZnVuY3Rpb24gdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IG8gPT09IG51bGwgPyBcIm51bGxcIiA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zcGxpdChcIiBcIikucG9wKCkuc3BsaXQoXCJdXCIpLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gb2JqIDogdHlwZW9mIG9iai5sZW5ndGggIT09IFwibnVtYmVyXCIgfHwgb2JqLnNwbGl0IHx8IG9iai5zZXRJbnRlcnZhbCB8fCBvYmouY2FsbCA/IFtvYmpdIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKSA6IFtdO1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gICAgdmFyIG9iaiA9IHRhcmdldDtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gYnVpbGRFeHBzKGlzSVJJKSB7XG4gICAgdmFyIEFMUEhBJCQgPSBcIltBLVphLXpdXCIsXG4gICAgICAgIENSJCA9IFwiW1xcXFx4MERdXCIsXG4gICAgICAgIERJR0lUJCQgPSBcIlswLTldXCIsXG4gICAgICAgIERRVU9URSQkID0gXCJbXFxcXHgyMl1cIixcbiAgICAgICAgSEVYRElHJCQgPSBtZXJnZShESUdJVCQkLCBcIltBLUZhLWZdXCIpLFxuICAgICAgICAvL2Nhc2UtaW5zZW5zaXRpdmVcbiAgICBMRiQkID0gXCJbXFxcXHgwQV1cIixcbiAgICAgICAgU1AkJCA9IFwiW1xcXFx4MjBdXCIsXG4gICAgICAgIFBDVF9FTkNPREVEJCA9IHN1YmV4cChzdWJleHAoXCIlW0VGZWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVbODlBLUZhLWZdXCIgKyBIRVhESUckJCArIFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkgKyBcInxcIiArIHN1YmV4cChcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpKSxcbiAgICAgICAgLy9leHBhbmRlZFxuICAgIEdFTl9ERUxJTVMkJCA9IFwiW1xcXFw6XFxcXC9cXFxcP1xcXFwjXFxcXFtcXFxcXVxcXFxAXVwiLFxuICAgICAgICBTVUJfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCZcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw9XVwiLFxuICAgICAgICBSRVNFUlZFRCQkID0gbWVyZ2UoR0VOX0RFTElNUyQkLCBTVUJfREVMSU1TJCQpLFxuICAgICAgICBVQ1NDSEFSJCQgPSBpc0lSSSA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXQsIGV4Y2x1ZGVzIGJpZGkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgSVBSSVZBVEUkJCA9IGlzSVJJID8gXCJbXFxcXHVFMDAwLVxcXFx1RjhGRl1cIiA6IFwiW11cIixcbiAgICAgICAgLy9zdWJzZXRcbiAgICBVTlJFU0VSVkVEJCQgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSxcbiAgICAgICAgU0NIRU1FJCA9IHN1YmV4cChBTFBIQSQkICsgbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSArIFwiKlwiKSxcbiAgICAgICAgVVNFUklORk8kID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikpICsgXCIqXCIpLFxuICAgICAgICBERUNfT0NURVQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiWzEtOV1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBESUdJVCQkKSxcbiAgICAgICAgREVDX09DVEVUX1JFTEFYRUQkID0gc3ViZXhwKHN1YmV4cChcIjI1WzAtNV1cIikgKyBcInxcIiArIHN1YmV4cChcIjJbMC00XVwiICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjFcIiArIERJR0lUJCQgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMD9bMS05XVwiICsgRElHSVQkJCkgKyBcInwwPzA/XCIgKyBESUdJVCQkKSxcbiAgICAgICAgLy9yZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSxcbiAgICAgICAgSDE2JCA9IHN1YmV4cChIRVhESUckJCArIFwiezEsNH1cIiksXG4gICAgICAgIExTMzIkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiICsgSDE2JCkgKyBcInxcIiArIElQVjRBRERSRVNTJCksXG4gICAgICAgIElQVjZBRERSRVNTMSQgPSBzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Nn1cIiArIExTMzIkKSxcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MyJCA9IHN1YmV4cChcIlxcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezV9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgSVBWNkFERFJFU1MzJCA9IHN1YmV4cChzdWJleHAoSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns0fVwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7M31cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Mn1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTNiQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsM31cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCArIFwiXFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICozKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgaDE2IFwiOlwiICAgbHMzMlxuICAgIElQVjZBRERSRVNTNyQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNH1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgTFMzMiQpLFxuICAgICAgICAvL1sgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuICAgIElQVjZBRERSRVNTOCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgSDE2JCksXG4gICAgICAgIC8vWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcbiAgICBJUFY2QUREUkVTUzkkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDZ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiksXG4gICAgICAgIC8vWyAqNiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiXG4gICAgSVBWNkFERFJFU1MkID0gc3ViZXhwKFtJUFY2QUREUkVTUzEkLCBJUFY2QUREUkVTUzIkLCBJUFY2QUREUkVTUzMkLCBJUFY2QUREUkVTUzQkLCBJUFY2QUREUkVTUzUkLCBJUFY2QUREUkVTUzYkLCBJUFY2QUREUkVTUzckLCBJUFY2QUREUkVTUzgkLCBJUFY2QUREUkVTUzkkXS5qb2luKFwifFwiKSksXG4gICAgICAgIFpPTkVJRCQgPSBzdWJleHAoc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkKSArIFwiK1wiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWiQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgXCJcXFxcJTI1XCIgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIElQVjZBRERSWl9SRUxBWEVEJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBzdWJleHAoXCJcXFxcJTI1fFxcXFwlKD8hXCIgKyBIRVhESUckJCArIFwiezJ9KVwiKSArIFpPTkVJRCQpLFxuICAgICAgICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIElQVkZVVFVSRSQgPSBzdWJleHAoXCJbdlZdXCIgKyBIRVhESUckJCArIFwiK1xcXFwuXCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpICsgXCIrXCIpLFxuICAgICAgICBJUF9MSVRFUkFMJCA9IHN1YmV4cChcIlxcXFxbXCIgKyBzdWJleHAoSVBWNkFERFJaX1JFTEFYRUQkICsgXCJ8XCIgKyBJUFY2QUREUkVTUyQgKyBcInxcIiArIElQVkZVVFVSRSQpICsgXCJcXFxcXVwiKSxcbiAgICAgICAgLy9SRkMgNjg3NFxuICAgIFJFR19OQU1FJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCkpICsgXCIqXCIpLFxuICAgICAgICBIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLFxuICAgICAgICBQT1JUJCA9IHN1YmV4cChESUdJVCQkICsgXCIqXCIpLFxuICAgICAgICBBVVRIT1JJVFkkID0gc3ViZXhwKHN1YmV4cChVU0VSSU5GTyQgKyBcIkBcIikgKyBcIj9cIiArIEhPU1QkICsgc3ViZXhwKFwiXFxcXDpcIiArIFBPUlQkKSArIFwiP1wiKSxcbiAgICAgICAgUENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBdXCIpKSxcbiAgICAgICAgU0VHTUVOVCQgPSBzdWJleHAoUENIQVIkICsgXCIqXCIpLFxuICAgICAgICBTRUdNRU5UX05aJCA9IHN1YmV4cChQQ0hBUiQgKyBcIitcIiksXG4gICAgICAgIFNFR01FTlRfTlpfTkMkID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcQF1cIikpICsgXCIrXCIpLFxuICAgICAgICBQQVRIX0FCRU1QVFkkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXCIgKyBTRUdNRU5UJCkgKyBcIipcIiksXG4gICAgICAgIFBBVEhfQUJTT0xVVEUkID0gc3ViZXhwKFwiXFxcXC9cIiArIHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpICsgXCI/XCIpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX05PU0NIRU1FJCA9IHN1YmV4cChTRUdNRU5UX05aX05DJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX1JPT1RMRVNTJCA9IHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpLFxuICAgICAgICAvL3NpbXBsaWZpZWRcbiAgICBQQVRIX0VNUFRZJCA9IFwiKD8hXCIgKyBQQ0hBUiQgKyBcIilcIixcbiAgICAgICAgUEFUSCQgPSBzdWJleHAoUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfTk9TQ0hFTUUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBRVUVSWSQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFwiICsgbWVyZ2UoXCJbXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCkpICsgXCIqXCIpLFxuICAgICAgICBGUkFHTUVOVCQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFtcXFxcL1xcXFw/XVwiKSArIFwiKlwiKSxcbiAgICAgICAgSElFUl9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBVUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBSRUxBVElWRV9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuICAgICAgICBSRUxBVElWRSQgPSBzdWJleHAoUkVMQVRJVkVfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCNcIiArIEZSQUdNRU5UJCkgKyBcIj9cIiksXG4gICAgICAgIFVSSV9SRUZFUkVOQ0UkID0gc3ViZXhwKFVSSSQgKyBcInxcIiArIFJFTEFUSVZFJCksXG4gICAgICAgIEFCU09MVVRFX1VSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiKSxcbiAgICAgICAgR0VORVJJQ19SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBSRUxBVElWRV9SRUYkID0gXCJeKCl7MH1cIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFCU09MVVRFX1JFRiQgPSBcIl4oXCIgKyBTQ0hFTUUkICsgXCIpXFxcXDpcIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX1JPT1RMRVNTJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgU0FNRURPQ19SRUYkID0gXCJeXCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgQVVUSE9SSVRZX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPyRcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBOT1RfU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIiksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1VTRVJJTkZPOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0hPU1Q6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXFtcXFxcXVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEg6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcOlxcXFxAXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEhfTk9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9RVUVSWTogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiwgSVBSSVZBVEUkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX0ZSQUdNRU5UOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiKSwgXCJnXCIpLFxuICAgICAgICBFU0NBUEU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIFVOUkVTRVJWRUQ6IG5ldyBSZWdFeHAoVU5SRVNFUlZFRCQkLCBcImdcIiksXG4gICAgICAgIE9USEVSX0NIQVJTOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJV1cIiwgVU5SRVNFUlZFRCQkLCBSRVNFUlZFRCQkKSwgXCJnXCIpLFxuICAgICAgICBQQ1RfRU5DT0RFRDogbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKSxcbiAgICAgICAgSVBWNEFERFJFU1M6IG5ldyBSZWdFeHAoXCJeKFwiICsgSVBWNEFERFJFU1MkICsgXCIpJFwiKSxcbiAgICAgICAgSVBWNkFERFJFU1M6IG5ldyBSZWdFeHAoXCJeXFxcXFs/KFwiICsgSVBWNkFERFJFU1MkICsgXCIpXCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBcIihcIiArIFpPTkVJRCQgKyBcIilcIikgKyBcIj9cXFxcXT8kXCIpIC8vUkZDIDY4NzQsIHdpdGggcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgfTtcbn1cbnZhciBVUklfUFJPVE9DT0wgPSBidWlsZEV4cHMoZmFsc2UpO1xuXG52YXIgSVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKHRydWUpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gIH1cbn07XG5cbi8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblxudmFyIG1heEludCA9IDIxNDc0ODM2NDc7IC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xudmFyIGJhc2UgPSAzNjtcbnZhciB0TWluID0gMTtcbnZhciB0TWF4ID0gMjY7XG52YXIgc2tldyA9IDM4O1xudmFyIGRhbXAgPSA3MDA7XG52YXIgaW5pdGlhbEJpYXMgPSA3MjtcbnZhciBpbml0aWFsTiA9IDEyODsgLy8gMHg4MFxudmFyIGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xudmFyIHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vO1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx4N0VdLzsgLy8gbm9uLUFTQ0lJIGNoYXJzXG52YXIgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbnZhciBlcnJvcnMgPSB7XG5cdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuXG4vKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZXJyb3IkMSh0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAqIGFkZHJlc3Nlcy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gKiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHR2YXIgcmVzdWx0ID0gJyc7XG5cdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdH1cblx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBkZWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGNvdW50ZXIgPSAwO1xuXHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdC8vIEl0J3MgYSBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXIuXG5cdFx0XHR2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG5cdFx0XHRcdC8vIExvdyBzdXJyb2dhdGUuXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJdCdzIGFuIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZVxuXHRcdFx0XHQvLyBuZXh0IGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci5cblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gKiBAbmFtZSBlbmNvZGVcbiAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gKi9cbnZhciB1Y3MyZW5jb2RlID0gZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCB0b0NvbnN1bWFibGVBcnJheShhcnJheSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cbiAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICovXG52YXIgYmFzaWNUb0RpZ2l0ID0gZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xudmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbn07XG5cbi8qKlxuICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgYWRhcHQgPSBmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0dmFyIGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoOyAvKiBubyBpbml0aWFsaXphdGlvbiAqL2RlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdC8vIERvbid0IHVzZSBVQ1MtMi5cblx0dmFyIG91dHB1dCA9IFtdO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBpID0gMDtcblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0dmFyIGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdGJhc2ljID0gMDtcblx0fVxuXG5cdGZvciAodmFyIGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdGVycm9yJDEoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKHZhciBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7KSAvKiBubyBmaW5hbCBleHByZXNzaW9uICove1xuXG5cdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHR2YXIgb2xkaSA9IGk7XG5cdFx0Zm9yICh2YXIgdyA9IDEsIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cblx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRlcnJvciQxKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cblx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblx0XHR9XG5cblx0XHR2YXIgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cdH1cblxuXHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCBvdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdHZhciBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0dmFyIG4gPSBpbml0aWFsTjtcblx0dmFyIGRlbHRhID0gMDtcblx0dmFyIGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG5cdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHR2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cblx0dHJ5IHtcblx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcblx0XHRcdHZhciBfY3VycmVudFZhbHVlMiA9IF9zdGVwLnZhbHVlO1xuXG5cdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZTIgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShfY3VycmVudFZhbHVlMikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0X2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuXHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHR9IGZpbmFsbHkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRfaXRlcmF0b3IucmV0dXJuKCk7XG5cdFx0XHR9XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuXHRcdFx0XHR0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXHR2YXIgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aDtcblxuXHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG5cdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdH1cblxuXHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHR2YXIgbSA9IG1heEludDtcblx0XHR2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuXHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcblx0XHR2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGZvciAodmFyIF9pdGVyYXRvcjIgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuXHRcdFx0XHR2YXIgY3VycmVudFZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdy5cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IyLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdG4gPSBtO1xuXG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IzID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMyA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IzID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDM7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSAoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWUpIHtcblx0XHRcdFx0dmFyIF9jdXJyZW50VmFsdWUgPSBfc3RlcDMudmFsdWU7XG5cblx0XHRcdFx0aWYgKF9jdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cblx0XHRcdFx0XHR2YXIgcSA9IGRlbHRhO1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSBiYXNlOzsgLyogbm8gY29uZGl0aW9uICovayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdF9kaWRJdGVyYXRvckVycm9yMyA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcblx0XHRcdFx0XHRfaXRlcmF0b3IzLnJldHVybigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3IzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0KytkZWx0YTtcblx0XHQrK247XG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbnZhciB0b1VuaWNvZGUgPSBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKSA/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSkgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xudmFyIHRvQVNDSUkgPSBmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZykgPyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKSA6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xudmFyIHB1bnljb2RlID0ge1xuXHQvKipcbiAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICogQG1lbWJlck9mIHB1bnljb2RlXG4gICogQHR5cGUgU3RyaW5nXG4gICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG4gICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcbiAgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIE9iamVjdFxuICAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbi8qKlxuICogVVJJLmpzXG4gKlxuICogQGZpbGVvdmVydmlldyBBbiBSRkMgMzk4NiBjb21wbGlhbnQsIHNjaGVtZSBleHRlbmRhYmxlIFVSSSBwYXJzaW5nL3ZhbGlkYXRpbmcvcmVzb2x2aW5nIGxpYnJhcnkgZm9yIEphdmFTY3JpcHQuXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z2FyeS5jb3VydEBnbWFpbC5jb21cIj5HYXJ5IENvdXJ0PC9hPlxuICogQHNlZSBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzXG4gKi9cbi8qKlxuICogQ29weXJpZ2h0IDIwMTEgR2FyeSBDb3VydC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmVcbiAqIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqICAgIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mXG4gKiAgICAgICBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3RcbiAqICAgICAgIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gKiAgICAgICBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBHQVJZIENPVVJUIGBgQVMgSVMnJyBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRFxuICogV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIEdBUlkgQ09VUlQgT1JcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG4gKiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbiAqIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFRoZSB2aWV3cyBhbmQgY29uY2x1c2lvbnMgY29udGFpbmVkIGluIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBhcmUgdGhvc2Ugb2YgdGhlXG4gKiBhdXRob3JzIGFuZCBzaG91bGQgbm90IGJlIGludGVycHJldGVkIGFzIHJlcHJlc2VudGluZyBvZmZpY2lhbCBwb2xpY2llcywgZWl0aGVyIGV4cHJlc3NlZFxuICogb3IgaW1wbGllZCwgb2YgR2FyeSBDb3VydC5cbiAqL1xudmFyIFNDSEVNRVMgPSB7fTtcbmZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyKSB7XG4gICAgdmFyIGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZSA9IHZvaWQgMDtcbiAgICBpZiAoYyA8IDE2KSBlID0gXCIlMFwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMTI4KSBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgaWYgKGMgPCAyMDQ4KSBlID0gXCIlXCIgKyAoYyA+PiA2IHwgMTkyKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKGMgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBlID0gXCIlXCIgKyAoYyA+PiAxMiB8IDIyNCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjID4+IDYgJiA2MyB8IDEyOCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcGN0RGVjQ2hhcnMoc3RyKSB7XG4gICAgdmFyIG5ld1N0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBpbCA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBpbCkge1xuICAgICAgICB2YXIgYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNik7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDYpIHtcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCBjMiAmIDYzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDY7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAyMjQpIHtcbiAgICAgICAgICAgIGlmIChpbCAtIGkgPj0gOSkge1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDQsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIGMzID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNywgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDE1KSA8PCAxMiB8IChfYyAmIDYzKSA8PCA2IHwgYzMgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgMyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0cjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCkge1xuICAgIGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgICAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lKSBjb21wb25lbnRzLnNjaGVtZSA9IFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9TQ0hFTUUsIFwiXCIpO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMudXNlcmluZm8gPSBTdHJpbmcoY29tcG9uZW50cy51c2VyaW5mbykucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfVVNFUklORk8sIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuaG9zdCA9IFN0cmluZyhjb21wb25lbnRzLmhvc3QpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfSE9TVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLnBhdGggIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5wYXRoID0gU3RyaW5nKGNvbXBvbmVudHMucGF0aCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShjb21wb25lbnRzLnNjaGVtZSA/IHByb3RvY29sLk5PVF9QQVRIIDogcHJvdG9jb2wuTk9UX1BBVEhfTk9TQ0hFTUUsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnF1ZXJ5ID0gU3RyaW5nKGNvbXBvbmVudHMucXVlcnkpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1FVRVJZLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5mcmFnbWVudCA9IFN0cmluZyhjb21wb25lbnRzLmZyYWdtZW50KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9GUkFHTUVOVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfc3RyaXBMZWFkaW5nWmVyb3Moc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbn1cbmZ1bmN0aW9uIF9ub3JtYWxpemVJUHY0KGhvc3QsIHByb3RvY29sKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjRBRERSRVNTKSB8fCBbXTtcblxuICAgIHZhciBfbWF0Y2hlcyA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMiksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlc1sxXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLnNwbGl0KFwiLlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKS5qb2luKFwiLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2Nihob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMyID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAzKSxcbiAgICAgICAgYWRkcmVzcyA9IF9tYXRjaGVzMlsxXSxcbiAgICAgICAgem9uZSA9IF9tYXRjaGVzMlsyXTtcblxuICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoJzo6JykucmV2ZXJzZSgpLFxuICAgICAgICAgICAgX2FkZHJlc3MkdG9Mb3dlckNhc2UkMiA9IHNsaWNlZFRvQXJyYXkoX2FkZHJlc3MkdG9Mb3dlckNhc2UkLCAyKSxcbiAgICAgICAgICAgIGxhc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzBdLFxuICAgICAgICAgICAgZmlyc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzFdO1xuXG4gICAgICAgIHZhciBmaXJzdEZpZWxkcyA9IGZpcnN0ID8gZmlyc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpIDogW107XG4gICAgICAgIHZhciBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG4gICAgICAgIHZhciBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB2YXIgZmllbGRDb3VudCA9IGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPyA3IDogODtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcbiAgICAgICAgdmFyIGZpZWxkcyA9IEFycmF5KGZpZWxkQ291bnQpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGZpZWxkQ291bnQ7ICsreCkge1xuICAgICAgICAgICAgZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMYXN0RmllbGRJUHY0QWRkcmVzcykge1xuICAgICAgICAgICAgZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0TG9uZ2VzdCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMb25nZXN0ICYmIGxhc3RMb25nZXN0LmluZGV4ICsgbGFzdExvbmdlc3QubGVuZ3RoID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TG9uZ2VzdC5sZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2MucHVzaCh7IGluZGV4OiBpbmRleCwgbGVuZ3RoOiAxIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdmFyIGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHZhciBuZXdIb3N0ID0gdm9pZCAwO1xuICAgICAgICBpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIG5ld0ZpcnN0ID0gZmllbGRzLnNsaWNlKDAsIGxvbmdlc3RaZXJvRmllbGRzLmluZGV4KTtcbiAgICAgICAgICAgIHZhciBuZXdMYXN0ID0gZmllbGRzLnNsaWNlKGxvbmdlc3RaZXJvRmllbGRzLmluZGV4ICsgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdIb3N0ID0gZmllbGRzLmpvaW4oXCI6XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6b25lKSB7XG4gICAgICAgICAgICBuZXdIb3N0ICs9IFwiJVwiICsgem9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SG9zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICB9XG59XG52YXIgVVJJX1BBUlNFID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KFteXFwvPyNAXSopQCk/KFxcW1teXFwvPyNcXF1dK1xcXXxbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxufFxccikqKSk/L2k7XG52YXIgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gXCJcIi5tYXRjaCgvKCl7MH0vKVsxXSA9PT0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gcGFyc2UodXJpU3RyaW5nKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSBcInN1ZmZpeFwiKSB1cmlTdHJpbmcgPSAob3B0aW9ucy5zY2hlbWUgPyBvcHRpb25zLnNjaGVtZSArIFwiOlwiIDogXCJcIikgKyBcIi8vXCIgKyB1cmlTdHJpbmc7XG4gICAgdmFyIG1hdGNoZXMgPSB1cmlTdHJpbmcubWF0Y2goVVJJX1BBUlNFKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBpZiAoTk9fTUFUQ0hfSVNfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gbWF0Y2hlc1s3XTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gbWF0Y2hlc1s1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vSUUgRklYIGZvciBpbXByb3BlciBSZWdFeHAgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICAgICAgICAgIGNvbXBvbmVudHMuc2NoZW1lID0gbWF0Y2hlc1sxXSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gdXJpU3RyaW5nLmluZGV4T2YoXCJAXCIpICE9PSAtMSA/IG1hdGNoZXNbM10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSB1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gdXJpU3RyaW5nLmluZGV4T2YoXCI/XCIpICE9PSAtMSA/IG1hdGNoZXNbN10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIjXCIpICE9PSAtMSA/IG1hdGNoZXNbOF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvL2ZpeCBwb3J0IG51bWJlclxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0c1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoY29tcG9uZW50cy5ob3N0LCBwcm90b2NvbCksIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL2RldGVybWluZSByZWZlcmVuY2UgdHlwZVxuICAgICAgICBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5ob3N0ID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy5wb3J0ID09PSB1bmRlZmluZWQgJiYgIWNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJzYW1lLWRvY3VtZW50XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJ1cmlcIjtcbiAgICAgICAgfVxuICAgICAgICAvL2NoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gY29tcG9uZW50cy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGlzIG5vdCBhIFwiICsgb3B0aW9ucy5yZWZlcmVuY2UgKyBcIiByZWZlcmVuY2UuXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9maW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIC8vY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCBzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUkgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb252ZXJ0IElSSSAtPiBVUklcbiAgICAgICAgICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBVUklfUFJPVE9DT0wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgZW5jb2RpbmdzXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgICAgICB9XG4gICAgICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICAgICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnRzO1xufVxuXG5mdW5jdGlvbiBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy51c2VyaW5mbyk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiQFwiKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIElQIGhvc3RzLCBhZGQgYnJhY2tldHMgYW5kIGVzY2FwZSB6b25lIHNlcGFyYXRvciBmb3IgSVB2NlxuICAgICAgICB1cmlUb2tlbnMucHVzaChfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChTdHJpbmcoY29tcG9uZW50cy5ob3N0KSwgcHJvdG9jb2wpLCBwcm90b2NvbCkucmVwbGFjZShwcm90b2NvbC5JUFY2QUREUkVTUywgZnVuY3Rpb24gKF8sICQxLCAkMikge1xuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgJDEgKyAoJDIgPyBcIiUyNVwiICsgJDIgOiBcIlwiKSArIFwiXVwiO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5wb3J0LnRvU3RyaW5nKDEwKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBSRFMxID0gL15cXC5cXC4/XFwvLztcbnZhciBSRFMyID0gL15cXC9cXC4oXFwvfCQpLztcbnZhciBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLztcbnZhciBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgd2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goUkRTMSkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzIsIFwiL1wiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsIFwiL1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgaW5wdXQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGltID0gaW5wdXQubWF0Y2goUkRTNSk7XG4gICAgICAgICAgICBpZiAoaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGltWzBdO1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2Uocy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgLy9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhbiBJUHY2IGFkZHJlc3NcbiAgICAgICAgaWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge31cbiAgICAgICAgLy9UT0RPOiBub3JtYWxpemUgSVB2NiBhZGRyZXNzIGFzIHBlciBSRkMgNTk1MlxuXG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvL25vcm1hbGl6ZSBlbmNvZGluZ1xuICAgIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiICYmIGNvbXBvbmVudHMuc2NoZW1lKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuc2NoZW1lKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuICAgIH1cbiAgICB2YXIgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xuICAgICAgICB9XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiL1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHMgPSBjb21wb25lbnRzLnBhdGg7XG4gICAgICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgICAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vLCBcIi8lMkZcIik7IC8vZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChzKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIj9cIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMucXVlcnkpO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiI1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB1cmlUb2tlbnMuam9pbihcIlwiKTsgLy9tZXJnZSB0b2tlbnMgaW50byBhIHN0cmluZ1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50cyhiYXNlLCByZWxhdGl2ZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgc2tpcE5vcm1hbGl6YXRpb24gPSBhcmd1bWVudHNbM107XG5cbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgICAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgLy9ub3JtYWxpemUgYmFzZSBjb21wb25lbnRzXG4gICAgICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudHNcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgICAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lO1xuICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGg7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3RhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgICAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZTtcbiAgICB9XG4gICAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICAgIHZhciBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZUNvbXBvbmVudHMocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSksIHNjaGVtZWxlc3NPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKHVyaSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaSA9IHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaTtcbn1cblxuZnVuY3Rpb24gZXF1YWwodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdXJpQSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmlBID0gc2VyaWFsaXplKHVyaUEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZShwYXJzZSh1cmlCLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQiA9IHNlcmlhbGl6ZSh1cmlCLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaUEgPT09IHVyaUI7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLkVTQ0FQRSA6IElSSV9QUk9UT0NPTC5FU0NBUEUsIHBjdEVuY0NoYXIpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLlBDVF9FTkNPREVEIDogSVJJX1BST1RPQ09MLlBDVF9FTkNPREVELCBwY3REZWNDaGFycyk7XG59XG5cbnZhciBoYW5kbGVyID0ge1xuICAgIHNjaGVtZTogXCJodHRwXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL3JlcG9ydCBtaXNzaW5nIGhvc3RcbiAgICAgICAgaWYgKCFjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKFN0cmluZyhjb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSAhPT0gXCJodHRwc1wiID8gODAgOiA0NDMpIHx8IGNvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gICAgICAgIGlmICghY29tcG9uZW50cy5wYXRoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBhdGggPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvL05PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgICAgICAgLy9hcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgICAgICAgLy9hbmQgbm90IHRoZSBIVFRQIHNwZWMuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBoYW5kbGVyJDEgPSB7XG4gICAgc2NoZW1lOiBcImh0dHBzXCIsXG4gICAgZG9tYWluSG9zdDogaGFuZGxlci5kb21haW5Ib3N0LFxuICAgIHBhcnNlOiBoYW5kbGVyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlci5zZXJpYWxpemVcbn07XG5cbnZhciBPID0ge307XG52YXIgaXNJUkkgPSB0cnVlO1xuLy9SRkMgMzk4NlxudmFyIFVOUkVTRVJWRUQkJCA9IFwiW0EtWmEtejAtOVxcXFwtXFxcXC5cXFxcX1xcXFx+XCIgKyAoaXNJUkkgPyBcIlxcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRlwiIDogXCJcIikgKyBcIl1cIjtcbnZhciBIRVhESUckJCA9IFwiWzAtOUEtRmEtZl1cIjsgLy9jYXNlLWluc2Vuc2l0aXZlXG52YXIgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpOyAvL2V4cGFuZGVkXG4vL1JGQyA1MzIyLCBleGNlcHQgdGhlc2Ugc3ltYm9scyBhcyBwZXIgUkZDIDYwNjg6IEAgOiAvID8gIyBbIF0gJiA7ID1cbi8vY29uc3QgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFwvXFxcXD1cXFxcP1xcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVRFWFQkJCA9IFwiW1xcXFx4MDEtXFxcXHgwOFxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3Rl1cIjsgIC8vKCVkMS04IC8gJWQxMS0xMiAvICVkMTQtMzEgLyAlZDEyNylcbi8vY29uc3QgUVRFWFQkJCA9IG1lcmdlKFwiW1xcXFx4MjFcXFxceDIzLVxcXFx4NUJcXFxceDVELVxcXFx4N0VdXCIsIE9CU19RVEVYVCQkKTsgIC8vJWQzMyAvICVkMzUtOTEgLyAlZDkzLTEyNiAvIG9icy1xdGV4dFxuLy9jb25zdCBWQ0hBUiQkID0gXCJbXFxcXHgyMS1cXFxceDdFXVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVAkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIG1lcmdlKFwiW1xcXFx4MDBcXFxceDBEXFxcXHgwQV1cIiwgT0JTX1FURVhUJCQpKTsgIC8vJWQwIC8gQ1IgLyBMRiAvIG9icy1xdGV4dFxuLy9jb25zdCBGV1MkID0gc3ViZXhwKHN1YmV4cChXU1AkJCArIFwiKlwiICsgXCJcXFxceDBEXFxcXHgwQVwiKSArIFwiP1wiICsgV1NQJCQgKyBcIitcIik7XG4vL2NvbnN0IFFVT1RFRF9QQUlSJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcXFxcXFwiICsgc3ViZXhwKFZDSEFSJCQgKyBcInxcIiArIFdTUCQkKSkgKyBcInxcIiArIE9CU19RUCQpO1xuLy9jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIHN1YmV4cChGV1MkICsgXCI/XCIgKyBRQ09OVEVOVCQpICsgXCIqXCIgKyBGV1MkICsgXCI/XCIgKyAnXFxcXFwiJyk7XG52YXIgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG52YXIgUVRFWFQkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJVxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwtXFxcXC4wLTlcXFxcPFxcXFw+QS1aXFxcXHg1RS1cXFxceDdFXVwiO1xudmFyIFZDSEFSJCQgPSBtZXJnZShRVEVYVCQkLCBcIltcXFxcXFxcIlxcXFxcXFxcXVwiKTtcbnZhciBTT01FX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXDpcXFxcQF1cIjtcbnZhciBVTlJFU0VSVkVEID0gbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKTtcbnZhciBQQ1RfRU5DT0RFRCA9IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIik7XG52YXIgTk9UX0xPQ0FMX1BBUlQgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFURVhUJCQsIFwiW1xcXFwuXVwiLCAnW1xcXFxcIl0nLCBWQ0hBUiQkKSwgXCJnXCIpO1xudmFyIE5PVF9IRk5BTUUgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU09NRV9ERUxJTVMkJCksIFwiZ1wiKTtcbnZhciBOT1RfSEZWQUxVRSA9IE5PVF9IRk5BTUU7XG5mdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cikge1xuICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgIHJldHVybiAhZGVjU3RyLm1hdGNoKFVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyO1xufVxudmFyIGhhbmRsZXIkMiA9IHtcbiAgICBzY2hlbWU6IFwibWFpbHRvXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlJCQxKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1haWx0b0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB2YXIgdG8gPSBtYWlsdG9Db21wb25lbnRzLnRvID0gbWFpbHRvQ29tcG9uZW50cy5wYXRoID8gbWFpbHRvQ29tcG9uZW50cy5wYXRoLnNwbGl0KFwiLFwiKSA6IFtdO1xuICAgICAgICBtYWlsdG9Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgdW5rbm93bkhlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgICAgICAgICB2YXIgaGZpZWxkcyA9IG1haWx0b0NvbXBvbmVudHMucXVlcnkuc3BsaXQoXCImXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsID0gaGZpZWxkcy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhmaWVsZCA9IGhmaWVsZHNbeF0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaGZpZWxkWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvQWRkcnMgPSBoZmllbGRbMV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX3ggPSAwLCBfeGwgPSB0b0FkZHJzLmxlbmd0aDsgX3ggPCBfeGw7ICsrX3gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0by5wdXNoKHRvQWRkcnNbX3hdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3ViamVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5ib2R5ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5rbm93bkhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1t1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMF0sIG9wdGlvbnMpXSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5rbm93bkhlYWRlcnMpIG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgX3gyID0gMCwgX3hsMiA9IHRvLmxlbmd0aDsgX3gyIDwgX3hsMjsgKytfeDIpIHtcbiAgICAgICAgICAgIHZhciBhZGRyID0gdG9bX3gyXS5zcGxpdChcIkBcIik7XG4gICAgICAgICAgICBhZGRyWzBdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclswXSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkclsxXSA9IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLmVycm9yID0gbWFpbHRvQ29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZHJbMV0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9bX3gyXSA9IGFkZHIuam9pbihcIkBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1haWx0b0NvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSQkMShtYWlsdG9Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb21wb25lbnRzID0gbWFpbHRvQ29tcG9uZW50cztcbiAgICAgICAgdmFyIHRvID0gdG9BcnJheShtYWlsdG9Db21wb25lbnRzLnRvKTtcbiAgICAgICAgaWYgKHRvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGwgPSB0by5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvQWRkciA9IFN0cmluZyh0b1t4XSk7XG4gICAgICAgICAgICAgICAgdmFyIGF0SWR4ID0gdG9BZGRyLmxhc3RJbmRleE9mKFwiQFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQYXJ0ID0gdG9BZGRyLnNsaWNlKDAsIGF0SWR4KS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfTE9DQUxfUEFSVCwgcGN0RW5jQ2hhcik7XG4gICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHRvQWRkci5zbGljZShhdElkeCArIDEpO1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBJRE4gdmlhIHB1bnljb2RlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluID0gIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChkb21haW4sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGRvbWFpbik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9beF0gPSBsb2NhbFBhcnQgKyBcIkBcIiArIGRvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IHRvLmpvaW4oXCIsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0KSBoZWFkZXJzW1wic3ViamVjdFwiXSA9IG1haWx0b0NvbXBvbmVudHMuc3ViamVjdDtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMuYm9keSkgaGVhZGVyc1tcImJvZHlcIl0gPSBtYWlsdG9Db21wb25lbnRzLmJvZHk7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyc1tuYW1lXSAhPT0gT1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKG5hbWUucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGTkFNRSwgcGN0RW5jQ2hhcikgKyBcIj1cIiArIGhlYWRlcnNbbmFtZV0ucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGVkFMVUUsIHBjdEVuY0NoYXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IGZpZWxkcy5qb2luKFwiJlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgVVJOX1BBUlNFID0gL14oW15cXDpdKylcXDooLiopLztcbi8vUkZDIDIxNDFcbnZhciBoYW5kbGVyJDMgPSB7XG4gICAgc2NoZW1lOiBcInVyblwiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5tYXRjaChVUk5fUEFSU0UpO1xuICAgICAgICB2YXIgdXJuQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcbiAgICAgICAgICAgIHZhciBuaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbnNzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgIHZhciB1cm5TY2hlbWUgPSBzY2hlbWUgKyBcIjpcIiArIChvcHRpb25zLm5pZCB8fCBuaWQpO1xuICAgICAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLm5pZCA9IG5pZDtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMubnNzID0gbnNzO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMuZXJyb3IgPSB1cm5Db21wb25lbnRzLmVycm9yIHx8IFwiVVJOIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cm5Db21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcbiAgICAgICAgdmFyIG5pZCA9IHVybkNvbXBvbmVudHMubmlkO1xuICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG4gICAgICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVyaUNvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzO1xuICAgICAgICB2YXIgbnNzID0gdXJuQ29tcG9uZW50cy5uc3M7XG4gICAgICAgIHVyaUNvbXBvbmVudHMucGF0aCA9IChuaWQgfHwgb3B0aW9ucy5uaWQpICsgXCI6XCIgKyBuc3M7XG4gICAgICAgIHJldHVybiB1cmlDb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBVVUlEID0gL15bMC05QS1GYS1mXXs4fSg/OlxcLVswLTlBLUZhLWZdezR9KXszfVxcLVswLTlBLUZhLWZdezEyfSQvO1xuLy9SRkMgNDEyMlxudmFyIGhhbmRsZXIkNCA9IHtcbiAgICBzY2hlbWU6IFwidXJuOnV1aWRcIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodXJuQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXVpZENvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzO1xuICAgICAgICB1dWlkQ29tcG9uZW50cy51dWlkID0gdXVpZENvbXBvbmVudHMubnNzO1xuICAgICAgICB1dWlkQ29tcG9uZW50cy5uc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiAoIXV1aWRDb21wb25lbnRzLnV1aWQgfHwgIXV1aWRDb21wb25lbnRzLnV1aWQubWF0Y2goVVVJRCkpKSB7XG4gICAgICAgICAgICB1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8IFwiVVVJRCBpcyBub3QgdmFsaWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV1aWRDb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUodXVpZENvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSB1dWlkQ29tcG9uZW50cztcbiAgICAgICAgLy9ub3JtYWxpemUgVVVJRFxuICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9ICh1dWlkQ29tcG9uZW50cy51dWlkIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB1cm5Db21wb25lbnRzO1xuICAgIH1cbn07XG5cblNDSEVNRVNbaGFuZGxlci5zY2hlbWVdID0gaGFuZGxlcjtcblNDSEVNRVNbaGFuZGxlciQxLnNjaGVtZV0gPSBoYW5kbGVyJDE7XG5TQ0hFTUVTW2hhbmRsZXIkMi5zY2hlbWVdID0gaGFuZGxlciQyO1xuU0NIRU1FU1toYW5kbGVyJDMuc2NoZW1lXSA9IGhhbmRsZXIkMztcblNDSEVNRVNbaGFuZGxlciQ0LnNjaGVtZV0gPSBoYW5kbGVyJDQ7XG5cbmV4cG9ydHMuU0NIRU1FUyA9IFNDSEVNRVM7XG5leHBvcnRzLnBjdEVuY0NoYXIgPSBwY3RFbmNDaGFyO1xuZXhwb3J0cy5wY3REZWNDaGFycyA9IHBjdERlY0NoYXJzO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5yZW1vdmVEb3RTZWdtZW50cyA9IHJlbW92ZURvdFNlZ21lbnRzO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5leHBvcnRzLnJlc29sdmVDb21wb25lbnRzID0gcmVzb2x2ZUNvbXBvbmVudHM7XG5leHBvcnRzLnJlc29sdmUgPSByZXNvbHZlO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5leHBvcnRzLmVxdWFsID0gZXF1YWw7XG5leHBvcnRzLmVzY2FwZUNvbXBvbmVudCA9IGVzY2FwZUNvbXBvbmVudDtcbmV4cG9ydHMudW5lc2NhcGVDb21wb25lbnQgPSB1bmVzY2FwZUNvbXBvbmVudDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS5hbGwuanMubWFwXG4iLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcbiAgcmV0dXJuIChbYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXV0pLmpvaW4oJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ5dGVzVG9VdWlkO1xuIiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIEluIG5vZGUuanNcbi8vIHRoaXMgaXMgcHJldHR5IHN0cmFpZ2h0LWZvcndhcmQgLSB3ZSB1c2UgdGhlIGNyeXB0byBBUEkuXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub2RlUk5HKCkge1xuICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbn07XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgYnVmID0gb3B0aW9ucyA9PT0gJ2JpbmFyeScgPyBuZXcgQXJyYXkoMTYpIDogbnVsbDtcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgaWYgKGJ1Zikge1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgKytpaSkge1xuICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IGJ5dGVzVG9VdWlkKHJuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHY0O1xuIiwiLypcbiAqIHZlcnJvci5qczogcmljaGVyIEphdmFTY3JpcHQgZXJyb3JzXG4gKi9cblxudmFyIG1vZF9hc3NlcnRwbHVzID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBtb2RfdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIG1vZF9leHRzcHJpbnRmID0gcmVxdWlyZSgnZXh0c3ByaW50ZicpO1xudmFyIG1vZF9pc0Vycm9yID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJykuaXNFcnJvcjtcbnZhciBzcHJpbnRmID0gbW9kX2V4dHNwcmludGYuc3ByaW50ZjtcblxuLypcbiAqIFB1YmxpYyBpbnRlcmZhY2VcbiAqL1xuXG4vKiBTbyB5b3UgY2FuICd2YXIgVkVycm9yID0gcmVxdWlyZSgndmVycm9yJyknICovXG5tb2R1bGUuZXhwb3J0cyA9IFZFcnJvcjtcbi8qIEZvciBjb21wYXRpYmlsaXR5ICovXG5WRXJyb3IuVkVycm9yID0gVkVycm9yO1xuLyogT3RoZXIgZXhwb3J0ZWQgY2xhc3NlcyAqL1xuVkVycm9yLlNFcnJvciA9IFNFcnJvcjtcblZFcnJvci5XRXJyb3IgPSBXRXJyb3I7XG5WRXJyb3IuTXVsdGlFcnJvciA9IE11bHRpRXJyb3I7XG5cbi8qXG4gKiBDb21tb24gZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBjb25zdHJ1Y3RvciBhcmd1bWVudHMgZm9yIFZFcnJvciwgV0Vycm9yLCBhbmRcbiAqIFNFcnJvci4gIE5hbWVkIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uOlxuICpcbiAqICAgICBzdHJpY3RcdFx0Zm9yY2Ugc3RyaWN0IGludGVycHJldGF0aW9uIG9mIHNwcmludGYgYXJndW1lbnRzLCBldmVuXG4gKiAgICAgXHRcdFx0aWYgdGhlIG9wdGlvbnMgaW4gXCJhcmd2XCIgZG9uJ3Qgc2F5IHNvXG4gKlxuICogICAgIGFyZ3ZcdFx0ZXJyb3IncyBjb25zdHJ1Y3RvciBhcmd1bWVudHMsIHdoaWNoIGFyZSB0byBiZVxuICogICAgIFx0XHRcdGludGVycHJldGVkIGFzIGRlc2NyaWJlZCBpbiBSRUFETUUubWQuICBGb3IgcXVpY2tcbiAqICAgICBcdFx0XHRyZWZlcmVuY2UsIFwiYXJndlwiIGhhcyBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAqXG4gKiAgICAgICAgICBbIHNwcmludGZfYXJncy4uLiBdICAgICAgICAgICAoYXJndlswXSBpcyBhIHN0cmluZylcbiAqICAgICAgICAgIFsgY2F1c2UsIHNwcmludGZfYXJncy4uLiBdICAgIChhcmd2WzBdIGlzIGFuIEVycm9yKVxuICogICAgICAgICAgWyBvcHRpb25zLCBzcHJpbnRmX2FyZ3MuLi4gXSAgKGFyZ3ZbMF0gaXMgYW4gb2JqZWN0KVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbm9ybWFsaXplcyB0aGVzZSBmb3JtcywgcHJvZHVjaW5nIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAgb3B0aW9ucyAgICAgICAgICAgZXF1aXZhbGVudCB0byBcIm9wdGlvbnNcIiBpbiB0aGlyZCBmb3JtLiAgVGhpcyB3aWxsIG5ldmVyXG4gKiAgICBcdFx0XHRiZSBhIGRpcmVjdCByZWZlcmVuY2UgdG8gd2hhdCB0aGUgY2FsbGVyIHBhc3NlZCBpblxuICogICAgXHRcdFx0KGkuZS4sIGl0IG1heSBiZSBhIHNoYWxsb3cgY29weSksIHNvIGl0IGNhbiBiZSBmcmVlbHlcbiAqICAgIFx0XHRcdG1vZGlmaWVkLlxuICpcbiAqICAgIHNob3J0bWVzc2FnZSAgICAgIHJlc3VsdCBvZiBzcHJpbnRmKHNwcmludGZfYXJncyksIHRha2luZyBvcHRpb25zLnN0cmljdFxuICogICAgXHRcdFx0aW50byBhY2NvdW50IGFzIGRlc2NyaWJlZCBpbiBSRUFETUUubWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoYXJncylcbntcblx0dmFyIGFyZ3YsIG9wdGlvbnMsIHNwcmludGZfYXJncywgc2hvcnRtZXNzYWdlLCBrO1xuXG5cdG1vZF9hc3NlcnRwbHVzLm9iamVjdChhcmdzLCAnYXJncycpO1xuXHRtb2RfYXNzZXJ0cGx1cy5ib29sKGFyZ3Muc3RyaWN0LCAnYXJncy5zdHJpY3QnKTtcblx0bW9kX2Fzc2VydHBsdXMuYXJyYXkoYXJncy5hcmd2LCAnYXJncy5hcmd2Jyk7XG5cdGFyZ3YgPSBhcmdzLmFyZ3Y7XG5cblx0Lypcblx0ICogRmlyc3QsIGZpZ3VyZSBvdXQgd2hpY2ggZm9ybSBvZiBpbnZvY2F0aW9uIHdlJ3ZlIGJlZW4gZ2l2ZW4uXG5cdCAqL1xuXHRpZiAoYXJndi5sZW5ndGggPT09IDApIHtcblx0XHRvcHRpb25zID0ge307XG5cdFx0c3ByaW50Zl9hcmdzID0gW107XG5cdH0gZWxzZSBpZiAobW9kX2lzRXJyb3IoYXJndlswXSkpIHtcblx0XHRvcHRpb25zID0geyAnY2F1c2UnOiBhcmd2WzBdIH07XG5cdFx0c3ByaW50Zl9hcmdzID0gYXJndi5zbGljZSgxKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgKGFyZ3ZbMF0pID09PSAnb2JqZWN0Jykge1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0XHRmb3IgKGsgaW4gYXJndlswXSkge1xuXHRcdFx0b3B0aW9uc1trXSA9IGFyZ3ZbMF1ba107XG5cdFx0fVxuXHRcdHNwcmludGZfYXJncyA9IGFyZ3Yuc2xpY2UoMSk7XG5cdH0gZWxzZSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMuc3RyaW5nKGFyZ3ZbMF0sXG5cdFx0ICAgICdmaXJzdCBhcmd1bWVudCB0byBWRXJyb3IsIFNFcnJvciwgb3IgV0Vycm9yICcgK1xuXHRcdCAgICAnY29uc3RydWN0b3IgbXVzdCBiZSBhIHN0cmluZywgb2JqZWN0LCBvciBFcnJvcicpO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0XHRzcHJpbnRmX2FyZ3MgPSBhcmd2O1xuXHR9XG5cblx0Lypcblx0ICogTm93IGNvbnN0cnVjdCB0aGUgZXJyb3IncyBtZXNzYWdlLlxuXHQgKlxuXHQgKiBleHRzcHJpbnRmICh3aGljaCB3ZSBpbnZva2UgaGVyZSB3aXRoIG91ciBjYWxsZXIncyBhcmd1bWVudHMgaW4gb3JkZXJcblx0ICogdG8gY29uc3RydWN0IHRoaXMgRXJyb3IncyBtZXNzYWdlKSBpcyBzdHJpY3QgaW4gaXRzIGludGVycHJldGF0aW9uIG9mXG5cdCAqIHZhbHVlcyB0byBiZSBwcm9jZXNzZWQgYnkgdGhlIFwiJXNcIiBzcGVjaWZpZXIuICBUaGUgdmFsdWUgcGFzc2VkIHRvXG5cdCAqIGV4dHNwcmludGYgbXVzdCBhY3R1YWxseSBiZSBhIHN0cmluZyBvciBzb21ldGhpbmcgY29udmVydGlibGUgdG8gYVxuXHQgKiBTdHJpbmcgdXNpbmcgLnRvU3RyaW5nKCkuICBQYXNzaW5nIG90aGVyIHZhbHVlcyAobm90YWJseSBcIm51bGxcIiBhbmRcblx0ICogXCJ1bmRlZmluZWRcIikgaXMgY29uc2lkZXJlZCBhIHByb2dyYW1tZXIgZXJyb3IuICBUaGUgYXNzdW1wdGlvbiBpc1xuXHQgKiB0aGF0IGlmIHlvdSBhY3R1YWxseSB3YW50IHRvIHByaW50IHRoZSBzdHJpbmcgXCJudWxsXCIgb3IgXCJ1bmRlZmluZWRcIixcblx0ICogdGhlbiB0aGF0J3MgZWFzeSB0byBkbyB0aGF0IHdoZW4geW91J3JlIGNhbGxpbmcgZXh0c3ByaW50Zjsgb24gdGhlXG5cdCAqIG90aGVyIGhhbmQsIGlmIHlvdSBkaWQgTk9UIHdhbnQgdGhhdCAoaS5lLiwgdGhlcmUncyBhY3R1YWxseSBhIGJ1Z1xuXHQgKiB3aGVyZSB0aGUgcHJvZ3JhbSBhc3N1bWVzIHNvbWUgdmFyaWFibGUgaXMgbm9uLW51bGwgYW5kIHRyaWVzIHRvXG5cdCAqIHByaW50IGl0LCB3aGljaCBtaWdodCBoYXBwZW4gd2hlbiBjb25zdHJ1Y3RpbmcgYSBwYWNrZXQgb3IgZmlsZSBpblxuXHQgKiBzb21lIHNwZWNpZmljIGZvcm1hdCksIHRoZW4gaXQncyBiZXR0ZXIgdG8gc3RvcCBpbW1lZGlhdGVseSB0aGFuXG5cdCAqIHByb2R1Y2UgYm9ndXMgb3V0cHV0LlxuXHQgKlxuXHQgKiBIb3dldmVyLCBzb21ldGltZXMgdGhlIGJ1ZyBpcyBvbmx5IGluIHRoZSBjb2RlIGNhbGxpbmcgVkVycm9yLCBhbmQgYVxuXHQgKiBwcm9ncmFtbWVyIG1pZ2h0IHByZWZlciB0byBoYXZlIHRoZSBlcnJvciBtZXNzYWdlIGNvbnRhaW4gXCJudWxsXCIgb3Jcblx0ICogXCJ1bmRlZmluZWRcIiByYXRoZXIgdGhhbiBoYXZlIHRoZSBidWcgaW4gdGhlIGVycm9yIHBhdGggY3Jhc2ggdGhlXG5cdCAqIHByb2dyYW0gKG1ha2luZyB0aGUgZmlyc3QgYnVnIGhhcmRlciB0byBpZGVudGlmeSkuICBGb3IgdGhhdCByZWFzb24sXG5cdCAqIGJ5IGRlZmF1bHQgVkVycm9yIGNvbnZlcnRzIFwibnVsbFwiIG9yIFwidW5kZWZpbmVkXCIgYXJndW1lbnRzIHRvIHRoZWlyXG5cdCAqIHN0cmluZyByZXByZXNlbnRhdGlvbnMgYW5kIHBhc3NlcyB0aG9zZSB0byBleHRzcHJpbnRmLiAgUHJvZ3JhbW1lcnNcblx0ICogZGVzaXJpbmcgdGhlIHN0cmljdCBiZWhhdmlvciBjYW4gdXNlIHRoZSBTRXJyb3IgY2xhc3Mgb3IgcGFzcyB0aGVcblx0ICogXCJzdHJpY3RcIiBvcHRpb24gdG8gdGhlIFZFcnJvciBjb25zdHJ1Y3Rvci5cblx0ICovXG5cdG1vZF9hc3NlcnRwbHVzLm9iamVjdChvcHRpb25zKTtcblx0aWYgKCFvcHRpb25zLnN0cmljdCAmJiAhYXJncy5zdHJpY3QpIHtcblx0XHRzcHJpbnRmX2FyZ3MgPSBzcHJpbnRmX2FyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XG5cdFx0XHRyZXR1cm4gKGEgPT09IG51bGwgPyAnbnVsbCcgOlxuXHRcdFx0ICAgIGEgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogYSk7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoc3ByaW50Zl9hcmdzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHNob3J0bWVzc2FnZSA9ICcnO1xuXHR9IGVsc2Uge1xuXHRcdHNob3J0bWVzc2FnZSA9IHNwcmludGYuYXBwbHkobnVsbCwgc3ByaW50Zl9hcmdzKTtcblx0fVxuXG5cdHJldHVybiAoe1xuXHQgICAgJ29wdGlvbnMnOiBvcHRpb25zLFxuXHQgICAgJ3Nob3J0bWVzc2FnZSc6IHNob3J0bWVzc2FnZVxuXHR9KTtcbn1cblxuLypcbiAqIFNlZSBSRUFETUUubWQgZm9yIHJlZmVyZW5jZSBkb2N1bWVudGF0aW9uLlxuICovXG5mdW5jdGlvbiBWRXJyb3IoKVxue1xuXHR2YXIgYXJncywgb2JqLCBwYXJzZWQsIGNhdXNlLCBjdG9yLCBtZXNzYWdlLCBrO1xuXG5cdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG5cdC8qXG5cdCAqIFRoaXMgaXMgYSByZWdyZXR0YWJsZSBwYXR0ZXJuLCBidXQgSmF2YVNjcmlwdCdzIGJ1aWx0LWluIEVycm9yIGNsYXNzXG5cdCAqIGlzIGRlZmluZWQgdG8gd29yayB0aGlzIHdheSwgc28gd2UgYWxsb3cgdGhlIGNvbnN0cnVjdG9yIHRvIGJlIGNhbGxlZFxuXHQgKiB3aXRob3V0IFwibmV3XCIuXG5cdCAqL1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgVkVycm9yKSkge1xuXHRcdG9iaiA9IE9iamVjdC5jcmVhdGUoVkVycm9yLnByb3RvdHlwZSk7XG5cdFx0VkVycm9yLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gKG9iaik7XG5cdH1cblxuXHQvKlxuXHQgKiBGb3IgY29udmVuaWVuY2UgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHNldmVyYWxcblx0ICogZGlmZmVyZW50IGNhbGxpbmcgZm9ybXMuICBOb3JtYWxpemUgdGhlbSBoZXJlLlxuXHQgKi9cblx0cGFyc2VkID0gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyh7XG5cdCAgICAnYXJndic6IGFyZ3MsXG5cdCAgICAnc3RyaWN0JzogZmFsc2Vcblx0fSk7XG5cblx0Lypcblx0ICogSWYgd2UndmUgYmVlbiBnaXZlbiBhIG5hbWUsIGFwcGx5IGl0IG5vdy5cblx0ICovXG5cdGlmIChwYXJzZWQub3B0aW9ucy5uYW1lKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMuc3RyaW5nKHBhcnNlZC5vcHRpb25zLm5hbWUsXG5cdFx0ICAgICdlcnJvclxcJ3MgXCJuYW1lXCIgbXVzdCBiZSBhIHN0cmluZycpO1xuXHRcdHRoaXMubmFtZSA9IHBhcnNlZC5vcHRpb25zLm5hbWU7XG5cdH1cblxuXHQvKlxuXHQgKiBGb3IgZGVidWdnaW5nLCB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBvcmlnaW5hbCBzaG9ydCBtZXNzYWdlIChhdHRhY2hlZFxuXHQgKiB0aGlzIEVycm9yIHBhcnRpY3VsYXJseSkgc2VwYXJhdGVseSBmcm9tIHRoZSBjb21wbGV0ZSBtZXNzYWdlICh3aGljaFxuXHQgKiBpbmNsdWRlcyB0aGUgbWVzc2FnZXMgb2Ygb3VyIGNhdXNlIGNoYWluKS5cblx0ICovXG5cdHRoaXMuanNlX3Nob3J0bXNnID0gcGFyc2VkLnNob3J0bWVzc2FnZTtcblx0bWVzc2FnZSA9IHBhcnNlZC5zaG9ydG1lc3NhZ2U7XG5cblx0Lypcblx0ICogSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNhdXNlLCByZWNvcmQgYSByZWZlcmVuY2UgdG8gaXQgYW5kIHVwZGF0ZSBvdXJcblx0ICogbWVzc2FnZSBhcHByb3ByaWF0ZWx5LlxuXHQgKi9cblx0Y2F1c2UgPSBwYXJzZWQub3B0aW9ucy5jYXVzZTtcblx0aWYgKGNhdXNlKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoY2F1c2UpLCAnY2F1c2UgaXMgbm90IGFuIEVycm9yJyk7XG5cdFx0dGhpcy5qc2VfY2F1c2UgPSBjYXVzZTtcblxuXHRcdGlmICghcGFyc2VkLm9wdGlvbnMuc2tpcENhdXNlTWVzc2FnZSkge1xuXHRcdFx0bWVzc2FnZSArPSAnOiAnICsgY2F1c2UubWVzc2FnZTtcblx0XHR9XG5cdH1cblxuXHQvKlxuXHQgKiBJZiB3ZSd2ZSBiZWVuIGdpdmVuIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMsIHNoYWxsb3ctY29weSB0aGF0XG5cdCAqIGhlcmUuICBXZSBkb24ndCB3YW50IHRvIHVzZSBhIGRlZXAgY29weSBpbiBjYXNlIHRoZXJlIGFyZSBub24tcGxhaW5cblx0ICogb2JqZWN0cyBoZXJlLCBidXQgd2UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIG9yaWdpbmFsIG9iamVjdCBpbiBjYXNlXG5cdCAqIHRoZSBjYWxsZXIgbW9kaWZpZXMgaXQgbGF0ZXIuXG5cdCAqL1xuXHR0aGlzLmpzZV9pbmZvID0ge307XG5cdGlmIChwYXJzZWQub3B0aW9ucy5pbmZvKSB7XG5cdFx0Zm9yIChrIGluIHBhcnNlZC5vcHRpb25zLmluZm8pIHtcblx0XHRcdHRoaXMuanNlX2luZm9ba10gPSBwYXJzZWQub3B0aW9ucy5pbmZvW2tdO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cblx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0Y3RvciA9IHBhcnNlZC5vcHRpb25zLmNvbnN0cnVjdG9yT3B0IHx8IHRoaXMuY29uc3RydWN0b3I7XG5cdFx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgY3Rvcik7XG5cdH1cblxuXHRyZXR1cm4gKHRoaXMpO1xufVxuXG5tb2RfdXRpbC5pbmhlcml0cyhWRXJyb3IsIEVycm9yKTtcblZFcnJvci5wcm90b3R5cGUubmFtZSA9ICdWRXJyb3InO1xuXG5WRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdmVfdG9TdHJpbmcoKVxue1xuXHR2YXIgc3RyID0gKHRoaXMuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiB0aGlzLm5hbWUgfHxcblx0XHR0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUubmFtZSk7XG5cdGlmICh0aGlzLm1lc3NhZ2UpXG5cdFx0c3RyICs9ICc6ICcgKyB0aGlzLm1lc3NhZ2U7XG5cblx0cmV0dXJuIChzdHIpO1xufTtcblxuLypcbiAqIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGZvciBjb21wYXRpYmlsaXR5LiAgTmV3IGNhbGxlcnMgc2hvdWxkIHVzZVxuICogVkVycm9yLmNhdXNlKCkgaW5zdGVhZC4gIFRoYXQgbWV0aG9kIGFsc28gdXNlcyB0aGUgc2FuZXIgYG51bGxgIHJldHVybiB2YWx1ZVxuICogd2hlbiB0aGVyZSBpcyBubyBjYXVzZS5cbiAqL1xuVkVycm9yLnByb3RvdHlwZS5jYXVzZSA9IGZ1bmN0aW9uIHZlX2NhdXNlKClcbntcblx0dmFyIGNhdXNlID0gVkVycm9yLmNhdXNlKHRoaXMpO1xuXHRyZXR1cm4gKGNhdXNlID09PSBudWxsID8gdW5kZWZpbmVkIDogY2F1c2UpO1xufTtcblxuLypcbiAqIFN0YXRpYyBtZXRob2RzXG4gKlxuICogVGhlc2UgY2xhc3MtbGV2ZWwgbWV0aG9kcyBhcmUgcHJvdmlkZWQgc28gdGhhdCBjYWxsZXJzIGNhbiB1c2UgdGhlbSBvblxuICogaW5zdGFuY2VzIG9mIEVycm9ycyB0aGF0IGFyZSBub3QgVkVycm9ycy4gIE5ldyBpbnRlcmZhY2VzIHNob3VsZCBiZSBwcm92aWRlZFxuICogb25seSB1c2luZyBzdGF0aWMgbWV0aG9kcyB0byBlbGltaW5hdGUgdGhlIGNsYXNzIG9mIHByb2dyYW1taW5nIG1pc3Rha2Ugd2hlcmVcbiAqIHBlb3BsZSBmYWlsIHRvIGNoZWNrIHdoZXRoZXIgdGhlIEVycm9yIG9iamVjdCBoYXMgdGhlIGNvcnJlc3BvbmRpbmcgbWV0aG9kcy5cbiAqL1xuXG5WRXJyb3IuY2F1c2UgPSBmdW5jdGlvbiAoZXJyKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0cmV0dXJuIChtb2RfaXNFcnJvcihlcnIuanNlX2NhdXNlKSA/IGVyci5qc2VfY2F1c2UgOiBudWxsKTtcbn07XG5cblZFcnJvci5pbmZvID0gZnVuY3Rpb24gKGVycilcbntcblx0dmFyIHJ2LCBjYXVzZSwgaztcblxuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0Y2F1c2UgPSBWRXJyb3IuY2F1c2UoZXJyKTtcblx0aWYgKGNhdXNlICE9PSBudWxsKSB7XG5cdFx0cnYgPSBWRXJyb3IuaW5mbyhjYXVzZSk7XG5cdH0gZWxzZSB7XG5cdFx0cnYgPSB7fTtcblx0fVxuXG5cdGlmICh0eXBlb2YgKGVyci5qc2VfaW5mbykgPT0gJ29iamVjdCcgJiYgZXJyLmpzZV9pbmZvICE9PSBudWxsKSB7XG5cdFx0Zm9yIChrIGluIGVyci5qc2VfaW5mbykge1xuXHRcdFx0cnZba10gPSBlcnIuanNlX2luZm9ba107XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIChydik7XG59O1xuXG5WRXJyb3IuZmluZENhdXNlQnlOYW1lID0gZnVuY3Rpb24gKGVyciwgbmFtZSlcbntcblx0dmFyIGNhdXNlO1xuXG5cdG1vZF9hc3NlcnRwbHVzLm9rKG1vZF9pc0Vycm9yKGVyciksICdlcnIgbXVzdCBiZSBhbiBFcnJvcicpO1xuXHRtb2RfYXNzZXJ0cGx1cy5zdHJpbmcobmFtZSwgJ25hbWUnKTtcblx0bW9kX2Fzc2VydHBsdXMub2sobmFtZS5sZW5ndGggPiAwLCAnbmFtZSBjYW5ub3QgYmUgZW1wdHknKTtcblxuXHRmb3IgKGNhdXNlID0gZXJyOyBjYXVzZSAhPT0gbnVsbDsgY2F1c2UgPSBWRXJyb3IuY2F1c2UoY2F1c2UpKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoY2F1c2UpKTtcblx0XHRpZiAoY2F1c2UubmFtZSA9PSBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gKGNhdXNlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKG51bGwpO1xufTtcblxuVkVycm9yLmhhc0NhdXNlV2l0aE5hbWUgPSBmdW5jdGlvbiAoZXJyLCBuYW1lKVxue1xuXHRyZXR1cm4gKFZFcnJvci5maW5kQ2F1c2VCeU5hbWUoZXJyLCBuYW1lKSAhPT0gbnVsbCk7XG59O1xuXG5WRXJyb3IuZnVsbFN0YWNrID0gZnVuY3Rpb24gKGVycilcbntcblx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZXJyKSwgJ2VyciBtdXN0IGJlIGFuIEVycm9yJyk7XG5cblx0dmFyIGNhdXNlID0gVkVycm9yLmNhdXNlKGVycik7XG5cblx0aWYgKGNhdXNlKSB7XG5cdFx0cmV0dXJuIChlcnIuc3RhY2sgKyAnXFxuY2F1c2VkIGJ5OiAnICsgVkVycm9yLmZ1bGxTdGFjayhjYXVzZSkpO1xuXHR9XG5cblx0cmV0dXJuIChlcnIuc3RhY2spO1xufTtcblxuVkVycm9yLmVycm9yRnJvbUxpc3QgPSBmdW5jdGlvbiAoZXJyb3JzKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5hcnJheU9mT2JqZWN0KGVycm9ycywgJ2Vycm9ycycpO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIChudWxsKTtcblx0fVxuXG5cdGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0bW9kX2Fzc2VydHBsdXMub2sobW9kX2lzRXJyb3IoZSkpO1xuXHR9KTtcblxuXHRpZiAoZXJyb3JzLmxlbmd0aCA9PSAxKSB7XG5cdFx0cmV0dXJuIChlcnJvcnNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIChuZXcgTXVsdGlFcnJvcihlcnJvcnMpKTtcbn07XG5cblZFcnJvci5lcnJvckZvckVhY2ggPSBmdW5jdGlvbiAoZXJyLCBmdW5jKVxue1xuXHRtb2RfYXNzZXJ0cGx1cy5vayhtb2RfaXNFcnJvcihlcnIpLCAnZXJyIG11c3QgYmUgYW4gRXJyb3InKTtcblx0bW9kX2Fzc2VydHBsdXMuZnVuYyhmdW5jLCAnZnVuYycpO1xuXG5cdGlmIChlcnIgaW5zdGFuY2VvZiBNdWx0aUVycm9yKSB7XG5cdFx0ZXJyLmVycm9ycygpLmZvckVhY2goZnVuY3Rpb24gaXRlckVycm9yKGUpIHsgZnVuYyhlKTsgfSk7XG5cdH0gZWxzZSB7XG5cdFx0ZnVuYyhlcnIpO1xuXHR9XG59O1xuXG5cbi8qXG4gKiBTRXJyb3IgaXMgbGlrZSBWRXJyb3IsIGJ1dCBzdHJpY3RlciBhYm91dCB0eXBlcy4gIFlvdSBjYW5ub3QgcGFzcyBcIm51bGxcIiBvclxuICogXCJ1bmRlZmluZWRcIiBhcyBzdHJpbmcgYXJndW1lbnRzIHRvIHRoZSBmb3JtYXR0ZXIuXG4gKi9cbmZ1bmN0aW9uIFNFcnJvcigpXG57XG5cdHZhciBhcmdzLCBvYmosIHBhcnNlZCwgb3B0aW9ucztcblxuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFNFcnJvcikpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKFNFcnJvci5wcm90b3R5cGUpO1xuXHRcdFNFcnJvci5hcHBseShvYmosIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIChvYmopO1xuXHR9XG5cblx0cGFyc2VkID0gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyh7XG5cdCAgICAnYXJndic6IGFyZ3MsXG5cdCAgICAnc3RyaWN0JzogdHJ1ZVxuXHR9KTtcblxuXHRvcHRpb25zID0gcGFyc2VkLm9wdGlvbnM7XG5cdFZFcnJvci5jYWxsKHRoaXMsIG9wdGlvbnMsICclcycsIHBhcnNlZC5zaG9ydG1lc3NhZ2UpO1xuXG5cdHJldHVybiAodGhpcyk7XG59XG5cbi8qXG4gKiBXZSBkb24ndCBib3RoZXIgc2V0dGluZyBTRXJyb3IucHJvdG90eXBlLm5hbWUgYmVjYXVzZSBvbmNlIGNvbnN0cnVjdGVkLFxuICogU0Vycm9ycyBhcmUganVzdCBsaWtlIFZFcnJvcnMuXG4gKi9cbm1vZF91dGlsLmluaGVyaXRzKFNFcnJvciwgVkVycm9yKTtcblxuXG4vKlxuICogUmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgZXJyb3JzIGZvciB0aGUgcHVycG9zZSBvZiBjb25zdW1lcnMgdGhhdCBnZW5lcmFsbHlcbiAqIG9ubHkgZGVhbCB3aXRoIG9uZSBlcnJvci4gIENhbGxlcnMgY2FuIGV4dHJhY3QgdGhlIGluZGl2aWR1YWwgZXJyb3JzXG4gKiBjb250YWluZWQgaW4gdGhpcyBvYmplY3QsIGJ1dCBtYXkgYWxzbyBqdXN0IHRyZWF0IGl0IGFzIGEgbm9ybWFsIHNpbmdsZVxuICogZXJyb3IsIGluIHdoaWNoIGNhc2UgYSBzdW1tYXJ5IG1lc3NhZ2Ugd2lsbCBiZSBwcmludGVkLlxuICovXG5mdW5jdGlvbiBNdWx0aUVycm9yKGVycm9ycylcbntcblx0bW9kX2Fzc2VydHBsdXMuYXJyYXkoZXJyb3JzLCAnbGlzdCBvZiBlcnJvcnMnKTtcblx0bW9kX2Fzc2VydHBsdXMub2soZXJyb3JzLmxlbmd0aCA+IDAsICdtdXN0IGJlIGF0IGxlYXN0IG9uZSBlcnJvcicpO1xuXHR0aGlzLmFzZV9lcnJvcnMgPSBlcnJvcnM7XG5cblx0VkVycm9yLmNhbGwodGhpcywge1xuXHQgICAgJ2NhdXNlJzogZXJyb3JzWzBdXG5cdH0sICdmaXJzdCBvZiAlZCBlcnJvciVzJywgZXJyb3JzLmxlbmd0aCwgZXJyb3JzLmxlbmd0aCA9PSAxID8gJycgOiAncycpO1xufVxuXG5tb2RfdXRpbC5pbmhlcml0cyhNdWx0aUVycm9yLCBWRXJyb3IpO1xuTXVsdGlFcnJvci5wcm90b3R5cGUubmFtZSA9ICdNdWx0aUVycm9yJztcblxuTXVsdGlFcnJvci5wcm90b3R5cGUuZXJyb3JzID0gZnVuY3Rpb24gbWVfZXJyb3JzKClcbntcblx0cmV0dXJuICh0aGlzLmFzZV9lcnJvcnMuc2xpY2UoMCkpO1xufTtcblxuXG4vKlxuICogU2VlIFJFQURNRS5tZCBmb3IgcmVmZXJlbmNlIGRldGFpbHMuXG4gKi9cbmZ1bmN0aW9uIFdFcnJvcigpXG57XG5cdHZhciBhcmdzLCBvYmosIHBhcnNlZCwgb3B0aW9ucztcblxuXHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFdFcnJvcikpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKFdFcnJvci5wcm90b3R5cGUpO1xuXHRcdFdFcnJvci5hcHBseShvYmosIGFyZ3MpO1xuXHRcdHJldHVybiAob2JqKTtcblx0fVxuXG5cdHBhcnNlZCA9IHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoe1xuXHQgICAgJ2FyZ3YnOiBhcmdzLFxuXHQgICAgJ3N0cmljdCc6IGZhbHNlXG5cdH0pO1xuXG5cdG9wdGlvbnMgPSBwYXJzZWQub3B0aW9ucztcblx0b3B0aW9uc1snc2tpcENhdXNlTWVzc2FnZSddID0gdHJ1ZTtcblx0VkVycm9yLmNhbGwodGhpcywgb3B0aW9ucywgJyVzJywgcGFyc2VkLnNob3J0bWVzc2FnZSk7XG5cblx0cmV0dXJuICh0aGlzKTtcbn1cblxubW9kX3V0aWwuaW5oZXJpdHMoV0Vycm9yLCBWRXJyb3IpO1xuV0Vycm9yLnByb3RvdHlwZS5uYW1lID0gJ1dFcnJvcic7XG5cbldFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB3ZV90b1N0cmluZygpXG57XG5cdHZhciBzdHIgPSAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpICYmIHRoaXMubmFtZSB8fFxuXHRcdHRoaXMuY29uc3RydWN0b3IubmFtZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5uYW1lKTtcblx0aWYgKHRoaXMubWVzc2FnZSlcblx0XHRzdHIgKz0gJzogJyArIHRoaXMubWVzc2FnZTtcblx0aWYgKHRoaXMuanNlX2NhdXNlICYmIHRoaXMuanNlX2NhdXNlLm1lc3NhZ2UpXG5cdFx0c3RyICs9ICc7IGNhdXNlZCBieSAnICsgdGhpcy5qc2VfY2F1c2UudG9TdHJpbmcoKTtcblxuXHRyZXR1cm4gKHN0cik7XG59O1xuXG4vKlxuICogRm9yIHB1cmVseSBoaXN0b3JpY2FsIHJlYXNvbnMsIFdFcnJvcidzIGNhdXNlKCkgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXRcbiAqIHRoZSBjYXVzZS5cbiAqL1xuV0Vycm9yLnByb3RvdHlwZS5jYXVzZSA9IGZ1bmN0aW9uIHdlX2NhdXNlKGMpXG57XG5cdGlmIChtb2RfaXNFcnJvcihjKSlcblx0XHR0aGlzLmpzZV9jYXVzZSA9IGM7XG5cblx0cmV0dXJuICh0aGlzLmpzZV9jYXVzZSk7XG59O1xuIiwiLypcbiAqIGV4dHNwcmludGYuanM6IGV4dGVuZGVkIFBPU0lYLXN0eWxlIHNwcmludGZcbiAqL1xuXG52YXIgbW9kX2Fzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIG1vZF91dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKlxuICogUHVibGljIGludGVyZmFjZVxuICovXG5leHBvcnRzLnNwcmludGYgPSBqc1NwcmludGY7XG5leHBvcnRzLnByaW50ZiA9IGpzUHJpbnRmO1xuZXhwb3J0cy5mcHJpbnRmID0ganNGcHJpbnRmO1xuXG4vKlxuICogU3RyaXBwZWQgZG93biB2ZXJzaW9uIG9mIHNbbl1wcmludGYoM2MpLiAgV2UgbWFrZSBhIGJlc3QgZWZmb3J0IHRvIHRocm93IGFuXG4gKiBleGNlcHRpb24gd2hlbiBnaXZlbiBhIGZvcm1hdCBzdHJpbmcgd2UgZG9uJ3QgdW5kZXJzdGFuZCwgcmF0aGVyIHRoYW5cbiAqIGlnbm9yaW5nIGl0LCBzbyB0aGF0IHdlIHdvbid0IGJyZWFrIGV4aXN0aW5nIHByb2dyYW1zIGlmL3doZW4gd2UgZ28gaW1wbGVtZW50XG4gKiB0aGUgcmVzdCBvZiB0aGlzLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gY3VycmVudGx5IHN1cHBvcnRzIHNwZWNpZnlpbmdcbiAqXHQtIGZpZWxkIGFsaWdubWVudCAoJy0nIGZsYWcpLFxuICogXHQtIHplcm8tcGFkICgnMCcgZmxhZylcbiAqXHQtIGFsd2F5cyBzaG93IG51bWVyaWMgc2lnbiAoJysnIGZsYWcpLFxuICpcdC0gZmllbGQgd2lkdGhcbiAqXHQtIGNvbnZlcnNpb25zIGZvciBzdHJpbmdzLCBkZWNpbWFsIGludGVnZXJzLCBhbmQgZmxvYXRzIChudW1iZXJzKS5cbiAqXHQtIGFyZ3VtZW50IHNpemUgc3BlY2lmaWVycy4gIFRoZXNlIGFyZSBhbGwgYWNjZXB0ZWQgYnV0IGlnbm9yZWQsIHNpbmNlXG4gKlx0ICBKYXZhc2NyaXB0IGhhcyBubyBub3Rpb24gb2YgdGhlIHBoeXNpY2FsIHNpemUgb2YgYW4gYXJndW1lbnQuXG4gKlxuICogRXZlcnl0aGluZyBlbHNlIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZCwgbW9zdCBub3RhYmx5IHByZWNpc2lvbiwgdW5zaWduZWRcbiAqIG51bWJlcnMsIG5vbi1kZWNpbWFsIG51bWJlcnMsIGFuZCBjaGFyYWN0ZXJzLlxuICovXG5mdW5jdGlvbiBqc1NwcmludGYob2ZtdClcbntcblx0dmFyIHJlZ2V4ID0gW1xuXHQgICAgJyhbXiVdKiknLFx0XHRcdFx0Lyogbm9ybWFsIHRleHQgKi9cblx0ICAgICclJyxcdFx0XHRcdC8qIHN0YXJ0IG9mIGZvcm1hdCAqL1xuXHQgICAgJyhbXFwnXFxcXC0rICMwXSo/KScsXHRcdFx0LyogZmxhZ3MgKG9wdGlvbmFsKSAqL1xuXHQgICAgJyhbMS05XVxcXFxkKik/JyxcdFx0XHQvKiB3aWR0aCAob3B0aW9uYWwpICovXG5cdCAgICAnKFxcXFwuKFsxLTldXFxcXGQqKSk/JyxcdFx0LyogcHJlY2lzaW9uIChvcHRpb25hbCkgKi9cblx0ICAgICdbbGhqenRMXSo/JyxcdFx0XHQvKiBsZW5ndGggbW9kcyAoaWdub3JlZCkgKi9cblx0ICAgICcoW2Rpb3V4WGZGZUVnR2FBY0NzU3AlanJdKSdcdC8qIGNvbnZlcnNpb24gKi9cblx0XS5qb2luKCcnKTtcblxuXHR2YXIgcmUgPSBuZXcgUmVnRXhwKHJlZ2V4KTtcblxuXHQvKiB2YXJpYWRpYyBhcmd1bWVudHMgdXNlZCB0byBmaWxsIGluIGNvbnZlcnNpb24gc3BlY2lmaWVycyAqL1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdC8qIHJlbWFpbmluZyBmb3JtYXQgc3RyaW5nICovXG5cdHZhciBmbXQgPSBvZm10O1xuXG5cdC8qIGNvbXBvbmVudHMgb2YgdGhlIGN1cnJlbnQgY29udmVyc2lvbiBzcGVjaWZpZXIgKi9cblx0dmFyIGZsYWdzLCB3aWR0aCwgcHJlY2lzaW9uLCBjb252ZXJzaW9uO1xuXHR2YXIgbGVmdCwgcGFkLCBzaWduLCBhcmcsIG1hdGNoO1xuXG5cdC8qIHJldHVybiB2YWx1ZSAqL1xuXHR2YXIgcmV0ID0gJyc7XG5cblx0LyogY3VycmVudCB2YXJpYWRpYyBhcmd1bWVudCAoMS1iYXNlZCkgKi9cblx0dmFyIGFyZ24gPSAxO1xuXHQvKiAwLWJhc2VkIHBvc2l0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgd2UndmUgcmVhZCAqL1xuXHR2YXIgcG9zbiA9IDA7XG5cdC8qIDEtYmFzZWQgcG9zaXRpb24gaW4gdGhlIGZvcm1hdCBzdHJpbmcgb2YgdGhlIGN1cnJlbnQgY29udmVyc2lvbiAqL1xuXHR2YXIgY29udnBvc247XG5cdC8qIGN1cnJlbnQgY29udmVyc2lvbiBzcGVjaWZpZXIgKi9cblx0dmFyIGN1cmNvbnY7XG5cblx0bW9kX2Fzc2VydC5lcXVhbCgnc3RyaW5nJywgdHlwZW9mIChmbXQpLFxuXHQgICAgJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBmb3JtYXQgc3RyaW5nJyk7XG5cblx0d2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoZm10KSkgIT09IG51bGwpIHtcblx0XHRyZXQgKz0gbWF0Y2hbMV07XG5cdFx0Zm10ID0gZm10LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuXG5cdFx0Lypcblx0XHQgKiBVcGRhdGUgZmxhZ3MgcmVsYXRlZCB0byB0aGUgY3VycmVudCBjb252ZXJzaW9uIHNwZWNpZmllcidzXG5cdFx0ICogcG9zaXRpb24gc28gdGhhdCB3ZSBjYW4gcmVwb3J0IGNsZWFyIGVycm9yIG1lc3NhZ2VzLlxuXHRcdCAqL1xuXHRcdGN1cmNvbnYgPSBtYXRjaFswXS5zdWJzdHJpbmcobWF0Y2hbMV0ubGVuZ3RoKTtcblx0XHRjb252cG9zbiA9IHBvc24gKyBtYXRjaFsxXS5sZW5ndGggKyAxO1xuXHRcdHBvc24gKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuXG5cdFx0ZmxhZ3MgPSBtYXRjaFsyXSB8fCAnJztcblx0XHR3aWR0aCA9IG1hdGNoWzNdIHx8IDA7XG5cdFx0cHJlY2lzaW9uID0gbWF0Y2hbNF0gfHwgJyc7XG5cdFx0Y29udmVyc2lvbiA9IG1hdGNoWzZdO1xuXHRcdGxlZnQgPSBmYWxzZTtcblx0XHRzaWduID0gZmFsc2U7XG5cdFx0cGFkID0gJyAnO1xuXG5cdFx0aWYgKGNvbnZlcnNpb24gPT0gJyUnKSB7XG5cdFx0XHRyZXQgKz0gJyUnO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR0aHJvdyAoanNFcnJvcihvZm10LCBjb252cG9zbiwgY3VyY29udixcblx0XHRcdCAgICAnaGFzIG5vIG1hdGNoaW5nIGFyZ3VtZW50ICcgK1xuXHRcdFx0ICAgICcodG9vIGZldyBhcmd1bWVudHMgcGFzc2VkKScpKTtcblx0XHR9XG5cblx0XHRhcmcgPSBhcmdzLnNoaWZ0KCk7XG5cdFx0YXJnbisrO1xuXG5cdFx0aWYgKGZsYWdzLm1hdGNoKC9bXFwnICNdLykpIHtcblx0XHRcdHRocm93IChqc0Vycm9yKG9mbXQsIGNvbnZwb3NuLCBjdXJjb252LFxuXHRcdFx0ICAgICd1c2VzIHVuc3VwcG9ydGVkIGZsYWdzJykpO1xuXHRcdH1cblxuXHRcdGlmIChwcmVjaXNpb24ubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhyb3cgKGpzRXJyb3Iob2ZtdCwgY29udnBvc24sIGN1cmNvbnYsXG5cdFx0XHQgICAgJ3VzZXMgbm9uLXplcm8gcHJlY2lzaW9uIChub3Qgc3VwcG9ydGVkKScpKTtcblx0XHR9XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goLy0vKSlcblx0XHRcdGxlZnQgPSB0cnVlO1xuXG5cdFx0aWYgKGZsYWdzLm1hdGNoKC8wLykpXG5cdFx0XHRwYWQgPSAnMCc7XG5cblx0XHRpZiAoZmxhZ3MubWF0Y2goL1xcKy8pKVxuXHRcdFx0c2lnbiA9IHRydWU7XG5cblx0XHRzd2l0Y2ggKGNvbnZlcnNpb24pIHtcblx0XHRjYXNlICdzJzpcblx0XHRcdGlmIChhcmcgPT09IHVuZGVmaW5lZCB8fCBhcmcgPT09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgKGpzRXJyb3Iob2ZtdCwgY29udnBvc24sIGN1cmNvbnYsXG5cdFx0XHRcdCAgICAnYXR0ZW1wdGVkIHRvIHByaW50IHVuZGVmaW5lZCBvciBudWxsICcgK1xuXHRcdFx0XHQgICAgJ2FzIGEgc3RyaW5nIChhcmd1bWVudCAnICsgYXJnbiArICcgdG8gJyArXG5cdFx0XHRcdCAgICAnc3ByaW50ZiknKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXQgKz0gZG9QYWQocGFkLCB3aWR0aCwgbGVmdCwgYXJnLnRvU3RyaW5nKCkpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdkJzpcblx0XHRcdGFyZyA9IE1hdGguZmxvb3IoYXJnKTtcblx0XHRcdC8qanNsOmZhbGx0aHJ1Ki9cblx0XHRjYXNlICdmJzpcblx0XHRcdHNpZ24gPSBzaWduICYmIGFyZyA+IDAgPyAnKycgOiAnJztcblx0XHRcdHJldCArPSBzaWduICsgZG9QYWQocGFkLCB3aWR0aCwgbGVmdCxcblx0XHRcdCAgICBhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ3gnOlxuXHRcdFx0cmV0ICs9IGRvUGFkKHBhZCwgd2lkdGgsIGxlZnQsIGFyZy50b1N0cmluZygxNikpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdqJzogLyogbm9uLXN0YW5kYXJkICovXG5cdFx0XHRpZiAod2lkdGggPT09IDApXG5cdFx0XHRcdHdpZHRoID0gMTA7XG5cdFx0XHRyZXQgKz0gbW9kX3V0aWwuaW5zcGVjdChhcmcsIGZhbHNlLCB3aWR0aCk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ3InOiAvKiBub24tc3RhbmRhcmQgKi9cblx0XHRcdHJldCArPSBkdW1wRXhjZXB0aW9uKGFyZyk7XG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aHJvdyAoanNFcnJvcihvZm10LCBjb252cG9zbiwgY3VyY29udixcblx0XHRcdCAgICAnaXMgbm90IHN1cHBvcnRlZCcpKTtcblx0XHR9XG5cdH1cblxuXHRyZXQgKz0gZm10O1xuXHRyZXR1cm4gKHJldCk7XG59XG5cbmZ1bmN0aW9uIGpzRXJyb3IoZm10c3RyLCBjb252cG9zbiwgY3VyY29udiwgcmVhc29uKSB7XG5cdG1vZF9hc3NlcnQuZXF1YWwodHlwZW9mIChmbXRzdHIpLCAnc3RyaW5nJyk7XG5cdG1vZF9hc3NlcnQuZXF1YWwodHlwZW9mIChjdXJjb252KSwgJ3N0cmluZycpO1xuXHRtb2RfYXNzZXJ0LmVxdWFsKHR5cGVvZiAoY29udnBvc24pLCAnbnVtYmVyJyk7XG5cdG1vZF9hc3NlcnQuZXF1YWwodHlwZW9mIChyZWFzb24pLCAnc3RyaW5nJyk7XG5cdHJldHVybiAobmV3IEVycm9yKCdmb3JtYXQgc3RyaW5nIFwiJyArIGZtdHN0ciArXG5cdCAgICAnXCI6IGNvbnZlcnNpb24gc3BlY2lmaWVyIFwiJyArIGN1cmNvbnYgKyAnXCIgYXQgY2hhcmFjdGVyICcgK1xuXHQgICAgY29udnBvc24gKyAnICcgKyByZWFzb24pKTtcbn1cblxuZnVuY3Rpb24ganNQcmludGYoKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0YXJncy51bnNoaWZ0KHByb2Nlc3Muc3Rkb3V0KTtcblx0anNGcHJpbnRmLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBqc0ZwcmludGYoc3RyZWFtKSB7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0cmV0dXJuIChzdHJlYW0ud3JpdGUoanNTcHJpbnRmLmFwcGx5KHRoaXMsIGFyZ3MpKSk7XG59XG5cbmZ1bmN0aW9uIGRvUGFkKGNociwgd2lkdGgsIGxlZnQsIHN0cilcbntcblx0dmFyIHJldCA9IHN0cjtcblxuXHR3aGlsZSAocmV0Lmxlbmd0aCA8IHdpZHRoKSB7XG5cdFx0aWYgKGxlZnQpXG5cdFx0XHRyZXQgKz0gY2hyO1xuXHRcdGVsc2Vcblx0XHRcdHJldCA9IGNociArIHJldDtcblx0fVxuXG5cdHJldHVybiAocmV0KTtcbn1cblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gZHVtcHMgbG9uZyBzdGFjayB0cmFjZXMgZm9yIGV4Y2VwdGlvbnMgaGF2aW5nIGEgY2F1c2UoKSBtZXRob2QuXG4gKiBTZWUgbm9kZS12ZXJyb3IgZm9yIGFuIGV4YW1wbGUuXG4gKi9cbmZ1bmN0aW9uIGR1bXBFeGNlcHRpb24oZXgpXG57XG5cdHZhciByZXQ7XG5cblx0aWYgKCEoZXggaW5zdGFuY2VvZiBFcnJvcikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcihqc1NwcmludGYoJ2ludmFsaWQgdHlwZSBmb3IgJSVyOiAlaicsIGV4KSkpO1xuXG5cdC8qIE5vdGUgdGhhdCBWOCBwcmVwZW5kcyBcImV4LnN0YWNrXCIgd2l0aCBleC50b1N0cmluZygpLiAqL1xuXHRyZXQgPSAnRVhDRVBUSU9OOiAnICsgZXguY29uc3RydWN0b3IubmFtZSArICc6ICcgKyBleC5zdGFjaztcblxuXHRpZiAoZXguY2F1c2UgJiYgdHlwZW9mIChleC5jYXVzZSkgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgY2V4ID0gZXguY2F1c2UoKTtcblx0XHRpZiAoY2V4KSB7XG5cdFx0XHRyZXQgKz0gJ1xcbkNhdXNlZCBieTogJyArIGR1bXBFeGNlcHRpb24oY2V4KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gKHJldCk7XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IEJvdCBmcm9tICdrZXliYXNlLWJvdCdcbmltcG9ydCB7IG51bVRvRW1vamkgfSBmcm9tICcuL2Vtb2ppJ1xuaW1wb3J0IHsgZ2V0T3JTZWFyY2ggfSBmcm9tICcuL3NlYXJjaCdcbmltcG9ydCB0eXBlIHsgQ29tbWVudE1lc3NhZ2UgfSBmcm9tICcuL21lc3NhZ2UnXG5pbXBvcnQgdHlwZSB7IENvbnRleHQgfSBmcm9tICcuL2NvbnRleHQnXG5cbmNvbnN0IHJlYWN0TnVtID0gKGNvbnRleHQ6IENvbnRleHQsIGNoYW5uZWwsIGlkLCBudW0sIHVudGlsKSA9PlxuICBudW0gPCB1bnRpbCAmJlxuICBjb250ZXh0LmJvdC5jaGF0XG4gICAgLnJlYWN0KGNoYW5uZWwsIGlkLCBudW1Ub0Vtb2ppKG51bSkpXG4gICAgLnRoZW4oKCkgPT4gcmVhY3ROdW0oY29udGV4dCwgY2hhbm5lbCwgaWQsIG51bSArIDEsIHVudGlsKSlcblxuZXhwb3J0IGRlZmF1bHQgKFxuICBjb250ZXh0OiBDb250ZXh0LFxuICBjaGFubmVsOiBCb3QuQ2hhdENoYW5uZWwsXG4gIHBhcnNlZE1lc3NhZ2U6IENvbW1lbnRNZXNzYWdlXG4pID0+XG4gIGdldE9yU2VhcmNoKFxuICAgIGNvbnRleHQsXG4gICAgY2hhbm5lbCxcbiAgICBwYXJzZWRNZXNzYWdlLFxuICAgICdUbyBjb25maXJtIGNvbW1lbnRpbmcsIGNsaWNrIG9uIGVtb2ppcyBiZWxvdyBpbiB0aGUgbmV4dCAyIG1pbnV0ZXM6J1xuICApLnRoZW4oKHsgY291bnQsIGlkLCBpc3N1ZXMgfSkgPT4ge1xuICAgIGNvbnRleHQuY29tbWVudC5hZGQoaWQsIHBhcnNlZE1lc3NhZ2UsIGlzc3VlcylcbiAgICByZWFjdE51bShjb250ZXh0LCBjaGFubmVsLCBpZCwgMCwgY291bnQpXG4gIH0pXG4iLCIvLyBAZmxvd1xuaW1wb3J0IEJvdCBmcm9tICdrZXliYXNlLWJvdCdcbmltcG9ydCB0eXBlIHsgSXNzdWUgfSBmcm9tICcuL2ppcmEnXG5pbXBvcnQgdHlwZSB7IENvbW1lbnRNZXNzYWdlIH0gZnJvbSAnLi9tZXNzYWdlJ1xuaW1wb3J0IHV0aWwgZnJvbSAndXRpbCdcblxuY29uc3Qgc2V0VGltZW91dFByb21pc2UgPSB1dGlsLnByb21pc2lmeShzZXRUaW1lb3V0KVxuXG50eXBlIENvbW1lbnRDb250ZXh0SXRlbSA9IHtcbiAgbWVzc2FnZTogQ29tbWVudE1lc3NhZ2UsXG4gIGlzc3VlczogQXJyYXk8SXNzdWU+LFxufVxuXG5jbGFzcyBDb21tZW50Q29udGV4dCB7XG4gIF9yZXNwTXNnSURUb0NvbW1lbnRNZXNzYWdlID0gbmV3IE1hcCgpXG5cbiAgYWRkID0gKHJlc3BvbnNlSUQ6IG51bWJlciwgbWVzc2FnZTogQ29tbWVudE1lc3NhZ2UsIGlzc3VlczogQXJyYXk8SXNzdWU+KSA9PiB7XG4gICAgdGhpcy5fcmVzcE1zZ0lEVG9Db21tZW50TWVzc2FnZS5zZXQocmVzcG9uc2VJRCwgeyBtZXNzYWdlLCBpc3N1ZXMgfSlcbiAgICBzZXRUaW1lb3V0UHJvbWlzZSgxMDAwICogMTIwIC8qIDJtaW4gKi8pLnRoZW4oKCkgPT5cbiAgICAgIHRoaXMuX3Jlc3BNc2dJRFRvQ29tbWVudE1lc3NhZ2UuZGVsZXRlKHJlc3BvbnNlSUQpXG4gICAgKVxuICB9XG5cbiAgZ2V0ID0gKHJlc3BvbnNlSUQ6IG51bWJlcik6ID9Db21tZW50Q29udGV4dEl0ZW0gPT5cbiAgICB0aGlzLl9yZXNwTXNnSURUb0NvbW1lbnRNZXNzYWdlLmdldChyZXNwb25zZUlEKVxufVxuXG5leHBvcnQgdHlwZSBDb250ZXh0ID0ge1xuICBib3Q6IEJvdC5Cb3QsXG4gIGNvbW1lbnQ6IENvbW1lbnRDb250ZXh0LFxufVxuXG5leHBvcnQgZGVmYXVsdCAoKTogQ29udGV4dCA9PiAoe1xuICBib3Q6IG5ldyBCb3QoKSxcbiAgY29tbWVudDogbmV3IENvbW1lbnRDb250ZXh0KCksXG59KVxuIiwiLy8gQGZsb3dcblxuZXhwb3J0IGNvbnN0IGVtb2ppVG9OdW0gPSAobnVtOiBzdHJpbmcpOiA/bnVtYmVyID0+IHtcbiAgc3dpdGNoIChudW0pIHtcbiAgICBjYXNlICc6emVybzonOlxuICAgICAgcmV0dXJuIDBcbiAgICBjYXNlICc6b25lOic6XG4gICAgICByZXR1cm4gMVxuICAgIGNhc2UgJzp0d286JzpcbiAgICAgIHJldHVybiAyXG4gICAgY2FzZSAnOnRocmVlOic6XG4gICAgICByZXR1cm4gM1xuICAgIGNhc2UgJzpmb3VyOic6XG4gICAgICByZXR1cm4gNFxuICAgIGNhc2UgJzpmaXZlOic6XG4gICAgICByZXR1cm4gNVxuICAgIGNhc2UgJzpzaXg6JzpcbiAgICAgIHJldHVybiA2XG4gICAgY2FzZSAnOnNldmVuOic6XG4gICAgICByZXR1cm4gN1xuICAgIGNhc2UgJzplaWdodDonOlxuICAgICAgcmV0dXJuIDhcbiAgICBjYXNlICc6bmluZTonOlxuICAgICAgcmV0dXJuIDlcbiAgICBjYXNlICc6a2V5Y2FwX3RlbjonOlxuICAgICAgcmV0dXJuIDEwXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG51bVRvRW1vamkgPSAobnVtOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBzd2l0Y2ggKG51bSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiAnOnplcm86J1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAnOm9uZTonXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuICc6dHdvOidcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gJzp0aHJlZTonXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuICc6Zm91cjonXG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuICc6Zml2ZTonXG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuICc6c2l4OidcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gJzpzZXZlbjonXG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuICc6ZWlnaHQ6J1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiAnOm5pbmU6J1xuICAgIGNhc2UgMTA6XG4gICAgICByZXR1cm4gJzprZXljYXBfdGVuOidcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICc6cXVlc3Rpb246J1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzdGF0dXNUb0Vtb2ppID0gKHN0YXR1czogc3RyaW5nKSA9PiB7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSAnRG9uZSc6XG4gICAgICByZXR1cm4gJzp3aGl0ZV9jaGVja19tYXJrOidcbiAgICBjYXNlICdUbyBEbyc6XG4gICAgICByZXR1cm4gJzpzdGF0dWVfb2ZfbGliZXJ0eTonXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnOmJ1aWxkaW5nX2NvbnN0cnVjdGlvbjonXG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgS2lyYSBmcm9tICcuL2tpcmEnXG5pbXBvcnQgQ29udGV4dCBmcm9tICcuL2NvbnRleHQnXG5cbktpcmEoQ29udGV4dCgpKVxuIiwiLy8gQGZsb3dcbmltcG9ydCBKaXJhQ2xpZW50IGZyb20gJ2ppcmEtY29ubmVjdG9yJ1xuaW1wb3J0ICogYXMgQ29uZmlnIGZyb20gJy4uL2NvbmZpZydcblxuY29uc3QgamlyYSA9IG5ldyBKaXJhQ2xpZW50KHtcbiAgaG9zdDogQ29uZmlnLmppcmEuaG9zdCxcbiAgYmFzaWNfYXV0aDoge1xuICAgIHVzZXJuYW1lOiBDb25maWcuamlyYS51c2VybmFtZSxcbiAgICBwYXNzd29yZDogQ29uZmlnLmppcmEucGFzc3dvcmQsXG4gIH0sXG59KVxuXG5jb25zdCBsb29rc0xpa2VJc3N1ZUtleSA9IHN0ciA9PiAhIXN0ci5tYXRjaCgvW0EtWmEtel0rLVswLTldKy8pXG5cbmV4cG9ydCB0eXBlIElzc3VlID0ge1xuICBrZXk6IHN0cmluZyxcbiAgc3VtbWFyeTogc3RyaW5nLFxuICBzdGF0dXM6IHN0cmluZyxcbiAgdXJsOiBzdHJpbmcsXG59XG5cbmNvbnN0IGppcmFSZXNwTWFwcGVyID0gKGlzc3VlKTogSXNzdWUgPT4gKHtcbiAga2V5OiBpc3N1ZS5rZXksXG4gIHN1bW1hcnk6IGlzc3VlLmZpZWxkcy5zdW1tYXJ5LFxuICBzdGF0dXM6IGlzc3VlLmZpZWxkcy5zdGF0dXMuc3RhdHVzQ2F0ZWdvcnkubmFtZSxcbiAgdXJsOiBgaHR0cHM6Ly8ke0NvbmZpZy5qaXJhLmhvc3R9L2Jyb3dzZS8ke2lzc3VlLmtleX1gLFxufSlcblxuZXhwb3J0IGNvbnN0IGdldE9yU2VhcmNoID0gKHN0cjogc3RyaW5nKTogUHJvbWlzZTxhbnk+ID0+XG4gIFByb21pc2UuYWxsKFtcbiAgICBsb29rc0xpa2VJc3N1ZUtleShzdHIpXG4gICAgICA/IGppcmEuaXNzdWUuZ2V0SXNzdWUoe1xuICAgICAgICAgIGlzc3VlS2V5OiBzdHIsXG4gICAgICAgICAgZmllbGRzOiBbJ2tleScsICdzdW1tYXJ5JywgJ3N0YXR1cyddLFxuICAgICAgICB9KVxuICAgICAgOiBuZXcgUHJvbWlzZShyID0+IHIoKSksXG4gICAgamlyYS5zZWFyY2guc2VhcmNoKHtcbiAgICAgIGpxbDogYHRleHQgfiBcIiR7c3RyfVwiYCxcbiAgICAgIGZpZWxkczogJ2tleSxzdW1tYXJ5LHN0YXR1cycsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgbWF4UmVzdWx0czogMTEsXG4gICAgfSksXG4gIF0pLnRoZW4oKFtmcm9tR2V0LCBmcm9tU2VhcmNoXSkgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICAuLi4oZnJvbUdldCA/IFtmcm9tR2V0XSA6IFtdKSxcbiAgICAgIC4uLihmcm9tU2VhcmNoID8gZnJvbVNlYXJjaC5pc3N1ZXMgOiBbXSksXG4gICAgXS5tYXAoamlyYVJlc3BNYXBwZXIpXG4gIH0pXG5cbmV4cG9ydCBjb25zdCBhZGRDb21tZW50ID0gKGlzc3VlS2V5OiBzdHJpbmcsIGNvbW1lbnQ6IHN0cmluZyk6IFByb21pc2U8YW55PiA9PlxuICBqaXJhLmlzc3VlXG4gICAgLmFkZENvbW1lbnQoe1xuICAgICAgaXNzdWVLZXksXG4gICAgICBjb21tZW50OiB7IGJvZHk6IGNvbW1lbnQgfSxcbiAgICB9KVxuICAgIC50aGVuKFxuICAgICAgKHsgaWQgfSkgPT5cbiAgICAgICAgYGh0dHBzOi8vJHtDb25maWcuamlyYS5ob3N0fS9icm93c2UvJHtpc3N1ZUtleX0/Zm9jdXNlZENvbW1lbnRJZD0ke2lkfWBcbiAgICApXG4iLCIvLyBAZmxvd1xuaW1wb3J0IEJvdCBmcm9tICdrZXliYXNlLWJvdCdcbmltcG9ydCAqIGFzIENvbmZpZyBmcm9tICcuLi9jb25maWcnXG5pbXBvcnQgKiBhcyBNZXNzYWdlIGZyb20gJy4vbWVzc2FnZSdcbmltcG9ydCBzZWFyY2ggZnJvbSAnLi9zZWFyY2gnXG5pbXBvcnQgY29tbWVudCBmcm9tICcuL2NvbW1lbnQnXG5pbXBvcnQgcmVhY2ppIGZyb20gJy4vcmVhY2ppJ1xuaW1wb3J0IENvbnRleHQsIHsgdHlwZSBDb250ZXh0IGFzIENvbnRleHRUeXBlIH0gZnJvbSAnLi9jb250ZXh0J1xuXG5jb25zdCBzZW5kSGVscCA9IChjb250ZXh0LCBjaGFubmVsKSA9PlxuICBjb250ZXh0LmJvdC5jaGF0LnNlbmQoY2hhbm5lbCwge1xuICAgIGJvZHk6XG4gICAgICAnVXNhZ2U6IFxcbicgK1xuICAgICAgJyAgYCFraXJhIHNlYXJjaCA8cXVlcnk+YFxcbicgK1xuICAgICAgJyAgYCFraXJhIGNvbW1lbnQgPHF1ZXJ5PiA8eW91ciBjb21tZW50PmBcXG4nLFxuICB9KVxuXG5jb25zdCByZWFjdEFjayA9IChjb250ZXh0LCBjaGFubmVsOiBCb3QuQ2hhdENoYW5uZWwsIGlkOiBudW1iZXIpID0+XG4gIGNvbnRleHQuYm90LmNoYXQucmVhY3QoY2hhbm5lbCwgaWQsICc6ZXllczonKVxuXG5jb25zdCBtYWtlT25NZXNzYWdlID0gY29udGV4dCA9PiBrYk1lc3NhZ2UgPT4ge1xuICBjb25zb2xlLmRlYnVnKGtiTWVzc2FnZSlcbiAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IE1lc3NhZ2UucGFyc2VNZXNzYWdlKGtiTWVzc2FnZSlcbiAgY29uc29sZS5kZWJ1Zyh7IG1zZzogJ2dvdCBtZXNzYWdlJywgcGFyc2VkTWVzc2FnZSB9KVxuICBpZiAoIXBhcnNlZE1lc3NhZ2UpIHtcbiAgICAvLyBub3QgYSBraXJhIG1lc3NhZ2VcbiAgICByZXR1cm5cbiAgfVxuICBzd2l0Y2ggKHBhcnNlZE1lc3NhZ2UudHlwZSkge1xuICAgIGNhc2UgJ3Vua25vd24nOlxuICAgIGNhc2UgJ2hlbHAnOlxuICAgICAgc2VuZEhlbHAoY29udGV4dCwga2JNZXNzYWdlLmNoYW5uZWwpXG4gICAgICByZXR1cm5cbiAgICBjYXNlICdzZWFyY2gnOlxuICAgICAgcmVhY3RBY2soY29udGV4dCwga2JNZXNzYWdlLmNoYW5uZWwsIGtiTWVzc2FnZS5pZClcbiAgICAgIHNlYXJjaChjb250ZXh0LCBrYk1lc3NhZ2UuY2hhbm5lbCwgcGFyc2VkTWVzc2FnZSlcbiAgICAgIHJldHVyblxuICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgcmVhY3RBY2soY29udGV4dCwga2JNZXNzYWdlLmNoYW5uZWwsIGtiTWVzc2FnZS5pZClcbiAgICAgIGNvbW1lbnQoY29udGV4dCwga2JNZXNzYWdlLmNoYW5uZWwsIHBhcnNlZE1lc3NhZ2UpXG4gICAgICByZXR1cm5cbiAgICBjYXNlICdyZWFjamknOlxuICAgICAgcmVhY2ppKGNvbnRleHQsIGtiTWVzc2FnZS5jaGFubmVsLCBwYXJzZWRNZXNzYWdlKVxuICAgICAgcmV0dXJuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUuZXJyb3IoeyBlcnJvcjogJ2hvdyBjb3VsZCB0aGlzIGhhcHBlbicgfSlcbiAgICAgIHJldHVyblxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IChjb250ZXh0OiBDb250ZXh0VHlwZSkgPT5cbiAgY29udGV4dC5ib3RcbiAgICAuaW5pdChDb25maWcua2V5YmFzZS51c2VybmFtZSwgQ29uZmlnLmtleWJhc2UucGFwZXJrZXksIHsgdmVyYm9zZTogdHJ1ZSB9KVxuICAgIC50aGVuKCgpID0+XG4gICAgICBDb25maWcua2V5YmFzZS5jaGFubmVscy5mb3JFYWNoKGNoYW5uZWwgPT5cbiAgICAgICAgY29udGV4dC5ib3QuY2hhdC53YXRjaENoYW5uZWxGb3JOZXdNZXNzYWdlcyhcbiAgICAgICAgICBjaGFubmVsLFxuICAgICAgICAgIG1ha2VPbk1lc3NhZ2UoY29udGV4dClcbiAgICAgICAgKVxuICAgICAgKVxuICAgIClcbiIsIi8vIEBmbG93XG5pbXBvcnQgQm90IGZyb20gJ2tleWJhc2UtYm90J1xuXG50eXBlIFVua25vd25NZXNzYWdlID0ge3xcbiAgdHlwZTogJ3Vua25vd24nLFxufH1cblxudHlwZSBIZWxwTWVzc2FnZSA9IHt8XG4gIHR5cGU6ICdoZWxwJyxcbnx9XG5cbmV4cG9ydCB0eXBlIFNlYXJjaE1lc3NhZ2UgPSB7fFxuICBmcm9tOiBzdHJpbmcsXG4gIHR5cGU6ICdzZWFyY2gnLFxuICBxdWVyeTogc3RyaW5nLFxufH1cblxuZXhwb3J0IHR5cGUgQ29tbWVudE1lc3NhZ2UgPSB7fFxuICBmcm9tOiBzdHJpbmcsXG4gIHR5cGU6ICdjb21tZW50JyxcbiAgcXVlcnk6IHN0cmluZyxcbiAgY29tbWVudDogc3RyaW5nLFxufH1cblxuZXhwb3J0IHR5cGUgUmVhY2ppTWVzc2FnZSA9IHt8XG4gIGZyb206IHN0cmluZyxcbiAgdHlwZTogJ3JlYWNqaScsXG4gIHJlYWN0VG9JRDogbnVtYmVyLFxuICBlbW9qaTogc3RyaW5nLFxufH1cblxuZXhwb3J0IHR5cGUgTWVzc2FnZSA9XG4gIHwgVW5rbm93bk1lc3NhZ2VcbiAgfCBIZWxwTWVzc2FnZVxuICB8IFNlYXJjaE1lc3NhZ2VcbiAgfCBDb21tZW50TWVzc2FnZVxuICB8IFJlYWNqaU1lc3NhZ2VcblxuY29uc3QgY21kUkUgPSBuZXcgUmVnRXhwKC8oPzoha2lyYSlcXHMrKFxcUyspKD86XFxzKyhcXFMrKSk/KD86XFxzKyguKikpPy8pXG5cbmNvbnN0IGlzS2lyYU1lc3NhZ2UgPSBtZXNzYWdlID0+XG4gIG1lc3NhZ2UgJiZcbiAgbWVzc2FnZS5jb250ZW50ICYmXG4gIG1lc3NhZ2UuY29udGVudC50eXBlID09PSAndGV4dCcgJiZcbiAgdHlwZW9mIG1lc3NhZ2UuY29udGVudC50ZXh0LmJvZHkgPT09ICdzdHJpbmcnICYmXG4gIG1lc3NhZ2UuY29udGVudC50ZXh0LmJvZHkuc3RhcnRzV2l0aCgnIWtpcmEnKVxuXG5jb25zdCBpc0tpcmFSZWFjdGlvbiA9IG1lc3NhZ2UgPT5cbiAgbWVzc2FnZSAmJiBtZXNzYWdlLmNvbnRlbnQgJiYgbWVzc2FnZS5jb250ZW50LnR5cGUgPT09ICdyZWFjdGlvbidcblxuZXhwb3J0IGNvbnN0IHBhcnNlTWVzc2FnZSA9IChtZXNzYWdlOiBCb3QuTWVzc2FnZSk6ID9NZXNzYWdlID0+IHtcbiAgaWYgKGlzS2lyYVJlYWN0aW9uKG1lc3NhZ2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IG1lc3NhZ2Uuc2VuZGVyLnVzZXJuYW1lLFxuICAgICAgdHlwZTogJ3JlYWNqaScsXG4gICAgICByZWFjdFRvSUQ6IG1lc3NhZ2UuY29udGVudC5yZWFjdGlvbi5tLFxuICAgICAgZW1vamk6IG1lc3NhZ2UuY29udGVudC5yZWFjdGlvbi5iLFxuICAgIH1cbiAgfVxuXG4gIGlmICghaXNLaXJhTWVzc2FnZShtZXNzYWdlKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBtYXRjaGVzID0gbWVzc2FnZS5jb250ZW50LnRleHQuYm9keS5tYXRjaChjbWRSRSlcbiAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiB7IHR5cGU6ICd1bmtub3duJyB9XG4gIH1cblxuICBzd2l0Y2ggKG1hdGNoZXNbMV0pIHtcbiAgICBjYXNlICdoZWxwJzpcbiAgICAgIHJldHVybiB7IHR5cGU6ICdoZWxwJyB9XG4gICAgY2FzZSAnc2VhcmNoJzpcbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3Vua25vd24nIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IG1lc3NhZ2Uuc2VuZGVyLnVzZXJuYW1lLFxuICAgICAgICB0eXBlOiAnc2VhcmNoJyxcbiAgICAgICAgcXVlcnk6IG1hdGNoZXNbMl0sXG4gICAgICB9XG4gICAgY2FzZSAnY29tbWVudCc6XG4gICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPCA0KSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICd1bmtub3duJyB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBtZXNzYWdlLnNlbmRlci51c2VybmFtZSxcbiAgICAgICAgdHlwZTogJ2NvbW1lbnQnLFxuICAgICAgICBxdWVyeTogbWF0Y2hlc1syXSxcbiAgICAgICAgY29tbWVudDogbWF0Y2hlc1szXSxcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHsgdHlwZTogJ3Vua25vd24nIH1cbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgUmVhY2ppTWVzc2FnZSB9IGZyb20gJy4vbWVzc2FnZSdcbmltcG9ydCB7IGVtb2ppVG9OdW0gfSBmcm9tICcuL2Vtb2ppJ1xuaW1wb3J0IEJvdCBmcm9tICdrZXliYXNlLWJvdCdcbmltcG9ydCAqIGFzIEppcmEgZnJvbSAnLi9qaXJhJ1xuaW1wb3J0ICogYXMgQ29uZmlnIGZyb20gJy4uL2NvbmZpZydcbmltcG9ydCB0eXBlIHsgQ29udGV4dCB9IGZyb20gJy4vY29udGV4dCdcblxuY29uc3Qga2IyamlyYSA9IGtiID0+IENvbmZpZy5qaXJhLnVzZXJuYW1lTWFwcGVyW2tiXSB8fCBrYlxuXG5leHBvcnQgZGVmYXVsdCAoXG4gIGNvbnRleHQ6IENvbnRleHQsXG4gIGNoYW5uZWw6IEJvdC5DaGF0Q2hhbm5lbCxcbiAgcGFyc2VkTWVzc2FnZTogUmVhY2ppTWVzc2FnZVxuKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSBjb250ZXh0LmNvbW1lbnQuZ2V0KHBhcnNlZE1lc3NhZ2UucmVhY3RUb0lEKVxuICBpZiAoIWl0ZW0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChwYXJzZWRNZXNzYWdlLmZyb20gPT09IENvbmZpZy5rZXliYXNlLnVzZXJuYW1lKSB7XG4gICAgLy8gV2UgbmV2ZXIgZ2V0IG91ciBvd24gcmVhY2ppIGFzIG9mIG5vdywgYnV0IGp1c3QgaW4gY2FzZSAuLi5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IG51bSA9IGVtb2ppVG9OdW0ocGFyc2VkTWVzc2FnZS5lbW9qaSlcbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKG51bSA+PSBpdGVtLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGlzc3VlS2V5ID0gaXRlbS5pc3N1ZXNbbnVtXS5rZXlcbiAgY29uc3QgY29tbWVudCA9XG4gICAgYENvbW1lbnQgYnkgJHtrYjJqaXJhKGl0ZW0ubWVzc2FnZS5mcm9tKX1gICtcbiAgICAoaXRlbS5tZXNzYWdlLmZyb20gPT09IHBhcnNlZE1lc3NhZ2UuZnJvbVxuICAgICAgPyAnOiAnXG4gICAgICA6IGAgKGNvbmZpcm1lZCBieSAke2tiMmppcmEocGFyc2VkTWVzc2FnZS5mcm9tKX0pOiBgKSArXG4gICAgaXRlbS5tZXNzYWdlLmNvbW1lbnRcbiAgcmV0dXJuIEppcmEuYWRkQ29tbWVudChpc3N1ZUtleSwgY29tbWVudCkudGhlbih1cmwgPT5cbiAgICBjb250ZXh0LmJvdC5jaGF0LnNlbmQoY2hhbm5lbCwge1xuICAgICAgYm9keTogYEAke3BhcnNlZE1lc3NhZ2UuZnJvbX0gRG9uZSEgJHt1cmx9YCxcbiAgICB9KVxuICApXG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0IEJvdCBmcm9tICdrZXliYXNlLWJvdCdcbmltcG9ydCAqIGFzIEppcmEgZnJvbSAnLi9qaXJhJ1xuaW1wb3J0IHsgbnVtVG9FbW9qaSwgc3RhdHVzVG9FbW9qaSB9IGZyb20gJy4vZW1vamknXG5pbXBvcnQgdHlwZSB7IFNlYXJjaE1lc3NhZ2UsIENvbW1lbnRNZXNzYWdlIH0gZnJvbSAnLi9tZXNzYWdlJ1xuaW1wb3J0IHR5cGUgeyBDb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0J1xuXG5jb25zdCBpc3N1ZVRvTGluZSA9IChpc3N1ZSwgaW5kZXgpID0+XG4gIGAke251bVRvRW1vamkoaW5kZXgpfSAqJHtpc3N1ZS5rZXl9KiAke3N0YXR1c1RvRW1vamkoaXNzdWUuc3RhdHVzKX0gJHtcbiAgICBpc3N1ZS5zdW1tYXJ5XG4gIH0gLSAke2lzc3VlLnVybH1gXG5cbmNvbnN0IGJ1aWxkU2VhcmNoUmVzdWx0Qm9keSA9IChwYXJzZWRNZXNzYWdlLCBpc3N1ZXMsIGFkZGl0aW9uYWwpID0+IHtcbiAgaWYgKCFpc3N1ZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdJIGdvdCBub3RoaW5nIGZyb20gSmlyYS4nXG4gIH1cbiAgY29uc3QgZmlyc3RJc3N1ZXMgPSBpc3N1ZXMuc2xpY2UoMCwgMTEpXG4gIGNvbnN0IGhlYWQgPVxuICAgIGBAJHtwYXJzZWRNZXNzYWdlLmZyb219IEkgZ290ICR7aXNzdWVzLmxlbmd0aH0gdGlja2V0cyBmcm9tIEppcmFgICtcbiAgICAoaXNzdWVzID4gMTEgPyAnLiBIZXJlIGFyZSB0aGUgZmlyc3QgMTE6XFxuXFxuJyA6ICc6XFxuXFxuJylcbiAgY29uc3QgYm9keSA9IGZpcnN0SXNzdWVzLm1hcChpc3N1ZVRvTGluZSkuam9pbignXFxuJylcbiAgcmV0dXJuIGFkZGl0aW9uYWwgPyBoZWFkICsgYm9keSArICdcXG5cXG4nICsgYWRkaXRpb25hbCA6IGhlYWQgKyBib2R5XG59XG5cbmV4cG9ydCBjb25zdCBnZXRPclNlYXJjaCA9IChcbiAgY29udGV4dDogQ29udGV4dCxcbiAgY2hhbm5lbDogQm90LkNoYXRDaGFubmVsLFxuICBwYXJzZWRNZXNzYWdlOiBTZWFyY2hNZXNzYWdlIHwgQ29tbWVudE1lc3NhZ2UsXG4gIGFkZGl0aW9uYWw/OiBzdHJpbmdcbik6IFByb21pc2U8eyBpc3N1ZXM6IEFycmF5PEppcmEuSXNzdWU+LCBjb3VudDogbnVtYmVyLCBpZDogbnVtYmVyIH0+ID0+XG4gIEppcmEuZ2V0T3JTZWFyY2gocGFyc2VkTWVzc2FnZS5xdWVyeSkudGhlbihpc3N1ZXMgPT5cbiAgICBjb250ZXh0LmJvdC5jaGF0XG4gICAgICAuc2VuZChjaGFubmVsLCB7XG4gICAgICAgIGJvZHk6IGJ1aWxkU2VhcmNoUmVzdWx0Qm9keShwYXJzZWRNZXNzYWdlLCBpc3N1ZXMsIGFkZGl0aW9uYWwpLFxuICAgICAgfSlcbiAgICAgIC50aGVuKCh7IGlkIH0pID0+ICh7XG4gICAgICAgIGNvdW50OiBpc3N1ZXMubGVuZ3RoID4gMTEgPyAxMSA6IGlzc3Vlcy5sZW5ndGgsXG4gICAgICAgIGlkLFxuICAgICAgICBpc3N1ZXMsXG4gICAgICB9KSlcbiAgKVxuXG5leHBvcnQgZGVmYXVsdCAoXG4gIGNvbnRleHQ6IENvbnRleHQsXG4gIGNoYW5uZWw6IEJvdC5DaGF0Q2hhbm5lbCxcbiAgcGFyc2VkTWVzc2FnZTogU2VhcmNoTWVzc2FnZVxuKSA9PiBnZXRPclNlYXJjaChjb250ZXh0LCBjaGFubmVsLCBwYXJzZWRNZXNzYWdlKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJ1ZmZlclwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwdW55Y29kZVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFkbGluZVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidGxzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInpsaWJcIik7Il0sInNvdXJjZVJvb3QiOiIifQ==